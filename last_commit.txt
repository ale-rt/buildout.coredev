Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2016-03-11T23:13:07+01:00
Author: Gil Forcada (gforcada) <gforcada@gnome.org>
Commit: https://github.com/plone/plone.app.iterate/commit/98df4a53d08f47d27aec3474c458e2fe1e5903b2

Minimal cleanup

Files changed:
M plone/app/iterate/__init__.py
M plone/app/iterate/archiver.py
M plone/app/iterate/browser/cancel.py
M plone/app/iterate/browser/checkin.py
M plone/app/iterate/browser/checkout.py
M plone/app/iterate/containers.py
M plone/app/iterate/copier.py
M plone/app/iterate/dexterity/copier.py
M plone/app/iterate/dexterity/interfaces.py
M plone/app/iterate/dexterity/policy.py
M plone/app/iterate/dexterity/utils.py
M plone/app/iterate/event.py
M plone/app/iterate/interfaces.py
M plone/app/iterate/lock.py
M plone/app/iterate/policy.py
M plone/app/iterate/relation.py
M plone/app/iterate/setuphandlers.py
M plone/app/iterate/subscribers/locking.py
M plone/app/iterate/subscribers/marker.py
M plone/app/iterate/subscribers/versioning.py
M plone/app/iterate/util.py

diff --git a/plone/app/iterate/__init__.py b/plone/app/iterate/__init__.py
index 4b7c8c5..67a650a 100644
--- a/plone/app/iterate/__init__.py
+++ b/plone/app/iterate/__init__.py
@@ -43,4 +43,4 @@
                  'of plone.app.iterate. You may experience problems running this configuration. '
                  'plone.app.iterate now has dexterity suport built-in.')
 except ImportError:
-    pass
\ No newline at end of file
+    pass
diff --git a/plone/app/iterate/archiver.py b/plone/app/iterate/archiver.py
index bf8c13b..451055a 100644
--- a/plone/app/iterate/archiver.py
+++ b/plone/app/iterate/archiver.py
@@ -30,6 +30,7 @@
 
 import interfaces
 
+
 class ContentArchiver(object):
 
     implements(interfaces.IObjectArchiver)
diff --git a/plone/app/iterate/browser/cancel.py b/plone/app/iterate/browser/cancel.py
index 29e85a8..68da659 100644
--- a/plone/app/iterate/browser/cancel.py
+++ b/plone/app/iterate/browser/cancel.py
@@ -32,6 +32,7 @@
 from plone.app.iterate.interfaces import ICheckinCheckoutPolicy
 from plone.app.iterate.interfaces import CheckoutException
 
+
 class Cancel(BrowserView):
 
     index = ViewPageTemplateFile('cancel.pt')
@@ -40,7 +41,8 @@ def __call__(self):
         context = aq_inner(self.context)
 
         if self.request.form.has_key('form.button.Cancel'):
-            control = getMultiAdapter((context, self.request), name=u"iterate_control")
+            control = getMultiAdapter(
+                (context, self.request), name=u"iterate_control")
             if not control.cancel_allowed():
                 raise CheckoutException(u"Not a checkout")
 
@@ -48,12 +50,14 @@ def __call__(self):
             baseline = policy.cancelCheckout()
             baseline.reindexObject()
 
-            IStatusMessage(self.request).addStatusMessage(_(u"Checkout cancelled"), type='info')
-            view_url = baseline.restrictedTraverse("@@plone_context_state").view_url()
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"Checkout cancelled"), type='info')
+            view_url = baseline.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         elif self.request.form.has_key('form.button.Keep'):
-            view_url = context.restrictedTraverse("@@plone_context_state").view_url()
+            view_url = context.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
-
diff --git a/plone/app/iterate/browser/checkin.py b/plone/app/iterate/browser/checkin.py
index c6bc589..033562a 100644
--- a/plone/app/iterate/browser/checkin.py
+++ b/plone/app/iterate/browser/checkin.py
@@ -32,6 +32,7 @@
 from plone.app.iterate.interfaces import ICheckinCheckoutPolicy
 from plone.app.iterate.interfaces import CheckinException
 
+
 class Checkin(BrowserView):
 
     index = ViewPageTemplateFile('checkin.pt')
@@ -40,7 +41,8 @@ def __call__(self):
         context = aq_inner(self.context)
 
         if self.request.form.has_key('form.button.Checkin'):
-            control = getMultiAdapter((context, self.request), name=u"iterate_control")
+            control = getMultiAdapter(
+                (context, self.request), name=u"iterate_control")
             if not control.checkin_allowed():
                 raise CheckinException(u"Not a checkout")
 
@@ -49,11 +51,14 @@ def __call__(self):
             policy = ICheckinCheckoutPolicy(context)
             baseline = policy.checkin(message)
 
-            IStatusMessage(self.request).addStatusMessage(_("Checked in"), type='info')
-            view_url = baseline.restrictedTraverse("@@plone_context_state").view_url()
+            IStatusMessage(self.request).addStatusMessage(
+                _("Checked in"), type='info')
+            view_url = baseline.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         elif self.request.form.has_key('form.button.Cancel'):
-            view_url = context.restrictedTraverse("@@plone_context_state").view_url()
+            view_url = context.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
diff --git a/plone/app/iterate/browser/checkout.py b/plone/app/iterate/browser/checkout.py
index f88a5ff..30f30dd 100644
--- a/plone/app/iterate/browser/checkout.py
+++ b/plone/app/iterate/browser/checkout.py
@@ -58,32 +58,39 @@ def __call__(self):
         # We want to redirect to a specific template, else we might
         # end up downloading a file
         if 'form.button.Checkout' in self.request.form:
-            control = getMultiAdapter((context, self.request), name=u"iterate_control")
+            control = getMultiAdapter(
+                (context, self.request), name=u"iterate_control")
             if not control.checkout_allowed():
                 raise CheckoutException(u"Not allowed")
 
             location = self.request.form.get('checkout_location', None)
             locator = None
             try:
-                locator = [c['locator'] for c in self.containers() if c['name'] == location][0]
+                locator = [c['locator']
+                           for c in self.containers() if c['name'] == location][0]
             except IndexError:
                 IStatusMessage(self.request).addStatusMessage(_("Cannot find checkout location"),
                                                               type='error')
-                view_url = context.restrictedTraverse("@@plone_context_state").view_url()
+                view_url = context.restrictedTraverse(
+                    "@@plone_context_state").view_url()
                 self.request.response.redirect(view_url)
                 return
 
             policy = ICheckinCheckoutPolicy(context)
             wc = policy.checkout(locator())
 
-            # we do this for metadata update side affects which will update lock info
+            # we do this for metadata update side affects which will update
+            # lock info
             context.reindexObject('review_state')
 
-            IStatusMessage(self.request).addStatusMessage(_("Check-out created"), type='info')
-            view_url = wc.restrictedTraverse("@@plone_context_state").view_url()
+            IStatusMessage(self.request).addStatusMessage(
+                _("Check-out created"), type='info')
+            view_url = wc.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         elif 'form.button.Cancel' in self.request.form:
-            view_url = context.restrictedTraverse("@@plone_context_state").view_url()
+            view_url = context.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
diff --git a/plone/app/iterate/containers.py b/plone/app/iterate/containers.py
index 7a69d47..4c15290 100644
--- a/plone/app/iterate/containers.py
+++ b/plone/app/iterate/containers.py
@@ -51,6 +51,7 @@ def available(self):
     def __call__(self):
         return getToolByName(self.context, 'portal_membership').getHomeFolder()
 
+
 class ParentFolderLocator(object):
     """Locate the parent of the context, if the user has the
     Add portal content permission.
diff --git a/plone/app/iterate/copier.py b/plone/app/iterate/copier.py
index 055c34c..d71c5de 100644
--- a/plone/app/iterate/copier.py
+++ b/plone/app/iterate/copier.py
@@ -42,76 +42,76 @@
 from interfaces import CheckinException
 
 
-class ContentCopier( object ):
+class ContentCopier(object):
 
-    interface.implements( interfaces.IObjectCopier )
-    component.adapts( interfaces.IIterateAware )
+    interface.implements(interfaces.IObjectCopier)
+    component.adapts(interfaces.IIterateAware)
 
-    def __init__( self, context ):
+    def __init__(self, context):
         self.context = context
 
-    def copyTo( self, container ):
-        wc = self._copyBaseline( container )
+    def copyTo(self, container):
+        wc = self._copyBaseline(container)
         wc_ref = wc.addReference(
             self.context,
             relationship=WorkingCopyRelation.relationship,
             referenceClass=WorkingCopyRelation)
-        self._handleReferences( self.context, wc, "checkout", wc_ref )
+        self._handleReferences(self.context, wc, "checkout", wc_ref)
         return wc, wc_ref
 
-    def merge( self ):
+    def merge(self):
         baseline = self._getBaseline()
 
         # delete the working copy reference to the baseline
         wc_ref = self._deleteWorkingCopyRelation()
 
         # reassemble references on the new baseline
-        self._handleReferences( baseline, self.context, "checkin", wc_ref )
+        self._handleReferences(baseline, self.context, "checkin", wc_ref)
 
         # move the working copy to the baseline container, deleting
         # the baseline
-        new_baseline = self._replaceBaseline( baseline )
+        new_baseline = self._replaceBaseline(baseline)
 
         # patch the working copy with baseline info not preserved
         # during checkout
-        self._reassembleWorkingCopy( new_baseline, baseline )
+        self._reassembleWorkingCopy(new_baseline, baseline)
 
         return new_baseline
 
-    def _getBaseline( self ):
+    def _getBaseline(self):
         # follow the working copy's reference back to the baseline
-        refs = self.context.getRefs( WorkingCopyRelation.relationship )
+        refs = self.context.getRefs(WorkingCopyRelation.relationship)
 
         if not len(refs) == 1:
-            raise CheckinException( "Baseline count mismatch" )
+            raise CheckinException("Baseline count mismatch")
 
         if not refs or refs[0] is None:
-            raise CheckinException( "Baseline has disappeared" )
+            raise CheckinException("Baseline has disappeared")
 
         baseline = refs[0]
         return baseline
 
-    def _replaceBaseline( self, baseline ):
+    def _replaceBaseline(self, baseline):
         # move the working copy object to the baseline, returns the
         # new baseline
         baseline_id = baseline.getId()
 
         # delete the baseline from the folder to make room for the
         # committed working copy
-        baseline_container = aq_parent( aq_inner( baseline ) )
+        baseline_container = aq_parent(aq_inner(baseline))
         # Check if we are a default_page, because this property of the
         # container might get lost.
         is_default_page = (
             baseline_container.getProperty('default_page', '') == baseline_id)
         baseline_pos = baseline_container.getObjectPosition(baseline_id)
-        baseline_container._delOb( baseline_id )
+        baseline_container._delOb(baseline_id)
 
         # uninedxing the deleted baseline object from portal_catalog
         portal_catalog = getToolByName(self.context, 'portal_catalog')
         portal_catalog.unindexObject(baseline)
 
         # delete the working copy from the its container
-        wc_container = aq_parent( aq_inner( self.context ) )
+        wc_container = aq_parent(aq_inner(self.context))
 
         # trick out the at machinery to not delete references
         self.context._v_cp_refs = 1
@@ -121,12 +121,12 @@ def _replaceBaseline( self, baseline ):
         wc_container.manage_delObjects([wc_id])
 
         # move the working copy back to the baseline container
-        working_copy = aq_base( self.context )
-        working_copy.setId( baseline_id )
-        baseline_container._setOb( baseline_id, working_copy )
+        working_copy = aq_base(self.context)
+        working_copy.setId(baseline_id)
+        baseline_container._setOb(baseline_id, working_copy)
         baseline_container.moveObjectToPosition(baseline_id, baseline_pos)
 
-        new_baseline = baseline_container._getOb( baseline_id )
+        new_baseline = baseline_container._getOb(baseline_id)
         if is_default_page:
             # Restore default_page to container.  Note that the property might
             # have been removed by an event handler in the mean time.
@@ -136,15 +136,15 @@ def _replaceBaseline( self, baseline ):
                 baseline_container._setProperty('default_page', baseline_id)
 
         # reregister our references with the reference machinery after moving
-        Referenceable.manage_afterAdd( new_baseline, new_baseline,
-                                       baseline_container)
+        Referenceable.manage_afterAdd(new_baseline, new_baseline,
+                                      baseline_container)
 
         notify(ObjectMovedEvent(new_baseline, wc_container,
                                 wc_id, baseline_container, baseline_id))
 
         return new_baseline
 
-    def _reassembleWorkingCopy( self, new_baseline, baseline ):
+    def _reassembleWorkingCopy(self, new_baseline, baseline):
         # reattach the source's workflow history, try avoid a dangling ref
         try:
             new_baseline.workflow_history = PersistentMapping(
@@ -155,11 +155,11 @@ def _reassembleWorkingCopy( self, new_baseline, baseline ):
 
         # reset wf state security directly
         workflow_tool = getToolByName(self.context, 'portal_workflow')
-        wfs = workflow_tool.getWorkflowsFor( self.context )
+        wfs = workflow_tool.getWorkflowsFor(self.context)
         for wf in wfs:
-            if not isinstance( wf, DCWorkflowDefinition ):
+            if not isinstance(wf, DCWorkflowDefinition):
                 continue
-            wf.updateRoleMappingsFor( new_baseline )
+            wf.updateRoleMappingsFor(new_baseline)
 
         # Reattach the source's uid, this will update wc refs to point
         # back to the new baseline.  This may introduce duplicate
@@ -169,15 +169,15 @@ def _reassembleWorkingCopy( self, new_baseline, baseline ):
         # reattach the source's history id, to get the previous
         # version ancestry
         histid_handler = getToolByName(self.context, 'portal_historyidhandler')
-        huid = histid_handler.getUid( baseline )
-        histid_handler.setUid( new_baseline, huid, check_uniqueness=False )
+        huid = histid_handler.getUid(baseline)
+        histid_handler.setUid(new_baseline, huid, check_uniqueness=False)
 
         return new_baseline
 
     def _recursivelyReattachUIDs(self, baseline, new_baseline):
         original_refs = len(new_baseline.getRefs())
         original_back_refs = len(new_baseline.getBRefs())
-        new_baseline._setUID( baseline.UID() )
+        new_baseline._setUID(baseline.UID())
         new_refs = len(new_baseline.getRefs())
         new_back_refs = len(new_baseline.getBRefs())
         if original_refs != new_refs:
@@ -209,57 +209,57 @@ def _removeDuplicateReferences(self, item, backrefs=False):
             if brain.getObject() is None:
                 reference_tool.uncatalog_object(brain.getPath())
 
-    def _deleteWorkingCopyRelation( self ):
+    def _deleteWorkingCopyRelation(self):
         # delete the wc reference keeping a reference to it for its annotations
         refs = self.context.getReferenceImpl(WorkingCopyRelation.relationship)
         wc_ref = refs[0]
-        self.context.deleteReferences( WorkingCopyRelation.relationship )
+        self.context.deleteReferences(WorkingCopyRelation.relationship)
         return wc_ref
 
     #################################
-    ## Checkout Support Methods
+    # Checkout Support Methods
 
-    def _copyBaseline( self, container ):
+    def _copyBaseline(self, container):
         # copy the context from source to the target container
-        source_container = aq_parent( aq_inner( self.context ) )
+        source_container = aq_parent(aq_inner(self.context))
         clipboard = source_container.manage_copyObjects([self.context.getId()])
-        result = container.manage_pasteObjects( clipboard )
+        result = container.manage_pasteObjects(clipboard)
 
         # get a reference to the working copy
         target_id = result[0]['new_id']
-        target = container._getOb( target_id )
+        target = container._getOb(target_id)
         return target
 
-    def _handleReferences( self, baseline, wc, mode, wc_ref ):
+    def _handleReferences(self, baseline, wc, mode, wc_ref):
 
-        annotations = IAnnotations( wc_ref )
+        annotations = IAnnotations(wc_ref)
 
-        baseline_adapter = interfaces.ICheckinCheckoutReference( baseline )
+        baseline_adapter = interfaces.ICheckinCheckoutReference(baseline)
 
         # handle forward references
         for relationship in baseline.getRelationships():
             # look for a named relation adapter first
             adapter = component.queryAdapter(
-                baseline, interfaces.ICheckinCheckoutReference, relationship )
+                baseline, interfaces.ICheckinCheckoutReference, relationship)
 
             if adapter is None:  # default
                 adapter = baseline_adapter
 
-            references = baseline.getReferenceImpl( relationship )
+            references = baseline.getReferenceImpl(relationship)
 
-            mode_method = getattr( adapter, mode )
-            mode_method( baseline, wc, references, annotations )
+            mode_method = getattr(adapter, mode)
+            mode_method(baseline, wc, references, annotations)
 
         mode = mode + "BackReferences"
 
         # handle backward references
         for relationship in baseline.getBRelationships():
             adapter = component.queryAdapter(
-                baseline, interfaces.ICheckinCheckoutReference, relationship )
+                baseline, interfaces.ICheckinCheckoutReference, relationship)
             if adapter is None:
                 adapter = baseline_adapter
 
-            references = baseline.getBackReferenceImpl( relationship )
+            references = baseline.getBackReferenceImpl(relationship)
 
-            mode_method = getattr( adapter, mode )
-            mode_method( baseline, wc, references, annotations )
+            mode_method = getattr(adapter, mode)
+            mode_method(baseline, wc, references, annotations)
diff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py
index 50a1f45..ed7270b 100644
--- a/plone/app/iterate/dexterity/copier.py
+++ b/plone/app/iterate/dexterity/copier.py
@@ -48,10 +48,12 @@ def merge(self):
         # reassemble references on the new baseline
         self._handleReferences(baseline, self.context, "checkin", wc_ref)
 
-        # move the working copy to the baseline container, deleting the baseline
+        # move the working copy to the baseline container, deleting the
+        # baseline
         new_baseline = self._replaceBaseline(baseline)
 
-        # patch the working copy with baseline info not preserved during checkout
+        # patch the working copy with baseline info not preserved during
+        # checkout
         self._reassembleWorkingCopy(new_baseline, baseline)
 
         return new_baseline
@@ -101,7 +103,8 @@ def _replaceBaseline(self, baseline):
     def _reassembleWorkingCopy(self, new_baseline, baseline):
         # reattach the source's workflow history, try avoid a dangling ref
         try:
-            new_baseline.workflow_history = PersistentMapping(baseline.workflow_history.items())
+            new_baseline.workflow_history = PersistentMapping(
+                baseline.workflow_history.items())
         except AttributeError:
             # No workflow apparently.  Oh well.
             pass
@@ -157,7 +160,8 @@ def checkin(self, checkin_message):
         baseline = self._getBaseline()
         # get a hold of the relation object
         relation = self._get_relation_to_baseline()
-        # publish the event for subscribers, early because contexts are about to be manipulated
+        # publish the event for subscribers, early because contexts are about
+        # to be manipulated
         notify(event.CheckinEvent(self.context,
                                   baseline,
                                   relation,
diff --git a/plone/app/iterate/dexterity/interfaces.py b/plone/app/iterate/dexterity/interfaces.py
index e937076..ceb666e 100644
--- a/plone/app/iterate/dexterity/interfaces.py
+++ b/plone/app/iterate/dexterity/interfaces.py
@@ -6,5 +6,6 @@
 class IStagingRelationValue(IRelationValue):
     pass
 
+
 class IDexterityIterateAware(IIterateAware):
-    pass
\ No newline at end of file
+    pass
diff --git a/plone/app/iterate/dexterity/policy.py b/plone/app/iterate/dexterity/policy.py
index 3e2a694..a676d84 100644
--- a/plone/app/iterate/dexterity/policy.py
+++ b/plone/app/iterate/dexterity/policy.py
@@ -20,17 +20,20 @@ def _get_relation_to_baseline(self):
         relations = get_relations(self.context)
 
         if relations and not len(relations) == 1:
-            raise iterate.interfaces.CheckinException("Baseline count mismatch")
+            raise iterate.interfaces.CheckinException(
+                "Baseline count mismatch")
 
         if not relations or not relations[0]:
-            raise iterate.interfaces.CheckinException("Baseline has disappeared")
+            raise iterate.interfaces.CheckinException(
+                "Baseline has disappeared")
 
         return relations[0]
 
     def _getBaseline(self):
         baseline = get_baseline(self.context)
         if not baseline:
-            raise iterate.interfaces.CheckinException("Baseline has disappeared")
+            raise iterate.interfaces.CheckinException(
+                "Baseline has disappeared")
         return baseline
 
     def checkin(self, checkin_message):
@@ -38,7 +41,8 @@ def checkin(self, checkin_message):
         baseline = self._getBaseline()
         # get a hold of the relation object
         relation = self._get_relation_to_baseline()
-        # publish the event for subscribers, early because contexts are about to be manipulated
+        # publish the event for subscribers, early because contexts are about
+        # to be manipulated
         notify(iterate.event.CheckinEvent(self.context,
                                           baseline,
                                           relation,
@@ -61,4 +65,4 @@ def getProperties(self, obj, default=None):
         try:
             return get_storage(get_checkout_relation(obj), default=default)
         except AttributeError:
-            return default
\ No newline at end of file
+            return default
diff --git a/plone/app/iterate/dexterity/utils.py b/plone/app/iterate/dexterity/utils.py
index bb2fbc3..feb4918 100644
--- a/plone/app/iterate/dexterity/utils.py
+++ b/plone/app/iterate/dexterity/utils.py
@@ -23,7 +23,8 @@ def get_relations(context):
     catalog = component.getUtility(ICatalog)
     relations = list(catalog.findRelations({'to_id': id}))
     relations += list(catalog.findRelations({'from_id': id}))
-    relations = filter(lambda r: r.from_attribute == ITERATE_RELATION_NAME, relations)
+    relations = filter(lambda r: r.from_attribute ==
+                       ITERATE_RELATION_NAME, relations)
     return relations
 
 
diff --git a/plone/app/iterate/event.py b/plone/app/iterate/event.py
index a20256c..ecf99ee 100644
--- a/plone/app/iterate/event.py
+++ b/plone/app/iterate/event.py
@@ -27,58 +27,63 @@
 
 import interfaces
 
-class CheckoutEvent( ObjectEvent ):
 
-    implements( interfaces.ICheckoutEvent )
+class CheckoutEvent(ObjectEvent):
+
+    implements(interfaces.ICheckoutEvent)
 
     def __init__(self, baseline, wc, relation):
-        ObjectEvent.__init__(self, baseline )
+        ObjectEvent.__init__(self, baseline)
         self.working_copy = wc
         self.relation = relation
 
-class CheckinEvent( ObjectEvent ):
 
-    implements( interfaces.ICheckinEvent )
+class CheckinEvent(ObjectEvent):
+
+    implements(interfaces.ICheckinEvent)
 
     def __init__(self, wc, baseline, relation, message):
-        ObjectEvent.__init__( self, wc )
+        ObjectEvent.__init__(self, wc)
         self.baseline = baseline
         self.relation = relation
         self.message = message
 
-class AfterCheckinEvent( ObjectEvent ):
 
-    implements( interfaces.IAfterCheckinEvent )
+class AfterCheckinEvent(ObjectEvent):
 
-    def __init__( self, new_baseline, checkin_message ):
-        super( AfterCheckinEvent, self).__init__( new_baseline )
+    implements(interfaces.IAfterCheckinEvent)
+
+    def __init__(self, new_baseline, checkin_message):
+        super(AfterCheckinEvent, self).__init__(new_baseline)
         self.message = checkin_message
 
-class CancelCheckoutEvent( ObjectEvent ):
 
-    implements( interfaces.ICancelCheckoutEvent )
+class CancelCheckoutEvent(ObjectEvent):
+
+    implements(interfaces.ICancelCheckoutEvent)
 
-    def __init__( self, wc, baseline):
-        ObjectEvent.__init__(self, wc )
+    def __init__(self, wc, baseline):
+        ObjectEvent.__init__(self, wc)
         self.baseline = baseline
 
-class WorkingCopyDeletedEvent( ObjectEvent ):
 
-    implements( interfaces.IWorkingCopyDeletedEvent )
+class WorkingCopyDeletedEvent(ObjectEvent):
 
-    def __init__( self, wc, baseline, relation ):
-        ObjectEvent.__init__( self, wc )
+    implements(interfaces.IWorkingCopyDeletedEvent)
+
+    def __init__(self, wc, baseline, relation):
+        ObjectEvent.__init__(self, wc)
         self.baseline = baseline
         self.relation = relation
 
-class BeforeCheckoutEvent( ObjectEvent ):
 
-    implements( interfaces.IBeforeCheckoutEvent )
+class BeforeCheckoutEvent(ObjectEvent):
+
+    implements(interfaces.IBeforeCheckoutEvent)
 
 
-def handleDeletion( reference, event ):
+def handleDeletion(reference, event):
     # a filtering/enriching event rebroadcaster for working copy deletions
     workingCopy = reference.getSourceObject()
     baseline = reference.getTargetObject()
-    notify( WorkingCopyDeletedEvent( workingCopy, baseline, reference ) )
-
+    notify(WorkingCopyDeletedEvent(workingCopy, baseline, reference))
diff --git a/plone/app/iterate/interfaces.py b/plone/app/iterate/interfaces.py
index 9fce57e..9b57f4d 100644
--- a/plone/app/iterate/interfaces.py
+++ b/plone/app/iterate/interfaces.py
@@ -35,6 +35,7 @@
 ################################
 #  Marker interface
 
+
 class IIterateAware(Interface):
     """An object that can be used for check-in/check-out operations.
     """
@@ -47,15 +48,19 @@ class IIterateAware(Interface):
 #################################
 #  Exceptions
 
+
 class CociException(Exception):
     pass
 
+
 class CheckinException(CociException):
     pass
 
+
 class CheckoutException(CociException):
     pass
 
+
 class ConflictError(CheckinException):
     pass
 
@@ -64,6 +69,7 @@ class ConflictError(CheckinException):
 # Annotation Key
 annotation_key = "ore.iterate"
 
+
 class keys(object):
     # various common keys
     checkout_user = "checkout_user"
@@ -82,25 +88,30 @@ class ICheckinEvent(IObjectEvent):
     relation = Attribute("The Working Copy Archetypes Relation Object")
     checkin_message = Attribute("checkin message")
 
+
 class IAfterCheckinEvent(IObjectEvent):
     """ sent out after an object is checked in """
 
     checkin_message = Attribute("checkin message")
 
+
 class IBeforeCheckoutEvent(IObjectEvent):
     """ sent out before a working copy is created """
 
+
 class ICheckoutEvent(IObjectEvent):
     """ an object is being checked out, event.object is the baseline """
 
     working_copy = Attribute("The object's working copy")
     relation = Attribute("The Working Copy Archetypes Relation Object")
 
+
 class ICancelCheckoutEvent(IObjectEvent):
     """ a working copy is being cancelled """
 
     baseline = Attribute("The working copy's baseline")
 
+
 class IWorkingCopyDeletedEvent(IObjectEvent):
     """ a working copy is being deleted, this gets called multiple times at different
     states. so on cancel checkout and checkin operations, its mostly designed to
@@ -114,19 +125,23 @@ class IWorkingCopyDeletedEvent(IObjectEvent):
 #################################
 # Content Marker Interfaces
 
+
 class IIterateManagedContent(Interface):
     """Any content managed by iterate - normally a sub-interface is
     applied as a marker to an instance.
     """
 
+
 class IWorkingCopy(IIterateManagedContent):
     """A working copy/check-out
     """
 
+
 class IBaseline(IIterateManagedContent):
     """A baseline
     """
 
+
 class IWorkingCopyRelation(IReference):
     """A relationship to a working copy
     """
@@ -134,14 +149,17 @@ class IWorkingCopyRelation(IReference):
 #################################
 #  Working copy container locator
 
+
 class IWCContainerLocator(Interface):
     """A named adapter capable of discovering containers where working
     copies can be created.
     """
 
-    available = schema.Bool(title=u"Available", description=u"Whether location will be available.")
+    available = schema.Bool(
+        title=u"Available", description=u"Whether location will be available.")
 
-    title = schema.TextLine(title=u"Title", description=u"Title of this location")
+    title = schema.TextLine(
+        title=u"Title", description=u"Title of this location")
 
     def __call__():
         """Return a container object, or None if available() is False
@@ -150,6 +168,7 @@ def __call__():
 #################################
 #  Interfaces
 
+
 class ICheckinCheckoutTool(Interface):
 
     def allowCheckin(content):
@@ -196,6 +215,7 @@ def merge():
         """ merge/replace the source with the copy, context is the copy.
         """
 
+
 class IObjectArchiver(Interface):
     """ iterate needs minimal versioning support
     """
@@ -216,6 +236,7 @@ def isModified(self):
         """ is the resource current state, different than its last saved state.
         """
 
+
 class ICheckinCheckoutPolicy(Interface):
     """
     Checkin / Checkout Policy
diff --git a/plone/app/iterate/lock.py b/plone/app/iterate/lock.py
index 0eb8dbd..0a7bedb 100644
--- a/plone/app/iterate/lock.py
+++ b/plone/app/iterate/lock.py
@@ -31,17 +31,20 @@
 
 __all__ = ['lockContext', 'unlockContext', 'isLocked']
 
-def lockContext( context ):
+
+def lockContext(context):
     lockable = ILockable(context)
     # Be quite forceful - we assume that we won't have gotten here unless
     # we had rights to do this.
     lockable.clear_locks()
     lockable.lock(ITERATE_LOCK, children=True)
 
-def unlockContext( context ):
+
+def unlockContext(context):
     lockable = ILockable(context)
     lockable.unlock(ITERATE_LOCK)
 
-def isLocked( context ):
+
+def isLocked(context):
     lockable = ILockable(context)
-    lockable.locked()
\ No newline at end of file
+    lockable.locked()
diff --git a/plone/app/iterate/policy.py b/plone/app/iterate/policy.py
index 336f53e..249e56b 100644
--- a/plone/app/iterate/policy.py
+++ b/plone/app/iterate/policy.py
@@ -78,10 +78,13 @@ def checkin(self, checkin_message):
         baseline = self._getBaseline()
 
         # get a hold of the relation object
-        wc_ref = self.context.getReferenceImpl(WorkingCopyRelation.relationship)[0]
+        wc_ref = self.context.getReferenceImpl(
+            WorkingCopyRelation.relationship)[0]
 
-        # publish the event for subscribers, early because contexts are about to be manipulated
-        notify(event.CheckinEvent(self.context, baseline, wc_ref, checkin_message))
+        # publish the event for subscribers, early because contexts are about
+        # to be manipulated
+        notify(event.CheckinEvent(self.context,
+                                  baseline, wc_ref, checkin_message))
 
         # merge the object back to the baseline with a copier
 
@@ -139,4 +142,4 @@ def getWorkingCopy(self):
                 return refs[0]
 
     def getProperties(self, obj, default=None):
-        return get_storage(obj, default=default)
\ No newline at end of file
+        return get_storage(obj, default=default)
diff --git a/plone/app/iterate/relation.py b/plone/app/iterate/relation.py
index 21b6fc6..4e2948d 100644
--- a/plone/app/iterate/relation.py
+++ b/plone/app/iterate/relation.py
@@ -75,7 +75,8 @@ def __init__(self, context):
 
     def checkout(self, baseline, wc, refs, storage):
         for ref in refs:
-            wc.addReference(ref.targetUID, ref.relationship, referenceClass=ref.__class__)
+            wc.addReference(ref.targetUID, ref.relationship,
+                            referenceClass=ref.__class__)
 
     def checkin(self, *args):
         pass
@@ -98,7 +99,8 @@ def __init__(self, context):
     def checkin(self, baseline, wc, refs, storage):
         # move the references from the baseline to the wc
 
-        # one note, on checkin the wc uid is not yet changed to match that of the baseline
+        # one note, on checkin the wc uid is not yet changed to match that of
+        # the baseline
         ref_ids = [r.getId() for r in refs]
 
         baseline_ref_container = getattr(baseline, atconf.REFERENCE_ANNOTATION)
@@ -108,15 +110,14 @@ def checkin(self, baseline, wc, refs, storage):
 
         # references aren't globally addable w/ associated perm which default copysupport
         # wants to check, temporarily monkey around the issue.
-        def _verifyObjectPaste( *args, **kw ): pass
+        def _verifyObjectPaste(*args, **kw): pass
         wc_ref_container._verifyObjectPaste = _verifyObjectPaste
         try:
-            wc_ref_container.manage_pasteObjects( clipboard )
+            wc_ref_container.manage_pasteObjects(clipboard)
         finally:
             del wc_ref_container._verifyObjectPaste
 
-    def checkout( self, *args ):
+    def checkout(self, *args):
         pass
 
     checkoutBackReferences = checkinBackReferences = checkout
-
diff --git a/plone/app/iterate/setuphandlers.py b/plone/app/iterate/setuphandlers.py
index 595e04f..7ecd606 100644
--- a/plone/app/iterate/setuphandlers.py
+++ b/plone/app/iterate/setuphandlers.py
@@ -9,4 +9,4 @@ def deprecate_profile(tool):
     warnings.warn(
         'The profile with id "plone.app.iterate" was renamed to "default".',
         DeprecationWarning
-        )
+    )
diff --git a/plone/app/iterate/subscribers/locking.py b/plone/app/iterate/subscribers/locking.py
index 3e61161..58c36e3 100644
--- a/plone/app/iterate/subscribers/locking.py
+++ b/plone/app/iterate/subscribers/locking.py
@@ -26,28 +26,30 @@
 from plone.locking.interfaces import ILockable
 from plone.app.iterate import lock
 
-def handleWCDeleted( event ):
+
+def handleWCDeleted(event):
     # may be called multiple times, must be reentrant
-    lock.unlockContext( event.baseline )
+    lock.unlockContext(event.baseline)
     # we reindex to force a metadata update
-    event.baseline.reindexObject( idxs=['review_state'] )
+    event.baseline.reindexObject(idxs=['review_state'])
+
+
+def handleCheckout(event):
+    lock.lockContext(event.object)
+    event.object.reindexObject(idxs=['review_state'])
 
-def handleCheckout( event ):
-    lock.lockContext( event.object )
-    event.object.reindexObject( idxs=['review_state'] )
 
-def handleCheckin( event ):
-    lockable = ILockable( event.object )
+def handleCheckin(event):
+    lockable = ILockable(event.object)
     if lockable.locked():
         # unlock working copy if it was auto-locked, or this will fail
         lockable.clear_locks()
 
-def handleCancelCheckout( event ):
-    lockable = ILockable( event.object )
+
+def handleCancelCheckout(event):
+    lockable = ILockable(event.object)
     if lockable.locked():
         # unlock working copy if it was auto-locked, or this will fail
         lockable.clear_locks()
-    lock.unlockContext( event.baseline )
-    event.baseline.reindexObject( idxs=['review_state'] )
-
-
+    lock.unlockContext(event.baseline)
+    event.baseline.reindexObject(idxs=['review_state'])
diff --git a/plone/app/iterate/subscribers/marker.py b/plone/app/iterate/subscribers/marker.py
index 03328bf..cb76ccf 100644
--- a/plone/app/iterate/subscribers/marker.py
+++ b/plone/app/iterate/subscribers/marker.py
@@ -26,17 +26,20 @@
 from Products.Five.utilities import marker
 from plone.app.iterate import interfaces
 
-def handleCheckout( event ):
-    marker.mark( event.working_copy, interfaces.IWorkingCopy )
-    marker.mark( event.object, interfaces.IBaseline )
 
-def handleCheckin( event ):
-    marker.erase( event.object, interfaces.IWorkingCopy )
-    marker.erase( event.baseline, interfaces.IBaseline )
+def handleCheckout(event):
+    marker.mark(event.working_copy, interfaces.IWorkingCopy)
+    marker.mark(event.object, interfaces.IBaseline)
 
-def handleWCDeleted( event ):
-    marker.erase( event.baseline, interfaces.IBaseline )
 
-def handleCancelCheckout( event ):
-    marker.erase( event.baseline, interfaces.IBaseline )
+def handleCheckin(event):
+    marker.erase(event.object, interfaces.IWorkingCopy)
+    marker.erase(event.baseline, interfaces.IBaseline)
 
+
+def handleWCDeleted(event):
+    marker.erase(event.baseline, interfaces.IBaseline)
+
+
+def handleCancelCheckout(event):
+    marker.erase(event.baseline, interfaces.IBaseline)
diff --git a/plone/app/iterate/subscribers/versioning.py b/plone/app/iterate/subscribers/versioning.py
index 1f63124..b7a1a67 100644
--- a/plone/app/iterate/subscribers/versioning.py
+++ b/plone/app/iterate/subscribers/versioning.py
@@ -25,12 +25,12 @@
 from plone.app.iterate import interfaces
 
 
-def handleBeforeCheckout( event ):
-    archiver = interfaces.IObjectArchiver( event.object )
+def handleBeforeCheckout(event):
+    archiver = interfaces.IObjectArchiver(event.object)
     if archiver.isModified() or not archiver.isVersioned():
         archiver.save("Baseline created")
 
 
-def handleAfterCheckin( event ):
-    archiver = interfaces.IObjectArchiver( event.object )
-    archiver.save( event.message )
+def handleAfterCheckin(event):
+    archiver = interfaces.IObjectArchiver(event.object)
+    archiver.save(event.message)
diff --git a/plone/app/iterate/util.py b/plone/app/iterate/util.py
index f1a2908..9da465a 100644
--- a/plone/app/iterate/util.py
+++ b/plone/app/iterate/util.py
@@ -25,6 +25,7 @@
 from interfaces import annotation_key
 from Products.CMFCore.utils import getToolByName
 
+
 def get_storage(context, default=None):
     annotations = IAnnotations(context)
     if annotation_key not in annotations:


Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2016-03-12T08:08:15+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.forcada@freitag.de>
Commit: https://github.com/plone/plone.app.iterate/commit/638a61a1402c749d58b90f36dee203ece2aac52a

Merge pull request #24 from plone/minimal-cleanup

Minimal cleanup

Files changed:
M plone/app/iterate/__init__.py
M plone/app/iterate/archiver.py
M plone/app/iterate/browser/cancel.py
M plone/app/iterate/browser/checkin.py
M plone/app/iterate/browser/checkout.py
M plone/app/iterate/containers.py
M plone/app/iterate/copier.py
M plone/app/iterate/dexterity/copier.py
M plone/app/iterate/dexterity/interfaces.py
M plone/app/iterate/dexterity/policy.py
M plone/app/iterate/dexterity/utils.py
M plone/app/iterate/event.py
M plone/app/iterate/interfaces.py
M plone/app/iterate/lock.py
M plone/app/iterate/policy.py
M plone/app/iterate/relation.py
M plone/app/iterate/setuphandlers.py
M plone/app/iterate/subscribers/locking.py
M plone/app/iterate/subscribers/marker.py
M plone/app/iterate/subscribers/versioning.py
M plone/app/iterate/util.py

diff --git a/plone/app/iterate/__init__.py b/plone/app/iterate/__init__.py
index 4b7c8c5..67a650a 100644
--- a/plone/app/iterate/__init__.py
+++ b/plone/app/iterate/__init__.py
@@ -43,4 +43,4 @@
                  'of plone.app.iterate. You may experience problems running this configuration. '
                  'plone.app.iterate now has dexterity suport built-in.')
 except ImportError:
-    pass
\ No newline at end of file
+    pass
diff --git a/plone/app/iterate/archiver.py b/plone/app/iterate/archiver.py
index bf8c13b..451055a 100644
--- a/plone/app/iterate/archiver.py
+++ b/plone/app/iterate/archiver.py
@@ -30,6 +30,7 @@
 
 import interfaces
 
+
 class ContentArchiver(object):
 
     implements(interfaces.IObjectArchiver)
diff --git a/plone/app/iterate/browser/cancel.py b/plone/app/iterate/browser/cancel.py
index 29e85a8..68da659 100644
--- a/plone/app/iterate/browser/cancel.py
+++ b/plone/app/iterate/browser/cancel.py
@@ -32,6 +32,7 @@
 from plone.app.iterate.interfaces import ICheckinCheckoutPolicy
 from plone.app.iterate.interfaces import CheckoutException
 
+
 class Cancel(BrowserView):
 
     index = ViewPageTemplateFile('cancel.pt')
@@ -40,7 +41,8 @@ def __call__(self):
         context = aq_inner(self.context)
 
         if self.request.form.has_key('form.button.Cancel'):
-            control = getMultiAdapter((context, self.request), name=u"iterate_control")
+            control = getMultiAdapter(
+                (context, self.request), name=u"iterate_control")
             if not control.cancel_allowed():
                 raise CheckoutException(u"Not a checkout")
 
@@ -48,12 +50,14 @@ def __call__(self):
             baseline = policy.cancelCheckout()
             baseline.reindexObject()
 
-            IStatusMessage(self.request).addStatusMessage(_(u"Checkout cancelled"), type='info')
-            view_url = baseline.restrictedTraverse("@@plone_context_state").view_url()
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"Checkout cancelled"), type='info')
+            view_url = baseline.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         elif self.request.form.has_key('form.button.Keep'):
-            view_url = context.restrictedTraverse("@@plone_context_state").view_url()
+            view_url = context.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
-
diff --git a/plone/app/iterate/browser/checkin.py b/plone/app/iterate/browser/checkin.py
index c6bc589..033562a 100644
--- a/plone/app/iterate/browser/checkin.py
+++ b/plone/app/iterate/browser/checkin.py
@@ -32,6 +32,7 @@
 from plone.app.iterate.interfaces import ICheckinCheckoutPolicy
 from plone.app.iterate.interfaces import CheckinException
 
+
 class Checkin(BrowserView):
 
     index = ViewPageTemplateFile('checkin.pt')
@@ -40,7 +41,8 @@ def __call__(self):
         context = aq_inner(self.context)
 
         if self.request.form.has_key('form.button.Checkin'):
-            control = getMultiAdapter((context, self.request), name=u"iterate_control")
+            control = getMultiAdapter(
+                (context, self.request), name=u"iterate_control")
             if not control.checkin_allowed():
                 raise CheckinException(u"Not a checkout")
 
@@ -49,11 +51,14 @@ def __call__(self):
             policy = ICheckinCheckoutPolicy(context)
             baseline = policy.checkin(message)
 
-            IStatusMessage(self.request).addStatusMessage(_("Checked in"), type='info')
-            view_url = baseline.restrictedTraverse("@@plone_context_state").view_url()
+            IStatusMessage(self.request).addStatusMessage(
+                _("Checked in"), type='info')
+            view_url = baseline.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         elif self.request.form.has_key('form.button.Cancel'):
-            view_url = context.restrictedTraverse("@@plone_context_state").view_url()
+            view_url = context.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
diff --git a/plone/app/iterate/browser/checkout.py b/plone/app/iterate/browser/checkout.py
index f88a5ff..30f30dd 100644
--- a/plone/app/iterate/browser/checkout.py
+++ b/plone/app/iterate/browser/checkout.py
@@ -58,32 +58,39 @@ def __call__(self):
         # We want to redirect to a specific template, else we might
         # end up downloading a file
         if 'form.button.Checkout' in self.request.form:
-            control = getMultiAdapter((context, self.request), name=u"iterate_control")
+            control = getMultiAdapter(
+                (context, self.request), name=u"iterate_control")
             if not control.checkout_allowed():
                 raise CheckoutException(u"Not allowed")
 
             location = self.request.form.get('checkout_location', None)
             locator = None
             try:
-                locator = [c['locator'] for c in self.containers() if c['name'] == location][0]
+                locator = [c['locator']
+                           for c in self.containers() if c['name'] == location][0]
             except IndexError:
                 IStatusMessage(self.request).addStatusMessage(_("Cannot find checkout location"),
                                                               type='error')
-                view_url = context.restrictedTraverse("@@plone_context_state").view_url()
+                view_url = context.restrictedTraverse(
+                    "@@plone_context_state").view_url()
                 self.request.response.redirect(view_url)
                 return
 
             policy = ICheckinCheckoutPolicy(context)
             wc = policy.checkout(locator())
 
-            # we do this for metadata update side affects which will update lock info
+            # we do this for metadata update side affects which will update
+            # lock info
             context.reindexObject('review_state')
 
-            IStatusMessage(self.request).addStatusMessage(_("Check-out created"), type='info')
-            view_url = wc.restrictedTraverse("@@plone_context_state").view_url()
+            IStatusMessage(self.request).addStatusMessage(
+                _("Check-out created"), type='info')
+            view_url = wc.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         elif 'form.button.Cancel' in self.request.form:
-            view_url = context.restrictedTraverse("@@plone_context_state").view_url()
+            view_url = context.restrictedTraverse(
+                "@@plone_context_state").view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
diff --git a/plone/app/iterate/containers.py b/plone/app/iterate/containers.py
index 7a69d47..4c15290 100644
--- a/plone/app/iterate/containers.py
+++ b/plone/app/iterate/containers.py
@@ -51,6 +51,7 @@ def available(self):
     def __call__(self):
         return getToolByName(self.context, 'portal_membership').getHomeFolder()
 
+
 class ParentFolderLocator(object):
     """Locate the parent of the context, if the user has the
     Add portal content permission.
diff --git a/plone/app/iterate/copier.py b/plone/app/iterate/copier.py
index 055c34c..d71c5de 100644
--- a/plone/app/iterate/copier.py
+++ b/plone/app/iterate/copier.py
@@ -42,76 +42,76 @@
 from interfaces import CheckinException
 
 
-class ContentCopier( object ):
+class ContentCopier(object):
 
-    interface.implements( interfaces.IObjectCopier )
-    component.adapts( interfaces.IIterateAware )
+    interface.implements(interfaces.IObjectCopier)
+    component.adapts(interfaces.IIterateAware)
 
-    def __init__( self, context ):
+    def __init__(self, context):
         self.context = context
 
-    def copyTo( self, container ):
-        wc = self._copyBaseline( container )
+    def copyTo(self, container):
+        wc = self._copyBaseline(container)
         wc_ref = wc.addReference(
             self.context,
             relationship=WorkingCopyRelation.relationship,
             referenceClass=WorkingCopyRelation)
-        self._handleReferences( self.context, wc, "checkout", wc_ref )
+        self._handleReferences(self.context, wc, "checkout", wc_ref)
         return wc, wc_ref
 
-    def merge( self ):
+    def merge(self):
         baseline = self._getBaseline()
 
         # delete the working copy reference to the baseline
         wc_ref = self._deleteWorkingCopyRelation()
 
         # reassemble references on the new baseline
-        self._handleReferences( baseline, self.context, "checkin", wc_ref )
+        self._handleReferences(baseline, self.context, "checkin", wc_ref)
 
         # move the working copy to the baseline container, deleting
         # the baseline
-        new_baseline = self._replaceBaseline( baseline )
+        new_baseline = self._replaceBaseline(baseline)
 
         # patch the working copy with baseline info not preserved
         # during checkout
-        self._reassembleWorkingCopy( new_baseline, baseline )
+        self._reassembleWorkingCopy(new_baseline, baseline)
 
         return new_baseline
 
-    def _getBaseline( self ):
+    def _getBaseline(self):
         # follow the working copy's reference back to the baseline
-        refs = self.context.getRefs( WorkingCopyRelation.relationship )
+        refs = self.context.getRefs(WorkingCopyRelation.relationship)
 
         if not len(refs) == 1:
-            raise CheckinException( "Baseline count mismatch" )
+            raise CheckinException("Baseline count mismatch")
 
         if not refs or refs[0] is None:
-            raise CheckinException( "Baseline has disappeared" )
+            raise CheckinException("Baseline has disappeared")
 
         baseline = refs[0]
         return baseline
 
-    def _replaceBaseline( self, baseline ):
+    def _replaceBaseline(self, baseline):
         # move the working copy object to the baseline, returns the
         # new baseline
         baseline_id = baseline.getId()
 
         # delete the baseline from the folder to make room for the
         # committed working copy
-        baseline_container = aq_parent( aq_inner( baseline ) )
+        baseline_container = aq_parent(aq_inner(baseline))
         # Check if we are a default_page, because this property of the
         # container might get lost.
         is_default_page = (
             baseline_container.getProperty('default_page', '') == baseline_id)
         baseline_pos = baseline_container.getObjectPosition(baseline_id)
-        baseline_container._delOb( baseline_id )
+        baseline_container._delOb(baseline_id)
 
         # uninedxing the deleted baseline object from portal_catalog
         portal_catalog = getToolByName(self.context, 'portal_catalog')
         portal_catalog.unindexObject(baseline)
 
         # delete the working copy from the its container
-        wc_container = aq_parent( aq_inner( self.context ) )
+        wc_container = aq_parent(aq_inner(self.context))
 
         # trick out the at machinery to not delete references
         self.context._v_cp_refs = 1
@@ -121,12 +121,12 @@ def _replaceBaseline( self, baseline ):
         wc_container.manage_delObjects([wc_id])
 
         # move the working copy back to the baseline container
-        working_copy = aq_base( self.context )
-        working_copy.setId( baseline_id )
-        baseline_container._setOb( baseline_id, working_copy )
+        working_copy = aq_base(self.context)
+        working_copy.setId(baseline_id)
+        baseline_container._setOb(baseline_id, working_copy)
         baseline_container.moveObjectToPosition(baseline_id, baseline_pos)
 
-        new_baseline = baseline_container._getOb( baseline_id )
+        new_baseline = baseline_container._getOb(baseline_id)
         if is_default_page:
             # Restore default_page to container.  Note that the property might
             # have been removed by an event handler in the mean time.
@@ -136,15 +136,15 @@ def _replaceBaseline( self, baseline ):
                 baseline_container._setProperty('default_page', baseline_id)
 
         # reregister our references with the reference machinery after moving
-        Referenceable.manage_afterAdd( new_baseline, new_baseline,
-                                       baseline_container)
+        Referenceable.manage_afterAdd(new_baseline, new_baseline,
+                                      baseline_container)
 
         notify(ObjectMovedEvent(new_baseline, wc_container,
                                 wc_id, baseline_container, baseline_id))
 
         return new_baseline
 
-    def _reassembleWorkingCopy( self, new_baseline, baseline ):
+    def _reassembleWorkingCopy(self, new_baseline, baseline):
         # reattach the source's workflow history, try avoid a dangling ref
         try:
             new_baseline.workflow_history = PersistentMapping(
@@ -155,11 +155,11 @@ def _reassembleWorkingCopy( self, new_baseline, baseline ):
 
         # reset wf state security directly
         workflow_tool = getToolByName(self.context, 'portal_workflow')
-        wfs = workflow_tool.getWorkflowsFor( self.context )
+        wfs = workflow_tool.getWorkflowsFor(self.context)
         for wf in wfs:
-            if not isinstance( wf, DCWorkflowDefinition ):
+            if not isinstance(wf, DCWorkflowDefinition):
                 continue
-            wf.updateRoleMappingsFor( new_baseline )
+            wf.updateRoleMappingsFor(new_baseline)
 
         # Reattach the source's uid, this will update wc refs to point
         # back to the new baseline.  This may introduce duplicate
@@ -169,15 +169,15 @@ def _reassembleWorkingCopy( self, new_baseline, baseline ):
         # reattach the source's history id, to get the previous
         # version ancestry
         histid_handler = getToolByName(self.context, 'portal_historyidhandler')
-        huid = histid_handler.getUid( baseline )
-        histid_handler.setUid( new_baseline, huid, check_uniqueness=False )
+        huid = histid_handler.getUid(baseline)
+        histid_handler.setUid(new_baseline, huid, check_uniqueness=False)
 
         return new_baseline
 
     def _recursivelyReattachUIDs(self, baseline, new_baseline):
         original_refs = len(new_baseline.getRefs())
         original_back_refs = len(new_baseline.getBRefs())
-        new_baseline._setUID( baseline.UID() )
+        new_baseline._setUID(baseline.UID())
         new_refs = len(new_baseline.getRefs())
         new_back_refs = len(new_baseline.getBRefs())
         if original_refs != new_refs:
@@ -209,57 +209,57 @@ def _removeDuplicateReferences(self, item, backrefs=False):
             if brain.getObject() is None:
                 reference_tool.uncatalog_object(brain.getPath())
 
-    def _deleteWorkingCopyRelation( self ):
+    def _deleteWorkingCopyRelation(self):
         # delete the wc reference keeping a reference to it for its annotations
         refs = self.context.getReferenceImpl(WorkingCopyRelation.relationship)
         wc_ref = refs[0]
-        self.context.deleteReferences( WorkingCopyRelation.relationship )
+        self.context.deleteReferences(WorkingCopyRelation.relationship)
         return wc_ref
 
     #################################
-    ## Checkout Support Methods
+    # Checkout Support Methods
 
-    def _copyBaseline( self, container ):
+    def _copyBaseline(self, container):
         # copy the context from source to the target container
-        source_container = aq_parent( aq_inner( self.context ) )
+        source_container = aq_parent(aq_inner(self.context))
         clipboard = source_container.manage_copyObjects([self.context.getId()])
-        result = container.manage_pasteObjects( clipboard )
+        result = container.manage_pasteObjects(clipboard)
 
         # get a reference to the working copy
         target_id = result[0]['new_id']
-        target = container._getOb( target_id )
+        target = container._getOb(target_id)
         return target
 
-    def _handleReferences( self, baseline, wc, mode, wc_ref ):
+    def _handleReferences(self, baseline, wc, mode, wc_ref):
 
-        annotations = IAnnotations( wc_ref )
+        annotations = IAnnotations(wc_ref)
 
-        baseline_adapter = interfaces.ICheckinCheckoutReference( baseline )
+        baseline_adapter = interfaces.ICheckinCheckoutReference(baseline)
 
         # handle forward references
         for relationship in baseline.getRelationships():
             # look for a named relation adapter first
             adapter = component.queryAdapter(
-                baseline, interfaces.ICheckinCheckoutReference, relationship )
+                baseline, interfaces.ICheckinCheckoutReference, relationship)
 
             if adapter is None:  # default
                 adapter = baseline_adapter
 
-            references = baseline.getReferenceImpl( relationship )
+            references = baseline.getReferenceImpl(relationship)
 
-            mode_method = getattr( adapter, mode )
-            mode_method( baseline, wc, references, annotations )
+            mode_method = getattr(adapter, mode)
+            mode_method(baseline, wc, references, annotations)
 
         mode = mode + "BackReferences"
 
         # handle backward references
         for relationship in baseline.getBRelationships():
             adapter = component.queryAdapter(
-                baseline, interfaces.ICheckinCheckoutReference, relationship )
+                baseline, interfaces.ICheckinCheckoutReference, relationship)
             if adapter is None:
                 adapter = baseline_adapter
 
-            references = baseline.getBackReferenceImpl( relationship )
+            references = baseline.getBackReferenceImpl(relationship)
 
-            mode_method = getattr( adapter, mode )
-            mode_method( baseline, wc, references, annotations )
+            mode_method = getattr(adapter, mode)
+            mode_method(baseline, wc, references, annotations)
diff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py
index 50a1f45..ed7270b 100644
--- a/plone/app/iterate/dexterity/copier.py
+++ b/plone/app/iterate/dexterity/copier.py
@@ -48,10 +48,12 @@ def merge(self):
         # reassemble references on the new baseline
         self._handleReferences(baseline, self.context, "checkin", wc_ref)
 
-        # move the working copy to the baseline container, deleting the baseline
+        # move the working copy to the baseline container, deleting the
+        # baseline
         new_baseline = self._replaceBaseline(baseline)
 
-        # patch the working copy with baseline info not preserved during checkout
+        # patch the working copy with baseline info not preserved during
+        # checkout
         self._reassembleWorkingCopy(new_baseline, baseline)
 
         return new_baseline
@@ -101,7 +103,8 @@ def _replaceBaseline(self, baseline):
     def _reassembleWorkingCopy(self, new_baseline, baseline):
         # reattach the source's workflow history, try avoid a dangling ref
         try:
-            new_baseline.workflow_history = PersistentMapping(baseline.workflow_history.items())
+            new_baseline.workflow_history = PersistentMapping(
+                baseline.workflow_history.items())
         except AttributeError:
             # No workflow apparently.  Oh well.
             pass
@@ -157,7 +160,8 @@ def checkin(self, checkin_message):
         baseline = self._getBaseline()
         # get a hold of the relation object
         relation = self._get_relation_to_baseline()
-        # publish the event for subscribers, early because contexts are about to be manipulated
+        # publish the event for subscribers, early because contexts are about
+        # to be manipulated
         notify(event.CheckinEvent(self.context,
                                   baseline,
                                   relation,
diff --git a/plone/app/iterate/dexterity/interfaces.py b/plone/app/iterate/dexterity/interfaces.py
index e937076..ceb666e 100644
--- a/plone/app/iterate/dexterity/interfaces.py
+++ b/plone/app/iterate/dexterity/interfaces.py
@@ -6,5 +6,6 @@
 class IStagingRelationValue(IRelationValue):
     pass
 
+
 class IDexterityIterateAware(IIterateAware):
-    pass
\ No newline at end of file
+    pass
diff --git a/plone/app/iterate/dexterity/policy.py b/plone/app/iterate/dexterity/policy.py
index 3e2a694..a676d84 100644
--- a/plone/app/iterate/dexterity/policy.py
+++ b/plone/app/iterate/dexterity/policy.py
@@ -20,17 +20,20 @@ def _get_relation_to_baseline(self):
         relations = get_relations(self.context)
 
         if relations and not len(relations) == 1:
-            raise iterate.interfaces.CheckinException("Baseline count mismatch")
+            raise iterate.interfaces.CheckinException(
+                "Baseline count mismatch")
 
         if not relations or not relations[0]:
-            raise iterate.interfaces.CheckinException("Baseline has disappeared")
+            raise iterate.interfaces.CheckinException(
+                "Baseline has disappeared")
 
         return relations[0]
 
     def _getBaseline(self):
         baseline = get_baseline(self.context)
         if not baseline:
-            raise iterate.interfaces.CheckinException("Baseline has disappeared")
+            raise iterate.interfaces.CheckinException(
+                "Baseline has disappeared")
         return baseline
 
     def checkin(self, checkin_message):
@@ -38,7 +41,8 @@ def checkin(self, checkin_message):
         baseline = self._getBaseline()
         # get a hold of the relation object
         relation = self._get_relation_to_baseline()
-        # publish the event for subscribers, early because contexts are about to be manipulated
+        # publish the event for subscribers, early because contexts are about
+        # to be manipulated
         notify(iterate.event.CheckinEvent(self.context,
                                           baseline,
                                           relation,
@@ -61,4 +65,4 @@ def getProperties(self, obj, default=None):
         try:
             return get_storage(get_checkout_relation(obj), default=default)
         except AttributeError:
-            return default
\ No newline at end of file
+            return default
diff --git a/plone/app/iterate/dexterity/utils.py b/plone/app/iterate/dexterity/utils.py
index bb2fbc3..feb4918 100644
--- a/plone/app/iterate/dexterity/utils.py
+++ b/plone/app/iterate/dexterity/utils.py
@@ -23,7 +23,8 @@ def get_relations(context):
     catalog = component.getUtility(ICatalog)
     relations = list(catalog.findRelations({'to_id': id}))
     relations += list(catalog.findRelations({'from_id': id}))
-    relations = filter(lambda r: r.from_attribute == ITERATE_RELATION_NAME, relations)
+    relations = filter(lambda r: r.from_attribute ==
+                       ITERATE_RELATION_NAME, relations)
     return relations
 
 
diff --git a/plone/app/iterate/event.py b/plone/app/iterate/event.py
index a20256c..ecf99ee 100644
--- a/plone/app/iterate/event.py
+++ b/plone/app/iterate/event.py
@@ -27,58 +27,63 @@
 
 import interfaces
 
-class CheckoutEvent( ObjectEvent ):
 
-    implements( interfaces.ICheckoutEvent )
+class CheckoutEvent(ObjectEvent):
+
+    implements(interfaces.ICheckoutEvent)
 
     def __init__(self, baseline, wc, relation):
-        ObjectEvent.__init__(self, baseline )
+        ObjectEvent.__init__(self, baseline)
         self.working_copy = wc
         self.relation = relation
 
-class CheckinEvent( ObjectEvent ):
 
-    implements( interfaces.ICheckinEvent )
+class CheckinEvent(ObjectEvent):
+
+    implements(interfaces.ICheckinEvent)
 
     def __init__(self, wc, baseline, relation, message):
-        ObjectEvent.__init__( self, wc )
+        ObjectEvent.__init__(self, wc)
         self.baseline = baseline
         self.relation = relation
         self.message = message
 
-class AfterCheckinEvent( ObjectEvent ):
 
-    implements( interfaces.IAfterCheckinEvent )
+class AfterCheckinEvent(ObjectEvent):
 
-    def __init__( self, new_baseline, checkin_message ):
-        super( AfterCheckinEvent, self).__init__( new_baseline )
+    implements(interfaces.IAfterCheckinEvent)
+
+    def __init__(self, new_baseline, checkin_message):
+        super(AfterCheckinEvent, self).__init__(new_baseline)
         self.message = checkin_message
 
-class CancelCheckoutEvent( ObjectEvent ):
 
-    implements( interfaces.ICancelCheckoutEvent )
+class CancelCheckoutEvent(ObjectEvent):
+
+    implements(interfaces.ICancelCheckoutEvent)
 
-    def __init__( self, wc, baseline):
-        ObjectEvent.__init__(self, wc )
+    def __init__(self, wc, baseline):
+        ObjectEvent.__init__(self, wc)
         self.baseline = baseline
 
-class WorkingCopyDeletedEvent( ObjectEvent ):
 
-    implements( interfaces.IWorkingCopyDeletedEvent )
+class WorkingCopyDeletedEvent(ObjectEvent):
 
-    def __init__( self, wc, baseline, relation ):
-        ObjectEvent.__init__( self, wc )
+    implements(interfaces.IWorkingCopyDeletedEvent)
+
+    def __init__(self, wc, baseline, relation):
+        ObjectEvent.__init__(self, wc)
         self.baseline = baseline
         self.relation = relation
 
-class BeforeCheckoutEvent( ObjectEvent ):
 
-    implements( interfaces.IBeforeCheckoutEvent )
+class BeforeCheckoutEvent(ObjectEvent):
+
+    implements(interfaces.IBeforeCheckoutEvent)
 
 
-def handleDeletion( reference, event ):
+def handleDeletion(reference, event):
     # a filtering/enriching event rebroadcaster for working copy deletions
     workingCopy = reference.getSourceObject()
     baseline = reference.getTargetObject()
-    notify( WorkingCopyDeletedEvent( workingCopy, baseline, reference ) )
-
+    notify(WorkingCopyDeletedEvent(workingCopy, baseline, reference))
diff --git a/plone/app/iterate/interfaces.py b/plone/app/iterate/interfaces.py
index 9fce57e..9b57f4d 100644
--- a/plone/app/iterate/interfaces.py
+++ b/plone/app/iterate/interfaces.py
@@ -35,6 +35,7 @@
 ################################
 #  Marker interface
 
+
 class IIterateAware(Interface):
     """An object that can be used for check-in/check-out operations.
     """
@@ -47,15 +48,19 @@ class IIterateAware(Interface):
 #################################
 #  Exceptions
 
+
 class CociException(Exception):
     pass
 
+
 class CheckinException(CociException):
     pass
 
+
 class CheckoutException(CociException):
     pass
 
+
 class ConflictError(CheckinException):
     pass
 
@@ -64,6 +69,7 @@ class ConflictError(CheckinException):
 # Annotation Key
 annotation_key = "ore.iterate"
 
+
 class keys(object):
     # various common keys
     checkout_user = "checkout_user"
@@ -82,25 +88,30 @@ class ICheckinEvent(IObjectEvent):
     relation = Attribute("The Working Copy Archetypes Relation Object")
     checkin_message = Attribute("checkin message")
 
+
 class IAfterCheckinEvent(IObjectEvent):
     """ sent out after an object is checked in """
 
     checkin_message = Attribute("checkin message")
 
+
 class IBeforeCheckoutEvent(IObjectEvent):
     """ sent out before a working copy is created """
 
+
 class ICheckoutEvent(IObjectEvent):
     """ an object is being checked out, event.object is the baseline """
 
     working_copy = Attribute("The object's working copy")
     relation = Attribute("The Working Copy Archetypes Relation Object")
 
+
 class ICancelCheckoutEvent(IObjectEvent):
     """ a working copy is being cancelled """
 
     baseline = Attribute("The working copy's baseline")
 
+
 class IWorkingCopyDeletedEvent(IObjectEvent):
     """ a working copy is being deleted, this gets called multiple times at different
     states. so on cancel checkout and checkin operations, its mostly designed to
@@ -114,19 +125,23 @@ class IWorkingCopyDeletedEvent(IObjectEvent):
 #################################
 # Content Marker Interfaces
 
+
 class IIterateManagedContent(Interface):
     """Any content managed by iterate - normally a sub-interface is
     applied as a marker to an instance.
     """
 
+
 class IWorkingCopy(IIterateManagedContent):
     """A working copy/check-out
     """
 
+
 class IBaseline(IIterateManagedContent):
     """A baseline
     """
 
+
 class IWorkingCopyRelation(IReference):
     """A relationship to a working copy
     """
@@ -134,14 +149,17 @@ class IWorkingCopyRelation(IReference):
 #################################
 #  Working copy container locator
 
+
 class IWCContainerLocator(Interface):
     """A named adapter capable of discovering containers where working
     copies can be created.
     """
 
-    available = schema.Bool(title=u"Available", description=u"Whether location will be available.")
+    available = schema.Bool(
+        title=u"Available", description=u"Whether location will be available.")
 
-    title = schema.TextLine(title=u"Title", description=u"Title of this location")
+    title = schema.TextLine(
+        title=u"Title", description=u"Title of this location")
 
     def __call__():
         """Return a container object, or None if available() is False
@@ -150,6 +168,7 @@ def __call__():
 #################################
 #  Interfaces
 
+
 class ICheckinCheckoutTool(Interface):
 
     def allowCheckin(content):
@@ -196,6 +215,7 @@ def merge():
         """ merge/replace the source with the copy, context is the copy.
         """
 
+
 class IObjectArchiver(Interface):
     """ iterate needs minimal versioning support
     """
@@ -216,6 +236,7 @@ def isModified(self):
         """ is the resource current state, different than its last saved state.
         """
 
+
 class ICheckinCheckoutPolicy(Interface):
     """
     Checkin / Checkout Policy
diff --git a/plone/app/iterate/lock.py b/plone/app/iterate/lock.py
index 0eb8dbd..0a7bedb 100644
--- a/plone/app/iterate/lock.py
+++ b/plone/app/iterate/lock.py
@@ -31,17 +31,20 @@
 
 __all__ = ['lockContext', 'unlockContext', 'isLocked']
 
-def lockContext( context ):
+
+def lockContext(context):
     lockable = ILockable(context)
     # Be quite forceful - we assume that we won't have gotten here unless
     # we had rights to do this.
     lockable.clear_locks()
     lockable.lock(ITERATE_LOCK, children=True)
 
-def unlockContext( context ):
+
+def unlockContext(context):
     lockable = ILockable(context)
     lockable.unlock(ITERATE_LOCK)
 
-def isLocked( context ):
+
+def isLocked(context):
     lockable = ILockable(context)
-    lockable.locked()
\ No newline at end of file
+    lockable.locked()
diff --git a/plone/app/iterate/policy.py b/plone/app/iterate/policy.py
index 336f53e..249e56b 100644
--- a/plone/app/iterate/policy.py
+++ b/plone/app/iterate/policy.py
@@ -78,10 +78,13 @@ def checkin(self, checkin_message):
         baseline = self._getBaseline()
 
         # get a hold of the relation object
-        wc_ref = self.context.getReferenceImpl(WorkingCopyRelation.relationship)[0]
+        wc_ref = self.context.getReferenceImpl(
+            WorkingCopyRelation.relationship)[0]
 
-        # publish the event for subscribers, early because contexts are about to be manipulated
-        notify(event.CheckinEvent(self.context, baseline, wc_ref, checkin_message))
+        # publish the event for subscribers, early because contexts are about
+        # to be manipulated
+        notify(event.CheckinEvent(self.context,
+                                  baseline, wc_ref, checkin_message))
 
         # merge the object back to the baseline with a copier
 
@@ -139,4 +142,4 @@ def getWorkingCopy(self):
                 return refs[0]
 
     def getProperties(self, obj, default=None):
-        return get_storage(obj, default=default)
\ No newline at end of file
+        return get_storage(obj, default=default)
diff --git a/plone/app/iterate/relation.py b/plone/app/iterate/relation.py
index 21b6fc6..4e2948d 100644
--- a/plone/app/iterate/relation.py
+++ b/plone/app/iterate/relation.py
@@ -75,7 +75,8 @@ def __init__(self, context):
 
     def checkout(self, baseline, wc, refs, storage):
         for ref in refs:
-            wc.addReference(ref.targetUID, ref.relationship, referenceClass=ref.__class__)
+            wc.addReference(ref.targetUID, ref.relationship,
+                            referenceClass=ref.__class__)
 
     def checkin(self, *args):
         pass
@@ -98,7 +99,8 @@ def __init__(self, context):
     def checkin(self, baseline, wc, refs, storage):
         # move the references from the baseline to the wc
 
-        # one note, on checkin the wc uid is not yet changed to match that of the baseline
+        # one note, on checkin the wc uid is not yet changed to match that of
+        # the baseline
         ref_ids = [r.getId() for r in refs]
 
         baseline_ref_container = getattr(baseline, atconf.REFERENCE_ANNOTATION)
@@ -108,15 +110,14 @@ def checkin(self, baseline, wc, refs, storage):
 
         # references aren't globally addable w/ associated perm which default copysupport
         # wants to check, temporarily monkey around the issue.
-        def _verifyObjectPaste( *args, **kw ): pass
+        def _verifyObjectPaste(*args, **kw): pass
         wc_ref_container._verifyObjectPaste = _verifyObjectPaste
         try:
-            wc_ref_container.manage_pasteObjects( clipboard )
+            wc_ref_container.manage_pasteObjects(clipboard)
         finally:
             del wc_ref_container._verifyObjectPaste
 
-    def checkout( self, *args ):
+    def checkout(self, *args):
         pass
 
     checkoutBackReferences = checkinBackReferences = checkout
-
diff --git a/plone/app/iterate/setuphandlers.py b/plone/app/iterate/setuphandlers.py
index 595e04f..7ecd606 100644
--- a/plone/app/iterate/setuphandlers.py
+++ b/plone/app/iterate/setuphandlers.py
@@ -9,4 +9,4 @@ def deprecate_profile(tool):
     warnings.warn(
         'The profile with id "plone.app.iterate" was renamed to "default".',
         DeprecationWarning
-        )
+    )
diff --git a/plone/app/iterate/subscribers/locking.py b/plone/app/iterate/subscribers/locking.py
index 3e61161..58c36e3 100644
--- a/plone/app/iterate/subscribers/locking.py
+++ b/plone/app/iterate/subscribers/locking.py
@@ -26,28 +26,30 @@
 from plone.locking.interfaces import ILockable
 from plone.app.iterate import lock
 
-def handleWCDeleted( event ):
+
+def handleWCDeleted(event):
     # may be called multiple times, must be reentrant
-    lock.unlockContext( event.baseline )
+    lock.unlockContext(event.baseline)
     # we reindex to force a metadata update
-    event.baseline.reindexObject( idxs=['review_state'] )
+    event.baseline.reindexObject(idxs=['review_state'])
+
+
+def handleCheckout(event):
+    lock.lockContext(event.object)
+    event.object.reindexObject(idxs=['review_state'])
 
-def handleCheckout( event ):
-    lock.lockContext( event.object )
-    event.object.reindexObject( idxs=['review_state'] )
 
-def handleCheckin( event ):
-    lockable = ILockable( event.object )
+def handleCheckin(event):
+    lockable = ILockable(event.object)
     if lockable.locked():
         # unlock working copy if it was auto-locked, or this will fail
         lockable.clear_locks()
 
-def handleCancelCheckout( event ):
-    lockable = ILockable( event.object )
+
+def handleCancelCheckout(event):
+    lockable = ILockable(event.object)
     if lockable.locked():
         # unlock working copy if it was auto-locked, or this will fail
         lockable.clear_locks()
-    lock.unlockContext( event.baseline )
-    event.baseline.reindexObject( idxs=['review_state'] )
-
-
+    lock.unlockContext(event.baseline)
+    event.baseline.reindexObject(idxs=['review_state'])
diff --git a/plone/app/iterate/subscribers/marker.py b/plone/app/iterate/subscribers/marker.py
index 03328bf..cb76ccf 100644
--- a/plone/app/iterate/subscribers/marker.py
+++ b/plone/app/iterate/subscribers/marker.py
@@ -26,17 +26,20 @@
 from Products.Five.utilities import marker
 from plone.app.iterate import interfaces
 
-def handleCheckout( event ):
-    marker.mark( event.working_copy, interfaces.IWorkingCopy )
-    marker.mark( event.object, interfaces.IBaseline )
 
-def handleCheckin( event ):
-    marker.erase( event.object, interfaces.IWorkingCopy )
-    marker.erase( event.baseline, interfaces.IBaseline )
+def handleCheckout(event):
+    marker.mark(event.working_copy, interfaces.IWorkingCopy)
+    marker.mark(event.object, interfaces.IBaseline)
 
-def handleWCDeleted( event ):
-    marker.erase( event.baseline, interfaces.IBaseline )
 
-def handleCancelCheckout( event ):
-    marker.erase( event.baseline, interfaces.IBaseline )
+def handleCheckin(event):
+    marker.erase(event.object, interfaces.IWorkingCopy)
+    marker.erase(event.baseline, interfaces.IBaseline)
 
+
+def handleWCDeleted(event):
+    marker.erase(event.baseline, interfaces.IBaseline)
+
+
+def handleCancelCheckout(event):
+    marker.erase(event.baseline, interfaces.IBaseline)
diff --git a/plone/app/iterate/subscribers/versioning.py b/plone/app/iterate/subscribers/versioning.py
index 1f63124..b7a1a67 100644
--- a/plone/app/iterate/subscribers/versioning.py
+++ b/plone/app/iterate/subscribers/versioning.py
@@ -25,12 +25,12 @@
 from plone.app.iterate import interfaces
 
 
-def handleBeforeCheckout( event ):
-    archiver = interfaces.IObjectArchiver( event.object )
+def handleBeforeCheckout(event):
+    archiver = interfaces.IObjectArchiver(event.object)
     if archiver.isModified() or not archiver.isVersioned():
         archiver.save("Baseline created")
 
 
-def handleAfterCheckin( event ):
-    archiver = interfaces.IObjectArchiver( event.object )
-    archiver.save( event.message )
+def handleAfterCheckin(event):
+    archiver = interfaces.IObjectArchiver(event.object)
+    archiver.save(event.message)
diff --git a/plone/app/iterate/util.py b/plone/app/iterate/util.py
index f1a2908..9da465a 100644
--- a/plone/app/iterate/util.py
+++ b/plone/app/iterate/util.py
@@ -25,6 +25,7 @@
 from interfaces import annotation_key
 from Products.CMFCore.utils import getToolByName
 
+
 def get_storage(context, default=None):
     annotations = IAnnotations(context)
     if annotation_key not in annotations:


