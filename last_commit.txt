Repository: plone.memoize


Branch: refs/heads/master
Date: 2015-12-15T18:36:19+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/4905a68f6fe9e71bf0fa9bd8c0941f48bcc5db40

move all DocFile tests to doctests and reformat all nicely

Files changed:
A docs/index.rst
A plone/memoize/compress.rst
A plone/memoize/ram.rst
A plone/memoize/request.rst
A plone/memoize/volatile.rst
M plone/memoize/README.rst
M plone/memoize/compress.py
M plone/memoize/forever.rst
M plone/memoize/instance.py
M plone/memoize/instance.rst
M plone/memoize/ram.py
M plone/memoize/request.py
M plone/memoize/tests.py
M plone/memoize/view.rst
M plone/memoize/volatile.py
M setup.py

diff --git a/docs/index.rst b/docs/index.rst
new file mode 100644
index 0000000..f179dab
--- /dev/null
+++ b/docs/index.rst
@@ -0,0 +1,21 @@
+plone.memoize
+=============
+
+Documentation for the caching decorator package plone.memoize.
+
+.. toctree::
+    :maxdepth: 2
+
+    ../plone/memoize/README.rst
+    ../plone/memoize/compress.rst
+    ../plone/memoize/forever.rst
+    ../plone/memoize/instance.rst
+../plone/memoize/ram.rst
+../plone/memoize/request.rst
+../plone/memoize/view.rst
+../plone/memoize/volatile.rst
+
+
+
+
+
diff --git a/plone/memoize/README.rst b/plone/memoize/README.rst
index 7911143..7a3b3ba 100644
--- a/plone/memoize/README.rst
+++ b/plone/memoize/README.rst
@@ -1,31 +1,26 @@
 Introduction
 ============
 
-plone.memoize provides Python function decorators for caching the
-values of functions and methods.
+plone.memoize provides Python function decorators for caching the values of functions and methods.
 
-The type of cache storage is freely configurable by the user, as is
-the cache key, which is what the function's value depends on.
+The type of cache storage is freely configurable by the user, as is the cache key, which is what the function's value depends on.
 
-plone.memoize has support for memcached and is easily extended to use
-other caching storages.  It also has specialized decorators for use
-with Zope views.  However, plone.memoize can be used without Zope.
+plone.memoize has support for memcached and is easily extended to use other caching storages.
+It also has specialized decorators for use with Zope views.
+However, plone.memoize can be used without Zope.
 
 
-volatile
+Volatile
 ========
 
-The 'volatile' module defines a versatile caching decorator that gives
-you total control of how the cache key is calculated and where it is
-stored.  This decorator is explained in more in depth with example
-usage in 'volatile.py'.
+The 'volatile' module defines a versatile caching decorator that gives you total control of how the cache key is calculated and where it is stored.
+This decorator is explained in more in depth with example usage in 'volatile.py'.
 
-'volatile' caches can be stored in different places. A common use is
-a zope RAMCache. There are convenience methods in the 'ram' module
-to support that.
+'volatile' caches can be stored in different places.
+A common use is a zope RAMCache.
+There are convenience methods in the 'ram' module to support that.
 
-A quick example of a view that uses 'volatile' caching through the 'ram'
-module::
+A quick example of a view that uses 'volatile' caching through the 'ram' module::
 
     >>> from zope.publisher.browser import BrowserView
     >>> from plone.memoize import ram
@@ -40,13 +35,10 @@ module::
     ...        view = obj.restrictedTraverse('@@obj-view')
     ...        return view.render()
 
-The results of our hypothetical 'render_details' method are cached
-*across requests* and independently of the (not) logged in user.  The
-cache is only refreshed when the brain's path or modification date
-change, as defined in '_render_details_cachekey'.
+The results of our hypothetical 'render_details' method are cached *across requests* and independently of the (not) logged in user.
+The cache is only refreshed when the brain's path or modification date change, as defined in '_render_details_cachekey'.
 
-This is how you could use the same decorator to cache a function's
-value for an hour::
+This is how you could use the same decorator to cache a function's value for an hour::
 
     >>> from time import time
     >>> @ram.cache(lambda *args: time() // (60 * 60))
@@ -56,12 +48,11 @@ value for an hour::
     'Something that takes awfully long'
 
 
-view and instance
+View and Instance
 =================
 
-See view.rst and instance.rst for usage of cache decorators that have
-a fixed cache key and cache storage.  The most common usage pattern of
-these view and instance caching decorators is::
+See view.rst and instance.rst for usage of cache decorators that have a fixed cache key and cache storage.
+The most common usage pattern of these view and instance caching decorators is::
 
     >>> from plone.memoize import instance
     >>> class MyClass(object):
@@ -69,10 +60,9 @@ these view and instance caching decorators is::
     ...   def some_expensive_function(self, arg1, arg2):
     ...       return "Some expensive result"
 
-The first time some_expensive_function() is called, the return value will
-be saved. On subsequent calls with the same arguments, the cached version
-will be returned. Passing in different arguments will cause the function to
-be called again.
+The first time some_expensive_function() is called, the return value will be saved.
+On subsequent calls with the same arguments, the cached version will be returned.
+Passing in different arguments will cause the function to be called again.
 
 Note that this only works if the arguments are hashable!
 
@@ -84,38 +74,31 @@ If you are writing a Zope 3 view, you can do::
     ...   def some_expensive_function(self, arg1, arg2):
     ...       return "Some expensive result"
 
-This has the same effect, but subsequent lookup of the same view in the
-same context will be memoized as well.
+This has the same effect, but subsequent lookup of the same view in the same context will be memoized as well.
 
-You can also use @view.memoize_contextless to have the memoization not
-take the context into account - the same view looked up during the same
-request (but possibly on another context) with the same parameters will
-be memoized.
+You can also use @view.memoize_contextless to have the memoization not take the context into account - the same view looked up during the same request (but possibly on another context) with the same parameters will be memoized.
 
 Note that this requires that the request is annotatable using zope.annotation!
 
 
-generic
+Generic
 =======
 
-The generic decorator uses the GenericCache module as storage. By default
-it'll store into a global cache of its own, with default parameters of 1000
-maximal objects and 1 hour maximal lifespan.
+The generic decorator uses the GenericCache module as storage.
+By default it'll store into a global cache of its own, with default parameters of 1000 maximal objects and 1 hour maximal lifespan.
 
-You can create your own storage area with its specific parameters using
-the new_storage method.
+You can create your own storage area with its specific parameters using the new_storage method.
 
 Look at the docstring for a few examples.
 
 
-keys and parameters marshaling
+Keys and Parameters Marshaling
 ==============================
 
-An important issue about caches is how to generate the cache key. In all
-the decorators above, you can create your own function.
+An important issue about caches is how to generate the cache key.
+In all the decorators above, you can create your own function.
 
 The marshallers module provide with useful default marshallers.
-args_marshaller will compute a key from function name, module and
-parameters, applying a hash if asked for. Look into the docstring
-for usage example.
+args_marshaller will compute a key from function name, module and parameters, applying a hash if asked for.
+Look into the docstring for usage example.
 
diff --git a/plone/memoize/compress.py b/plone/memoize/compress.py
index 2b7f00f..569bd3a 100644
--- a/plone/memoize/compress.py
+++ b/plone/memoize/compress.py
@@ -1,38 +1,5 @@
 # -*- coding: utf-8 -*-
-"""In order to use Peter Bengtsson's slimmer library available from
-http://www.issuetrackerproduct.com/Download#slimmer
-you need to register the XHTMLSlimmer utility like this:
-
-  <utility component="plone.memoize.compress.xhtmlslimmer"
-           provides="plone.memoize.interfaces.IXHTMLCompressor" />
-
-You can register other XHTML-whitespace removal libraries as well.
-
-Per default there is no compressor available and we get the same string back:
-
-   >>> html_string = u"<html><body><SPAN>Hello.</SPAN></body><html>"
-   >>> xhtml_compress(html_string) is html_string
-   True
-
-Make a stupid lowercasing compressor. This is not safe as it would lowercase
-all text outside of tags as well:
-
-   >>> class LowerCaser(object):
-   ...     implements(IXHTMLCompressor)
-   ...
-   ...     def compress(self, string):
-   ...         return string.lower()
-
-   >>> lower = LowerCaser()
-
-Register our new compressor:
-
-   >>> from zope.component import getSiteManager
-   >>> sm = getSiteManager()
-   >>> sm.registerUtility(lower)
-
-   >>> xhtml_compress(html_string)
-   u'<html><body><span>hello.</span></body><html>'
+"""XHTML Compressor
 """
 
 from plone.memoize.interfaces import IXHTMLCompressor
diff --git a/plone/memoize/compress.rst b/plone/memoize/compress.rst
new file mode 100644
index 0000000..ad4ac17
--- /dev/null
+++ b/plone/memoize/compress.rst
@@ -0,0 +1,41 @@
+================
+XHTML Compressor
+================
+
+In order to use Peter Bengtsson's slimmer library available from http://www.issuetrackerproduct.com/Download#slimmer you need to register the XHTMLSlimmer utility like this:
+
+::
+  <utility component="plone.memoize.compress.xhtmlslimmer"
+           provides="plone.memoize.interfaces.IXHTMLCompressor" />
+
+You can register other XHTML-whitespace removal libraries as well.
+
+Per default there is no compressor available and we get the same string back:
+
+::
+    >>> html_string = u"<html><body><SPAN>Hello.</SPAN></body><html>"
+    >>> xhtml_compress(html_string) is html_string
+    True
+
+Make a stupid lowercasing compressor.
+This is not safe as it would lowercase all text outside of tags as well:
+
+::
+    >>> class LowerCaser(object):
+    ...     implements(IXHTMLCompressor)
+    ...
+    ...     def compress(self, string):
+    ...         return string.lower()
+
+    >>> lower = LowerCaser()
+
+Register our new compressor:
+
+::
+    >>> from zope.component import getSiteManager
+    >>> sm = getSiteManager()
+    >>> sm.registerUtility(lower)
+
+    >>> xhtml_compress(html_string)
+    u'<html><body><span>hello.</span></body><html>'
+
diff --git a/plone/memoize/forever.rst b/plone/memoize/forever.rst
index 204099d..17808d6 100644
--- a/plone/memoize/forever.rst
+++ b/plone/memoize/forever.rst
@@ -1,10 +1,17 @@
-===================
- forever decorators
-===================
+==================
+Forever Decorators
+==================
 
-These remember a value "forever", i.e. until the process is restarted. They
-work on both global functions and class functions.
+Memo decorators for globals - memoized values survive for as long as the process lives.
 
+Stores values in a module-level variable.
+
+Pay attention that is module is not thread-safe, so use it with care.
+
+These remember a value "forever", i.e. until the process is restarted.
+They work on both global functions and class functions.
+
+::
     >>> from plone.memoize import forever
 
     >>> @forever.memoize
@@ -12,9 +19,9 @@ work on both global functions and class functions.
     ...     print "Calculating"
     ...     return arg1 + arg2
 
-No matter how many times we call this function with a particular set of
-arguments, it will only perform its calculation once.
+No matter how many times we call this function with a particular set of arguments, it will only perform its calculation once.
 
+::
     >>> remember(1, 1)
     Calculating
     2
@@ -28,6 +35,7 @@ arguments, it will only perform its calculation once.
 
 This also works for methods in classes.
 
+::
     >>> class Test(object):
     ...
     ...     @forever.memoize
diff --git a/plone/memoize/instance.py b/plone/memoize/instance.py
index 7310bb9..585d9ac 100644
--- a/plone/memoize/instance.py
+++ b/plone/memoize/instance.py
@@ -3,7 +3,7 @@
 
 Stores values in an attribute on the instance. See instance.rst.
 
-This package current subsumes memojito
+This package current subsumes memojito.
 """
 
 _marker = object()
diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index 5c4ed6c..10debd3 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -1,14 +1,15 @@
-====================
- instance decorators
-====================
+===================
+Instance Decorators
+===================
 
-Originally from Whit Morriss' memojito package, they are used to
-memoize return values for methods on an instance. The memoized values
-are stored on an attribute on the instance and disappear when the
-instance is destroyed or a cleanup is called.
+Memo decorators for instances.
 
-Let's try it out w/ a dummy class::
+Originally from Whit Morriss' memojito package, they are used to memoize return values for methods on an instance.
+The memoized values are stored on an attribute on the instance and disappear when the instance is destroyed or a cleanup is called.
 
+Let's try it out w/ a dummy class:
+
+::
     >>> from plone.memoize import instance
     >>> class MyMsg(object):
     ...     bang='!'
@@ -46,56 +47,61 @@ Let's try it out w/ a dummy class::
 
     >>> msg.txt1 = 'nice to visit this'
 
-Even though we've twiddled txt1, txt2 is not recalculated::
+Even though we've twiddled txt1, txt2 is not recalculated:
 
+::
     >>> msg.txt2
     'hello world'
 
-The memo is stored by a key made of the method's name, args,
-and a frozenset of any kwargs. If those are expected to be big,
-you should compute your own hash of it::
+The memo is stored by a key made of the method's name, args, and a frozenset of any kwargs.
+If those are expected to be big, you should compute your own hash of it:
 
+::
     >>> key = ('txt2', (msg,), frozenset([]))
     >>> msg._memojito_[key]
     'hello world'
 
-The clear after decorator will clear the memos after
-returning the methods value::
+The clear after decorator will clear the memos after returning the methods value:
 
+::
     >>> msg.clearafter()
     'hello world'
 
-So now the message should have changed::
+So now the message should have changed:
 
+::
     >>> msg.txt2
     'nice to visit this world'
 
-We change the text again::
+We change the text again:
 
+::
     >>> msg.txt1 = 'goodbye cruel'
 
-The message is still the same of course::
+The message is still the same of course:
 
+::
     >>> msg.txt2
     'nice to visit this world'
 
-Now we can test the clear before, which does the opposite from the
-clear after, allowing new values to be calculated::
+Now we can test the clear before, which does the opposite from the clear after, allowing new values to be calculated:
 
+::
     >>> msg.clearbefore()
     'goodbye cruel world'
 
-memojito supports memoization of multiple signatures as long as all
-signature values are hashable::
+memojito supports memoization of multiple signatures as long as all signature values are hashable:
 
+::
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
     >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: goodbye cruel world! raise--roofbeams
 
-We can alter data underneath, but nothing changes::
+We can alter data underneath, but nothing changes:
 
+::
     >>> msg.txt1 = 'sound and fury'
     >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: goodbye cruel world! raise--roofbeams
@@ -103,9 +109,9 @@ We can alter data underneath, but nothing changes::
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
-If we alter the signature, our msg is recalculated, but since mst.txt2
-is a memo, only the values passed in change::
+If we alter the signature, our msg is recalculated, but since mst.txt2 is a memo, only the values passed in change:
 
+::
     >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
     >>> print msg.getMsg('Bill F.', **ins)
     Bill F.: goodbye cruel world! tale--told by idiot signify--nothing
@@ -113,8 +119,9 @@ is a memo, only the values passed in change::
     >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
     J.D.: goodbye cruel world! catcher--rye
 
-If change the bang, the memo remains the same::
+If change the bang, the memo remains the same:
 
+::
     >>> msg.bang='#!'
     >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
     J.D.: goodbye cruel world! catcher--rye
@@ -122,31 +129,35 @@ If change the bang, the memo remains the same::
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
-clearing works the same as for properties::
+clearing works the same as for properties:
 
+::
     >>> print msg.clearafter()
     goodbye cruel world
 
-Our shebang appears::
+Our shebang appears:
 
+::
     >>> print msg.getMsg('Ernest')
     Ernest: sound and fury world#!
 
-Our message to faulkner now is semantically correct::
+Our message to faulkner now is semantically correct:
 
+::
     >>> ins = dict(tale='told by idiot', signify='nothing')
     >>> print msg.getMsg('Bill F.', **ins)
     Bill F.: sound and fury world#! tale--told by idiot signify--nothing
 
-Let's make sure that memoized properties which call OTHER memoized
-properties do the right thing::
+Let's make sure that memoized properties which call OTHER memoized properties do the right thing:
 
+::
     >>> msg = MyMsg('hello')
     >>> print msg.recurse
     recursive: hello world
 
-Now we make sure that both the txt2 and the recurse values are in the
-cache::
+Now we make sure that both the txt2 and the recurse values are in the cache:
 
+::
     >>> print len(msg._memojito_.keys())
     2
+
diff --git a/plone/memoize/ram.py b/plone/memoize/ram.py
index c5f1a76..d07825d 100644
--- a/plone/memoize/ram.py
+++ b/plone/memoize/ram.py
@@ -1,98 +1,5 @@
 # -*- coding: utf-8 -*-
 """A cache decorator that uses RAMCache by default.
-
-See README.rst and the `volatile` module for more details.
-
-  >>> def cache_key(fun, first, second):
-  ...     return (first, second)
-  >>> @cache(cache_key)
-  ... def pow(first, second):
-  ...     print 'Someone or something called me'
-  ...     return first ** second
-
-  >>> pow(3, 2)
-  Someone or something called me
-  9
-  >>> pow(3, 2)
-  9
-
-Let's cache another function:
-
-  >>> @cache(cache_key)
-  ... def add(first, second):
-  ...     print 'Someone or something called me'
-  ...     return first + second
-
-  >>> add(3, 2)
-  Someone or something called me
-  5
-  >>> add(3, 2)
-  5
-
-Now invalidate the cache for the `pow` function:
-
-  >>> pow(3, 2)
-  9
-  >>> global_cache.invalidate('plone.memoize.ram.pow')
-  >>> pow(3, 2)
-  Someone or something called me
-  9
-
-Make sure that we only invalidated the cache for the `pow` function:
-
-  >>> add(3, 2)
-  5
-
-  >>> global_cache.invalidateAll()
-
-You can register an ICacheChooser utility to override the cache used
-based on the function that is cached.  To do this, we'll first
-unregister the already registered global `choose_cache` function:
-
-  >>> sm = component.getGlobalSiteManager()
-  >>> sm.unregisterUtility(choose_cache)
-  True
-
-This customized cache chooser will use the `my_cache` for the `pow`
-function, and use the `global_cache` for all other functions:
-
-  >>> my_cache = ram.RAMCache()
-  >>> def my_choose_cache(fun_name):
-  ...     if fun_name.endswith('.pow'):
-  ...         return RAMCacheAdapter(my_cache)
-  ...     else:
-  ...         return RAMCacheAdapter(global_cache)
-  >>> interface.directlyProvides(my_choose_cache, ICacheChooser)
-  >>> sm.registerUtility(my_choose_cache)
-
-Both caches are empty at this point:
-
-  >>> len(global_cache.getStatistics())
-  0
-  >>> len(my_cache.getStatistics())
-  0
-
-Let's fill them:
-
-  >>> pow(3, 2)
-  Someone or something called me
-  9
-  >>> pow(3, 2)
-  9
-  >>> len(global_cache.getStatistics())
-  0
-  >>> len(my_cache.getStatistics())
-  1
-
-  >>> add(3, 2)
-  Someone or something called me
-  5
-  >>> add(3, 2)
-  5
-  >>> len(global_cache.getStatistics())
-  1
-  >>> len(my_cache.getStatistics())
-  1
 """
 
 from plone.memoize import volatile
diff --git a/plone/memoize/ram.rst b/plone/memoize/ram.rst
new file mode 100644
index 0000000..6ab3a5b
--- /dev/null
+++ b/plone/memoize/ram.rst
@@ -0,0 +1,104 @@
+==============
+RAM Decorators
+==============
+
+A cache decorator that uses RAMCache by default.
+
+::
+    >>> def cache_key(fun, first, second):
+    ...     return (first, second)
+    >>> @cache(cache_key)
+    ... def pow(first, second):
+    ...     print 'Someone or something called me'
+    ...     return first ** second
+
+    >>> pow(3, 2)
+    Someone or something called me
+    9
+    >>> pow(3, 2)
+    9
+
+Let's cache another function:
+
+::
+    >>> @cache(cache_key)
+    ... def add(first, second):
+    ...     print 'Someone or something called me'
+    ...     return first + second
+
+    >>> add(3, 2)
+    Someone or something called me
+    5
+    >>> add(3, 2)
+    5
+
+Now invalidate the cache for the `pow` function:
+
+::
+    >>> pow(3, 2)
+    9
+    >>> global_cache.invalidate('plone.memoize.ram.pow')
+    >>> pow(3, 2)
+    Someone or something called me
+    9
+
+Make sure that we only invalidated the cache for the `pow` function:
+
+::
+    >>> add(3, 2)
+    5
+
+    >>> global_cache.invalidateAll()
+
+You can register an ICacheChooser utility to override the cache used based on the function that is cached.
+To do this, we'll first unregister the already registered global `choose_cache` function:
+
+::
+    >>> sm = component.getGlobalSiteManager()
+    >>> sm.unregisterUtility(choose_cache)
+    True
+
+This customized cache chooser will use the `my_cache` for the `pow` function, and use the `global_cache` for all other functions:
+
+::
+    >>> my_cache = ram.RAMCache()
+    >>> def my_choose_cache(fun_name):
+    ...     if fun_name.endswith('.pow'):
+    ...         return RAMCacheAdapter(my_cache)
+    ...     else:
+    ...         return RAMCacheAdapter(global_cache)
+    >>> interface.directlyProvides(my_choose_cache, ICacheChooser)
+    >>> sm.registerUtility(my_choose_cache)
+
+Both caches are empty at this point:
+
+::
+    >>> len(global_cache.getStatistics())
+    0
+    >>> len(my_cache.getStatistics())
+    0
+
+Let's fill them:
+
+::
+    >>> pow(3, 2)
+    Someone or something called me
+    9
+    >>> pow(3, 2)
+    9
+    >>> len(global_cache.getStatistics())
+    0
+    >>> len(my_cache.getStatistics())
+    1
+
+::
+    >>> add(3, 2)
+    Someone or something called me
+    5
+    >>> add(3, 2)
+    5
+    >>> len(global_cache.getStatistics())
+    1
+    >>> len(my_cache.getStatistics())
+    1
+
diff --git a/plone/memoize/request.py b/plone/memoize/request.py
index b910325..5219cf6 100644
--- a/plone/memoize/request.py
+++ b/plone/memoize/request.py
@@ -73,107 +73,6 @@ def _store_in_annotation(fun, *args, **kwargs):
 
 def cache(get_key, get_request='request'):
     r"""
-    This is a hypothetical function `increment` that'll store the
-    cache value on `a.request`, where a is the only argument to the
-    function:
-
-      >>> def increment(a):
-      ...     print 'Someone or something called me'
-      ...     return a + 1
-
-    Now we need to define this `a`.  For this, we'll inherit from
-    `int` and add a `request` class variable.  Note that we also make
-    our fake request `IAttributeAnnotatable`, because that's how the
-    cache values are stored on the request:
-
-      >>> from zope.publisher.browser import TestRequest
-      >>> class A(int):
-      ...     request = TestRequest()
-      >>> from zope.interface import directlyProvides
-      >>> from zope.annotation.interfaces import IAttributeAnnotatable
-      >>> directlyProvides(A.request, IAttributeAnnotatable)
-
-    In addition to this request, we'll also need to set up a cache key
-    generator.  We'll use the integer value of the only argument for
-    that:
-
-      >>> get_key = lambda fun, a, *args: a
-
-    Let's decorate our `increment` function now with the `cache`
-    decorator.  We'll tell the decorator to use `args_hash` for
-    generating the key. `get_request` will tell the decorator how to
-    actually find the `request` in the variable scope of the function
-    itself:
-
-      >>> cached_increment = \
-      ...     cache(get_key=get_key, get_request='a.request')(increment)
-
-      >>> cached_increment(A(1))
-      Someone or something called me
-      2
-      >>> cached_increment(A(1))
-      2
-      >>> IAnnotations(A.request)
-      {'plone.memoize.request.increment:1': 2}
-
-    If `request` is already part of the function's argument list, we
-    don't need to specify any expression:
-
-      >>> @cache(get_key=get_key)
-      ... def increment_plus(a, request):
-      ...     print 'Someone or something called me'
-      ...     return a + 1
-
-      >>> increment_plus(42, A.request)
-      Someone or something called me
-      43
-      >>> increment_plus(42, A.request)
-      43
-      >>> IAnnotations(A.request)['plone.memoize.request.increment_plus:42']
-      43
-
-    Create a function that can also take keyword arguments. For the sake of
-    convenience pass the request explicitly. get_key must be modified to take
-    kwargs into account:
-
-      >>> def get_key(fun, a, request, **kwargs):
-      ...     li = kwargs.items()
-      ...     li.sort()
-      ...     return "%s,%s" % (a, li)
-
-      >>> @cache(get_key=get_key)
-      ... def increment_kwargs(a, request, kwarg1=1, kwarg2=2):
-      ...     print 'Someone or something called me'
-      ...     return a + 1
-
-      >>> increment_kwargs(42, A.request, kwarg1='kwarg1', kwarg2='kwarg2')
-      Someone or something called me
-      43
-      >>> increment_kwargs(42, A.request, kwarg1='kwarg1', kwarg2='kwarg2')
-      43
-      >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[('kwarg1', 'kwarg1'), ('kwarg2', 'kwarg2')]"]
-      43
-
-    Call increment_kwargs without specifying any keyword arguments:
-
-      >>> increment_kwargs(42, A.request)
-      Someone or something called me
-      43
-      >>> increment_kwargs(42, A.request)
-      43
-      >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[]"]
-      43
-
-    Call increment_kwargs and specify only the second keyword argument:
-
-      >>> increment_kwargs(42, A.request, kwarg2='kwarg2')
-      Someone or something called me
-      43
-      >>> increment_kwargs(42, A.request, kwarg2='kwarg2')
-      43
-      >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[('kwarg2', 'kwarg2')]"]
-      43
-
     """
 
     return volatile.cache(get_key,
diff --git a/plone/memoize/request.rst b/plone/memoize/request.rst
new file mode 100644
index 0000000..c3ab40e
--- /dev/null
+++ b/plone/memoize/request.rst
@@ -0,0 +1,106 @@
+==================
+Request Decorators
+==================
+
+This is a hypothetical function `increment` that'll store the cache value on `a.request`, where a is the only argument to the function:
+
+::
+    >>> def increment(a):
+    ...     print 'Someone or something called me'
+    ...     return a + 1
+
+Now we need to define this `a`.
+For this, we'll inherit from `int` and add a `request` class variable.
+Note that we also make our fake request `IAttributeAnnotatable`, because that's how the cache values are stored on the request:
+
+::
+    >>> from zope.publisher.browser import TestRequest
+    >>> class A(int):
+    ...     request = TestRequest()
+    >>> from zope.interface import directlyProvides
+    >>> from zope.annotation.interfaces import IAttributeAnnotatable
+    >>> directlyProvides(A.request, IAttributeAnnotatable)
+
+In addition to this request, we'll also need to set up a cache key generator.
+We'll use the integer value of the only argument for that:
+
+::
+    >>> get_key = lambda fun, a, *args: a
+
+Let's decorate our `increment` function now with the `cache` decorator.
+We'll tell the decorator to use `args_hash` for generating the key.
+`get_request` will tell the decorator how to actually find the `request` in the variable scope of the function itself:
+
+::
+    >>> cached_increment = \
+    ...     cache(get_key=get_key, get_request='a.request')(increment)
+
+    >>> cached_increment(A(1))
+    Someone or something called me
+    2
+    >>> cached_increment(A(1))
+    2
+    >>> IAnnotations(A.request)
+    {'plone.memoize.request.increment:1': 2}
+
+If `request` is already part of the function's argument list, we don't need to specify any expression:
+
+::
+    >>> @cache(get_key=get_key)
+    ... def increment_plus(a, request):
+    ...     print 'Someone or something called me'
+    ...     return a + 1
+
+    >>> increment_plus(42, A.request)
+    Someone or something called me
+    43
+    >>> increment_plus(42, A.request)
+    43
+    >>> IAnnotations(A.request)['plone.memoize.request.increment_plus:42']
+    43
+
+Create a function that can also take keyword arguments.
+For the sake of convenience pass the request explicitly.
+get_key must be modified to take kwargs into account:
+
+::
+    >>> def get_key(fun, a, request, **kwargs):
+    ...     li = kwargs.items()
+    ...     li.sort()
+    ...     return "%s,%s" % (a, li)
+
+    >>> @cache(get_key=get_key)
+    ... def increment_kwargs(a, request, kwarg1=1, kwarg2=2):
+    ...     print 'Someone or something called me'
+    ...     return a + 1
+
+    >>> increment_kwargs(42, A.request, kwarg1='kwarg1', kwarg2='kwarg2')
+    Someone or something called me
+    43
+    >>> increment_kwargs(42, A.request, kwarg1='kwarg1', kwarg2='kwarg2')
+    43
+    >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[('kwarg1', 'kwarg1'), ('kwarg2', 'kwarg2')]"]
+    43
+
+Call increment_kwargs without specifying any keyword arguments:
+
+::
+    >>> increment_kwargs(42, A.request)
+    Someone or something called me
+    43
+    >>> increment_kwargs(42, A.request)
+    43
+    >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[]"]
+    43
+
+Call increment_kwargs and specify only the second keyword argument:
+
+::
+    >>> increment_kwargs(42, A.request, kwarg2='kwarg2')
+    Someone or something called me
+    43
+    >>> increment_kwargs(42, A.request, kwarg2='kwarg2')
+    43
+    >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[('kwarg2', 'kwarg2')]"]
+    43
+
diff --git a/plone/memoize/tests.py b/plone/memoize/tests.py
index 629392b..f1688ba 100644
--- a/plone/memoize/tests.py
+++ b/plone/memoize/tests.py
@@ -17,32 +17,43 @@ def configurationSetUp(test):
 
 def test_suite():
     tests = (
-        doctest.DocTestSuite('plone.memoize.compress',
+        doctest.DocTestSuite('README.rst',
+                             package="plone.memoize",
+                             setUp=configurationSetUp,
+                             tearDown=tearDown,
+                             optionflags=optionflags),
+        doctest.DocTestSuite('compress.rst',
+                             package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocFileSuite('instance.rst',
+        doctest.DocTestSuite('forever.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocFileSuite('view.rst',
+        doctest.DocTestSuite('instance.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocFileSuite('forever.rst',
+        doctest.DocTestSuite('ram.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocFileSuite('README.rst'),
-        doctest.DocTestSuite('plone.memoize.request',
+        doctest.DocTestSuite('request.rst',
+                             package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocTestSuite('plone.memoize.volatile'),
-        doctest.DocTestSuite('plone.memoize.ram',
+        doctest.DocTestSuite('view.rst',
+                             package="plone.memoize",
+                             setUp=configurationSetUp,
+                             tearDown=tearDown,
+                             optionflags=optionflags),
+        doctest.DocTestSuite('volatile.rst',
+                             package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
diff --git a/plone/memoize/view.rst b/plone/memoize/view.rst
index 499dcd3..d2bae90 100644
--- a/plone/memoize/view.rst
+++ b/plone/memoize/view.rst
@@ -1,12 +1,14 @@
-=====================
- view memo decorators
-=====================
+===============
+View Decorators
+===============
 
-Decorators for methods/properties in views. Values are cached by annotating
-the view's request, and keyed based on the context and any arguments to the
-function. This means that the same view can be looked up multiple times and
-the same memos will be returned::
+Memoize decorator for views.
 
+Decorators for methods/properties in views.
+Values are cached by annotating the view's request, and keyed based on the context and any arguments to the function.
+This means that the same view can be looked up multiple times and the same memos will be returned:
+
+::
     >>> from plone.memoize import view
     >>> from zope.component import adapts
     >>> from zope.interface import implements
@@ -14,8 +16,9 @@ the same memos will be returned::
     >>> from zope.publisher.interfaces.browser import IBrowserRequest
     >>> from zope.publisher.interfaces.browser import IBrowserView
 
-First we set up a dummy view::
+First we set up a dummy view:
 
+::
     >>> class MyView(object):
     ...     implements(IBrowserView)
     ...     adapts(Interface, IBrowserRequest)
@@ -48,19 +51,22 @@ First we set up a dummy view::
     >>> from zope.component import provideAdapter
     >>> provideAdapter(MyView, name=u'msg_view')
 
-We also need a dummy context::
+We also need a dummy context:
 
+::
     >>> class Dummy(object):
     ...     implements(Interface)
 
-Let's look up the view::
+Let's look up the view:
 
+::
     >>> from zope.publisher.browser import TestRequest
     >>> request = TestRequest()
     >>> context = Dummy()
 
-We need request to be annotatable::
+We need request to be annotatable:
 
+::
     >>> from zope.interface import directlyProvides
     >>> from zope.annotation.interfaces import IAttributeAnnotatable
     >>> directlyProvides(request, IAttributeAnnotatable)
@@ -68,30 +74,32 @@ We need request to be annotatable::
     >>> from zope.component import getMultiAdapter
     >>> msg = getMultiAdapter((context, request), name=u'msg_view')
 
-Now, if we access the memoized property txt2, we will get the value in
-txt1::
+Now, if we access the memoized property txt2, we will get the value in txt1:
 
+::
     >>> msg.txt2
     'hello world'
 
     >>> msg.txt1 = 'goodbye cruel'
 
-Even though we've twiddled txt1, txt2 is not recalculated::
+Even though we've twiddled txt1, txt2 is not recalculated:
 
+::
     >>> msg.txt2
     'hello world'
 
-We support memoization of multiple signatures as long as all
-signature values are hashable::
+We support memoization of multiple signatures as long as all signature values are hashable:
 
+::
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
     >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: goodbye cruel world! raise--roofbeams
 
-We can alter data underneath, but nothing changes::
+We can alter data underneath, but nothing changes:
 
+::
     >>> msg.txt1 = 'sound and fury'
     >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: goodbye cruel world! raise--roofbeams
@@ -99,8 +107,9 @@ We can alter data underneath, but nothing changes::
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
-If we alter the signature, our msg is recalculated::
+If we alter the signature, our msg is recalculated:
 
+::
     >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
     >>> print msg.getMsg('Bill F.', **ins)
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
@@ -108,8 +117,9 @@ If we alter the signature, our msg is recalculated::
     >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
     J.D.: sound and fury world! catcher--rye
 
-If change the bang, the memo remains the same::
+If change the bang, the memo remains the same:
 
+::
     >>> msg.bang='#!'
     >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
     J.D.: sound and fury world! catcher--rye
@@ -117,9 +127,9 @@ If change the bang, the memo remains the same::
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
-If we look up the view again on the same object, we will get the same
-memoized properties as before::
+If we look up the view again on the same object, we will get the same memoized properties as before:
 
+::
     >>> msg2 = getMultiAdapter((context, request), name=u'msg_view')
 
     >>> msg2.txt1 = 'and so on'
@@ -141,8 +151,9 @@ memoized properties as before::
     >>> print msg2.getMsg('J.D.', **{'catcher':'rye'})
     J.D.: sound and fury world! catcher--rye
 
-However, if we look up the view on another context object, things change::
+However, if we look up the view on another context object, things change:
 
+::
     >>> context = Dummy()
     >>> msg3 = getMultiAdapter((context, request), name=u'msg_view')
 
@@ -166,8 +177,9 @@ However, if we look up the view on another context object, things change::
     J.D.: so long, cruel world& catcher--rye
 
 This behaviour does not apply to contextless decorators, which memoize
-based on parameters, but not on context::
+based on parameters, but not on context:
 
+::
     >>> print msg3.getAnotherMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: so long, cruel world& raise--roofbeams
 
diff --git a/plone/memoize/volatile.py b/plone/memoize/volatile.py
index 641c8b9..30d9dcc 100644
--- a/plone/memoize/volatile.py
+++ b/plone/memoize/volatile.py
@@ -2,229 +2,15 @@
 """A flexible caching decorator.
 
 This module provides a cache decorator `cache` that you can use to
-cache results of your functions or methods.  Let's say we have a class
-with an expensive method `pow` that we want to cache:
-
-  >>> class MyClass:
-  ...     def pow(self, first, second):
-  ...         print 'Someone or something called me'
-  ...         return first ** second
-
-Okay, we know that if the `first` and `second` arguments are the same,
-the result is going to be the same, always.  We'll use a cache key
-calculator to tell the `cache` decorator about this assertion.  What's
-this cache key calculator?  It's a function that takes the original
-function plus the same arguments as the original function that we're
-caching:
-
-  >>> def cache_key(method, self, first, second):
-  ...     return (first, second)
-
-For performances and security reasons, no hash is done on the key in
-this example. You may consider using a cryptographic hash (MD5 or even
-better SHA1) if your parameters can hold big amount of data.
-
-The cache decorator is really simple to use.  Let's define our first
-class again, this time with a cached `pow` method:
-
-  >>> class MyClass:
-  ...     @cache(cache_key)
-  ...     def pow(self, first, second):
-  ...         print 'Someone or something called me'
-  ...         return first ** second
-
-The results:
-
-  >>> obj = MyClass()
-  >>> obj.pow(3, 2)
-  Someone or something called me
-  9
-  >>> obj.pow(3, 2)
-  9
-
-Did you see that?  The method was called only once.
-
-Now to where this cache is stored: That's actually variable.  The
-cache decorator takes an optional second argument with which you can
-define the where the cache is stored to.
-
-By default, the cache stores its values on the first argument to the
-function.  For our method, this is self, which is perfectly fine.  For
-normal functions, the first argument is maybe not the best place to
-store the cache.
-
-The default cache container function stores a dictionary on the
-instance as a *volatile* attribute.  That is, it's prefixed with
-``_v_``.  In Zope, this means that the cache is not persisted.
-
-  >>> ATTR
-  '_v_memoize_cache'
-  >>> cache_container = getattr(obj, ATTR)
-
-This cache container maps our key, including the function's dotted
-name, to the return value.
-
-  >>> cache_container # doctest: +ELLIPSIS
-  {'plone.memoize.volatile.pow:...': 9}
-  >>> len(cache_container)
-  1
-  >>> k = 'plone.memoize.volatile.pow:%s' % str(cache_key(MyClass.pow, None, 3, 2))
-  >>> cache_container[k]
-  9
-
-Okay, on to storing the cache somewhere else.  The function we'll have
-to provide is really similar to the cache key function we defined
-earlier.
-
-Like the cache key function, the storage function takes the same
-amount of arguments as the original cached function.  We'll use a
-global for caching this time:
-
-  >>> my_cache = {}
-  >>> def cache_storage(fun, *args, **kwargs):
-  ...     return my_cache
-
-This time, instead of caching a method, we'll cache a normal function.
-For this, we'll need to change our cache key function to take the
-correct number of arguments:
-
-  >>> def cache_key(fun, first, second):
-  ...     return (first, second)
-
-Note how we provide both the cache key generator and the cache storage
-as arguments to the `cache` decorator:
-
-  >>> @cache(cache_key, cache_storage)
-  ... def pow(first, second):
-  ...     print 'Someone or something called me'
-  ...     return first ** second
-
-Let's try it out:
-
-  >>> pow(3, 2)
-  Someone or something called me
-  9
-  >>> pow(3, 2)
-  9
-  >>> pow(3, 2)
-  9
-  >>> pow(3, 3)
-  Someone or something called me
-  27
-  >>> pow(3, 3)
-  27
-  >>> my_cache.clear()
-
-It works!
-
-A cache key generator may also raise DontCache to indicate that no
-caching should be applied:
-
-  >>> def cache_key(fun, first, second):
-  ...     if first == second:
-  ...         raise DontCache
-  ...     else:
-  ...         return (first, second)
-  >>> @cache(cache_key, cache_storage)
-  ... def pow(first, second):
-  ...     print 'Someone or something called me'
-  ...     return first ** second
-
-  >>> pow(3, 2)
-  Someone or something called me
-  9
-  >>> pow(3, 2)
-  9
-  >>> pow(3, 3)
-  Someone or something called me
-  27
-  >>> pow(3, 3)
-  Someone or something called me
-  27
-
-Caveats
--------
-
-Be careful when you have multiple methods with the same name in a
-single module:
-
-  >>> def cache_key(fun, instance, *args):
-  ...     return args
-  >>> cache_container = {}
-  >>> class A:
-  ...     @cache(cache_key, lambda *args: cache_container)
-  ...     def somemet(self, one, two):
-  ...         return one + two
-  >>> class B:
-  ...     @cache(cache_key, lambda *args: cache_container)
-  ...     def somemet(self, one, two):
-  ...         return one - two
-  >>> a = A()
-  >>> a.somemet(1, 2)
-  3
-  >>> cache_container
-  {'plone.memoize.volatile.somemet:(1, 2)': 3}
-
-The following call should really return -1, but since the default
-cache key isn't clever enough to include the function's name, it'll
-return 3:
-
-  >>> B().somemet(1, 2)
-  3
-  >>> len(cache_container)
-  1
-  >>> cache_container.clear()
-
-Ouch!  The fix for this is to e.g. include your class' name in the key
-when you create it:
-
-  >>> def cache_key(fun, instance, *args):
-  ...     return (instance.__class__,) + args
-  >>> class A:
-  ...     @cache(cache_key, lambda *args: cache_container)
-  ...     def somemet(self, one, two):
-  ...         return one + two
-  >>> class B:
-  ...     @cache(cache_key, lambda *args: cache_container)
-  ...     def somemet(self, one, two):
-  ...         return one - two
-  >>> a = A()
-  >>> a.somemet(1, 2)
-  3
-  >>> B().somemet(1, 2)
-  -1
-  >>> len(cache_container)
-  2
+cache results of your functions or methods.
 """
 
 import time
 
 
 class CleanupDict(dict):
-
     """A dict that automatically cleans up items that haven't been
     accessed in a given timespan on *set*.
-
-    This implementation is a bit naive, since it's not associated with
-    any policy that the user can configure, and it doesn't provide
-    statistics like RAMCache, but at least it helps make sure our
-    volatile attribute doesn't grow stale entries indefinitely.
-
-      >>> d = CleanupDict()
-      >>> d['spam'] = 'bar'
-      >>> d['spam']
-      'bar'
-
-   Setting the cleanup period to 0 (or a negative number) means the
-   values are thrown away immediately.  (Note that we do not test with
-   exactly zero, as running the tests can go too fast.)
-
-      >>> d = CleanupDict(-0.00001)
-      >>> d['spam'] = 'bar'
-      >>> d['spam'] # doctest: +ELLIPSIS
-      Traceback (most recent call last):
-      ...
-      KeyError: 'spam'
     """
     cleanup_period = 60 * 60 * 24 * 3  # 3 days
 
diff --git a/plone/memoize/volatile.rst b/plone/memoize/volatile.rst
new file mode 100644
index 0000000..e975c39
--- /dev/null
+++ b/plone/memoize/volatile.rst
@@ -0,0 +1,224 @@
+Volatile Decorators
+===================
+
+A flexible caching decorator.
+
+This module provides a cache decorator `cache` that you can use to cache results of your functions or methods.
+Let's say we have a class with an expensive method `pow` that we want to cache:
+
+::
+    >>> class MyClass:
+    ...     def pow(self, first, second):
+    ...         print 'Someone or something called me'
+    ...         return first ** second
+
+Okay, we know that if the `first` and `second` arguments are the same, the result is going to be the same, always.
+We'll use a cache key calculator to tell the `cache` decorator about this assertion.
+What's this cache key calculator?
+It's a function that takes the original function plus the same arguments as the original function that we're caching:
+
+::
+    >>> def cache_key(method, self, first, second):
+    ...     return (first, second)
+
+For performances and security reasons, no hash is done on the key in this example.
+You may consider using a cryptographic hash (MD5 or even better SHA1) if your parameters can hold big amount of data.
+
+The cache decorator is really simple to use.
+Let's define our first class again, this time with a cached `pow` method:
+
+::
+    >>> class MyClass:
+    ...     @cache(cache_key)
+    ...     def pow(self, first, second):
+    ...         print 'Someone or something called me'
+    ...         return first ** second
+
+The results:
+
+::
+    >>> obj = MyClass()
+    >>> obj.pow(3, 2)
+    Someone or something called me
+    9
+    >>> obj.pow(3, 2)
+    9
+
+Did you see that?  The method was called only once.
+
+Now to where this cache is stored: That's actually variable.
+The cache decorator takes an optional second argument with which you can define the where the cache is stored to.
+
+By default, the cache stores its values on the first argument to the function.
+For our method, this is self, which is perfectly fine.
+For normal functions, the first argument is maybe not the best place to store the cache.
+
+The default cache container function stores a dictionary on the instance as a *volatile* attribute.
+That is, it's prefixed with ``_v_``.
+In Zope, this means that the cache is not persisted.
+
+::
+    >>> ATTR
+    '_v_memoize_cache'
+    >>> cache_container = getattr(obj, ATTR)
+
+This cache container maps our key, including the function's dotted name, to the return value.
+
+::
+    >>> cache_container # doctest: +ELLIPSIS
+    {'plone.memoize.volatile.pow:...': 9}
+    >>> len(cache_container)
+    1
+    >>> k = 'plone.memoize.volatile.pow:%s' % str(cache_key(MyClass.pow, None, 3, 2))
+    >>> cache_container[k]
+    9
+
+Okay, on to storing the cache somewhere else.
+The function we'll have to provide is really similar to the cache key function we defined earlier.
+
+Like the cache key function, the storage function takes the same amount of arguments as the original cached function.
+We'll use a global for caching this time:
+
+::
+    >>> my_cache = {}
+    >>> def cache_storage(fun, *args, **kwargs):
+    ...     return my_cache
+
+This time, instead of caching a method, we'll cache a normal function.
+For this, we'll need to change our cache key function to take the correct number of arguments:
+
+::
+    >>> def cache_key(fun, first, second):
+    ...     return (first, second)
+
+Note how we provide both the cache key generator and the cache storage as arguments to the `cache` decorator:
+
+::
+    >>> @cache(cache_key, cache_storage)
+    ... def pow(first, second):
+    ...     print 'Someone or something called me'
+    ...     return first ** second
+
+Let's try it out:
+
+::
+    >>> pow(3, 2)
+    Someone or something called me
+    9
+    >>> pow(3, 2)
+    9
+    >>> pow(3, 2)
+    9
+    >>> pow(3, 3)
+    Someone or something called me
+    27
+    >>> pow(3, 3)
+    27
+    >>> my_cache.clear()
+
+It works!
+
+A cache key generator may also raise DontCache to indicate that no caching should be applied:
+
+::
+    >>> def cache_key(fun, first, second):
+    ...     if first == second:
+    ...         raise DontCache
+    ...     else:
+    ...         return (first, second)
+    >>> @cache(cache_key, cache_storage)
+    ... def pow(first, second):
+    ...     print 'Someone or something called me'
+    ...     return first ** second
+
+    >>> pow(3, 2)
+    Someone or something called me
+    9
+    >>> pow(3, 2)
+    9
+    >>> pow(3, 3)
+    Someone or something called me
+    27
+    >>> pow(3, 3)
+    Someone or something called me
+    27
+
+Caveats
+-------
+
+Be careful when you have multiple methods with the same name in a single module:
+
+::
+    >>> def cache_key(fun, instance, *args):
+    ...     return args
+    >>> cache_container = {}
+    >>> class A:
+    ...     @cache(cache_key, lambda *args: cache_container)
+    ...     def somemet(self, one, two):
+    ...         return one + two
+    >>> class B:
+    ...     @cache(cache_key, lambda *args: cache_container)
+    ...     def somemet(self, one, two):
+    ...         return one - two
+    >>> a = A()
+    >>> a.somemet(1, 2)
+    3
+    >>> cache_container
+    {'plone.memoize.volatile.somemet:(1, 2)': 3}
+
+The following call should really return -1, but since the default cache key isn't clever enough to include the function's name, it'll return 3:
+
+::
+    >>> B().somemet(1, 2)
+    3
+    >>> len(cache_container)
+    1
+    >>> cache_container.clear()
+
+Ouch!
+The fix for this is to e.g. include your class' name in the key when you create it:
+
+::
+    >>> def cache_key(fun, instance, *args):
+    ...     return (instance.__class__,) + args
+    >>> class A:
+    ...     @cache(cache_key, lambda *args: cache_container)
+    ...     def somemet(self, one, two):
+    ...         return one + two
+    >>> class B:
+    ...     @cache(cache_key, lambda *args: cache_container)
+    ...     def somemet(self, one, two):
+    ...         return one - two
+    >>> a = A()
+    >>> a.somemet(1, 2)
+    3
+    >>> B().somemet(1, 2)
+    -1
+    >>> len(cache_container)
+    2
+
+
+Cleanup Dict
+------------
+
+CleanupDict is a dict that automatically cleans up items that haven't been accessed in a given timespan on *set*.
+
+This implementation is a bit naive, since it's not associated with any policy that the user can configure, and it doesn't provide statistics like RAMCache, but at least it helps make sure our volatile attribute doesn't grow stale entries indefinitely.
+
+::
+    >>> d = CleanupDict()
+    >>> d['spam'] = 'bar'
+    >>> d['spam']
+    'bar'
+
+Setting the cleanup period to 0 (or a negative number) means the values are thrown away immediately.
+(Note that we do not test with exactly zero, as running the tests can go too fast.)
+
+::
+    >>> d = CleanupDict(-0.00001)
+    >>> d['spam'] = 'bar'
+    >>> d['spam'] # doctest: +ELLIPSIS
+    Traceback (most recent call last):
+    ...
+    KeyError: 'spam'
+
diff --git a/setup.py b/setup.py
index bcba279..070eea0 100644
--- a/setup.py
+++ b/setup.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 import os
 from setuptools import setup, find_packages
 


Repository: plone.memoize


Branch: refs/heads/master
Date: 2015-12-15T18:36:42+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/e9dbcbb384b935b115d8c432a4be9944f943953f

warning on instance memoize decorator

Files changed:
M plone/memoize/instance.rst

diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index 10debd3..e8de9ac 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -7,6 +7,10 @@ Memo decorators for instances.
 Originally from Whit Morriss' memojito package, they are used to memoize return values for methods on an instance.
 The memoized values are stored on an attribute on the instance and disappear when the instance is destroyed or a cleanup is called.
 
+.. warning::
+    The ``instance`` caching decorator writes to ZODB when filling the cache.
+    This can lead to database conflict errors caused by write on read.
+
 Let's try it out w/ a dummy class:
 
 ::


Repository: plone.memoize


Branch: refs/heads/master
Date: 2015-12-15T18:38:05+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/b89d4db051d65bb1305495db9b10b8dd2fc07021

headings

Files changed:
M docs/index.rst
M plone/memoize/compress.rst
M plone/memoize/forever.rst
M plone/memoize/instance.rst
M plone/memoize/ram.rst
M plone/memoize/request.rst
M plone/memoize/view.rst

diff --git a/docs/index.rst b/docs/index.rst
index f179dab..e4a8b82 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -7,15 +7,11 @@ Documentation for the caching decorator package plone.memoize.
     :maxdepth: 2
 
     ../plone/memoize/README.rst
-    ../plone/memoize/compress.rst
+    ../plone/memoize/volatile.rst
+    ../plone/memoize/request.rst
+    ../plone/memoize/view.rst
+    ../plone/memoize/ram.rst
     ../plone/memoize/forever.rst
     ../plone/memoize/instance.rst
-../plone/memoize/ram.rst
-../plone/memoize/request.rst
-../plone/memoize/view.rst
-../plone/memoize/volatile.rst
-
-
-
-
+    ../plone/memoize/compress.rst
 
diff --git a/plone/memoize/compress.rst b/plone/memoize/compress.rst
index ad4ac17..f36c168 100644
--- a/plone/memoize/compress.rst
+++ b/plone/memoize/compress.rst
@@ -1,4 +1,3 @@
-================
 XHTML Compressor
 ================
 
diff --git a/plone/memoize/forever.rst b/plone/memoize/forever.rst
index 17808d6..8024434 100644
--- a/plone/memoize/forever.rst
+++ b/plone/memoize/forever.rst
@@ -1,4 +1,3 @@
-==================
 Forever Decorators
 ==================
 
diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index e8de9ac..14e8b6c 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -1,4 +1,3 @@
-===================
 Instance Decorators
 ===================
 
diff --git a/plone/memoize/ram.rst b/plone/memoize/ram.rst
index 6ab3a5b..1fc286b 100644
--- a/plone/memoize/ram.rst
+++ b/plone/memoize/ram.rst
@@ -1,4 +1,3 @@
-==============
 RAM Decorators
 ==============
 
diff --git a/plone/memoize/request.rst b/plone/memoize/request.rst
index c3ab40e..07ec3ae 100644
--- a/plone/memoize/request.rst
+++ b/plone/memoize/request.rst
@@ -1,4 +1,3 @@
-==================
 Request Decorators
 ==================
 
diff --git a/plone/memoize/view.rst b/plone/memoize/view.rst
index d2bae90..dd41d9d 100644
--- a/plone/memoize/view.rst
+++ b/plone/memoize/view.rst
@@ -1,4 +1,3 @@
-===============
 View Decorators
 ===============
 


Repository: plone.memoize


Branch: refs/heads/master
Date: 2015-12-15T19:37:51+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/e879ead192c16e901da6d83d6a283c65e183b844

fix tests

Files changed:
M plone/memoize/compress.rst
M plone/memoize/ram.rst
M plone/memoize/request.rst
M plone/memoize/tests.py
M plone/memoize/volatile.rst

diff --git a/plone/memoize/compress.rst b/plone/memoize/compress.rst
index f36c168..08d36d8 100644
--- a/plone/memoize/compress.rst
+++ b/plone/memoize/compress.rst
@@ -7,6 +7,13 @@ In order to use Peter Bengtsson's slimmer library available from http://www.issu
   <utility component="plone.memoize.compress.xhtmlslimmer"
            provides="plone.memoize.interfaces.IXHTMLCompressor" />
 
+Make necessary imports:::
+    >>> from plone.memoize.compress import xhtml_compress
+    >>> from plone.memoize.interfaces import IXHTMLCompressor
+    >>> from zope.interface import implements
+
+
+
 You can register other XHTML-whitespace removal libraries as well.
 
 Per default there is no compressor available and we get the same string back:
diff --git a/plone/memoize/ram.rst b/plone/memoize/ram.rst
index 1fc286b..e6442e5 100644
--- a/plone/memoize/ram.rst
+++ b/plone/memoize/ram.rst
@@ -3,6 +3,16 @@ RAM Decorators
 
 A cache decorator that uses RAMCache by default.
 
+Make necessary imports:::
+    >>> from plone.memoize.interfaces import ICacheChooser
+    >>> from plone.memoize.ram import cache
+    >>> from plone.memoize.ram import choose_cache
+    >>> from plone.memoize.ram import global_cache
+    >>> from plone.memoize.ram import RAMCacheAdapter
+    >>> from zope import component
+    >>> from zope import interface
+    >>> from zope.ramcache import ram
+
 ::
     >>> def cache_key(fun, first, second):
     ...     return (first, second)
@@ -36,7 +46,7 @@ Now invalidate the cache for the `pow` function:
 ::
     >>> pow(3, 2)
     9
-    >>> global_cache.invalidate('plone.memoize.ram.pow')
+    >>> global_cache.invalidate('None.pow')
     >>> pow(3, 2)
     Someone or something called me
     9
diff --git a/plone/memoize/request.rst b/plone/memoize/request.rst
index 07ec3ae..011ccc9 100644
--- a/plone/memoize/request.rst
+++ b/plone/memoize/request.rst
@@ -3,6 +3,10 @@ Request Decorators
 
 This is a hypothetical function `increment` that'll store the cache value on `a.request`, where a is the only argument to the function:
 
+Make necessary imports:::
+    >>> from plone.memoize.request import cache
+    >>> from zope.annotation.interfaces import IAnnotations
+
 ::
     >>> def increment(a):
     ...     print 'Someone or something called me'
@@ -40,7 +44,7 @@ We'll tell the decorator to use `args_hash` for generating the key.
     >>> cached_increment(A(1))
     2
     >>> IAnnotations(A.request)
-    {'plone.memoize.request.increment:1': 2}
+    {'None.increment:1': 2}
 
 If `request` is already part of the function's argument list, we don't need to specify any expression:
 
@@ -55,7 +59,7 @@ If `request` is already part of the function's argument list, we don't need to s
     43
     >>> increment_plus(42, A.request)
     43
-    >>> IAnnotations(A.request)['plone.memoize.request.increment_plus:42']
+    >>> IAnnotations(A.request)['None.increment_plus:42']
     43
 
 Create a function that can also take keyword arguments.
@@ -78,7 +82,7 @@ get_key must be modified to take kwargs into account:
     43
     >>> increment_kwargs(42, A.request, kwarg1='kwarg1', kwarg2='kwarg2')
     43
-    >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[('kwarg1', 'kwarg1'), ('kwarg2', 'kwarg2')]"]
+    >>> IAnnotations(A.request)["None.increment_kwargs:42,[('kwarg1', 'kwarg1'), ('kwarg2', 'kwarg2')]"]
     43
 
 Call increment_kwargs without specifying any keyword arguments:
@@ -89,7 +93,7 @@ Call increment_kwargs without specifying any keyword arguments:
     43
     >>> increment_kwargs(42, A.request)
     43
-    >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[]"]
+    >>> IAnnotations(A.request)["None.increment_kwargs:42,[]"]
     43
 
 Call increment_kwargs and specify only the second keyword argument:
@@ -100,6 +104,6 @@ Call increment_kwargs and specify only the second keyword argument:
     43
     >>> increment_kwargs(42, A.request, kwarg2='kwarg2')
     43
-    >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[('kwarg2', 'kwarg2')]"]
+    >>> IAnnotations(A.request)["None.increment_kwargs:42,[('kwarg2', 'kwarg2')]"]
     43
 
diff --git a/plone/memoize/tests.py b/plone/memoize/tests.py
index f1688ba..1b74221 100644
--- a/plone/memoize/tests.py
+++ b/plone/memoize/tests.py
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
-from zope.component.testing import setUp, tearDown
+from zope.component.testing import setUp
+from zope.component.testing import tearDown
 from zope.configuration.xmlconfig import XMLConfig
 from zope.testing import doctest
 import unittest
@@ -17,42 +18,42 @@ def configurationSetUp(test):
 
 def test_suite():
     tests = (
-        doctest.DocTestSuite('README.rst',
+        doctest.DocFileSuite('README.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocTestSuite('compress.rst',
+        doctest.DocFileSuite('compress.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocTestSuite('forever.rst',
+        doctest.DocFileSuite('forever.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocTestSuite('instance.rst',
+        doctest.DocFileSuite('instance.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocTestSuite('ram.rst',
+        doctest.DocFileSuite('ram.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocTestSuite('request.rst',
+        doctest.DocFileSuite('request.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocTestSuite('view.rst',
+        doctest.DocFileSuite('view.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocTestSuite('volatile.rst',
+        doctest.DocFileSuite('volatile.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
diff --git a/plone/memoize/volatile.rst b/plone/memoize/volatile.rst
index e975c39..f6dfdeb 100644
--- a/plone/memoize/volatile.rst
+++ b/plone/memoize/volatile.rst
@@ -3,6 +3,12 @@ Volatile Decorators
 
 A flexible caching decorator.
 
+Make necessary imports:::
+    >>> from plone.memoize.volatile import ATTR
+    >>> from plone.memoize.volatile import cache
+    >>> from plone.memoize.volatile import DontCache
+    >>> from plone.memoize.volatile import CleanupDict
+
 This module provides a cache decorator `cache` that you can use to cache results of your functions or methods.
 Let's say we have a class with an expensive method `pow` that we want to cache:
 
@@ -66,10 +72,10 @@ This cache container maps our key, including the function's dotted name, to the
 
 ::
     >>> cache_container # doctest: +ELLIPSIS
-    {'plone.memoize.volatile.pow:...': 9}
+    {'None.pow:...': 9}
     >>> len(cache_container)
     1
-    >>> k = 'plone.memoize.volatile.pow:%s' % str(cache_key(MyClass.pow, None, 3, 2))
+    >>> k = 'None.pow:%s' % str(cache_key(MyClass.pow, None, 3, 2))
     >>> cache_container[k]
     9
 
@@ -164,7 +170,7 @@ Be careful when you have multiple methods with the same name in a single module:
     >>> a.somemet(1, 2)
     3
     >>> cache_container
-    {'plone.memoize.volatile.somemet:(1, 2)': 3}
+    {'None.somemet:(1, 2)': 3}
 
 The following call should really return -1, but since the default cache key isn't clever enough to include the function's name, it'll return 3:
 


Repository: plone.memoize


Branch: refs/heads/master
Date: 2015-12-15T20:01:22+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/9144ccaa94c225b1ec39baec097ddc95bc73f0e9

fix paths

Files changed:
M docs/index.rst

diff --git a/docs/index.rst b/docs/index.rst
index e4a8b82..dcdaabc 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -1,17 +1,18 @@
+=============
 plone.memoize
 =============
 
 Documentation for the caching decorator package plone.memoize.
 
 .. toctree::
-    :maxdepth: 2
+    :maxdepth: 4
 
-    ../plone/memoize/README.rst
-    ../plone/memoize/volatile.rst
-    ../plone/memoize/request.rst
-    ../plone/memoize/view.rst
-    ../plone/memoize/ram.rst
-    ../plone/memoize/forever.rst
-    ../plone/memoize/instance.rst
-    ../plone/memoize/compress.rst
+    ../plone/memoize/README
+    ../plone/memoize/volatile
+    ../plone/memoize/request
+    ../plone/memoize/view
+    ../plone/memoize/ram
+    ../plone/memoize/forever
+    ../plone/memoize/instance
+    ../plone/memoize/compress
 


Repository: plone.memoize


Branch: refs/heads/master
Date: 2015-12-16T00:21:46+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/9f809c49110269b1f95be63d875ef4f392191a82

headings, toctree depth, code sections

Files changed:
M docs/index.rst
M plone/memoize/README.rst
M plone/memoize/compress.rst
M plone/memoize/forever.rst
M plone/memoize/instance.rst
M plone/memoize/ram.rst
M plone/memoize/request.rst
M plone/memoize/view.rst
M plone/memoize/volatile.rst

diff --git a/docs/index.rst b/docs/index.rst
index dcdaabc..beb33a9 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -5,7 +5,7 @@ plone.memoize
 Documentation for the caching decorator package plone.memoize.
 
 .. toctree::
-    :maxdepth: 4
+    :maxdepth: 1
 
     ../plone/memoize/README
     ../plone/memoize/volatile
diff --git a/plone/memoize/README.rst b/plone/memoize/README.rst
index 7a3b3ba..6d81e14 100644
--- a/plone/memoize/README.rst
+++ b/plone/memoize/README.rst
@@ -11,7 +11,7 @@ However, plone.memoize can be used without Zope.
 
 
 Volatile
-========
+--------
 
 The 'volatile' module defines a versatile caching decorator that gives you total control of how the cache key is calculated and where it is stored.
 This decorator is explained in more in depth with example usage in 'volatile.py'.
@@ -49,7 +49,7 @@ This is how you could use the same decorator to cache a function's value for an
 
 
 View and Instance
-=================
+-----------------
 
 See view.rst and instance.rst for usage of cache decorators that have a fixed cache key and cache storage.
 The most common usage pattern of these view and instance caching decorators is::
@@ -82,7 +82,7 @@ Note that this requires that the request is annotatable using zope.annotation!
 
 
 Generic
-=======
+-------
 
 The generic decorator uses the GenericCache module as storage.
 By default it'll store into a global cache of its own, with default parameters of 1000 maximal objects and 1 hour maximal lifespan.
@@ -93,7 +93,7 @@ Look at the docstring for a few examples.
 
 
 Keys and Parameters Marshaling
-==============================
+------------------------------
 
 An important issue about caches is how to generate the cache key.
 In all the decorators above, you can create your own function.
diff --git a/plone/memoize/compress.rst b/plone/memoize/compress.rst
index 08d36d8..017a527 100644
--- a/plone/memoize/compress.rst
+++ b/plone/memoize/compress.rst
@@ -1,13 +1,13 @@
 XHTML Compressor
 ================
 
-In order to use Peter Bengtsson's slimmer library available from http://www.issuetrackerproduct.com/Download#slimmer you need to register the XHTMLSlimmer utility like this:
+In order to use Peter Bengtsson's slimmer library available from http://www.issuetrackerproduct.com/Download#slimmer you need to register the XHTMLSlimmer utility like this::
 
-::
   <utility component="plone.memoize.compress.xhtmlslimmer"
            provides="plone.memoize.interfaces.IXHTMLCompressor" />
 
-Make necessary imports:::
+Make necessary imports::
+
     >>> from plone.memoize.compress import xhtml_compress
     >>> from plone.memoize.interfaces import IXHTMLCompressor
     >>> from zope.interface import implements
@@ -16,17 +16,15 @@ Make necessary imports:::
 
 You can register other XHTML-whitespace removal libraries as well.
 
-Per default there is no compressor available and we get the same string back:
+Per default there is no compressor available and we get the same string back::
 
-::
     >>> html_string = u"<html><body><SPAN>Hello.</SPAN></body><html>"
     >>> xhtml_compress(html_string) is html_string
     True
 
 Make a stupid lowercasing compressor.
-This is not safe as it would lowercase all text outside of tags as well:
+This is not safe as it would lowercase all text outside of tags as well::
 
-::
     >>> class LowerCaser(object):
     ...     implements(IXHTMLCompressor)
     ...
@@ -35,9 +33,8 @@ This is not safe as it would lowercase all text outside of tags as well:
 
     >>> lower = LowerCaser()
 
-Register our new compressor:
+Register our new compressor::
 
-::
     >>> from zope.component import getSiteManager
     >>> sm = getSiteManager()
     >>> sm.registerUtility(lower)
diff --git a/plone/memoize/forever.rst b/plone/memoize/forever.rst
index 8024434..0362399 100644
--- a/plone/memoize/forever.rst
+++ b/plone/memoize/forever.rst
@@ -8,9 +8,8 @@ Stores values in a module-level variable.
 Pay attention that is module is not thread-safe, so use it with care.
 
 These remember a value "forever", i.e. until the process is restarted.
-They work on both global functions and class functions.
+They work on both global functions and class functions.::
 
-::
     >>> from plone.memoize import forever
 
     >>> @forever.memoize
@@ -18,9 +17,8 @@ They work on both global functions and class functions.
     ...     print "Calculating"
     ...     return arg1 + arg2
 
-No matter how many times we call this function with a particular set of arguments, it will only perform its calculation once.
+No matter how many times we call this function with a particular set of arguments, it will only perform its calculation once::
 
-::
     >>> remember(1, 1)
     Calculating
     2
@@ -32,9 +30,8 @@ No matter how many times we call this function with a particular set of argument
     >>> remember(1, 2)
     3
 
-This also works for methods in classes.
+This also works for methods in classes::
 
-::
     >>> class Test(object):
     ...
     ...     @forever.memoize
@@ -53,3 +50,4 @@ This also works for methods in classes.
     3
     >>> t.remember(1, 2)
     3
+
diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index 14e8b6c..bb35599 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -10,9 +10,8 @@ The memoized values are stored on an attribute on the instance and disappear whe
     The ``instance`` caching decorator writes to ZODB when filling the cache.
     This can lead to database conflict errors caused by write on read.
 
-Let's try it out w/ a dummy class:
+Let's try it out w/ a dummy class::
 
-::
     >>> from plone.memoize import instance
     >>> class MyMsg(object):
     ...     bang='!'
@@ -50,61 +49,52 @@ Let's try it out w/ a dummy class:
 
     >>> msg.txt1 = 'nice to visit this'
 
-Even though we've twiddled txt1, txt2 is not recalculated:
+Even though we've twiddled txt1, txt2 is not recalculated::
 
-::
     >>> msg.txt2
     'hello world'
 
 The memo is stored by a key made of the method's name, args, and a frozenset of any kwargs.
-If those are expected to be big, you should compute your own hash of it:
+If those are expected to be big, you should compute your own hash of it::
 
-::
     >>> key = ('txt2', (msg,), frozenset([]))
     >>> msg._memojito_[key]
     'hello world'
 
-The clear after decorator will clear the memos after returning the methods value:
+The clear after decorator will clear the memos after returning the methods value::
 
-::
     >>> msg.clearafter()
     'hello world'
 
-So now the message should have changed:
+So now the message should have changed::
 
-::
     >>> msg.txt2
     'nice to visit this world'
 
-We change the text again:
+We change the text again::
 
-::
     >>> msg.txt1 = 'goodbye cruel'
 
-The message is still the same of course:
+The message is still the same of course::
 
-::
     >>> msg.txt2
     'nice to visit this world'
 
-Now we can test the clear before, which does the opposite from the clear after, allowing new values to be calculated:
+Now we can test the clear before, which does the opposite from the clear after, allowing new values to be calculated::
 
-::
     >>> msg.clearbefore()
     'goodbye cruel world'
 
-memojito supports memoization of multiple signatures as long as all signature values are hashable:
+memojito supports memoization of multiple signatures as long as all signature values are hashable::
 
-::
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
     >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: goodbye cruel world! raise--roofbeams
 
-We can alter data underneath, but nothing changes:
+We can alter data underneath, but nothing changes::
 
-::
     >>> msg.txt1 = 'sound and fury'
     >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: goodbye cruel world! raise--roofbeams
@@ -112,9 +102,8 @@ We can alter data underneath, but nothing changes:
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
-If we alter the signature, our msg is recalculated, but since mst.txt2 is a memo, only the values passed in change:
+If we alter the signature, our msg is recalculated, but since mst.txt2 is a memo, only the values passed in change::
 
-::
     >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
     >>> print msg.getMsg('Bill F.', **ins)
     Bill F.: goodbye cruel world! tale--told by idiot signify--nothing
@@ -122,9 +111,8 @@ If we alter the signature, our msg is recalculated, but since mst.txt2 is a memo
     >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
     J.D.: goodbye cruel world! catcher--rye
 
-If change the bang, the memo remains the same:
+If change the bang, the memo remains the same::
 
-::
     >>> msg.bang='#!'
     >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
     J.D.: goodbye cruel world! catcher--rye
@@ -132,35 +120,30 @@ If change the bang, the memo remains the same:
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
-clearing works the same as for properties:
+clearing works the same as for properties::
 
-::
     >>> print msg.clearafter()
     goodbye cruel world
 
-Our shebang appears:
+Our shebang appears::
 
-::
     >>> print msg.getMsg('Ernest')
     Ernest: sound and fury world#!
 
-Our message to faulkner now is semantically correct:
+Our message to faulkner now is semantically correct::
 
-::
     >>> ins = dict(tale='told by idiot', signify='nothing')
     >>> print msg.getMsg('Bill F.', **ins)
     Bill F.: sound and fury world#! tale--told by idiot signify--nothing
 
-Let's make sure that memoized properties which call OTHER memoized properties do the right thing:
+Let's make sure that memoized properties which call OTHER memoized properties do the right thing::
 
-::
     >>> msg = MyMsg('hello')
     >>> print msg.recurse
     recursive: hello world
 
-Now we make sure that both the txt2 and the recurse values are in the cache:
+Now we make sure that both the txt2 and the recurse values are in the cache::
 
-::
     >>> print len(msg._memojito_.keys())
     2
 
diff --git a/plone/memoize/ram.rst b/plone/memoize/ram.rst
index e6442e5..674fdeb 100644
--- a/plone/memoize/ram.rst
+++ b/plone/memoize/ram.rst
@@ -3,7 +3,8 @@ RAM Decorators
 
 A cache decorator that uses RAMCache by default.
 
-Make necessary imports:::
+Make necessary imports::
+
     >>> from plone.memoize.interfaces import ICacheChooser
     >>> from plone.memoize.ram import cache
     >>> from plone.memoize.ram import choose_cache
@@ -14,6 +15,7 @@ Make necessary imports:::
     >>> from zope.ramcache import ram
 
 ::
+
     >>> def cache_key(fun, first, second):
     ...     return (first, second)
     >>> @cache(cache_key)
@@ -27,9 +29,8 @@ Make necessary imports:::
     >>> pow(3, 2)
     9
 
-Let's cache another function:
+Let's cache another function::
 
-::
     >>> @cache(cache_key)
     ... def add(first, second):
     ...     print 'Someone or something called me'
@@ -41,9 +42,8 @@ Let's cache another function:
     >>> add(3, 2)
     5
 
-Now invalidate the cache for the `pow` function:
+Now invalidate the cache for the `pow` function::
 
-::
     >>> pow(3, 2)
     9
     >>> global_cache.invalidate('None.pow')
@@ -51,25 +51,22 @@ Now invalidate the cache for the `pow` function:
     Someone or something called me
     9
 
-Make sure that we only invalidated the cache for the `pow` function:
+Make sure that we only invalidated the cache for the `pow` function::
 
-::
     >>> add(3, 2)
     5
 
     >>> global_cache.invalidateAll()
 
 You can register an ICacheChooser utility to override the cache used based on the function that is cached.
-To do this, we'll first unregister the already registered global `choose_cache` function:
+To do this, we'll first unregister the already registered global `choose_cache` function::
 
-::
     >>> sm = component.getGlobalSiteManager()
     >>> sm.unregisterUtility(choose_cache)
     True
 
-This customized cache chooser will use the `my_cache` for the `pow` function, and use the `global_cache` for all other functions:
+This customized cache chooser will use the `my_cache` for the `pow` function, and use the `global_cache` for all other functions::
 
-::
     >>> my_cache = ram.RAMCache()
     >>> def my_choose_cache(fun_name):
     ...     if fun_name.endswith('.pow'):
@@ -79,17 +76,15 @@ This customized cache chooser will use the `my_cache` for the `pow` function, an
     >>> interface.directlyProvides(my_choose_cache, ICacheChooser)
     >>> sm.registerUtility(my_choose_cache)
 
-Both caches are empty at this point:
+Both caches are empty at this point::
 
-::
     >>> len(global_cache.getStatistics())
     0
     >>> len(my_cache.getStatistics())
     0
 
-Let's fill them:
+Let's fill them::
 
-::
     >>> pow(3, 2)
     Someone or something called me
     9
@@ -101,6 +96,7 @@ Let's fill them:
     1
 
 ::
+
     >>> add(3, 2)
     Someone or something called me
     5
diff --git a/plone/memoize/request.rst b/plone/memoize/request.rst
index 011ccc9..7bca946 100644
--- a/plone/memoize/request.rst
+++ b/plone/memoize/request.rst
@@ -3,20 +3,21 @@ Request Decorators
 
 This is a hypothetical function `increment` that'll store the cache value on `a.request`, where a is the only argument to the function:
 
-Make necessary imports:::
+Make necessary imports::
+
     >>> from plone.memoize.request import cache
     >>> from zope.annotation.interfaces import IAnnotations
 
 ::
+
     >>> def increment(a):
     ...     print 'Someone or something called me'
     ...     return a + 1
 
 Now we need to define this `a`.
 For this, we'll inherit from `int` and add a `request` class variable.
-Note that we also make our fake request `IAttributeAnnotatable`, because that's how the cache values are stored on the request:
+Note that we also make our fake request `IAttributeAnnotatable`, because that's how the cache values are stored on the request::
 
-::
     >>> from zope.publisher.browser import TestRequest
     >>> class A(int):
     ...     request = TestRequest()
@@ -25,16 +26,14 @@ Note that we also make our fake request `IAttributeAnnotatable`, because that's
     >>> directlyProvides(A.request, IAttributeAnnotatable)
 
 In addition to this request, we'll also need to set up a cache key generator.
-We'll use the integer value of the only argument for that:
+We'll use the integer value of the only argument for that::
 
-::
     >>> get_key = lambda fun, a, *args: a
 
 Let's decorate our `increment` function now with the `cache` decorator.
 We'll tell the decorator to use `args_hash` for generating the key.
-`get_request` will tell the decorator how to actually find the `request` in the variable scope of the function itself:
+`get_request` will tell the decorator how to actually find the `request` in the variable scope of the function itself::
 
-::
     >>> cached_increment = \
     ...     cache(get_key=get_key, get_request='a.request')(increment)
 
@@ -46,9 +45,8 @@ We'll tell the decorator to use `args_hash` for generating the key.
     >>> IAnnotations(A.request)
     {'None.increment:1': 2}
 
-If `request` is already part of the function's argument list, we don't need to specify any expression:
+If `request` is already part of the function's argument list, we don't need to specify any expression::
 
-::
     >>> @cache(get_key=get_key)
     ... def increment_plus(a, request):
     ...     print 'Someone or something called me'
@@ -64,9 +62,8 @@ If `request` is already part of the function's argument list, we don't need to s
 
 Create a function that can also take keyword arguments.
 For the sake of convenience pass the request explicitly.
-get_key must be modified to take kwargs into account:
+get_key must be modified to take kwargs into account::
 
-::
     >>> def get_key(fun, a, request, **kwargs):
     ...     li = kwargs.items()
     ...     li.sort()
@@ -85,9 +82,8 @@ get_key must be modified to take kwargs into account:
     >>> IAnnotations(A.request)["None.increment_kwargs:42,[('kwarg1', 'kwarg1'), ('kwarg2', 'kwarg2')]"]
     43
 
-Call increment_kwargs without specifying any keyword arguments:
+Call increment_kwargs without specifying any keyword arguments::
 
-::
     >>> increment_kwargs(42, A.request)
     Someone or something called me
     43
@@ -96,9 +92,8 @@ Call increment_kwargs without specifying any keyword arguments:
     >>> IAnnotations(A.request)["None.increment_kwargs:42,[]"]
     43
 
-Call increment_kwargs and specify only the second keyword argument:
+Call increment_kwargs and specify only the second keyword argument::
 
-::
     >>> increment_kwargs(42, A.request, kwarg2='kwarg2')
     Someone or something called me
     43
diff --git a/plone/memoize/view.rst b/plone/memoize/view.rst
index dd41d9d..827e214 100644
--- a/plone/memoize/view.rst
+++ b/plone/memoize/view.rst
@@ -5,9 +5,8 @@ Memoize decorator for views.
 
 Decorators for methods/properties in views.
 Values are cached by annotating the view's request, and keyed based on the context and any arguments to the function.
-This means that the same view can be looked up multiple times and the same memos will be returned:
+This means that the same view can be looked up multiple times and the same memos will be returned::
 
-::
     >>> from plone.memoize import view
     >>> from zope.component import adapts
     >>> from zope.interface import implements
@@ -15,9 +14,8 @@ This means that the same view can be looked up multiple times and the same memos
     >>> from zope.publisher.interfaces.browser import IBrowserRequest
     >>> from zope.publisher.interfaces.browser import IBrowserView
 
-First we set up a dummy view:
+First we set up a dummy view::
 
-::
     >>> class MyView(object):
     ...     implements(IBrowserView)
     ...     adapts(Interface, IBrowserRequest)
@@ -50,22 +48,19 @@ First we set up a dummy view:
     >>> from zope.component import provideAdapter
     >>> provideAdapter(MyView, name=u'msg_view')
 
-We also need a dummy context:
+We also need a dummy context::
 
-::
     >>> class Dummy(object):
     ...     implements(Interface)
 
-Let's look up the view:
+Let's look up the view::
 
-::
     >>> from zope.publisher.browser import TestRequest
     >>> request = TestRequest()
     >>> context = Dummy()
 
-We need request to be annotatable:
+We need request to be annotatable::
 
-::
     >>> from zope.interface import directlyProvides
     >>> from zope.annotation.interfaces import IAttributeAnnotatable
     >>> directlyProvides(request, IAttributeAnnotatable)
@@ -73,32 +68,28 @@ We need request to be annotatable:
     >>> from zope.component import getMultiAdapter
     >>> msg = getMultiAdapter((context, request), name=u'msg_view')
 
-Now, if we access the memoized property txt2, we will get the value in txt1:
+Now, if we access the memoized property txt2, we will get the value in txt1::
 
-::
     >>> msg.txt2
     'hello world'
 
     >>> msg.txt1 = 'goodbye cruel'
 
-Even though we've twiddled txt1, txt2 is not recalculated:
+Even though we've twiddled txt1, txt2 is not recalculated::
 
-::
     >>> msg.txt2
     'hello world'
 
-We support memoization of multiple signatures as long as all signature values are hashable:
+We support memoization of multiple signatures as long as all signature values are hashable::
 
-::
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
     >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: goodbye cruel world! raise--roofbeams
 
-We can alter data underneath, but nothing changes:
+We can alter data underneath, but nothing changes::
 
-::
     >>> msg.txt1 = 'sound and fury'
     >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: goodbye cruel world! raise--roofbeams
@@ -106,9 +97,8 @@ We can alter data underneath, but nothing changes:
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
-If we alter the signature, our msg is recalculated:
+If we alter the signature, our msg is recalculated::
 
-::
     >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
     >>> print msg.getMsg('Bill F.', **ins)
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
@@ -116,9 +106,8 @@ If we alter the signature, our msg is recalculated:
     >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
     J.D.: sound and fury world! catcher--rye
 
-If change the bang, the memo remains the same:
+If change the bang, the memo remains the same::
 
-::
     >>> msg.bang='#!'
     >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
     J.D.: sound and fury world! catcher--rye
@@ -126,9 +115,8 @@ If change the bang, the memo remains the same:
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
-If we look up the view again on the same object, we will get the same memoized properties as before:
+If we look up the view again on the same object, we will get the same memoized properties as before::
 
-::
     >>> msg2 = getMultiAdapter((context, request), name=u'msg_view')
 
     >>> msg2.txt1 = 'and so on'
@@ -150,9 +138,8 @@ If we look up the view again on the same object, we will get the same memoized p
     >>> print msg2.getMsg('J.D.', **{'catcher':'rye'})
     J.D.: sound and fury world! catcher--rye
 
-However, if we look up the view on another context object, things change:
+However, if we look up the view on another context object, things change::
 
-::
     >>> context = Dummy()
     >>> msg3 = getMultiAdapter((context, request), name=u'msg_view')
 
@@ -176,11 +163,11 @@ However, if we look up the view on another context object, things change:
     J.D.: so long, cruel world& catcher--rye
 
 This behaviour does not apply to contextless decorators, which memoize
-based on parameters, but not on context:
+based on parameters, but not on context::
 
-::
     >>> print msg3.getAnotherMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: so long, cruel world& raise--roofbeams
 
     >>> print msg2.getAnotherMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: so long, cruel world& raise--roofbeams
+
diff --git a/plone/memoize/volatile.rst b/plone/memoize/volatile.rst
index f6dfdeb..844906f 100644
--- a/plone/memoize/volatile.rst
+++ b/plone/memoize/volatile.rst
@@ -3,16 +3,16 @@ Volatile Decorators
 
 A flexible caching decorator.
 
-Make necessary imports:::
+Make necessary imports::
+
     >>> from plone.memoize.volatile import ATTR
     >>> from plone.memoize.volatile import cache
     >>> from plone.memoize.volatile import DontCache
     >>> from plone.memoize.volatile import CleanupDict
 
 This module provides a cache decorator `cache` that you can use to cache results of your functions or methods.
-Let's say we have a class with an expensive method `pow` that we want to cache:
+Let's say we have a class with an expensive method `pow` that we want to cache::
 
-::
     >>> class MyClass:
     ...     def pow(self, first, second):
     ...         print 'Someone or something called me'
@@ -21,9 +21,8 @@ Let's say we have a class with an expensive method `pow` that we want to cache:
 Okay, we know that if the `first` and `second` arguments are the same, the result is going to be the same, always.
 We'll use a cache key calculator to tell the `cache` decorator about this assertion.
 What's this cache key calculator?
-It's a function that takes the original function plus the same arguments as the original function that we're caching:
+It's a function that takes the original function plus the same arguments as the original function that we're caching::
 
-::
     >>> def cache_key(method, self, first, second):
     ...     return (first, second)
 
@@ -31,18 +30,16 @@ For performances and security reasons, no hash is done on the key in this exampl
 You may consider using a cryptographic hash (MD5 or even better SHA1) if your parameters can hold big amount of data.
 
 The cache decorator is really simple to use.
-Let's define our first class again, this time with a cached `pow` method:
+Let's define our first class again, this time with a cached `pow` method::
 
-::
     >>> class MyClass:
     ...     @cache(cache_key)
     ...     def pow(self, first, second):
     ...         print 'Someone or something called me'
     ...         return first ** second
 
-The results:
+The results::
 
-::
     >>> obj = MyClass()
     >>> obj.pow(3, 2)
     Someone or something called me
@@ -61,16 +58,14 @@ For normal functions, the first argument is maybe not the best place to store th
 
 The default cache container function stores a dictionary on the instance as a *volatile* attribute.
 That is, it's prefixed with ``_v_``.
-In Zope, this means that the cache is not persisted.
+In Zope, this means that the cache is not persisted::
 
-::
     >>> ATTR
     '_v_memoize_cache'
     >>> cache_container = getattr(obj, ATTR)
 
-This cache container maps our key, including the function's dotted name, to the return value.
+This cache container maps our key, including the function's dotted name, to the return value::
 
-::
     >>> cache_container # doctest: +ELLIPSIS
     {'None.pow:...': 9}
     >>> len(cache_container)
@@ -83,31 +78,27 @@ Okay, on to storing the cache somewhere else.
 The function we'll have to provide is really similar to the cache key function we defined earlier.
 
 Like the cache key function, the storage function takes the same amount of arguments as the original cached function.
-We'll use a global for caching this time:
+We'll use a global for caching this time::
 
-::
     >>> my_cache = {}
     >>> def cache_storage(fun, *args, **kwargs):
     ...     return my_cache
 
 This time, instead of caching a method, we'll cache a normal function.
-For this, we'll need to change our cache key function to take the correct number of arguments:
+For this, we'll need to change our cache key function to take the correct number of arguments::
 
-::
     >>> def cache_key(fun, first, second):
     ...     return (first, second)
 
-Note how we provide both the cache key generator and the cache storage as arguments to the `cache` decorator:
+Note how we provide both the cache key generator and the cache storage as arguments to the `cache` decorator::
 
-::
     >>> @cache(cache_key, cache_storage)
     ... def pow(first, second):
     ...     print 'Someone or something called me'
     ...     return first ** second
 
-Let's try it out:
+Let's try it out::
 
-::
     >>> pow(3, 2)
     Someone or something called me
     9
@@ -124,9 +115,8 @@ Let's try it out:
 
 It works!
 
-A cache key generator may also raise DontCache to indicate that no caching should be applied:
+A cache key generator may also raise DontCache to indicate that no caching should be applied::
 
-::
     >>> def cache_key(fun, first, second):
     ...     if first == second:
     ...         raise DontCache
@@ -152,9 +142,8 @@ A cache key generator may also raise DontCache to indicate that no caching shoul
 Caveats
 -------
 
-Be careful when you have multiple methods with the same name in a single module:
+Be careful when you have multiple methods with the same name in a single module::
 
-::
     >>> def cache_key(fun, instance, *args):
     ...     return args
     >>> cache_container = {}
@@ -172,9 +161,8 @@ Be careful when you have multiple methods with the same name in a single module:
     >>> cache_container
     {'None.somemet:(1, 2)': 3}
 
-The following call should really return -1, but since the default cache key isn't clever enough to include the function's name, it'll return 3:
+The following call should really return -1, but since the default cache key isn't clever enough to include the function's name, it'll return 3::
 
-::
     >>> B().somemet(1, 2)
     3
     >>> len(cache_container)
@@ -182,9 +170,8 @@ The following call should really return -1, but since the default cache key isn'
     >>> cache_container.clear()
 
 Ouch!
-The fix for this is to e.g. include your class' name in the key when you create it:
+The fix for this is to e.g. include your class' name in the key when you create it::
 
-::
     >>> def cache_key(fun, instance, *args):
     ...     return (instance.__class__,) + args
     >>> class A:
@@ -212,6 +199,7 @@ CleanupDict is a dict that automatically cleans up items that haven't been acces
 This implementation is a bit naive, since it's not associated with any policy that the user can configure, and it doesn't provide statistics like RAMCache, but at least it helps make sure our volatile attribute doesn't grow stale entries indefinitely.
 
 ::
+
     >>> d = CleanupDict()
     >>> d['spam'] = 'bar'
     >>> d['spam']
@@ -221,6 +209,7 @@ Setting the cleanup period to 0 (or a negative number) means the values are thro
 (Note that we do not test with exactly zero, as running the tests can go too fast.)
 
 ::
+
     >>> d = CleanupDict(-0.00001)
     >>> d['spam'] = 'bar'
     >>> d['spam'] # doctest: +ELLIPSIS


Repository: plone.memoize


Branch: refs/heads/master
Date: 2015-12-16T00:24:43+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/b01cc8879739158992a47d4c2c0334efced6219b

changelog

Files changed:
M CHANGES.rst
M plone/memoize/request.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 3f25b90..1402b7a 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,6 +10,9 @@ New:
 
 Fixes:
 
+- Restructure docs.
+  [thet]
+
 - Minor PEP 8.
   [thet]
 
diff --git a/plone/memoize/request.py b/plone/memoize/request.py
index 5219cf6..e987ade 100644
--- a/plone/memoize/request.py
+++ b/plone/memoize/request.py
@@ -72,8 +72,6 @@ def _store_in_annotation(fun, *args, **kwargs):
 
 
 def cache(get_key, get_request='request'):
-    r"""
-    """
 
     return volatile.cache(get_key,
                           get_cache=store_in_annotation_of(get_request))


Repository: plone.memoize


Branch: refs/heads/master
Date: 2015-12-22T15:35:47+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.memoize/commit/cf275b092a00e7b3e9dbbbb2045d442b49aa0d19

Merge pull request #2 from plone/thet-restructure-docs

Restructure docs

Files changed:
A docs/index.rst
A plone/memoize/compress.rst
A plone/memoize/ram.rst
A plone/memoize/request.rst
A plone/memoize/volatile.rst
M CHANGES.rst
M plone/memoize/README.rst
M plone/memoize/compress.py
M plone/memoize/forever.rst
M plone/memoize/instance.py
M plone/memoize/instance.rst
M plone/memoize/ram.py
M plone/memoize/request.py
M plone/memoize/tests.py
M plone/memoize/view.rst
M plone/memoize/volatile.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 3f25b90..1402b7a 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,6 +10,9 @@ New:
 
 Fixes:
 
+- Restructure docs.
+  [thet]
+
 - Minor PEP 8.
   [thet]
 
diff --git a/docs/index.rst b/docs/index.rst
new file mode 100644
index 0000000..beb33a9
--- /dev/null
+++ b/docs/index.rst
@@ -0,0 +1,18 @@
+=============
+plone.memoize
+=============
+
+Documentation for the caching decorator package plone.memoize.
+
+.. toctree::
+    :maxdepth: 1
+
+    ../plone/memoize/README
+    ../plone/memoize/volatile
+    ../plone/memoize/request
+    ../plone/memoize/view
+    ../plone/memoize/ram
+    ../plone/memoize/forever
+    ../plone/memoize/instance
+    ../plone/memoize/compress
+
diff --git a/plone/memoize/README.rst b/plone/memoize/README.rst
index 7911143..6d81e14 100644
--- a/plone/memoize/README.rst
+++ b/plone/memoize/README.rst
@@ -1,31 +1,26 @@
 Introduction
 ============
 
-plone.memoize provides Python function decorators for caching the
-values of functions and methods.
+plone.memoize provides Python function decorators for caching the values of functions and methods.
 
-The type of cache storage is freely configurable by the user, as is
-the cache key, which is what the function's value depends on.
+The type of cache storage is freely configurable by the user, as is the cache key, which is what the function's value depends on.
 
-plone.memoize has support for memcached and is easily extended to use
-other caching storages.  It also has specialized decorators for use
-with Zope views.  However, plone.memoize can be used without Zope.
+plone.memoize has support for memcached and is easily extended to use other caching storages.
+It also has specialized decorators for use with Zope views.
+However, plone.memoize can be used without Zope.
 
 
-volatile
-========
+Volatile
+--------
 
-The 'volatile' module defines a versatile caching decorator that gives
-you total control of how the cache key is calculated and where it is
-stored.  This decorator is explained in more in depth with example
-usage in 'volatile.py'.
+The 'volatile' module defines a versatile caching decorator that gives you total control of how the cache key is calculated and where it is stored.
+This decorator is explained in more in depth with example usage in 'volatile.py'.
 
-'volatile' caches can be stored in different places. A common use is
-a zope RAMCache. There are convenience methods in the 'ram' module
-to support that.
+'volatile' caches can be stored in different places.
+A common use is a zope RAMCache.
+There are convenience methods in the 'ram' module to support that.
 
-A quick example of a view that uses 'volatile' caching through the 'ram'
-module::
+A quick example of a view that uses 'volatile' caching through the 'ram' module::
 
     >>> from zope.publisher.browser import BrowserView
     >>> from plone.memoize import ram
@@ -40,13 +35,10 @@ module::
     ...        view = obj.restrictedTraverse('@@obj-view')
     ...        return view.render()
 
-The results of our hypothetical 'render_details' method are cached
-*across requests* and independently of the (not) logged in user.  The
-cache is only refreshed when the brain's path or modification date
-change, as defined in '_render_details_cachekey'.
+The results of our hypothetical 'render_details' method are cached *across requests* and independently of the (not) logged in user.
+The cache is only refreshed when the brain's path or modification date change, as defined in '_render_details_cachekey'.
 
-This is how you could use the same decorator to cache a function's
-value for an hour::
+This is how you could use the same decorator to cache a function's value for an hour::
 
     >>> from time import time
     >>> @ram.cache(lambda *args: time() // (60 * 60))
@@ -56,12 +48,11 @@ value for an hour::
     'Something that takes awfully long'
 
 
-view and instance
-=================
+View and Instance
+-----------------
 
-See view.rst and instance.rst for usage of cache decorators that have
-a fixed cache key and cache storage.  The most common usage pattern of
-these view and instance caching decorators is::
+See view.rst and instance.rst for usage of cache decorators that have a fixed cache key and cache storage.
+The most common usage pattern of these view and instance caching decorators is::
 
     >>> from plone.memoize import instance
     >>> class MyClass(object):
@@ -69,10 +60,9 @@ these view and instance caching decorators is::
     ...   def some_expensive_function(self, arg1, arg2):
     ...       return "Some expensive result"
 
-The first time some_expensive_function() is called, the return value will
-be saved. On subsequent calls with the same arguments, the cached version
-will be returned. Passing in different arguments will cause the function to
-be called again.
+The first time some_expensive_function() is called, the return value will be saved.
+On subsequent calls with the same arguments, the cached version will be returned.
+Passing in different arguments will cause the function to be called again.
 
 Note that this only works if the arguments are hashable!
 
@@ -84,38 +74,31 @@ If you are writing a Zope 3 view, you can do::
     ...   def some_expensive_function(self, arg1, arg2):
     ...       return "Some expensive result"
 
-This has the same effect, but subsequent lookup of the same view in the
-same context will be memoized as well.
+This has the same effect, but subsequent lookup of the same view in the same context will be memoized as well.
 
-You can also use @view.memoize_contextless to have the memoization not
-take the context into account - the same view looked up during the same
-request (but possibly on another context) with the same parameters will
-be memoized.
+You can also use @view.memoize_contextless to have the memoization not take the context into account - the same view looked up during the same request (but possibly on another context) with the same parameters will be memoized.
 
 Note that this requires that the request is annotatable using zope.annotation!
 
 
-generic
-=======
+Generic
+-------
 
-The generic decorator uses the GenericCache module as storage. By default
-it'll store into a global cache of its own, with default parameters of 1000
-maximal objects and 1 hour maximal lifespan.
+The generic decorator uses the GenericCache module as storage.
+By default it'll store into a global cache of its own, with default parameters of 1000 maximal objects and 1 hour maximal lifespan.
 
-You can create your own storage area with its specific parameters using
-the new_storage method.
+You can create your own storage area with its specific parameters using the new_storage method.
 
 Look at the docstring for a few examples.
 
 
-keys and parameters marshaling
-==============================
+Keys and Parameters Marshaling
+------------------------------
 
-An important issue about caches is how to generate the cache key. In all
-the decorators above, you can create your own function.
+An important issue about caches is how to generate the cache key.
+In all the decorators above, you can create your own function.
 
 The marshallers module provide with useful default marshallers.
-args_marshaller will compute a key from function name, module and
-parameters, applying a hash if asked for. Look into the docstring
-for usage example.
+args_marshaller will compute a key from function name, module and parameters, applying a hash if asked for.
+Look into the docstring for usage example.
 
diff --git a/plone/memoize/compress.py b/plone/memoize/compress.py
index 2b7f00f..569bd3a 100644
--- a/plone/memoize/compress.py
+++ b/plone/memoize/compress.py
@@ -1,38 +1,5 @@
 # -*- coding: utf-8 -*-
-"""In order to use Peter Bengtsson's slimmer library available from
-http://www.issuetrackerproduct.com/Download#slimmer
-you need to register the XHTMLSlimmer utility like this:
-
-  <utility component="plone.memoize.compress.xhtmlslimmer"
-           provides="plone.memoize.interfaces.IXHTMLCompressor" />
-
-You can register other XHTML-whitespace removal libraries as well.
-
-Per default there is no compressor available and we get the same string back:
-
-   >>> html_string = u"<html><body><SPAN>Hello.</SPAN></body><html>"
-   >>> xhtml_compress(html_string) is html_string
-   True
-
-Make a stupid lowercasing compressor. This is not safe as it would lowercase
-all text outside of tags as well:
-
-   >>> class LowerCaser(object):
-   ...     implements(IXHTMLCompressor)
-   ...
-   ...     def compress(self, string):
-   ...         return string.lower()
-
-   >>> lower = LowerCaser()
-
-Register our new compressor:
-
-   >>> from zope.component import getSiteManager
-   >>> sm = getSiteManager()
-   >>> sm.registerUtility(lower)
-
-   >>> xhtml_compress(html_string)
-   u'<html><body><span>hello.</span></body><html>'
+"""XHTML Compressor
 """
 
 from plone.memoize.interfaces import IXHTMLCompressor
diff --git a/plone/memoize/compress.rst b/plone/memoize/compress.rst
new file mode 100644
index 0000000..017a527
--- /dev/null
+++ b/plone/memoize/compress.rst
@@ -0,0 +1,44 @@
+XHTML Compressor
+================
+
+In order to use Peter Bengtsson's slimmer library available from http://www.issuetrackerproduct.com/Download#slimmer you need to register the XHTMLSlimmer utility like this::
+
+  <utility component="plone.memoize.compress.xhtmlslimmer"
+           provides="plone.memoize.interfaces.IXHTMLCompressor" />
+
+Make necessary imports::
+
+    >>> from plone.memoize.compress import xhtml_compress
+    >>> from plone.memoize.interfaces import IXHTMLCompressor
+    >>> from zope.interface import implements
+
+
+
+You can register other XHTML-whitespace removal libraries as well.
+
+Per default there is no compressor available and we get the same string back::
+
+    >>> html_string = u"<html><body><SPAN>Hello.</SPAN></body><html>"
+    >>> xhtml_compress(html_string) is html_string
+    True
+
+Make a stupid lowercasing compressor.
+This is not safe as it would lowercase all text outside of tags as well::
+
+    >>> class LowerCaser(object):
+    ...     implements(IXHTMLCompressor)
+    ...
+    ...     def compress(self, string):
+    ...         return string.lower()
+
+    >>> lower = LowerCaser()
+
+Register our new compressor::
+
+    >>> from zope.component import getSiteManager
+    >>> sm = getSiteManager()
+    >>> sm.registerUtility(lower)
+
+    >>> xhtml_compress(html_string)
+    u'<html><body><span>hello.</span></body><html>'
+
diff --git a/plone/memoize/forever.rst b/plone/memoize/forever.rst
index 204099d..0362399 100644
--- a/plone/memoize/forever.rst
+++ b/plone/memoize/forever.rst
@@ -1,9 +1,14 @@
-===================
- forever decorators
-===================
+Forever Decorators
+==================
 
-These remember a value "forever", i.e. until the process is restarted. They
-work on both global functions and class functions.
+Memo decorators for globals - memoized values survive for as long as the process lives.
+
+Stores values in a module-level variable.
+
+Pay attention that is module is not thread-safe, so use it with care.
+
+These remember a value "forever", i.e. until the process is restarted.
+They work on both global functions and class functions.::
 
     >>> from plone.memoize import forever
 
@@ -12,8 +17,7 @@ work on both global functions and class functions.
     ...     print "Calculating"
     ...     return arg1 + arg2
 
-No matter how many times we call this function with a particular set of
-arguments, it will only perform its calculation once.
+No matter how many times we call this function with a particular set of arguments, it will only perform its calculation once::
 
     >>> remember(1, 1)
     Calculating
@@ -26,7 +30,7 @@ arguments, it will only perform its calculation once.
     >>> remember(1, 2)
     3
 
-This also works for methods in classes.
+This also works for methods in classes::
 
     >>> class Test(object):
     ...
@@ -46,3 +50,4 @@ This also works for methods in classes.
     3
     >>> t.remember(1, 2)
     3
+
diff --git a/plone/memoize/instance.py b/plone/memoize/instance.py
index 7310bb9..585d9ac 100644
--- a/plone/memoize/instance.py
+++ b/plone/memoize/instance.py
@@ -3,7 +3,7 @@
 
 Stores values in an attribute on the instance. See instance.rst.
 
-This package current subsumes memojito
+This package current subsumes memojito.
 """
 
 _marker = object()
diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index 5c4ed6c..bb35599 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -1,11 +1,14 @@
-====================
- instance decorators
-====================
+Instance Decorators
+===================
 
-Originally from Whit Morriss' memojito package, they are used to
-memoize return values for methods on an instance. The memoized values
-are stored on an attribute on the instance and disappear when the
-instance is destroyed or a cleanup is called.
+Memo decorators for instances.
+
+Originally from Whit Morriss' memojito package, they are used to memoize return values for methods on an instance.
+The memoized values are stored on an attribute on the instance and disappear when the instance is destroyed or a cleanup is called.
+
+.. warning::
+    The ``instance`` caching decorator writes to ZODB when filling the cache.
+    This can lead to database conflict errors caused by write on read.
 
 Let's try it out w/ a dummy class::
 
@@ -51,16 +54,14 @@ Even though we've twiddled txt1, txt2 is not recalculated::
     >>> msg.txt2
     'hello world'
 
-The memo is stored by a key made of the method's name, args,
-and a frozenset of any kwargs. If those are expected to be big,
-you should compute your own hash of it::
+The memo is stored by a key made of the method's name, args, and a frozenset of any kwargs.
+If those are expected to be big, you should compute your own hash of it::
 
     >>> key = ('txt2', (msg,), frozenset([]))
     >>> msg._memojito_[key]
     'hello world'
 
-The clear after decorator will clear the memos after
-returning the methods value::
+The clear after decorator will clear the memos after returning the methods value::
 
     >>> msg.clearafter()
     'hello world'
@@ -79,14 +80,12 @@ The message is still the same of course::
     >>> msg.txt2
     'nice to visit this world'
 
-Now we can test the clear before, which does the opposite from the
-clear after, allowing new values to be calculated::
+Now we can test the clear before, which does the opposite from the clear after, allowing new values to be calculated::
 
     >>> msg.clearbefore()
     'goodbye cruel world'
 
-memojito supports memoization of multiple signatures as long as all
-signature values are hashable::
+memojito supports memoization of multiple signatures as long as all signature values are hashable::
 
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
@@ -103,8 +102,7 @@ We can alter data underneath, but nothing changes::
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
-If we alter the signature, our msg is recalculated, but since mst.txt2
-is a memo, only the values passed in change::
+If we alter the signature, our msg is recalculated, but since mst.txt2 is a memo, only the values passed in change::
 
     >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
     >>> print msg.getMsg('Bill F.', **ins)
@@ -138,15 +136,14 @@ Our message to faulkner now is semantically correct::
     >>> print msg.getMsg('Bill F.', **ins)
     Bill F.: sound and fury world#! tale--told by idiot signify--nothing
 
-Let's make sure that memoized properties which call OTHER memoized
-properties do the right thing::
+Let's make sure that memoized properties which call OTHER memoized properties do the right thing::
 
     >>> msg = MyMsg('hello')
     >>> print msg.recurse
     recursive: hello world
 
-Now we make sure that both the txt2 and the recurse values are in the
-cache::
+Now we make sure that both the txt2 and the recurse values are in the cache::
 
     >>> print len(msg._memojito_.keys())
     2
+
diff --git a/plone/memoize/ram.py b/plone/memoize/ram.py
index c5f1a76..d07825d 100644
--- a/plone/memoize/ram.py
+++ b/plone/memoize/ram.py
@@ -1,98 +1,5 @@
 # -*- coding: utf-8 -*-
 """A cache decorator that uses RAMCache by default.
-
-See README.rst and the `volatile` module for more details.
-
-  >>> def cache_key(fun, first, second):
-  ...     return (first, second)
-  >>> @cache(cache_key)
-  ... def pow(first, second):
-  ...     print 'Someone or something called me'
-  ...     return first ** second
-
-  >>> pow(3, 2)
-  Someone or something called me
-  9
-  >>> pow(3, 2)
-  9
-
-Let's cache another function:
-
-  >>> @cache(cache_key)
-  ... def add(first, second):
-  ...     print 'Someone or something called me'
-  ...     return first + second
-
-  >>> add(3, 2)
-  Someone or something called me
-  5
-  >>> add(3, 2)
-  5
-
-Now invalidate the cache for the `pow` function:
-
-  >>> pow(3, 2)
-  9
-  >>> global_cache.invalidate('plone.memoize.ram.pow')
-  >>> pow(3, 2)
-  Someone or something called me
-  9
-
-Make sure that we only invalidated the cache for the `pow` function:
-
-  >>> add(3, 2)
-  5
-
-  >>> global_cache.invalidateAll()
-
-You can register an ICacheChooser utility to override the cache used
-based on the function that is cached.  To do this, we'll first
-unregister the already registered global `choose_cache` function:
-
-  >>> sm = component.getGlobalSiteManager()
-  >>> sm.unregisterUtility(choose_cache)
-  True
-
-This customized cache chooser will use the `my_cache` for the `pow`
-function, and use the `global_cache` for all other functions:
-
-  >>> my_cache = ram.RAMCache()
-  >>> def my_choose_cache(fun_name):
-  ...     if fun_name.endswith('.pow'):
-  ...         return RAMCacheAdapter(my_cache)
-  ...     else:
-  ...         return RAMCacheAdapter(global_cache)
-  >>> interface.directlyProvides(my_choose_cache, ICacheChooser)
-  >>> sm.registerUtility(my_choose_cache)
-
-Both caches are empty at this point:
-
-  >>> len(global_cache.getStatistics())
-  0
-  >>> len(my_cache.getStatistics())
-  0
-
-Let's fill them:
-
-  >>> pow(3, 2)
-  Someone or something called me
-  9
-  >>> pow(3, 2)
-  9
-  >>> len(global_cache.getStatistics())
-  0
-  >>> len(my_cache.getStatistics())
-  1
-
-  >>> add(3, 2)
-  Someone or something called me
-  5
-  >>> add(3, 2)
-  5
-  >>> len(global_cache.getStatistics())
-  1
-  >>> len(my_cache.getStatistics())
-  1
 """
 
 from plone.memoize import volatile
diff --git a/plone/memoize/ram.rst b/plone/memoize/ram.rst
new file mode 100644
index 0000000..674fdeb
--- /dev/null
+++ b/plone/memoize/ram.rst
@@ -0,0 +1,109 @@
+RAM Decorators
+==============
+
+A cache decorator that uses RAMCache by default.
+
+Make necessary imports::
+
+    >>> from plone.memoize.interfaces import ICacheChooser
+    >>> from plone.memoize.ram import cache
+    >>> from plone.memoize.ram import choose_cache
+    >>> from plone.memoize.ram import global_cache
+    >>> from plone.memoize.ram import RAMCacheAdapter
+    >>> from zope import component
+    >>> from zope import interface
+    >>> from zope.ramcache import ram
+
+::
+
+    >>> def cache_key(fun, first, second):
+    ...     return (first, second)
+    >>> @cache(cache_key)
+    ... def pow(first, second):
+    ...     print 'Someone or something called me'
+    ...     return first ** second
+
+    >>> pow(3, 2)
+    Someone or something called me
+    9
+    >>> pow(3, 2)
+    9
+
+Let's cache another function::
+
+    >>> @cache(cache_key)
+    ... def add(first, second):
+    ...     print 'Someone or something called me'
+    ...     return first + second
+
+    >>> add(3, 2)
+    Someone or something called me
+    5
+    >>> add(3, 2)
+    5
+
+Now invalidate the cache for the `pow` function::
+
+    >>> pow(3, 2)
+    9
+    >>> global_cache.invalidate('None.pow')
+    >>> pow(3, 2)
+    Someone or something called me
+    9
+
+Make sure that we only invalidated the cache for the `pow` function::
+
+    >>> add(3, 2)
+    5
+
+    >>> global_cache.invalidateAll()
+
+You can register an ICacheChooser utility to override the cache used based on the function that is cached.
+To do this, we'll first unregister the already registered global `choose_cache` function::
+
+    >>> sm = component.getGlobalSiteManager()
+    >>> sm.unregisterUtility(choose_cache)
+    True
+
+This customized cache chooser will use the `my_cache` for the `pow` function, and use the `global_cache` for all other functions::
+
+    >>> my_cache = ram.RAMCache()
+    >>> def my_choose_cache(fun_name):
+    ...     if fun_name.endswith('.pow'):
+    ...         return RAMCacheAdapter(my_cache)
+    ...     else:
+    ...         return RAMCacheAdapter(global_cache)
+    >>> interface.directlyProvides(my_choose_cache, ICacheChooser)
+    >>> sm.registerUtility(my_choose_cache)
+
+Both caches are empty at this point::
+
+    >>> len(global_cache.getStatistics())
+    0
+    >>> len(my_cache.getStatistics())
+    0
+
+Let's fill them::
+
+    >>> pow(3, 2)
+    Someone or something called me
+    9
+    >>> pow(3, 2)
+    9
+    >>> len(global_cache.getStatistics())
+    0
+    >>> len(my_cache.getStatistics())
+    1
+
+::
+
+    >>> add(3, 2)
+    Someone or something called me
+    5
+    >>> add(3, 2)
+    5
+    >>> len(global_cache.getStatistics())
+    1
+    >>> len(my_cache.getStatistics())
+    1
+
diff --git a/plone/memoize/request.py b/plone/memoize/request.py
index b910325..e987ade 100644
--- a/plone/memoize/request.py
+++ b/plone/memoize/request.py
@@ -72,109 +72,6 @@ def _store_in_annotation(fun, *args, **kwargs):
 
 
 def cache(get_key, get_request='request'):
-    r"""
-    This is a hypothetical function `increment` that'll store the
-    cache value on `a.request`, where a is the only argument to the
-    function:
-
-      >>> def increment(a):
-      ...     print 'Someone or something called me'
-      ...     return a + 1
-
-    Now we need to define this `a`.  For this, we'll inherit from
-    `int` and add a `request` class variable.  Note that we also make
-    our fake request `IAttributeAnnotatable`, because that's how the
-    cache values are stored on the request:
-
-      >>> from zope.publisher.browser import TestRequest
-      >>> class A(int):
-      ...     request = TestRequest()
-      >>> from zope.interface import directlyProvides
-      >>> from zope.annotation.interfaces import IAttributeAnnotatable
-      >>> directlyProvides(A.request, IAttributeAnnotatable)
-
-    In addition to this request, we'll also need to set up a cache key
-    generator.  We'll use the integer value of the only argument for
-    that:
-
-      >>> get_key = lambda fun, a, *args: a
-
-    Let's decorate our `increment` function now with the `cache`
-    decorator.  We'll tell the decorator to use `args_hash` for
-    generating the key. `get_request` will tell the decorator how to
-    actually find the `request` in the variable scope of the function
-    itself:
-
-      >>> cached_increment = \
-      ...     cache(get_key=get_key, get_request='a.request')(increment)
-
-      >>> cached_increment(A(1))
-      Someone or something called me
-      2
-      >>> cached_increment(A(1))
-      2
-      >>> IAnnotations(A.request)
-      {'plone.memoize.request.increment:1': 2}
-
-    If `request` is already part of the function's argument list, we
-    don't need to specify any expression:
-
-      >>> @cache(get_key=get_key)
-      ... def increment_plus(a, request):
-      ...     print 'Someone or something called me'
-      ...     return a + 1
-
-      >>> increment_plus(42, A.request)
-      Someone or something called me
-      43
-      >>> increment_plus(42, A.request)
-      43
-      >>> IAnnotations(A.request)['plone.memoize.request.increment_plus:42']
-      43
-
-    Create a function that can also take keyword arguments. For the sake of
-    convenience pass the request explicitly. get_key must be modified to take
-    kwargs into account:
-
-      >>> def get_key(fun, a, request, **kwargs):
-      ...     li = kwargs.items()
-      ...     li.sort()
-      ...     return "%s,%s" % (a, li)
-
-      >>> @cache(get_key=get_key)
-      ... def increment_kwargs(a, request, kwarg1=1, kwarg2=2):
-      ...     print 'Someone or something called me'
-      ...     return a + 1
-
-      >>> increment_kwargs(42, A.request, kwarg1='kwarg1', kwarg2='kwarg2')
-      Someone or something called me
-      43
-      >>> increment_kwargs(42, A.request, kwarg1='kwarg1', kwarg2='kwarg2')
-      43
-      >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[('kwarg1', 'kwarg1'), ('kwarg2', 'kwarg2')]"]
-      43
-
-    Call increment_kwargs without specifying any keyword arguments:
-
-      >>> increment_kwargs(42, A.request)
-      Someone or something called me
-      43
-      >>> increment_kwargs(42, A.request)
-      43
-      >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[]"]
-      43
-
-    Call increment_kwargs and specify only the second keyword argument:
-
-      >>> increment_kwargs(42, A.request, kwarg2='kwarg2')
-      Someone or something called me
-      43
-      >>> increment_kwargs(42, A.request, kwarg2='kwarg2')
-      43
-      >>> IAnnotations(A.request)["plone.memoize.request.increment_kwargs:42,[('kwarg2', 'kwarg2')]"]
-      43
-
-    """
 
     return volatile.cache(get_key,
                           get_cache=store_in_annotation_of(get_request))
diff --git a/plone/memoize/request.rst b/plone/memoize/request.rst
new file mode 100644
index 0000000..7bca946
--- /dev/null
+++ b/plone/memoize/request.rst
@@ -0,0 +1,104 @@
+Request Decorators
+==================
+
+This is a hypothetical function `increment` that'll store the cache value on `a.request`, where a is the only argument to the function:
+
+Make necessary imports::
+
+    >>> from plone.memoize.request import cache
+    >>> from zope.annotation.interfaces import IAnnotations
+
+::
+
+    >>> def increment(a):
+    ...     print 'Someone or something called me'
+    ...     return a + 1
+
+Now we need to define this `a`.
+For this, we'll inherit from `int` and add a `request` class variable.
+Note that we also make our fake request `IAttributeAnnotatable`, because that's how the cache values are stored on the request::
+
+    >>> from zope.publisher.browser import TestRequest
+    >>> class A(int):
+    ...     request = TestRequest()
+    >>> from zope.interface import directlyProvides
+    >>> from zope.annotation.interfaces import IAttributeAnnotatable
+    >>> directlyProvides(A.request, IAttributeAnnotatable)
+
+In addition to this request, we'll also need to set up a cache key generator.
+We'll use the integer value of the only argument for that::
+
+    >>> get_key = lambda fun, a, *args: a
+
+Let's decorate our `increment` function now with the `cache` decorator.
+We'll tell the decorator to use `args_hash` for generating the key.
+`get_request` will tell the decorator how to actually find the `request` in the variable scope of the function itself::
+
+    >>> cached_increment = \
+    ...     cache(get_key=get_key, get_request='a.request')(increment)
+
+    >>> cached_increment(A(1))
+    Someone or something called me
+    2
+    >>> cached_increment(A(1))
+    2
+    >>> IAnnotations(A.request)
+    {'None.increment:1': 2}
+
+If `request` is already part of the function's argument list, we don't need to specify any expression::
+
+    >>> @cache(get_key=get_key)
+    ... def increment_plus(a, request):
+    ...     print 'Someone or something called me'
+    ...     return a + 1
+
+    >>> increment_plus(42, A.request)
+    Someone or something called me
+    43
+    >>> increment_plus(42, A.request)
+    43
+    >>> IAnnotations(A.request)['None.increment_plus:42']
+    43
+
+Create a function that can also take keyword arguments.
+For the sake of convenience pass the request explicitly.
+get_key must be modified to take kwargs into account::
+
+    >>> def get_key(fun, a, request, **kwargs):
+    ...     li = kwargs.items()
+    ...     li.sort()
+    ...     return "%s,%s" % (a, li)
+
+    >>> @cache(get_key=get_key)
+    ... def increment_kwargs(a, request, kwarg1=1, kwarg2=2):
+    ...     print 'Someone or something called me'
+    ...     return a + 1
+
+    >>> increment_kwargs(42, A.request, kwarg1='kwarg1', kwarg2='kwarg2')
+    Someone or something called me
+    43
+    >>> increment_kwargs(42, A.request, kwarg1='kwarg1', kwarg2='kwarg2')
+    43
+    >>> IAnnotations(A.request)["None.increment_kwargs:42,[('kwarg1', 'kwarg1'), ('kwarg2', 'kwarg2')]"]
+    43
+
+Call increment_kwargs without specifying any keyword arguments::
+
+    >>> increment_kwargs(42, A.request)
+    Someone or something called me
+    43
+    >>> increment_kwargs(42, A.request)
+    43
+    >>> IAnnotations(A.request)["None.increment_kwargs:42,[]"]
+    43
+
+Call increment_kwargs and specify only the second keyword argument::
+
+    >>> increment_kwargs(42, A.request, kwarg2='kwarg2')
+    Someone or something called me
+    43
+    >>> increment_kwargs(42, A.request, kwarg2='kwarg2')
+    43
+    >>> IAnnotations(A.request)["None.increment_kwargs:42,[('kwarg2', 'kwarg2')]"]
+    43
+
diff --git a/plone/memoize/tests.py b/plone/memoize/tests.py
index 629392b..1b74221 100644
--- a/plone/memoize/tests.py
+++ b/plone/memoize/tests.py
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
-from zope.component.testing import setUp, tearDown
+from zope.component.testing import setUp
+from zope.component.testing import tearDown
 from zope.configuration.xmlconfig import XMLConfig
 from zope.testing import doctest
 import unittest
@@ -17,7 +18,18 @@ def configurationSetUp(test):
 
 def test_suite():
     tests = (
-        doctest.DocTestSuite('plone.memoize.compress',
+        doctest.DocFileSuite('README.rst',
+                             package="plone.memoize",
+                             setUp=configurationSetUp,
+                             tearDown=tearDown,
+                             optionflags=optionflags),
+        doctest.DocFileSuite('compress.rst',
+                             package="plone.memoize",
+                             setUp=configurationSetUp,
+                             tearDown=tearDown,
+                             optionflags=optionflags),
+        doctest.DocFileSuite('forever.rst',
+                             package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
@@ -26,23 +38,23 @@ def test_suite():
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocFileSuite('view.rst',
+        doctest.DocFileSuite('ram.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocFileSuite('forever.rst',
+        doctest.DocFileSuite('request.rst',
                              package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocFileSuite('README.rst'),
-        doctest.DocTestSuite('plone.memoize.request',
+        doctest.DocFileSuite('view.rst',
+                             package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
-        doctest.DocTestSuite('plone.memoize.volatile'),
-        doctest.DocTestSuite('plone.memoize.ram',
+        doctest.DocFileSuite('volatile.rst',
+                             package="plone.memoize",
                              setUp=configurationSetUp,
                              tearDown=tearDown,
                              optionflags=optionflags),
diff --git a/plone/memoize/view.rst b/plone/memoize/view.rst
index 499dcd3..827e214 100644
--- a/plone/memoize/view.rst
+++ b/plone/memoize/view.rst
@@ -1,11 +1,11 @@
-=====================
- view memo decorators
-=====================
+View Decorators
+===============
 
-Decorators for methods/properties in views. Values are cached by annotating
-the view's request, and keyed based on the context and any arguments to the
-function. This means that the same view can be looked up multiple times and
-the same memos will be returned::
+Memoize decorator for views.
+
+Decorators for methods/properties in views.
+Values are cached by annotating the view's request, and keyed based on the context and any arguments to the function.
+This means that the same view can be looked up multiple times and the same memos will be returned::
 
     >>> from plone.memoize import view
     >>> from zope.component import adapts
@@ -68,8 +68,7 @@ We need request to be annotatable::
     >>> from zope.component import getMultiAdapter
     >>> msg = getMultiAdapter((context, request), name=u'msg_view')
 
-Now, if we access the memoized property txt2, we will get the value in
-txt1::
+Now, if we access the memoized property txt2, we will get the value in txt1::
 
     >>> msg.txt2
     'hello world'
@@ -81,8 +80,7 @@ Even though we've twiddled txt1, txt2 is not recalculated::
     >>> msg.txt2
     'hello world'
 
-We support memoization of multiple signatures as long as all
-signature values are hashable::
+We support memoization of multiple signatures as long as all signature values are hashable::
 
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
@@ -117,8 +115,7 @@ If change the bang, the memo remains the same::
     >>> print msg.getMsg('Ernest')
     Ernest: goodbye cruel world!
 
-If we look up the view again on the same object, we will get the same
-memoized properties as before::
+If we look up the view again on the same object, we will get the same memoized properties as before::
 
     >>> msg2 = getMultiAdapter((context, request), name=u'msg_view')
 
@@ -173,3 +170,4 @@ based on parameters, but not on context::
 
     >>> print msg2.getAnotherMsg('J.D.', **{'raise':'roofbeams'})
     J.D.: so long, cruel world& raise--roofbeams
+
diff --git a/plone/memoize/volatile.py b/plone/memoize/volatile.py
index 641c8b9..30d9dcc 100644
--- a/plone/memoize/volatile.py
+++ b/plone/memoize/volatile.py
@@ -2,229 +2,15 @@
 """A flexible caching decorator.
 
 This module provides a cache decorator `cache` that you can use to
-cache results of your functions or methods.  Let's say we have a class
-with an expensive method `pow` that we want to cache:
-
-  >>> class MyClass:
-  ...     def pow(self, first, second):
-  ...         print 'Someone or something called me'
-  ...         return first ** second
-
-Okay, we know that if the `first` and `second` arguments are the same,
-the result is going to be the same, always.  We'll use a cache key
-calculator to tell the `cache` decorator about this assertion.  What's
-this cache key calculator?  It's a function that takes the original
-function plus the same arguments as the original function that we're
-caching:
-
-  >>> def cache_key(method, self, first, second):
-  ...     return (first, second)
-
-For performances and security reasons, no hash is done on the key in
-this example. You may consider using a cryptographic hash (MD5 or even
-better SHA1) if your parameters can hold big amount of data.
-
-The cache decorator is really simple to use.  Let's define our first
-class again, this time with a cached `pow` method:
-
-  >>> class MyClass:
-  ...     @cache(cache_key)
-  ...     def pow(self, first, second):
-  ...         print 'Someone or something called me'
-  ...         return first ** second
-
-The results:
-
-  >>> obj = MyClass()
-  >>> obj.pow(3, 2)
-  Someone or something called me
-  9
-  >>> obj.pow(3, 2)
-  9
-
-Did you see that?  The method was called only once.
-
-Now to where this cache is stored: That's actually variable.  The
-cache decorator takes an optional second argument with which you can
-define the where the cache is stored to.
-
-By default, the cache stores its values on the first argument to the
-function.  For our method, this is self, which is perfectly fine.  For
-normal functions, the first argument is maybe not the best place to
-store the cache.
-
-The default cache container function stores a dictionary on the
-instance as a *volatile* attribute.  That is, it's prefixed with
-``_v_``.  In Zope, this means that the cache is not persisted.
-
-  >>> ATTR
-  '_v_memoize_cache'
-  >>> cache_container = getattr(obj, ATTR)
-
-This cache container maps our key, including the function's dotted
-name, to the return value.
-
-  >>> cache_container # doctest: +ELLIPSIS
-  {'plone.memoize.volatile.pow:...': 9}
-  >>> len(cache_container)
-  1
-  >>> k = 'plone.memoize.volatile.pow:%s' % str(cache_key(MyClass.pow, None, 3, 2))
-  >>> cache_container[k]
-  9
-
-Okay, on to storing the cache somewhere else.  The function we'll have
-to provide is really similar to the cache key function we defined
-earlier.
-
-Like the cache key function, the storage function takes the same
-amount of arguments as the original cached function.  We'll use a
-global for caching this time:
-
-  >>> my_cache = {}
-  >>> def cache_storage(fun, *args, **kwargs):
-  ...     return my_cache
-
-This time, instead of caching a method, we'll cache a normal function.
-For this, we'll need to change our cache key function to take the
-correct number of arguments:
-
-  >>> def cache_key(fun, first, second):
-  ...     return (first, second)
-
-Note how we provide both the cache key generator and the cache storage
-as arguments to the `cache` decorator:
-
-  >>> @cache(cache_key, cache_storage)
-  ... def pow(first, second):
-  ...     print 'Someone or something called me'
-  ...     return first ** second
-
-Let's try it out:
-
-  >>> pow(3, 2)
-  Someone or something called me
-  9
-  >>> pow(3, 2)
-  9
-  >>> pow(3, 2)
-  9
-  >>> pow(3, 3)
-  Someone or something called me
-  27
-  >>> pow(3, 3)
-  27
-  >>> my_cache.clear()
-
-It works!
-
-A cache key generator may also raise DontCache to indicate that no
-caching should be applied:
-
-  >>> def cache_key(fun, first, second):
-  ...     if first == second:
-  ...         raise DontCache
-  ...     else:
-  ...         return (first, second)
-  >>> @cache(cache_key, cache_storage)
-  ... def pow(first, second):
-  ...     print 'Someone or something called me'
-  ...     return first ** second
-
-  >>> pow(3, 2)
-  Someone or something called me
-  9
-  >>> pow(3, 2)
-  9
-  >>> pow(3, 3)
-  Someone or something called me
-  27
-  >>> pow(3, 3)
-  Someone or something called me
-  27
-
-Caveats
--------
-
-Be careful when you have multiple methods with the same name in a
-single module:
-
-  >>> def cache_key(fun, instance, *args):
-  ...     return args
-  >>> cache_container = {}
-  >>> class A:
-  ...     @cache(cache_key, lambda *args: cache_container)
-  ...     def somemet(self, one, two):
-  ...         return one + two
-  >>> class B:
-  ...     @cache(cache_key, lambda *args: cache_container)
-  ...     def somemet(self, one, two):
-  ...         return one - two
-  >>> a = A()
-  >>> a.somemet(1, 2)
-  3
-  >>> cache_container
-  {'plone.memoize.volatile.somemet:(1, 2)': 3}
-
-The following call should really return -1, but since the default
-cache key isn't clever enough to include the function's name, it'll
-return 3:
-
-  >>> B().somemet(1, 2)
-  3
-  >>> len(cache_container)
-  1
-  >>> cache_container.clear()
-
-Ouch!  The fix for this is to e.g. include your class' name in the key
-when you create it:
-
-  >>> def cache_key(fun, instance, *args):
-  ...     return (instance.__class__,) + args
-  >>> class A:
-  ...     @cache(cache_key, lambda *args: cache_container)
-  ...     def somemet(self, one, two):
-  ...         return one + two
-  >>> class B:
-  ...     @cache(cache_key, lambda *args: cache_container)
-  ...     def somemet(self, one, two):
-  ...         return one - two
-  >>> a = A()
-  >>> a.somemet(1, 2)
-  3
-  >>> B().somemet(1, 2)
-  -1
-  >>> len(cache_container)
-  2
+cache results of your functions or methods.
 """
 
 import time
 
 
 class CleanupDict(dict):
-
     """A dict that automatically cleans up items that haven't been
     accessed in a given timespan on *set*.
-
-    This implementation is a bit naive, since it's not associated with
-    any policy that the user can configure, and it doesn't provide
-    statistics like RAMCache, but at least it helps make sure our
-    volatile attribute doesn't grow stale entries indefinitely.
-
-      >>> d = CleanupDict()
-      >>> d['spam'] = 'bar'
-      >>> d['spam']
-      'bar'
-
-   Setting the cleanup period to 0 (or a negative number) means the
-   values are thrown away immediately.  (Note that we do not test with
-   exactly zero, as running the tests can go too fast.)
-
-      >>> d = CleanupDict(-0.00001)
-      >>> d['spam'] = 'bar'
-      >>> d['spam'] # doctest: +ELLIPSIS
-      Traceback (most recent call last):
-      ...
-      KeyError: 'spam'
     """
     cleanup_period = 60 * 60 * 24 * 3  # 3 days
 
diff --git a/plone/memoize/volatile.rst b/plone/memoize/volatile.rst
new file mode 100644
index 0000000..844906f
--- /dev/null
+++ b/plone/memoize/volatile.rst
@@ -0,0 +1,219 @@
+Volatile Decorators
+===================
+
+A flexible caching decorator.
+
+Make necessary imports::
+
+    >>> from plone.memoize.volatile import ATTR
+    >>> from plone.memoize.volatile import cache
+    >>> from plone.memoize.volatile import DontCache
+    >>> from plone.memoize.volatile import CleanupDict
+
+This module provides a cache decorator `cache` that you can use to cache results of your functions or methods.
+Let's say we have a class with an expensive method `pow` that we want to cache::
+
+    >>> class MyClass:
+    ...     def pow(self, first, second):
+    ...         print 'Someone or something called me'
+    ...         return first ** second
+
+Okay, we know that if the `first` and `second` arguments are the same, the result is going to be the same, always.
+We'll use a cache key calculator to tell the `cache` decorator about this assertion.
+What's this cache key calculator?
+It's a function that takes the original function plus the same arguments as the original function that we're caching::
+
+    >>> def cache_key(method, self, first, second):
+    ...     return (first, second)
+
+For performances and security reasons, no hash is done on the key in this example.
+You may consider using a cryptographic hash (MD5 or even better SHA1) if your parameters can hold big amount of data.
+
+The cache decorator is really simple to use.
+Let's define our first class again, this time with a cached `pow` method::
+
+    >>> class MyClass:
+    ...     @cache(cache_key)
+    ...     def pow(self, first, second):
+    ...         print 'Someone or something called me'
+    ...         return first ** second
+
+The results::
+
+    >>> obj = MyClass()
+    >>> obj.pow(3, 2)
+    Someone or something called me
+    9
+    >>> obj.pow(3, 2)
+    9
+
+Did you see that?  The method was called only once.
+
+Now to where this cache is stored: That's actually variable.
+The cache decorator takes an optional second argument with which you can define the where the cache is stored to.
+
+By default, the cache stores its values on the first argument to the function.
+For our method, this is self, which is perfectly fine.
+For normal functions, the first argument is maybe not the best place to store the cache.
+
+The default cache container function stores a dictionary on the instance as a *volatile* attribute.
+That is, it's prefixed with ``_v_``.
+In Zope, this means that the cache is not persisted::
+
+    >>> ATTR
+    '_v_memoize_cache'
+    >>> cache_container = getattr(obj, ATTR)
+
+This cache container maps our key, including the function's dotted name, to the return value::
+
+    >>> cache_container # doctest: +ELLIPSIS
+    {'None.pow:...': 9}
+    >>> len(cache_container)
+    1
+    >>> k = 'None.pow:%s' % str(cache_key(MyClass.pow, None, 3, 2))
+    >>> cache_container[k]
+    9
+
+Okay, on to storing the cache somewhere else.
+The function we'll have to provide is really similar to the cache key function we defined earlier.
+
+Like the cache key function, the storage function takes the same amount of arguments as the original cached function.
+We'll use a global for caching this time::
+
+    >>> my_cache = {}
+    >>> def cache_storage(fun, *args, **kwargs):
+    ...     return my_cache
+
+This time, instead of caching a method, we'll cache a normal function.
+For this, we'll need to change our cache key function to take the correct number of arguments::
+
+    >>> def cache_key(fun, first, second):
+    ...     return (first, second)
+
+Note how we provide both the cache key generator and the cache storage as arguments to the `cache` decorator::
+
+    >>> @cache(cache_key, cache_storage)
+    ... def pow(first, second):
+    ...     print 'Someone or something called me'
+    ...     return first ** second
+
+Let's try it out::
+
+    >>> pow(3, 2)
+    Someone or something called me
+    9
+    >>> pow(3, 2)
+    9
+    >>> pow(3, 2)
+    9
+    >>> pow(3, 3)
+    Someone or something called me
+    27
+    >>> pow(3, 3)
+    27
+    >>> my_cache.clear()
+
+It works!
+
+A cache key generator may also raise DontCache to indicate that no caching should be applied::
+
+    >>> def cache_key(fun, first, second):
+    ...     if first == second:
+    ...         raise DontCache
+    ...     else:
+    ...         return (first, second)
+    >>> @cache(cache_key, cache_storage)
+    ... def pow(first, second):
+    ...     print 'Someone or something called me'
+    ...     return first ** second
+
+    >>> pow(3, 2)
+    Someone or something called me
+    9
+    >>> pow(3, 2)
+    9
+    >>> pow(3, 3)
+    Someone or something called me
+    27
+    >>> pow(3, 3)
+    Someone or something called me
+    27
+
+Caveats
+-------
+
+Be careful when you have multiple methods with the same name in a single module::
+
+    >>> def cache_key(fun, instance, *args):
+    ...     return args
+    >>> cache_container = {}
+    >>> class A:
+    ...     @cache(cache_key, lambda *args: cache_container)
+    ...     def somemet(self, one, two):
+    ...         return one + two
+    >>> class B:
+    ...     @cache(cache_key, lambda *args: cache_container)
+    ...     def somemet(self, one, two):
+    ...         return one - two
+    >>> a = A()
+    >>> a.somemet(1, 2)
+    3
+    >>> cache_container
+    {'None.somemet:(1, 2)': 3}
+
+The following call should really return -1, but since the default cache key isn't clever enough to include the function's name, it'll return 3::
+
+    >>> B().somemet(1, 2)
+    3
+    >>> len(cache_container)
+    1
+    >>> cache_container.clear()
+
+Ouch!
+The fix for this is to e.g. include your class' name in the key when you create it::
+
+    >>> def cache_key(fun, instance, *args):
+    ...     return (instance.__class__,) + args
+    >>> class A:
+    ...     @cache(cache_key, lambda *args: cache_container)
+    ...     def somemet(self, one, two):
+    ...         return one + two
+    >>> class B:
+    ...     @cache(cache_key, lambda *args: cache_container)
+    ...     def somemet(self, one, two):
+    ...         return one - two
+    >>> a = A()
+    >>> a.somemet(1, 2)
+    3
+    >>> B().somemet(1, 2)
+    -1
+    >>> len(cache_container)
+    2
+
+
+Cleanup Dict
+------------
+
+CleanupDict is a dict that automatically cleans up items that haven't been accessed in a given timespan on *set*.
+
+This implementation is a bit naive, since it's not associated with any policy that the user can configure, and it doesn't provide statistics like RAMCache, but at least it helps make sure our volatile attribute doesn't grow stale entries indefinitely.
+
+::
+
+    >>> d = CleanupDict()
+    >>> d['spam'] = 'bar'
+    >>> d['spam']
+    'bar'
+
+Setting the cleanup period to 0 (or a negative number) means the values are thrown away immediately.
+(Note that we do not test with exactly zero, as running the tests can go too fast.)
+
+::
+
+    >>> d = CleanupDict(-0.00001)
+    >>> d['spam'] = 'bar'
+    >>> d['spam'] # doctest: +ELLIPSIS
+    Traceback (most recent call last):
+    ...
+    KeyError: 'spam'
+
diff --git a/setup.py b/setup.py
index bcba279..070eea0 100644
--- a/setup.py
+++ b/setup.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 import os
 from setuptools import setup, find_packages
 


