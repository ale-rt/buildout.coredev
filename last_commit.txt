Repository: Products.statusmessages


Branch: refs/heads/master
Date: 2016-01-27T19:28:47+01:00
Author: Patrick Gerken (do3cc) <patrick.gerken@zumtobelgroup.com>
Commit: https://github.com/plone/Products.statusmessages/commit/1092712d759d0f0342f9ea79bb99765c5eba2b2a

Convert ZTK tests to plone.app.testing

Files changed:
M CHANGES.txt
M Products/statusmessages/tests/test_adapter.py
M Products/statusmessages/tests/test_encoding.py

diff --git a/CHANGES.txt b/CHANGES.txt
index c68bee6..f557380 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -4,6 +4,8 @@ Changelog
 4.0.1 - unreleased
 ------------------
 
+- Convert tests to plone.app.testing.
+  [do3cc]
 
 4.0 - 2010-07-18
 ----------------
diff --git a/Products/statusmessages/tests/test_adapter.py b/Products/statusmessages/tests/test_adapter.py
index fd21966..73a829c 100644
--- a/Products/statusmessages/tests/test_adapter.py
+++ b/Products/statusmessages/tests/test_adapter.py
@@ -3,313 +3,312 @@
     StatusMessage adapter tests.
 """
 
+from plone.app.testing import PLONE_INTEGRATION_TESTING
 import unittest
 
-def test_directives():
-    """
-    Test status messages
 
-    First some boilerplate.
+class TestAdapter(unittest.TestCase):
 
-      >>> from zope.component.testing import setUp
-      >>> setUp()
+    layer = PLONE_INTEGRATION_TESTING
 
-      >>> import Products.Five
-      >>> import Products.statusmessages
+    def test_directives(self):
+        """
+        Test status messages
 
-      >>> from Products.Five import zcml
-      >>> zcml.load_config('meta.zcml', Products.Five)
-      >>> zcml.load_config('configure.zcml', Products.statusmessages)
+        First some boilerplate.
 
-    Now lets make sure we can actually adapt the request.
+          >>> from zope.component.testing import setUp
+          >>> setUp()
 
-      >>> from Products.statusmessages.interfaces import IStatusMessage
-      >>> status = IStatusMessage(self.app.REQUEST)
-      >>> IStatusMessage.providedBy(status)
-      True
+          >>> import Products.Five
+          >>> import Products.statusmessages
 
-    We also need the request to be annotatable:
+          >>> from Products.Five import zcml
+          >>> zcml.load_config('meta.zcml', Products.Five)
+          >>> zcml.load_config('configure.zcml', Products.statusmessages)
 
-      >>> from zope.interface import directlyProvides
-      >>> from zope.annotation.interfaces import IAttributeAnnotatable
-      >>> directlyProvides(self.app.REQUEST, IAttributeAnnotatable)
+        Now lets make sure we can actually adapt the request.
 
-    The dummy request we have is a bit limited, so we need a simple method
-    to fake a real request/response for the cookie handling. Basically it
-    puts all entries from response.cookies into REQUEST.cookies but shifts
-    the real values into the right place as browsers would do it.
+          >>> from Products.statusmessages.interfaces import IStatusMessage
+          >>> status = IStatusMessage(self.app.REQUEST)
+          >>> IStatusMessage.providedBy(status)
+          True
 
-      >>> def fakePublish(request):
-      ...     cookies = request.response.cookies.copy()
-      ...     new_cookies = {}
-      ...     for key in cookies.keys():
-      ...         new_cookies[key] = cookies[key]['value']
-      ...     request.cookies = new_cookies
-      ...     request.response.cookies = {}
+        We also need the request to be annotatable:
 
-      >>> request = self.app.REQUEST
-      >>> status = IStatusMessage(request)
+          >>> from zope.interface import directlyProvides
+          >>> from zope.annotation.interfaces import IAttributeAnnotatable
+          >>> directlyProvides(self.app.REQUEST, IAttributeAnnotatable)
 
-    Make sure there's no stored message.
+        The dummy request we have is a bit limited, so we need a simple method
+        to fake a real request/response for the cookie handling. Basically it
+        puts all entries from response.cookies into REQUEST.cookies but shifts
+        the real values into the right place as browsers would do it.
 
-      >>> len(status.show())
-      0
+          >>> def fakePublish(request):
+          ...     cookies = request.response.cookies.copy()
+          ...     new_cookies = {}
+          ...     for key in cookies.keys():
+          ...         new_cookies[key] = cookies[key]['value']
+          ...     request.cookies = new_cookies
+          ...     request.response.cookies = {}
 
-    Add one message
+          >>> request = self.app.REQUEST
+          >>> status = IStatusMessage(request)
 
-      >>> status.add(u'test', type=u'info')
+        Make sure there's no stored message.
 
-    Now check the results
+          >>> len(status.show())
+          0
 
-      >>> messages = status.show()
-      >>> len(messages)
-      1
+        Add one message
 
-      >>> messages[0].message
-      u'test'
+          >>> status.add(u'test', type=u'info')
 
-      >>> messages[0].type
-      u'info'
+        Now check the results
 
-    Make sure messages are removed
+          >>> messages = status.show()
+          >>> len(messages)
+          1
 
-      >>> len(status.show())
-      0
+          >>> messages[0].message
+          u'test'
 
-    Since we accessed the message prior to publishing the page, we must
-    ensure that the messages have been removed from the cookies
+          >>> messages[0].type
+          u'info'
 
-      >>> fakePublish(request)
-      >>> len(status.show())
-      0
+        Make sure messages are removed
 
-    Now we repeat the test, only this time we publish the page prior to
-    retrieving the messages
+          >>> len(status.show())
+          0
 
-    Add one message
+        Since we accessed the message prior to publishing the page, we must
+        ensure that the messages have been removed from the cookies
 
-      >>> status.add(u'test', type=u'info')
+          >>> fakePublish(request)
+          >>> len(status.show())
+          0
 
-    Publish the request
+        Now we repeat the test, only this time we publish the page prior to
+        retrieving the messages
 
-      >>> fakePublish(request)
+        Add one message
 
-    Now check the results
+          >>> status.add(u'test', type=u'info')
 
-      >>> messages = status.show()
-      >>> len(messages)
-      1
+        Publish the request
 
-      >>> messages[0].message
-      u'test'
+          >>> fakePublish(request)
 
-      >>> messages[0].type
-      u'info'
+        Now check the results
 
-    Make sure messages are removed
+          >>> messages = status.show()
+          >>> len(messages)
+          1
 
-      >>> len(status.show())
-      0
+          >>> messages[0].message
+          u'test'
 
-    Add two messages (without publishing)
+          >>> messages[0].type
+          u'info'
 
-      >>> status.add(u'test', type=u'info')
-      >>> status.add(u'test1', u'warn')
+        Make sure messages are removed
 
-    And check the results again
+          >>> len(status.show())
+          0
 
-      >>> messages = status.show()
-      >>> len(messages)
-      2
+        Add two messages (without publishing)
 
-      >>> test = messages[1]
+          >>> status.add(u'test', type=u'info')
+          >>> status.add(u'test1', u'warn')
 
-      >>> test.message
-      u'test1'
+        And check the results again
 
-      >>> test.type
-      u'warn'
+          >>> messages = status.show()
+          >>> len(messages)
+          2
 
-    Make sure messages are removed again
+          >>> test = messages[1]
 
-      >>> len(status.show())
-      0
+          >>> test.message
+          u'test1'
 
-    Add two messages (with publishing)
+          >>> test.type
+          u'warn'
 
-      >>> status.add(u'test', type=u'info')
-      >>> fakePublish(request)
-      >>> status.add(u'test1', u'warn')
+        Make sure messages are removed again
 
-    And check the results again
+          >>> len(status.show())
+          0
 
-      >>> fakePublish(request)
-      >>> messages = status.show()
-      >>> len(messages)
-      2
+        Add two messages (with publishing)
 
-      >>> test = messages[1]
+          >>> status.add(u'test', type=u'info')
+          >>> fakePublish(request)
+          >>> status.add(u'test1', u'warn')
 
-      >>> test.message
-      u'test1'
+        And check the results again
 
-      >>> test.type
-      u'warn'
+          >>> fakePublish(request)
+          >>> messages = status.show()
+          >>> len(messages)
+          2
 
-    Make sure messages are removed again
+          >>> test = messages[1]
 
-      >>> len(status.show())
-      0
+          >>> test.message
+          u'test1'
 
-    Add two identical messages
+          >>> test.type
+          u'warn'
 
-      >>> status.add(u'test', type=u'info')
-      >>> status.add(u'test', type=u'info')
+        Make sure messages are removed again
 
-    And check the results again
+          >>> len(status.show())
+          0
 
-      >>> fakePublish(request)
-      >>> messages = status.show()
-      >>> len(messages)
-      1
+        Add two identical messages
 
-      >>> test = messages[0]
+          >>> status.add(u'test', type=u'info')
+          >>> status.add(u'test', type=u'info')
 
-      >>> test.message
-      u'test'
+        And check the results again
 
-      >>> test.type
-      u'info'
+          >>> fakePublish(request)
+          >>> messages = status.show()
+          >>> len(messages)
+          1
 
-    Make sure messages are removed again
+          >>> test = messages[0]
 
-      >>> len(status.show())
-      0
+          >>> test.message
+          u'test'
 
-    Test incredibly long messages:
+          >>> test.type
+          u'info'
 
-      >>> status.add(u'm' * 0x400, type=u't' * 0x20)
+        Make sure messages are removed again
 
-      And check the results again
+          >>> len(status.show())
+          0
 
-      >>> fakePublish(request)
-      >>> messages = status.show()
-      >>> len(messages)
-      1
+        Test incredibly long messages:
 
-      >>> test = messages[0]
+          >>> status.add(u'm' * 0x400, type=u't' * 0x20)
 
-      >>> test.message == u'm' * 0x3FF
-      True
+          And check the results again
 
-      >>> test.type == u't' * 0x1F
-      True
+          >>> fakePublish(request)
+          >>> messages = status.show()
+          >>> len(messages)
+          1
 
-    Messages are stored as base64-ed cookie values, so we must make sure we
-    create proper header values; all ascii characters, and no newlines:
+          >>> test = messages[0]
 
-      >>> status.add(u'test' * 40, type=u'info')
-      >>> cookies = [c['value'] for c in request.response.cookies.values()]
-      >>> cookies = ''.join(cookies)
-      >>> cookies == unicode(cookies).encode('ASCII')
-      True
-      >>> '\\n' in cookies
-      False
+          >>> test.message == u'm' * 0x3FF
+          True
 
-      >>> from zope.component.testing import tearDown
-      >>> tearDown()
-    """
+          >>> test.type == u't' * 0x1F
+          True
 
-def test_301():
-    """
-    Test status messages for 301/302/304 request
+        Messages are stored as base64-ed cookie values, so we must make sure we
+        create proper header values; all ascii characters, and no newlines:
 
-    First some boilerplate.
+          >>> status.add(u'test' * 40, type=u'info')
+          >>> cookies = [c['value'] for c in request.response.cookies.values()]
+          >>> cookies = ''.join(cookies)
+          >>> cookies == unicode(cookies).encode('ASCII')
+          True
+          >>> '\\n' in cookies
+          False
 
-      >>> from zope.component.testing import setUp
-      >>> setUp()
+          >>> from zope.component.testing import tearDown
+          >>> tearDown()
+        """
 
-      >>> import Products.Five
-      >>> import Products.statusmessages
+    def test_301(self):
+        """
+        Test status messages for 301/302/304 request
 
-      >>> from Products.Five import zcml
-      >>> zcml.load_config('meta.zcml', Products.Five)
-      >>> zcml.load_config('configure.zcml', Products.statusmessages)
+        First some boilerplate.
 
-      >>> from zope.interface import directlyProvides
-      >>> from zope.annotation.interfaces import IAttributeAnnotatable
-      >>> directlyProvides(self.app.REQUEST, IAttributeAnnotatable)
+          >>> from zope.component.testing import setUp
+          >>> setUp()
 
-      >>> from Products.statusmessages.interfaces import IStatusMessage
+          >>> import Products.Five
+          >>> import Products.statusmessages
 
-      >>> def fakePublish(request, status=200):
-      ...     cookies = request.response.cookies.copy()
-      ...     new_cookies = {}
-      ...     for key in cookies.keys():
-      ...         new_cookies[key] = cookies[key]['value']
-      ...     request.cookies = new_cookies
-      ...     request.response.cookies = {}
-      ...     request.response.setStatus(status)
+          >>> from Products.Five import zcml
+          >>> zcml.load_config('meta.zcml', Products.Five)
+          >>> zcml.load_config('configure.zcml', Products.statusmessages)
 
-      >>> request = self.app.REQUEST
-      >>> status = IStatusMessage(request)
+          >>> from zope.interface import directlyProvides
+          >>> from zope.annotation.interfaces import IAttributeAnnotatable
+          >>> directlyProvides(self.app.REQUEST, IAttributeAnnotatable)
 
-    Make sure there's no stored message.
+          >>> from Products.statusmessages.interfaces import IStatusMessage
 
-      >>> len(status.show())
-      0
+          >>> def fakePublish(request, status=200):
+          ...     cookies = request.response.cookies.copy()
+          ...     new_cookies = {}
+          ...     for key in cookies.keys():
+          ...         new_cookies[key] = cookies[key]['value']
+          ...     request.cookies = new_cookies
+          ...     request.response.cookies = {}
+          ...     request.response.setStatus(status)
 
-    Add one message
+          >>> request = self.app.REQUEST
+          >>> status = IStatusMessage(request)
 
-      >>> status.add(u'test', type=u'info')
+        Make sure there's no stored message.
 
-    Publish a redirect response that also happened to call show(). This could
-    happen if the redirect (unnecessarily) rendered a template showing the
-    status message, for example.
+          >>> len(status.show())
+          0
 
-      >>> fakePublish(request, 302)
-      >>> messages = status.show()
-      >>> len(messages)
-      1
+        Add one message
 
-      >>> messages[0].message
-      u'test'
+          >>> status.add(u'test', type=u'info')
 
-      >>> messages[0].type
-      u'info'
+        Publish a redirect response that also happened to call show(). This could
+        happen if the redirect (unnecessarily) rendered a template showing the
+        status message, for example.
 
-    Make sure messages are not removed - we really want them to show the
-    next time around, when the redirect has completed.
+          >>> fakePublish(request, 302)
+          >>> messages = status.show()
+          >>> len(messages)
+          1
 
-      >>> len(status.show())
-      1
+          >>> messages[0].message
+          u'test'
 
-    Let's now fake redirection. The message should still be there, but will
-    then be expired.
+          >>> messages[0].type
+          u'info'
 
-      >>> fakePublish(request, 200)
-      >>> messages = status.show()
-      >>> len(messages)
-      1
+        Make sure messages are not removed - we really want them to show the
+        next time around, when the redirect has completed.
 
-      >>> messages[0].message
-      u'test'
+          >>> len(status.show())
+          1
 
-      >>> messages[0].type
-      u'info'
+        Let's now fake redirection. The message should still be there, but will
+        then be expired.
 
-    The message should now be gone.
+          >>> fakePublish(request, 200)
+          >>> messages = status.show()
+          >>> len(messages)
+          1
 
-      >>> len(status.show())
-      0
+          >>> messages[0].message
+          u'test'
 
-      >>> from zope.component.testing import tearDown
-      >>> tearDown()
-    """
+          >>> messages[0].type
+          u'info'
 
-def test_suite():
-    from Testing.ZopeTestCase import ZopeDocTestSuite
-    return ZopeDocTestSuite()
+        The message should now be gone.
 
-if __name__ == '__main__':
-    unittest.main(defaultTest="test_suite")
+          >>> len(status.show())
+          0
+
+          >>> from zope.component.testing import tearDown
+          >>> tearDown()
+        """
diff --git a/Products/statusmessages/tests/test_encoding.py b/Products/statusmessages/tests/test_encoding.py
index d911c7a..b40e674 100644
--- a/Products/statusmessages/tests/test_encoding.py
+++ b/Products/statusmessages/tests/test_encoding.py
@@ -1,76 +1,75 @@
+# -*- coding: UTF-8 -*-
 """
     Encoding tests.
 """
 
+from plone.app.testing import PLONE_INTEGRATION_TESTING
 import unittest
 
-def test_encoding():
-    r"""
-    Test message encoding:
 
-      >>> from Products.statusmessages.message import Message
-      >>> from Products.statusmessages.message import decode
+class TestEncoding(unittest.TestCase):
 
-      >>> m = Message(u'spam', u'eggs')
-      >>> m.encode()
-      '\x00\x84spameggs'
+    layer = PLONE_INTEGRATION_TESTING
 
-      >>> decode(m.encode())[0] == m
-      True
+    def test_encoding(self):
+        r"""
+        Test message encoding:
 
-      >>> m = Message(u'spam')
-      >>> m.encode()
-      '\x00\x80spam'
+          >>> from Products.statusmessages.message import Message
+          >>> from Products.statusmessages.message import decode
 
-      >>> decode(m.encode())[0] == m
-      True
-    """
+          >>> m = Message(u'spam', u'eggs')
+          >>> m.encode()
+          '\x00\x84spameggs'
 
-def test_decoding():
-    r"""
-    Test message decoding:
+          >>> decode(m.encode())[0] == m
+          True
 
-      >>> from Products.statusmessages.message import Message
-      >>> from Products.statusmessages.message import decode
+          >>> m = Message(u'spam')
+          >>> m.encode()
+          '\x00\x80spam'
 
-    Craft a wrong value:
+          >>> decode(m.encode())[0] == m
+          True
+        """
 
-      >>> m, rem = decode('\x01\x84spameggs')
-      >>> m.message, m.type
-      (u'spameggs', u'')
+    def test_decoding(self):
+        r"""
+        Test message decoding:
 
-      >>> rem
-      ''
+          >>> from Products.statusmessages.message import Message
+          >>> from Products.statusmessages.message import decode
 
-    Craft another wrong value:
+        Craft a wrong value:
 
-      >>> m, rem = decode('\x00\x24spameggs')
-      >>> m.message, m.type
-      (u's', u'pame')
+          >>> m, rem = decode('\x01\x84spameggs')
+          >>> m.message, m.type
+          (u'spameggs', u'')
 
-      >>> rem
-      'ggs'
+          >>> rem
+          ''
 
-    And another wrong value:
+        Craft another wrong value:
 
-      >>> m, rem = decode('\x00spameggs')
-      >>> m.message, m.type
-      (u'pam', u'eggs')
+          >>> m, rem = decode('\x00\x24spameggs')
+          >>> m.message, m.type
+          (u's', u'pame')
 
-      >>> rem
-      ''
+          >>> rem
+          'ggs'
 
-    And yet another wrong value:
+        And another wrong value:
 
-      >>> m, rem = decode('')
-      >>> m is None, rem is ''
-      (True, True)
-    """
+          >>> m, rem = decode('\x00spameggs')
+          >>> m.message, m.type
+          (u'pam', u'eggs')
 
+          >>> rem
+          ''
 
-def test_suite():
-    from Testing.ZopeTestCase import ZopeDocTestSuite
-    return ZopeDocTestSuite()
+        And yet another wrong value:
 
-if __name__ == '__main__':
-    unittest.main(defaultTest="test_suite")
+          >>> m, rem = decode('')
+          >>> m is None, rem is ''
+          (True, True)
+        """


