Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2017-10-30T14:18:24+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/74f7a446aa63cc352ed208f63903f6712c770fcd

Allow to patch searchableText index during migrations.
Expose option to skip catalog-reindex after migration in form.

Files changed:
M CHANGES.rst
M plone/app/contenttypes/migration/browser.py
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/migration/patches.py
M plone/app/contenttypes/tests/test_migration.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 2e8f26d7..e2657450 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,7 +10,11 @@ Breaking changes:
 
 New features:
 
-- *add item here*
+- Allow to patch searchableText index during migrations.
+  [pbauer]
+
+- Expose option to skip catalog-reindex after migration in form.
+  [pbauer]
 
 Bug fixes:
 
diff --git a/plone/app/contenttypes/migration/browser.py b/plone/app/contenttypes/migration/browser.py
index 662efb74..f300da79 100644
--- a/plone/app/contenttypes/migration/browser.py
+++ b/plone/app/contenttypes/migration/browser.py
@@ -105,7 +105,9 @@ def __call__(self,
                  migrate_schemaextended_content=False,
                  migrate_references=True,
                  from_form=False,
-                 reindex_catalog=True):
+                 reindex_catalog=True,
+                 patch_searchabletext=False,
+                 ):
 
         portal = self.context
 
@@ -150,7 +152,9 @@ def __call__(self,
         catalog = portal.portal_catalog
 
         # Patch various things that make migration harder
-        link_integrity, queue_indexing = patch_before_migration()
+        (link_integrity,
+         queue_indexing,
+         patch_searchabletext) = patch_before_migration(patch_searchabletext)
 
         not_migrated = []
         migrated_types = {}
@@ -213,7 +217,8 @@ def __call__(self,
             restore_references(portal)
 
         # Revert to the original state
-        undo_patch_after_migration(link_integrity, queue_indexing)
+        undo_patch_after_migration(
+            link_integrity, queue_indexing, patch_searchabletext)
 
         duration = str(timedelta(seconds=(datetime.now() - starttime).seconds))
         if not_migrated:
@@ -275,7 +280,8 @@ class IATCTMigratorForm(Interface):
         description=(
             u'Select this option to migrate references.'
         ),
-        default=True
+        default=True,
+        required=False,
     )
 
     extended_content = schema.List(
@@ -292,6 +298,22 @@ class IATCTMigratorForm(Interface):
         required=False,
     )
 
+    reindex_catalog = schema.Bool(
+        title=_(u'Rebuild the catalog after the migration.'),
+        description=_(u'This operantion can take a very long time.'),
+        default=True,
+        required=False,
+    )
+
+    patch_searchabletext = schema.Bool(
+        title=_(u'Disable reindexing objects during migration?'),
+        description=_(
+            u'This can speed up your migration a lot if you have a lot of files with searchabe text.'
+        ),
+        default=False,
+        required=False,
+    )
+
 
 class ATCTMigratorForm(form.Form):
     template = ViewPageTemplateFile('atct_migrator.pt')
@@ -326,6 +348,8 @@ def handle_migrate(self, action):
             migrate_schemaextended_content=True,
             migrate_references=data['migrate_references'],
             from_form=True,
+            reindex_catalog=data['reindex_catalog'],
+            patch_searchabletext=data['patch_searchabletext'],
         )
 
     def updateActions(self):
diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index 44bf62a8..c7440364 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -96,6 +96,11 @@
             <p i18n:translate="">You can select which AT content type you want to migrate to an existing DX content type.</p>
             <form id="migrateCustomATForm" method="post"
                   tal:attributes="action python:context.absolute_url() + '/@@custom_migration'">
+
+            <input class="field" type="checkbox" name="patch_searchabletext" id="patch_searchabletext" />
+            <label for="patch_searchabletext" i18n:translate="">Disable reindexing objects during migration</label>
+            <span class="formHelp" id="patch_searchabletext_help" i18n:translate="">This can speed up your migration a lot if you have a lot of files with searchabe text.</span>
+
             <table>
                 <tr tal:repeat="at_type at_types">
                   <tal:block tal:define="safe_at_id python:at_type['id'].replace(' ', '_space_')">
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index bc2f98fb..89bd3659 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -5,6 +5,7 @@
 from plone.dexterity.interfaces import IDexterityFTI
 from plone.dexterity.utils import iterSchemataForType
 from Products.ATContentTypes.content.schemata import ATContentTypeSchema
+from Products.Archetypes.interfaces import IBaseObject
 from Products.CMFCore.utils import getToolByName
 from Products.CMFPlone.utils import safe_unicode
 from Products.Five.browser import BrowserView
@@ -109,7 +110,11 @@ def getATTypesWithoutFTI(self):
         for meta_type in catalog.uniqueValuesFor('meta_type'):
             # querying for meta_type will only return at-types
             brain = catalog(meta_type=meta_type, sort_limit=1)[0]
-            if IDexterityContent.providedBy(brain.getObject()):
+            obj = brain.getObject()
+            if IDexterityContent.providedBy(obj):
+                continue
+            if not IBaseObject.providedBy(obj):
+                # Discussion items are neither AT not DX
                 continue
             typename = brain.portal_type
             if typename not in all_registered_types:
@@ -232,6 +237,7 @@ def migrate(self, dry_run=False):
         '''
         data = {}
         form = self.request.form
+        patch_searchabletext = form.get('patch_searchabletext')
         # manipulate what we receive in the form and build a useable data dict
         for k in self.request.form.keys():
             if k.startswith('dx_select_'):
@@ -281,7 +287,9 @@ def migrate(self, dry_run=False):
                 fields_mapping=fields_mapping,
                 src_type=at_typename,
                 dst_type=data[at_typename]['target_type'],
-                dry_run=dry_run)
+                dry_run=dry_run,
+                patch_searchabletext=patch_searchabletext,
+                )
             migration_results.append({'type': at_typename,
                                       'infos': res})
         return migration_results
diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 95729f99..0649f111 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -470,7 +470,13 @@ def last_migrate_check(self):
     return CustomATMigrator
 
 
-def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
+def migrateCustomAT(fields_mapping,
+                    src_type,
+                    dst_type,
+                    dry_run=False,
+                    patch_linkintegrity=False,
+                    patch_searchabletext=False,
+                    ):
     """
     Try to get types infos from archetype_tool, then set a migrator and pass it
     given values. There is a dry_run mode that allows to check the success of
@@ -479,7 +485,9 @@ def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
     portal = getSite()
 
     # Patch various things that make migration harder
-    link_integrity, queue_indexing = patch_before_migration()
+    (link_integrity,
+     queue_indexing,
+     patch_searchabletext) = patch_before_migration(patch_searchabletext)
 
     # if the type still exists get the src_meta_type from the portal_type
     portal_types = getToolByName(portal, 'portal_types')
@@ -542,6 +550,7 @@ def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
             transaction.abort()
 
     # Revert to the original state
-    undo_patch_after_migration(link_integrity, queue_indexing)
+    undo_patch_after_migration(
+        link_integrity, queue_indexing, patch_searchabletext)
 
     return walker_infos
diff --git a/plone/app/contenttypes/migration/patches.py b/plone/app/contenttypes/migration/patches.py
index 24e32f60..e2c440ed 100644
--- a/plone/app/contenttypes/migration/patches.py
+++ b/plone/app/contenttypes/migration/patches.py
@@ -38,7 +38,7 @@ def patched_insertForwardIndexEntry(self, entry, documentId):
         self._length.change(1)
 
 
-def patch_before_migration():
+def patch_before_migration(patch_searchabletext=False):
     """Patch various things that make migration harder."""
     # Switch linkintegrity off
     ptool = queryUtility(IPropertiesTool)
@@ -80,10 +80,18 @@ def patch_before_migration():
         'insertForwardIndexEntry',
         patched_insertForwardIndexEntry)
 
-    return link_integrity, queue_indexing
+    # Patch SearchableText index
+    if patch_searchabletext:
+        patch_indexing_at_blobs()
+        patch_indexing_dx_blobs()
 
+    return link_integrity, queue_indexing, patch_searchabletext
 
-def undo_patch_after_migration(link_integrity=True, queue_indexing=None):
+
+def undo_patch_after_migration(link_integrity=True,
+                               queue_indexing=None,
+                               patch_searchabletext=False,
+                               ):
     """Revert to the original state."""
 
     # Switch linkintegrity back to what it was before migrating
@@ -118,3 +126,28 @@ def undo_patch_after_migration(link_integrity=True, queue_indexing=None):
 
     # Unpatch UUIDIndex
     undoPatch(UUIDIndex, 'insertForwardIndexEntry')
+
+    # Unpatch SearchableText index
+    if patch_searchabletext:
+        unpatch_indexing_at_blobs()
+        unpatch_indexing_dx_blobs()
+
+
+def patch_indexing_at_blobs():
+    from plone.app.blob.content import ATBlob
+    patch(ATBlob, 'getIndexValue', pass_fn)
+
+
+def unpatch_indexing_at_blobs():
+    from plone.app.blob.content import ATBlob
+    undoPatch(ATBlob, 'getIndexValue')
+
+
+def patch_indexing_dx_blobs():
+    from Products.ZCTextIndex.ZCTextIndex import ZCTextIndex
+    patch(ZCTextIndex, 'index_object', pass_fn)
+
+
+def unpatch_indexing_dx_blobs():
+    from Products.ZCTextIndex.ZCTextIndex import ZCTextIndex
+    undoPatch(ZCTextIndex, 'index_object')
diff --git a/plone/app/contenttypes/tests/test_migration.py b/plone/app/contenttypes/tests/test_migration.py
index 2bde6a8d..b0705d4a 100644
--- a/plone/app/contenttypes/tests/test_migration.py
+++ b/plone/app/contenttypes/tests/test_migration.py
@@ -1609,7 +1609,7 @@ def test_warning_for_uneditable_content(self):
         # request was constructed before. Otherwise, @@view cannot be render
         # it's IRichText widget.
         alsoProvides(self.request, IPloneFormLayer)
-        at_document_view = at_document.restrictedTraverse('')
+        at_document_view = at_document.restrictedTraverse('document_view')
         self.assertTrue(
             'http://nohost/plone/@@atct_migrator' in at_document_view()
         )
@@ -1619,7 +1619,7 @@ def test_warning_for_uneditable_content(self):
         self.assertTrue(IDocument.providedBy(dx_document))
         dx_document_view = dx_document.restrictedTraverse('@@view')
         self.assertFalse('alert-box' in dx_document_view())
-        at_newsitem_view = at_newsitem.restrictedTraverse('')
+        at_newsitem_view = at_newsitem.restrictedTraverse('newsitem_view')
         self.assertTrue('alert-box' in at_newsitem_view())
         self.assertTrue(
             'http://nohost/plone/@@atct_migrator' in at_newsitem_view()


Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2017-10-30T14:49:40+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/fbb25a5bd59f1d6f4c06fcd71f5aa58d3c9e9499

fix ZCTextIndex patch

Files changed:
M plone/app/contenttypes/migration/patches.py

diff --git a/plone/app/contenttypes/migration/patches.py b/plone/app/contenttypes/migration/patches.py
index e2c440ed..ed09898c 100644
--- a/plone/app/contenttypes/migration/patches.py
+++ b/plone/app/contenttypes/migration/patches.py
@@ -22,6 +22,10 @@ def pass_fn(*args, **kwargs):
     """Empty function used for patching."""
     pass
 
+def patched_index_object(*args, **kwargs):
+    """Patched Products.ZCTextIndex.ZCTextIndex.ZCTextIndex.index_object"""
+    return 1
+
 
 # Prevent UUID Error-Messages when migrating folders.
 # Products.PluginIndexes.UUIDIndex.UUIDIndex.UUIDIndex.insertForwardIndexEntry
@@ -145,7 +149,7 @@ def unpatch_indexing_at_blobs():
 
 def patch_indexing_dx_blobs():
     from Products.ZCTextIndex.ZCTextIndex import ZCTextIndex
-    patch(ZCTextIndex, 'index_object', pass_fn)
+    patch(ZCTextIndex, 'index_object', patched_index_object)
 
 
 def unpatch_indexing_dx_blobs():


Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2017-11-02T12:58:29+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/d68bd4739c46997ec1bf7c8a4cc23ee1c0b9a0d6

Fix typos. Return 0 for index_object.

Files changed:
M plone/app/contenttypes/migration/browser.py
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/patches.py

diff --git a/plone/app/contenttypes/migration/browser.py b/plone/app/contenttypes/migration/browser.py
index f300da79..7e4fdf3f 100644
--- a/plone/app/contenttypes/migration/browser.py
+++ b/plone/app/contenttypes/migration/browser.py
@@ -300,7 +300,7 @@ class IATCTMigratorForm(Interface):
 
     reindex_catalog = schema.Bool(
         title=_(u'Rebuild the catalog after the migration.'),
-        description=_(u'This operantion can take a very long time.'),
+        description=_(u'This operation can take a very long time.'),
         default=True,
         required=False,
     )
@@ -308,7 +308,7 @@ class IATCTMigratorForm(Interface):
     patch_searchabletext = schema.Bool(
         title=_(u'Disable reindexing objects during migration?'),
         description=_(
-            u'This can speed up your migration a lot if you have a lot of files with searchabe text.'
+            u'This can speed up your migration a lot if you have a lot of files with searchable text.'  # noqa: E501
         ),
         default=False,
         required=False,
diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index c7440364..386f8b20 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -99,7 +99,7 @@
 
             <input class="field" type="checkbox" name="patch_searchabletext" id="patch_searchabletext" />
             <label for="patch_searchabletext" i18n:translate="">Disable reindexing objects during migration</label>
-            <span class="formHelp" id="patch_searchabletext_help" i18n:translate="">This can speed up your migration a lot if you have a lot of files with searchabe text.</span>
+            <span class="formHelp" id="patch_searchabletext_help" i18n:translate="">This can speed up your migration a lot if you have a lot of files with searchable text.</span>
 
             <table>
                 <tr tal:repeat="at_type at_types">
diff --git a/plone/app/contenttypes/migration/patches.py b/plone/app/contenttypes/migration/patches.py
index ed09898c..7d57d8ac 100644
--- a/plone/app/contenttypes/migration/patches.py
+++ b/plone/app/contenttypes/migration/patches.py
@@ -22,9 +22,10 @@ def pass_fn(*args, **kwargs):
     """Empty function used for patching."""
     pass
 
+
 def patched_index_object(*args, **kwargs):
     """Patched Products.ZCTextIndex.ZCTextIndex.ZCTextIndex.index_object"""
-    return 1
+    return 0
 
 
 # Prevent UUID Error-Messages when migrating folders.


Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2017-11-02T18:01:07+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.contenttypes/commit/41c6a09cd77b97da7e48ebc55d868e995b5d7fd6

Merge pull request #439 from plone/patch_searchable_text

Allow patching of searchableText during migrations

Files changed:
M CHANGES.rst
M plone/app/contenttypes/migration/browser.py
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/migration/patches.py
M plone/app/contenttypes/tests/test_migration.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 4b6d8c35..a8d4c3bc 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,7 +10,11 @@ Breaking changes:
 
 New features:
 
-- *add item here*
+- Allow to patch searchableText index during migrations.
+  [pbauer]
+
+- Expose option to skip catalog-reindex after migration in form.
+  [pbauer]
 
 Bug fixes:
 
diff --git a/plone/app/contenttypes/migration/browser.py b/plone/app/contenttypes/migration/browser.py
index 662efb74..7e4fdf3f 100644
--- a/plone/app/contenttypes/migration/browser.py
+++ b/plone/app/contenttypes/migration/browser.py
@@ -105,7 +105,9 @@ def __call__(self,
                  migrate_schemaextended_content=False,
                  migrate_references=True,
                  from_form=False,
-                 reindex_catalog=True):
+                 reindex_catalog=True,
+                 patch_searchabletext=False,
+                 ):
 
         portal = self.context
 
@@ -150,7 +152,9 @@ def __call__(self,
         catalog = portal.portal_catalog
 
         # Patch various things that make migration harder
-        link_integrity, queue_indexing = patch_before_migration()
+        (link_integrity,
+         queue_indexing,
+         patch_searchabletext) = patch_before_migration(patch_searchabletext)
 
         not_migrated = []
         migrated_types = {}
@@ -213,7 +217,8 @@ def __call__(self,
             restore_references(portal)
 
         # Revert to the original state
-        undo_patch_after_migration(link_integrity, queue_indexing)
+        undo_patch_after_migration(
+            link_integrity, queue_indexing, patch_searchabletext)
 
         duration = str(timedelta(seconds=(datetime.now() - starttime).seconds))
         if not_migrated:
@@ -275,7 +280,8 @@ class IATCTMigratorForm(Interface):
         description=(
             u'Select this option to migrate references.'
         ),
-        default=True
+        default=True,
+        required=False,
     )
 
     extended_content = schema.List(
@@ -292,6 +298,22 @@ class IATCTMigratorForm(Interface):
         required=False,
     )
 
+    reindex_catalog = schema.Bool(
+        title=_(u'Rebuild the catalog after the migration.'),
+        description=_(u'This operation can take a very long time.'),
+        default=True,
+        required=False,
+    )
+
+    patch_searchabletext = schema.Bool(
+        title=_(u'Disable reindexing objects during migration?'),
+        description=_(
+            u'This can speed up your migration a lot if you have a lot of files with searchable text.'  # noqa: E501
+        ),
+        default=False,
+        required=False,
+    )
+
 
 class ATCTMigratorForm(form.Form):
     template = ViewPageTemplateFile('atct_migrator.pt')
@@ -326,6 +348,8 @@ def handle_migrate(self, action):
             migrate_schemaextended_content=True,
             migrate_references=data['migrate_references'],
             from_form=True,
+            reindex_catalog=data['reindex_catalog'],
+            patch_searchabletext=data['patch_searchabletext'],
         )
 
     def updateActions(self):
diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index 44bf62a8..386f8b20 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -96,6 +96,11 @@
             <p i18n:translate="">You can select which AT content type you want to migrate to an existing DX content type.</p>
             <form id="migrateCustomATForm" method="post"
                   tal:attributes="action python:context.absolute_url() + '/@@custom_migration'">
+
+            <input class="field" type="checkbox" name="patch_searchabletext" id="patch_searchabletext" />
+            <label for="patch_searchabletext" i18n:translate="">Disable reindexing objects during migration</label>
+            <span class="formHelp" id="patch_searchabletext_help" i18n:translate="">This can speed up your migration a lot if you have a lot of files with searchable text.</span>
+
             <table>
                 <tr tal:repeat="at_type at_types">
                   <tal:block tal:define="safe_at_id python:at_type['id'].replace(' ', '_space_')">
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index bc2f98fb..89bd3659 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -5,6 +5,7 @@
 from plone.dexterity.interfaces import IDexterityFTI
 from plone.dexterity.utils import iterSchemataForType
 from Products.ATContentTypes.content.schemata import ATContentTypeSchema
+from Products.Archetypes.interfaces import IBaseObject
 from Products.CMFCore.utils import getToolByName
 from Products.CMFPlone.utils import safe_unicode
 from Products.Five.browser import BrowserView
@@ -109,7 +110,11 @@ def getATTypesWithoutFTI(self):
         for meta_type in catalog.uniqueValuesFor('meta_type'):
             # querying for meta_type will only return at-types
             brain = catalog(meta_type=meta_type, sort_limit=1)[0]
-            if IDexterityContent.providedBy(brain.getObject()):
+            obj = brain.getObject()
+            if IDexterityContent.providedBy(obj):
+                continue
+            if not IBaseObject.providedBy(obj):
+                # Discussion items are neither AT not DX
                 continue
             typename = brain.portal_type
             if typename not in all_registered_types:
@@ -232,6 +237,7 @@ def migrate(self, dry_run=False):
         '''
         data = {}
         form = self.request.form
+        patch_searchabletext = form.get('patch_searchabletext')
         # manipulate what we receive in the form and build a useable data dict
         for k in self.request.form.keys():
             if k.startswith('dx_select_'):
@@ -281,7 +287,9 @@ def migrate(self, dry_run=False):
                 fields_mapping=fields_mapping,
                 src_type=at_typename,
                 dst_type=data[at_typename]['target_type'],
-                dry_run=dry_run)
+                dry_run=dry_run,
+                patch_searchabletext=patch_searchabletext,
+                )
             migration_results.append({'type': at_typename,
                                       'infos': res})
         return migration_results
diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 95729f99..0649f111 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -470,7 +470,13 @@ def last_migrate_check(self):
     return CustomATMigrator
 
 
-def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
+def migrateCustomAT(fields_mapping,
+                    src_type,
+                    dst_type,
+                    dry_run=False,
+                    patch_linkintegrity=False,
+                    patch_searchabletext=False,
+                    ):
     """
     Try to get types infos from archetype_tool, then set a migrator and pass it
     given values. There is a dry_run mode that allows to check the success of
@@ -479,7 +485,9 @@ def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
     portal = getSite()
 
     # Patch various things that make migration harder
-    link_integrity, queue_indexing = patch_before_migration()
+    (link_integrity,
+     queue_indexing,
+     patch_searchabletext) = patch_before_migration(patch_searchabletext)
 
     # if the type still exists get the src_meta_type from the portal_type
     portal_types = getToolByName(portal, 'portal_types')
@@ -542,6 +550,7 @@ def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
             transaction.abort()
 
     # Revert to the original state
-    undo_patch_after_migration(link_integrity, queue_indexing)
+    undo_patch_after_migration(
+        link_integrity, queue_indexing, patch_searchabletext)
 
     return walker_infos
diff --git a/plone/app/contenttypes/migration/patches.py b/plone/app/contenttypes/migration/patches.py
index 24e32f60..7d57d8ac 100644
--- a/plone/app/contenttypes/migration/patches.py
+++ b/plone/app/contenttypes/migration/patches.py
@@ -23,6 +23,11 @@ def pass_fn(*args, **kwargs):
     pass
 
 
+def patched_index_object(*args, **kwargs):
+    """Patched Products.ZCTextIndex.ZCTextIndex.ZCTextIndex.index_object"""
+    return 0
+
+
 # Prevent UUID Error-Messages when migrating folders.
 # Products.PluginIndexes.UUIDIndex.UUIDIndex.UUIDIndex.insertForwardIndexEntry
 def patched_insertForwardIndexEntry(self, entry, documentId):
@@ -38,7 +43,7 @@ def patched_insertForwardIndexEntry(self, entry, documentId):
         self._length.change(1)
 
 
-def patch_before_migration():
+def patch_before_migration(patch_searchabletext=False):
     """Patch various things that make migration harder."""
     # Switch linkintegrity off
     ptool = queryUtility(IPropertiesTool)
@@ -80,10 +85,18 @@ def patch_before_migration():
         'insertForwardIndexEntry',
         patched_insertForwardIndexEntry)
 
-    return link_integrity, queue_indexing
+    # Patch SearchableText index
+    if patch_searchabletext:
+        patch_indexing_at_blobs()
+        patch_indexing_dx_blobs()
+
+    return link_integrity, queue_indexing, patch_searchabletext
 
 
-def undo_patch_after_migration(link_integrity=True, queue_indexing=None):
+def undo_patch_after_migration(link_integrity=True,
+                               queue_indexing=None,
+                               patch_searchabletext=False,
+                               ):
     """Revert to the original state."""
 
     # Switch linkintegrity back to what it was before migrating
@@ -118,3 +131,28 @@ def undo_patch_after_migration(link_integrity=True, queue_indexing=None):
 
     # Unpatch UUIDIndex
     undoPatch(UUIDIndex, 'insertForwardIndexEntry')
+
+    # Unpatch SearchableText index
+    if patch_searchabletext:
+        unpatch_indexing_at_blobs()
+        unpatch_indexing_dx_blobs()
+
+
+def patch_indexing_at_blobs():
+    from plone.app.blob.content import ATBlob
+    patch(ATBlob, 'getIndexValue', pass_fn)
+
+
+def unpatch_indexing_at_blobs():
+    from plone.app.blob.content import ATBlob
+    undoPatch(ATBlob, 'getIndexValue')
+
+
+def patch_indexing_dx_blobs():
+    from Products.ZCTextIndex.ZCTextIndex import ZCTextIndex
+    patch(ZCTextIndex, 'index_object', patched_index_object)
+
+
+def unpatch_indexing_dx_blobs():
+    from Products.ZCTextIndex.ZCTextIndex import ZCTextIndex
+    undoPatch(ZCTextIndex, 'index_object')
diff --git a/plone/app/contenttypes/tests/test_migration.py b/plone/app/contenttypes/tests/test_migration.py
index 2bde6a8d..b0705d4a 100644
--- a/plone/app/contenttypes/tests/test_migration.py
+++ b/plone/app/contenttypes/tests/test_migration.py
@@ -1609,7 +1609,7 @@ def test_warning_for_uneditable_content(self):
         # request was constructed before. Otherwise, @@view cannot be render
         # it's IRichText widget.
         alsoProvides(self.request, IPloneFormLayer)
-        at_document_view = at_document.restrictedTraverse('')
+        at_document_view = at_document.restrictedTraverse('document_view')
         self.assertTrue(
             'http://nohost/plone/@@atct_migrator' in at_document_view()
         )
@@ -1619,7 +1619,7 @@ def test_warning_for_uneditable_content(self):
         self.assertTrue(IDocument.providedBy(dx_document))
         dx_document_view = dx_document.restrictedTraverse('@@view')
         self.assertFalse('alert-box' in dx_document_view())
-        at_newsitem_view = at_newsitem.restrictedTraverse('')
+        at_newsitem_view = at_newsitem.restrictedTraverse('newsitem_view')
         self.assertTrue('alert-box' in at_newsitem_view())
         self.assertTrue(
             'http://nohost/plone/@@atct_migrator' in at_newsitem_view()


