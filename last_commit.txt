Repository: plone.rfc822


Branch: refs/heads/master
Date: 2016-08-02T00:53:00+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.rfc822/commit/f25e77659b19865c6d1d34095c1cd6f0ae5c8b6e

isort

Files changed:
M plone/rfc822/__init__.py
M plone/rfc822/_utils.py
M plone/rfc822/defaultfields.py
M plone/rfc822/interfaces.py
M plone/rfc822/tests.py

diff --git a/plone/rfc822/__init__.py b/plone/rfc822/__init__.py
index ff7c8e8..ebee1f1 100644
--- a/plone/rfc822/__init__.py
+++ b/plone/rfc822/__init__.py
@@ -1,14 +1,13 @@
-import zope.interface
-from plone.rfc822.interfaces import IMessageAPI
-
-zope.interface.moduleProvides(IMessageAPI)
-
+from plone.rfc822._utils import constructMessage
 from plone.rfc822._utils import constructMessageFromSchema
 from plone.rfc822._utils import constructMessageFromSchemata
-from plone.rfc822._utils import constructMessage
-
-from plone.rfc822._utils import renderMessage
-
+from plone.rfc822._utils import initializeObject
 from plone.rfc822._utils import initializeObjectFromSchema
 from plone.rfc822._utils import initializeObjectFromSchemata
-from plone.rfc822._utils import initializeObject
+from plone.rfc822._utils import renderMessage
+from plone.rfc822.interfaces import IMessageAPI
+
+import zope.interface
+
+
+zope.interface.moduleProvides(IMessageAPI)
diff --git a/plone/rfc822/_utils.py b/plone/rfc822/_utils.py
index a6bcce3..66a92ec 100644
--- a/plone/rfc822/_utils.py
+++ b/plone/rfc822/_utils.py
@@ -5,19 +5,19 @@
 See interfaces.py for details.
 """
 
-import logging
 from cStringIO import StringIO
-
-# Note: We use capitalised module names to be compatible with Python 2.4
-from email.Message import Message 
-from email.Header import Header, decode_header
 from email.Generator import Generator
-
+from email.Header import decode_header
+from email.Header import Header
+# Note: We use capitalised module names to be compatible with Python 2.4
+from email.Message import Message
+from plone.rfc822.interfaces import IFieldMarshaler
+from plone.rfc822.interfaces import IPrimaryField
 from zope.component import queryMultiAdapter
 from zope.schema import getFieldsInOrder
 
-from plone.rfc822.interfaces import IFieldMarshaler
-from plone.rfc822.interfaces import IPrimaryField
+import logging
+
 
 LOG = logging.getLogger('plone.rfc822')
 
diff --git a/plone/rfc822/defaultfields.py b/plone/rfc822/defaultfields.py
index 9540238..8b24e81 100644
--- a/plone/rfc822/defaultfields.py
+++ b/plone/rfc822/defaultfields.py
@@ -31,20 +31,21 @@
 * Dict - stores a dict
 """
 
-import datetime
-import dateutil.parser
-
-from zope.component import queryMultiAdapter
-
-from zope.interface import implementer, Interface
+from plone.rfc822.interfaces import IFieldMarshaler
 from zope.component import adapts
-
-from zope.schema.interfaces import IFromUnicode
+from zope.component import queryMultiAdapter
+from zope.interface import implementer
+from zope.interface import Interface
 from zope.schema.interfaces import IBytes
-from zope.schema.interfaces import IDatetime, IDate, ITimedelta
 from zope.schema.interfaces import ICollection
+from zope.schema.interfaces import IDate
+from zope.schema.interfaces import IDatetime
+from zope.schema.interfaces import IFromUnicode
+from zope.schema.interfaces import ITimedelta
+
+import datetime
+import dateutil.parser
 
-from plone.rfc822.interfaces import IFieldMarshaler
 
 _marker = object()
 
diff --git a/plone/rfc822/interfaces.py b/plone/rfc822/interfaces.py
index 949ffd5..a47dc98 100644
--- a/plone/rfc822/interfaces.py
+++ b/plone/rfc822/interfaces.py
@@ -1,6 +1,7 @@
+from zope import schema
 from zope.interface import Attribute
 from zope.interface import Interface
-from zope import schema
+
 
 class IPrimaryField(Interface):
     """Marker interface for the primary field in a schema
diff --git a/plone/rfc822/tests.py b/plone/rfc822/tests.py
index 3679ca6..2be390f 100644
--- a/plone/rfc822/tests.py
+++ b/plone/rfc822/tests.py
@@ -1,8 +1,9 @@
-import unittest
-import doctest
 from plone.testing import layered
 from plone.testing.zca import UNIT_TESTING
 
+import doctest
+import unittest
+
 
 DOCFILES = [
     'message.txt',


Repository: plone.rfc822


Branch: refs/heads/master
Date: 2016-08-02T00:53:25+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.rfc822/commit/55a25edb001bc708eb2e9b99259f3df26b9b303d

utf8 headers

Files changed:
M plone/__init__.py
M plone/rfc822/__init__.py
M plone/rfc822/_utils.py
M plone/rfc822/defaultfields.py
M plone/rfc822/interfaces.py
M plone/rfc822/supermodel.py
M plone/rfc822/tests.py

diff --git a/plone/__init__.py b/plone/__init__.py
index f48ad10..85880ef 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
 try:
     __import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/rfc822/__init__.py b/plone/rfc822/__init__.py
index ebee1f1..98157cb 100644
--- a/plone/rfc822/__init__.py
+++ b/plone/rfc822/__init__.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.rfc822._utils import constructMessage
 from plone.rfc822._utils import constructMessageFromSchema
 from plone.rfc822._utils import constructMessageFromSchemata
diff --git a/plone/rfc822/_utils.py b/plone/rfc822/_utils.py
index 66a92ec..9987862 100644
--- a/plone/rfc822/_utils.py
+++ b/plone/rfc822/_utils.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 """Implementation of IMessageAPI methods.
 
 import these from plone.rfc822 directly, not from this module.
diff --git a/plone/rfc822/defaultfields.py b/plone/rfc822/defaultfields.py
index 8b24e81..a3c53f8 100644
--- a/plone/rfc822/defaultfields.py
+++ b/plone/rfc822/defaultfields.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 """Default field marshalers for the fields in zope.schema.
 
 Note that none of the marshalers will return a value for getContentType(),
diff --git a/plone/rfc822/interfaces.py b/plone/rfc822/interfaces.py
index a47dc98..c1c8b37 100644
--- a/plone/rfc822/interfaces.py
+++ b/plone/rfc822/interfaces.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from zope import schema
 from zope.interface import Attribute
 from zope.interface import Interface
diff --git a/plone/rfc822/supermodel.py b/plone/rfc822/supermodel.py
index 47fadc0..5e2db4c 100644
--- a/plone/rfc822/supermodel.py
+++ b/plone/rfc822/supermodel.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 try:
     from plone.supermodel.interfaces import IFieldMetadataHandler
     HAVE_SUPERMODEL = True
diff --git a/plone/rfc822/tests.py b/plone/rfc822/tests.py
index 2be390f..e6acfff 100644
--- a/plone/rfc822/tests.py
+++ b/plone/rfc822/tests.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.testing import layered
 from plone.testing.zca import UNIT_TESTING
 


Repository: plone.rfc822


Branch: refs/heads/master
Date: 2016-08-02T00:54:09+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.rfc822/commit/f0c5a0e2a8877e382f087415359dbdc0f33df40a

autopep8 -ir

Files changed:
M plone/rfc822/_utils.py
M plone/rfc822/defaultfields.py
M plone/rfc822/interfaces.py
M plone/rfc822/supermodel.py

diff --git a/plone/rfc822/_utils.py b/plone/rfc822/_utils.py
index 9987862..fc2b903 100644
--- a/plone/rfc822/_utils.py
+++ b/plone/rfc822/_utils.py
@@ -22,92 +22,98 @@
 
 LOG = logging.getLogger('plone.rfc822')
 
+
 def constructMessageFromSchema(context, schema, charset='utf-8'):
     return constructMessage(context, getFieldsInOrder(schema), charset)
 
+
 def constructMessageFromSchemata(context, schemata, charset='utf-8'):
     fields = []
     for schema in schemata:
         fields.extend(getFieldsInOrder(schema))
     return constructMessage(context, fields, charset)
 
+
 def constructMessage(context, fields, charset='utf-8'):
     msg = Message()
-    
+
     primary = []
-    
+
     # First get all headers, storing primary fields for later
     for name, field in fields:
-        
+
         if IPrimaryField.providedBy(field):
             primary.append((name, field,))
             continue
-        
+
         marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
         if marshaler is None:
-            LOG.debug("No marshaler found for field %s of %s" % (name, repr(context)))
+            LOG.debug("No marshaler found for field %s of %s" %
+                      (name, repr(context)))
             continue
-        
+
         try:
             value = marshaler.marshal(charset, primary=False)
         except ValueError, e:
-            LOG.debug("Marshaling of %s for %s failed: %s" % (name, repr(context), str(e)))
+            LOG.debug("Marshaling of %s for %s failed: %s" %
+                      (name, repr(context), str(e)))
             continue
-        
+
         if value is None:
             value = ''
         elif not isinstance(value, str):
-            raise ValueError("Marshaler for field %s did not return a string" % name)
-        
+            raise ValueError(
+                "Marshaler for field %s did not return a string" % name)
+
         if marshaler.ascii and '\n' not in value:
             msg[name] = value
         else:
             msg[name] = Header(value, charset)
-    
+
     # Then deal with the primary field
-    
+
     # If there's a single primary field, we have a non-multipart message with
     # a string payload
 
     if len(primary) == 1:
         name, field = primary[0]
-        
+
         marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
         if marshaler is not None:
             contentType = marshaler.getContentType()
             payloadCharset = marshaler.getCharset(charset)
-            
+
             if contentType is not None:
                 msg.set_type(contentType)
-            
+
             if payloadCharset is not None:
                 # using set_charset() would also add transfer encoding,
                 # which we don't want to do always
                 msg.set_param('charset', payloadCharset)
-                
+
             value = marshaler.marshal(charset, primary=True)
             if value is not None:
                 msg.set_payload(value)
-            
+
             marshaler.postProcessMessage(msg)
-    
+
     # Otherwise, we return a multipart message
-    
+
     elif len(primary) > 1:
         msg.set_type('multipart/mixed')
-        
+
         for name, field in primary:
-            
+
             marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
             if marshaler is None:
                 continue
-            
+
             payload = Message()
             attach = False
-            
+
             contentType = marshaler.getContentType()
             payloadCharset = marshaler.getCharset(charset)
-            
+
             if contentType is not None:
                 payload.set_type(contentType)
                 attach = True
@@ -116,42 +122,47 @@ def constructMessage(context, fields, charset='utf-8'):
                 # which we don't want to do always
                 payload.set_param('charset', payloadCharset)
                 attach = True
-            
+
             value = marshaler.marshal(charset, primary=True)
-            
+
             if value is not None:
                 payload.set_payload(value)
                 attach = True
-            
+
             if attach:
                 marshaler.postProcessMessage(payload)
                 msg.attach(payload)
 
     return msg
 
+
 def renderMessage(message, mangleFromHeader=False):
     out = StringIO()
     generator = Generator(out, mangle_from_=mangleFromHeader)
     generator.flatten(message)
     return out.getvalue()
 
+
 def initializeObjectFromSchema(context, schema, message, defaultCharset='utf-8'):
-    initializeObject(context, getFieldsInOrder(schema), message, defaultCharset)
+    initializeObject(context, getFieldsInOrder(
+        schema), message, defaultCharset)
+
 
 def initializeObjectFromSchemata(context, schemata, message, defaultCharset='utf-8'):
     """Convenience method which calls ``initializeObject()`` with all the
     fields in order, of all the given schemata (a sequence of schema
     interfaces).
     """
-    
+
     fields = []
     for schema in schemata:
         fields.extend(getFieldsInOrder(schema))
     return initializeObject(context, fields, message, defaultCharset)
 
+
 def initializeObject(context, fields, message, defaultCharset='utf-8'):
     contentType = message.get_content_type()
-    
+
     charset = message.get_charset()
     if charset is None:
         charset = message.get_param('charset')
@@ -159,100 +170,116 @@ def initializeObject(context, fields, message, defaultCharset='utf-8'):
         charset = str(charset)
     else:
         charset = defaultCharset
-    
+
     headerFields = {}
     primary = []
-    
+
     for name, field in fields:
         if IPrimaryField.providedBy(field):
             primary.append((name, field))
         else:
             headerFields.setdefault(name.lower(), []).append(field)
-    
+
     # Demarshal each header
-    
+
     for name, value in message.items():
-        
+
         name = name.lower()
         fieldset = headerFields.get(name, None)
         if fieldset is None or len(fieldset) == 0:
             LOG.debug("No matching field found for header %s" % name)
             continue
-        
+
         field = fieldset.pop(0)
-        
+
         marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
         if marshaler is None:
-            LOG.debug("No marshaler found for field %s of %s" % (name, repr(context)))
+            LOG.debug("No marshaler found for field %s of %s" %
+                      (name, repr(context)))
             continue
-        
+
         headerValue, headerCharset = decode_header(value)[0]
         if headerCharset is None:
             headerCharset = charset
-        
-        # MIME messages always use CRLF. For headers, we're probably safer with \n
+
+        # MIME messages always use CRLF. For headers, we're probably safer with
+        # \n
         headerValue = headerValue.replace('\r\n', '\n')
-        
+
         try:
-            marshaler.demarshal(headerValue, message=message, charset=headerCharset, contentType=contentType, primary=False)
+            marshaler.demarshal(headerValue, message=message,
+                                charset=headerCharset, contentType=contentType, primary=False)
         except ValueError, e:
-            # interface allows demarshal() to raise ValueError to indicate marshalling failed
-            LOG.debug("Demarshalling of %s for %s failed: %s" % (name, repr(context), str(e)))
+            # interface allows demarshal() to raise ValueError to indicate
+            # marshalling failed
+            LOG.debug("Demarshalling of %s for %s failed: %s" %
+                      (name, repr(context), str(e)))
             continue
-        
+
     # Then demarshal the primary field
-    
+
     payload = message.get_payload()
-    
+
     # do nothing if we don't have a payload
     if not payload:
         return
-    
+
     # A single string payload
     if isinstance(payload, str):
         if len(primary) != 1:
-            raise ValueError("Got a single string payload for message, but no primary fields found for %s" % repr(context))
+            raise ValueError(
+                "Got a single string payload for message, but no primary fields found for %s" % repr(context))
         else:
             name, field = primary[0]
-        
+
             marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
             if marshaler is None:
-                LOG.debug("No marshaler found for primary field %s of %s" % (name, repr(context),))
+                LOG.debug("No marshaler found for primary field %s of %s" %
+                          (name, repr(context),))
             else:
                 payloadValue = message.get_payload(decode=True)
                 payloadCharset = message.get_content_charset(charset)
                 try:
-                    marshaler.demarshal(payloadValue, message=message, charset=payloadCharset, contentType=contentType, primary=True)
+                    marshaler.demarshal(
+                        payloadValue, message=message, charset=payloadCharset, contentType=contentType, primary=True)
                 except ValueError, e:
-                    # interface allows demarshal() to raise ValueError to indicate marshalling failed
-                    LOG.debug("Demarshalling of %s for %s failed: %s" % (name, repr(context), str(e)))
-        
+                    # interface allows demarshal() to raise ValueError to
+                    # indicate marshalling failed
+                    LOG.debug("Demarshalling of %s for %s failed: %s" %
+                              (name, repr(context), str(e)))
+
     # Multiple payloads
     elif isinstance(payload, (list, tuple,)):
         if len(payload) != len(primary):
-            raise ValueError("Got %d payloads for message, but %s primary fields found for %s" %  (len(payload), len(primary), repr(context),))
+            raise ValueError("Got %d payloads for message, but %s primary fields found for %s" % (
+                len(payload), len(primary), repr(context),))
         else:
             for idx, msg in enumerate(payload):
                 name, field = primary[idx]
-                
+
                 contentType = msg.get_content_type()
-    
+
                 charset = message.get_charset()
                 if charset is not None:
                     charset = str(charset)
                 else:
                     charset = 'utf-8'
-                
-                marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
+
+                marshaler = queryMultiAdapter(
+                    (context, field,), IFieldMarshaler)
                 if marshaler is None:
-                    LOG.debug("No marshaler found for primary field %s of %s" % (name, repr(context),))
+                    LOG.debug("No marshaler found for primary field %s of %s" % (
+                        name, repr(context),))
                     continue
-                
+
                 payloadValue = msg.get_payload(decode=True)
                 payloadCharset = msg.get_content_charset(charset)
                 try:
-                    marshaler.demarshal(payloadValue, message=msg, charset=payloadCharset, contentType=contentType, primary=True)
+                    marshaler.demarshal(
+                        payloadValue, message=msg, charset=payloadCharset, contentType=contentType, primary=True)
                 except ValueError, e:
-                    # interface allows demarshal() to raise ValueError to indicate marshalling failed
-                    LOG.debug("Demarshalling of %s for %s failed: %s" % (name, repr(context), str(e)))
+                    # interface allows demarshal() to raise ValueError to
+                    # indicate marshalling failed
+                    LOG.debug("Demarshalling of %s for %s failed: %s" %
+                              (name, repr(context), str(e)))
                     continue
diff --git a/plone/rfc822/defaultfields.py b/plone/rfc822/defaultfields.py
index a3c53f8..27bcddd 100644
--- a/plone/rfc822/defaultfields.py
+++ b/plone/rfc822/defaultfields.py
@@ -50,85 +50,90 @@
 
 _marker = object()
 
+
 @implementer(IFieldMarshaler)
 class BaseFieldMarshaler(object):
     """Base class for field marshalers
     """
-    
+
     ascii = False
-    
+
     def __init__(self, context, field):
         self.context = context
         self.field = field.bind(context)
-        
+
         self.instance = context
         if field.interface is not None:
             self.instance = field.interface(context, context)
-    
+
     def marshal(self, charset='utf-8', primary=False):
         value = self._query(_marker)
         if value is _marker:
             return None
         return self.encode(value, charset, primary)
-    
+
     def demarshal(self, value, message=None, charset='utf-8', contentType=None, primary=False):
         fieldValue = self.field.missing_value
         if value:
-            fieldValue = self.decode(value, message, charset, contentType, primary)
+            fieldValue = self.decode(
+                value, message, charset, contentType, primary)
         self._set(fieldValue)
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         return None
-    
+
     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
-        raise ValueError("Demarshalling not implemented for %s" % repr(self.field))
-    
+        raise ValueError("Demarshalling not implemented for %s" %
+                         repr(self.field))
+
     def getContentType(self):
         return None
-    
+
     def getCharset(self, default='utf-8'):
         return None
-    
+
     def postProcessMessage(self, message):
         pass
-    
+
     # Helper methods
-    
+
     def _query(self, default=None):
         return self.field.query(self.instance, default)
-    
+
     def _set(self, value):
         try:
             self.field.set(self.instance, value)
         except TypeError, e:
             raise ValueError(e)
 
+
 class UnicodeFieldMarshaler(BaseFieldMarshaler):
     """Default marshaler for fields that support IFromUnicode
     """
-    
+
     adapts(Interface, IFromUnicode)
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         if value is None:
             return None
         return unicode(value).encode(charset)
-    
+
     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
         unicodeValue = value.decode(charset)
         try:
             return self.field.fromUnicode(unicodeValue)
         except Exception, e:
             raise ValueError(e)
-    
+
     def getCharset(self, default='utf-8'):
         return default
 
+
 class UnicodeValueFieldMarshaler(UnicodeFieldMarshaler):
     """Default marshaler for fields that contain unicode data and so may be
     ASCII safe.
     """
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         value = super(UnicodeValueFieldMarshaler, self).encode(
             value, charset, primary)
@@ -139,45 +144,48 @@ def encode(self, value, charset='utf-8', primary=False):
         else:
             self.ascii = False
         return value
-    
+
+
 class ASCIISafeFieldMarshaler(UnicodeFieldMarshaler):
     """Default marshaler for fields that are ASCII safe, but still support
     IFromUnicode. This includes Int, Float, Decimal, and Bool.
     """
-    
+
     ascii = True
-    
+
     def getCharset(self, default='utf-8'):
         return None
-    
+
+
 class BytesFieldMarshaler(BaseFieldMarshaler):
     """Default marshaler for IBytes fields and children. These store str
     objects, so we will attempt to encode them directly.
     """
-    
+
     adapts(Interface, IBytes)
-    
+
     ascii = True
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         return value
-    
+
     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
         return value
 
+
 class DatetimeMarshaler(BaseFieldMarshaler):
     """Marshaler for Python datetime values
     """
-    
+
     adapts(Interface, IDatetime)
-    
+
     ascii = True
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         if value is None:
             return None
         return value.isoformat()
-    
+
     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
         unicodeValue = value.decode(charset)
         try:
@@ -185,23 +193,24 @@ def decode(self, value, message=None, charset='utf-8', contentType=None, primary
         except Exception, e:
             raise ValueError(e)
 
+
 class DateMarshaler(BaseFieldMarshaler):
     """Marshaler for Python date values.
-    
+
     Note: we don't use the date formatting support in the 'email' module as
     this does not seem to be capable of round-tripping values with time zone
     information.
     """
-    
+
     adapts(Interface, IDate)
-    
+
     ascii = True
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         if value is None:
             return None
         return value.isoformat()
-    
+
     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
         unicodeValue = value.decode(charset)
         try:
@@ -209,23 +218,24 @@ def decode(self, value, message=None, charset='utf-8', contentType=None, primary
         except Exception, e:
             raise ValueError(e)
 
+
 class TimedeltaMarshaler(BaseFieldMarshaler):
     """Marshaler for Python timedelta values
-    
+
     Note: we don't use the date formatting support in the 'email' module as
     this does not seem to be capable of round-tripping values with time zone
     information.
     """
-    
+
     adapts(Interface, ITimedelta)
-    
+
     ascii = True
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         if value is None:
             return None
         return "%d:%d:%d" % (value.days, value.seconds, value.microseconds)
-    
+
     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
         unicodeValue = value.decode(charset)
         try:
@@ -234,54 +244,61 @@ def decode(self, value, message=None, charset='utf-8', contentType=None, primary
         except Exception, e:
             raise ValueError(e)
 
+
 class CollectionMarshaler(BaseFieldMarshaler):
     """Marshaler for collection values
     """
-    
+
     adapts(Interface, ICollection)
 
     ascii = False
-    
+
     def getCharset(self, default='utf-8'):
-        valueTypeMarshaler = queryMultiAdapter((self.context, self.field.value_type,), IFieldMarshaler)
+        valueTypeMarshaler = queryMultiAdapter(
+            (self.context, self.field.value_type,), IFieldMarshaler)
         if valueTypeMarshaler is None:
             return None
         return valueTypeMarshaler.getCharset(default)
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         if value is None:
             return None
-        
-        valueTypeMarshaler = queryMultiAdapter((self.context, self.field.value_type,), IFieldMarshaler)
+
+        valueTypeMarshaler = queryMultiAdapter(
+            (self.context, self.field.value_type,), IFieldMarshaler)
         if valueTypeMarshaler is None:
             return None
-        
+
         ascii = True
         value_lines = []
         for item in value:
-            marshaledValue = valueTypeMarshaler.encode(item, charset=charset, primary=primary)
+            marshaledValue = valueTypeMarshaler.encode(
+                item, charset=charset, primary=primary)
             if marshaledValue is None:
                 marshaledValue = ''
             value_lines.append(marshaledValue)
             if not valueTypeMarshaler.ascii:
                 ascii = False
-        
+
         self.ascii = ascii
 
         return '||'.join(value_lines)
-    
+
     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
-        valueTypeMarshaler = queryMultiAdapter((self.context, self.field.value_type,), IFieldMarshaler)
+        valueTypeMarshaler = queryMultiAdapter(
+            (self.context, self.field.value_type,), IFieldMarshaler)
         if valueTypeMarshaler is None:
-            raise ValueError("Cannot demarshal value type %s" % repr(self.field.value_type))
-        
+            raise ValueError("Cannot demarshal value type %s" %
+                             repr(self.field.value_type))
+
         listValue = []
-        
+
         for line in value.split('||'):
-            listValue.append(valueTypeMarshaler.decode(line, message, charset, contentType, primary))
-            
+            listValue.append(valueTypeMarshaler.decode(
+                line, message, charset, contentType, primary))
+
         sequenceType = self.field._type
         if isinstance(sequenceType, (list, tuple,)):
             sequenceType = sequenceType[-1]
-        
+
         return sequenceType(listValue)
diff --git a/plone/rfc822/interfaces.py b/plone/rfc822/interfaces.py
index c1c8b37..c46a8df 100644
--- a/plone/rfc822/interfaces.py
+++ b/plone/rfc822/interfaces.py
@@ -8,64 +8,66 @@ class IPrimaryField(Interface):
     """Marker interface for the primary field in a schema
     """
 
+
 class IPrimaryFieldInfo(Interface):
     """Information about the primary field of a content item
-    
+
     Content type frameworks should register an adapter to this interface.
     """
     fieldname = Attribute("Field name")
     field = Attribute("Field")
     value = Attribute("Field value")
 
+
 class IMessageAPI(Interface):
     """Functions provided by this module
-    
+
     These can all be imported as::
-    
+
         >>> from plone.rfc822 import constructMessage
     """
-    
+
     def constructMessageFromSchema(context, schema, charset='utf-8'):
         """Convenience method which calls ``constructMessage()`` with all the
         fields, in order, of the given schema interface
         """
-    
+
     def constructMessageFromSchemata(context, schemata, charset='utf-8'):
         """Convenience method which calls ``constructMessage()`` with all the
         fields, in order, of all the given schemata (a sequence of schema
         interfaces).
         """
-    
+
     def constructMessage(context, fields, charset='utf-8'):
         """Helper method to construct a message.
-    
+
         ``context`` is a content object.
-    
+
         ``fields`` is a sequence of (name, field) pairs for the fields which make
         up the message. This can be obtained from zope.schema.getFieldsInOrder,
         for example.
-    
+
         ``charset`` is the message charset.
-    
+
         The message body will be constructed from the primary field, i.e. the
         field which is marked with ``IPrimaryField``. If no such field exists,
         the message will have no body. If multiple fields exist, the message will
         be a multipart message. Otherwise, it will contain a scalar string
         payload.
-    
+
         A field will be ignored if ``(context, field)`` cannot be multi-adapted
         to ``IFieldMarshaler``, or if the ``marshal()`` method returns None.
         """
-    
+
     def renderMessage(message, mangleFromHeader=False):
         """Render a message to a string
         """
-        
+
     def initializeObjectFromSchema(context, schema, message, defaultCharset='utf-8'):
         """Convenience method which calls ``initializeObject()`` with all the
         fields, in order, of the given schema interface
         """
-    
+
     def initializeObjectFromSchemata(context, schemata, message, defaultCharset='utf-8'):
         """Convenience method which calls ``initializeObject()`` with all the
         fields in order, of all the given schemata (a sequence of schema
@@ -74,122 +76,123 @@ def initializeObjectFromSchemata(context, schemata, message, defaultCharset='utf
 
     def initializeObject(context, fields, message, defaultCharset='utf-8'):
         """Initialise an object from a message.
-    
+
         ``context`` is the content object to initialise.
-    
+
         ``fields`` is a sequence of (name, field) pairs for the fields which make
         up the message. This can be obtained from zope.schema.getFieldsInOrder,
         for example.
-    
+
         ``message`` is a ``Message`` object.
-    
+
         ``defaultCharset`` is the default character set to use.
-    
+
         If the message is a multipart message, the primary fields will be read
         in order.
         """
 
+
 class IFieldMarshaler(Interface):
     """Multi-adapter on (context, field), used for marshalling to and
     demarshalling from RFC2822 message headers.
-    
+
     This interface deals in unicode strings, which will be encoded/decoded
     elsewhere. 
     """
-    
+
     ascii = schema.Bool(
-            title=u"ASCII only",
-            description=u"Set this to true if this marshaler is guaranteed "
-                         "to return ASCII characters only. This will allow "
-                         "a header to be rendered without an encoding wrapper",
-            default=False,
-            required=True,
-        )
-    
+        title=u"ASCII only",
+        description=u"Set this to true if this marshaler is guaranteed "
+        "to return ASCII characters only. This will allow "
+        "a header to be rendered without an encoding wrapper",
+        default=False,
+        required=True,
+    )
+
     def marshal(charset='utf-8', primary=False):
         """Return the value of the adapted field on the adapted context.
-        
+
         Note: It may be necessary to adapt the context to the field's
               interface (``field.interface``) before getting the value.
-        
+
         ``charset`` is the default message charset. For string values, you
         should use this charset to encode the string. For binary values,
         it may be appropriate to use a different encoding method.
-        
+
         ``primary`` is set to True if the field being marshalled is a primary
         field, i.e. it will be used in the message body.
-        
+
         The returned value must be a string, or None if there is no value
         in the field.
-        
+
         Raise ``ValueError`` if marshaling is impossible. The field will be
         skipped.
         """
-    
+
     def demarshal(value, message=None, charset='utf-8', contentType=None, primary=False):
         """Update the value of the adapted field on the adapted context.
-        
+
         Note: It may be necessary to adapt the context to the field's
               interface (``field.interface``) before getting the value.
-        
+
         ``value`` is the string value from the message.
-        
+
         ``message`` is the message object itself. This may be None if the
         marshaler is being used in isolation.
-        
+
         ``charset`` is the default charset for the message. For string
         values, this is most likely the encoding of the string. For binary
         values, it may not be.
-        
+
         ``primary`` is set to True if the field being demarshalled is a primary
         field, i.e. it came from the message body.
-        
+
         ``contentType`` is the ``Content-Type`` header from the message, or
         None if this is not available. This is mainly used for primary fields.
-        
+
         Raise ``ValueError`` if the demarshalling cannot be completed.
         """
-    
+
     def encode(value, charset='utf-8', primary=False):
         """Like marshal(), but acts on the passed-in ``value`` instead of
         reading it from the field.
-        
+
         This is only used for collection fields and other situations where
         the value is not read from an instance.
-        
+
         Return None if the value cannot be encoded.
         """
-    
+
     def decode(value, message=None, charset='utf-8', contentType=None, primary=False):
         """Like demarshal, but return the value instead of updating the field.
-        
+
         This is only used for collection fields and other situations where
         the instance should not be updated directly.
-        
+
         Raise ValueError if the value cannot be extracted.
         """
-    
+
     def getContentType():
         """Return the MIME type of the field. The value should be appropriate
         for the Content-Type HTTP header. This is mainly used for marshalling
         the primary field to the message body.
-        
+
         May return None if a content type does not make sense.
         """
-    
+
     def getCharset(defualt='utf-8'):
         """Return the charset of the field. The value should be appropriate
         for the 'charset' parameter to the Content-Type HTTP header. This is
         mainly used for marshalling 
-        
+
         The ``default`` parameter contains the message's default charset.
-        
+
         Must return None if the message should not have a charset, i.e. it
         is not text data.
         """
-    
+
     def postProcessMessage(message):
         """This is a chance to perform any post-processing of the message.
-        
+
         It is only called for primary fields.
         """
diff --git a/plone/rfc822/supermodel.py b/plone/rfc822/supermodel.py
index 5e2db4c..af4e312 100644
--- a/plone/rfc822/supermodel.py
+++ b/plone/rfc822/supermodel.py
@@ -6,27 +6,27 @@
     HAVE_SUPERMODEL = False
 
 if HAVE_SUPERMODEL:
-    
+
     from zope.interface import implementer, alsoProvides
     from plone.supermodel.utils import ns
     from plone.rfc822.interfaces import IPrimaryField
-    
+
     @implementer(IFieldMetadataHandler)
     class PrimaryFieldMetadataHandler(object):
         """Define the ``marshal`` namespace.
-        
+
         This lets you write marshal:primary="true" on a field to mark it as
         a primary field.
         """
-        
+
         namespace = "http://namespaces.plone.org/supermodel/marshal"
         prefix = "marshal"
-    
+
         def read(self, fieldNode, schema, field):
             primary = fieldNode.get(ns('primary',  self.namespace))
             if primary is not None and primary.lower() in ("true", "on", "yes", "y", "1"):
                 alsoProvides(field, IPrimaryField)
-    
+
         def write(self, fieldNode, schema, field):
             if IPrimaryField.providedBy(field):
                 fieldNode.set(ns('primary', self.namespace), "true")


Repository: plone.rfc822


Branch: refs/heads/master
Date: 2016-08-02T00:58:42+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.rfc822/commit/af9c57aef858bbcd7ae5af797405daa9803c0171

txt -&gt; rst

Files changed:
A plone/rfc822/fields.rst
A plone/rfc822/message.rst
A plone/rfc822/supermodel.rst
M plone/rfc822/tests.py
D plone/rfc822/fields.txt
D plone/rfc822/message.txt
D plone/rfc822/supermodel.txt

diff --git a/plone/rfc822/fields.rst b/plone/rfc822/fields.rst
new file mode 100644
index 0000000..afb5617
--- /dev/null
+++ b/plone/rfc822/fields.rst
@@ -0,0 +1,503 @@
+Field marshaler tests
+=====================
+
+This test exercises the various standard field marshalers.
+
+First, we load the package's configuration:
+
+    >>> configuration = """\
+    ... <configure
+    ...      xmlns="http://namespaces.zope.org/zope"
+    ...      i18n_domain="plone.rfc822.tests">
+    ...      
+    ...     <include package="zope.component" file="meta.zcml" />
+    ...     <include package="zope.annotation" />
+    ...     
+    ...     <include package="plone.rfc822" />
+    ...     
+    ... </configure>
+    ... """
+
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+Next, we'll create an interface which contains an instance of every field
+we support.
+
+    >>> from zope.interface import Interface
+    >>> from zope import schema
+    >>> from dateutil.tz import tzoffset
+    >>> tz = tzoffset('Europe/Oslo', 3600)
+
+    >>> class ITestContent(Interface):
+    ...     _text = schema.Text()
+    ...     _text2 = schema.Text()
+    ...     _textLine = schema.TextLine()
+    ...     _textLine2 = schema.TextLine()
+    ...     _password = schema.Password()
+    ...     _password2 = schema.Password()
+    ...     _bytes = schema.Bytes()
+    ...     _bytesLine = schema.BytesLine()
+    ...     _ascii = schema.ASCII()
+    ...     _asciiLine = schema.ASCIILine()
+    ...     _uri = schema.URI()
+    ...     _id = schema.Id()
+    ...     _dottedName = schema.DottedName()
+    ...     _bool = schema.Bool()
+    ...     _int = schema.Int()
+    ...     _float = schema.Float()
+    ...     _decimal = schema.Decimal()
+    ...     _choice1 = schema.Choice(values=[u"one", u"two", u"three"])
+    ...     _choice2 = schema.Choice(values=["one", "two", "three"])
+    ...     _datetime = schema.Datetime()
+    ...     _date = schema.Date()
+    ...     _timedelta = schema.Timedelta()
+    ...     _tuple = schema.Tuple(value_type=schema.TextLine())
+    ...     _list = schema.List(value_type=schema.ASCIILine())
+    ...     _set = schema.Set(value_type=schema.Bool())
+    ...     _frozenset = schema.FrozenSet(value_type=schema.Timedelta())
+
+This interface is implemented by a the following class:
+
+    >>> from zope.interface import implements
+    >>> import datetime
+    >>> from decimal import Decimal
+    >>> class TestContent(object):
+    ...     implements(ITestContent)
+    ...     _text = u"text\xd8"
+    ...     _text2 = u"text" # ascii safe
+    ...     _textLine = u"textline\xd8"
+    ...     _textLine2 = u"textline" # ascii safe
+    ...     _password = u"password\xd8"
+    ...     _password2 = u"password" # ascii safe
+    ...     _bytes = 'bytes'
+    ...     _bytesLine = 'bytesline'
+    ...     _ascii = 'ascii'
+    ...     _asciiLine = 'asciiline'
+    ...     _uri = 'http://plone.org'
+    ...     _id = 'some.id'
+    ...     _dottedName = 'dotted.name'
+    ...     _bool = True
+    ...     _int = -10l
+    ...     _float = 0.3
+    ...     _decimal = Decimal("5.0")
+    ...     _choice1 = u"two"
+    ...     _choice2 = 'two'
+    ...     _datetime = datetime.datetime(2009, 1, 2, 15, 10, 5, 1, tz)
+    ...     _date = datetime.date(2008, 2, 3)
+    ...     _timedelta = datetime.timedelta(3, 4, 5)
+    ...     _tuple = (u"one\xd8", u"two")
+    ...     _list = ['three', 'four']
+    ...     _set = set([True, False])
+    ...     _frozenset = frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])
+
+    >>> t = TestContent()
+
+We can now look up the marshaler for each one and test the marshalling and
+extraction methods.
+
+    >>> from zope.component import getMultiAdapter
+    >>> from plone.rfc822.interfaces import IFieldMarshaler
+
+Notes: 
+
+* Unicode \xd8 (capital letter O with stroke) is \xc3\x98 in UTF-8.
+* None of the default marshalers support getContentType(), i.e. they all
+  return None
+* For simplicity, we do not call ``demarshal()`` for each field. For all the
+  standard marshalers, this simply sets the value returned by ``extract()``
+  using the ``set()`` method on the field instance.
+
+Text
+----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_text']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'text\xc3\x98'
+    >>> marshaler.decode('text\xc3\x98')
+    u'text\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    False
+
+Text field types and derivatives will return True for the ``ascii`` property
+if the field value is within the ascii range.
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_text2']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'text'
+    >>> marshaler.decode('text\xc3\x98')
+    u'text\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    True
+
+TextLine
+--------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_textLine']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'textline\xc3\x98'
+    >>> marshaler.decode('textline\xc3\x98')
+    u'textline\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    False
+
+Text field types and derivatives will return True for the ``ascii`` property
+if the field value is within the ascii range.
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_textLine2']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'textline'
+    >>> marshaler.decode('textline\xc3\x98')
+    u'textline\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    True
+
+Password
+--------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_password']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'password\xc3\x98'
+    >>> marshaler.decode('password\xc3\x98')
+    u'password\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    False
+
+Text field types and derivatives will return True for the ``ascii`` property
+if the field value is within the ascii range.
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_password2']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'password'
+    >>> marshaler.decode('password\xc3\x98')
+    u'password\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    True
+
+Bytes
+-----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_bytes']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'bytes'
+    >>> marshaler.decode('bytes')
+    'bytes'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+BytesLine
+---------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_bytesLine']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'bytesline'
+    >>> marshaler.decode('bytesline')
+    'bytesline'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+ASCII
+-----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_ascii']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'ascii'
+    >>> marshaler.decode('ascii')
+    'ascii'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+ASCIILine
+---------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_asciiLine']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'asciiline'
+    >>> marshaler.decode('asciiline')
+    'asciiline'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+URI
+---
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_uri']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'http://plone.org'
+    >>> marshaler.decode('http://plone.org')
+    'http://plone.org'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Id
+--
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_id']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'some.id'
+    >>> marshaler.decode('some.id')
+    'some.id'
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.ascii
+    True
+
+DottedName
+----------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_dottedName']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'dotted.name'
+    >>> marshaler.decode('dotted.name')
+    'dotted.name'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Bool
+----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_bool']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'True'
+    >>> t._bool = False
+    >>> marshaler.marshal()
+    'False'
+    >>> t._bool = True
+    >>> marshaler.decode('True')
+    True
+    >>> marshaler.decode('False')
+    False
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Int
+---
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_int']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '-10'
+    >>> marshaler.decode('-10')
+    -10
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Float
+-----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_float']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '0.3'
+    >>> marshaler.decode('0.25')
+    0.25
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Decimal
+-------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_decimal']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '5.0'
+    >>> marshaler.decode('5.0')
+    Decimal('5.0')
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Choice
+------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_choice1']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'two'
+    >>> marshaler.decode('one')
+    u'one'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    True
+    
+    >>> marshaler = getMultiAdapter((t, ITestContent['_choice2']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'two'
+    >>> marshaler.decode('three')
+    u'three'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    True
+
+Datetime
+--------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_datetime']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '2009-01-02T15:10:05.000001+01:00'
+    >>> marshaler.decode('2009-01-02T15:10:05.000001+01:00')
+    datetime.datetime(2009, 1, 2, 15, 10, 5, 1, tzinfo=tzoffset(None, 3600))
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Date
+----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_date']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '2008-02-03'
+    >>> marshaler.decode('2008-02-03')
+    datetime.date(2008, 2, 3)
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Timedelta
+---------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_timedelta']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '3:4:5'
+    >>> marshaler.decode('3:4:5')
+    datetime.timedelta(3, 4, 5)
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Tuple
+-----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_tuple']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'one\xc3\x98||two'
+    >>> marshaler.decode('one\xc3\x98||two')
+    (u'one\xd8', u'two')
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    False
+
+List
+----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_list']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'three||four'
+    >>> marshaler.decode('three||four')
+    ['three', 'four']
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Set
+---
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_set']), IFieldMarshaler)
+    >>> marshaler.marshal() in ('False||True' or 'True||False',)
+    True
+    >>> marshaler.decode('True||False') == set([True, False])
+    True
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Frozenset
+---------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_frozenset']), IFieldMarshaler)
+    >>> marshaler.marshal() in ('3:4:5||5:4:3', '5:4:3||3:4:5')
+    True
+    >>> marshaler.decode('3:4:5||5:4:3') == frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])
+    True
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
diff --git a/plone/rfc822/fields.txt b/plone/rfc822/fields.txt
deleted file mode 100644
index afb5617..0000000
--- a/plone/rfc822/fields.txt
+++ /dev/null
@@ -1,503 +0,0 @@
-Field marshaler tests
-=====================
-
-This test exercises the various standard field marshalers.
-
-First, we load the package's configuration:
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.rfc822.tests">
-    ...      
-    ...     <include package="zope.component" file="meta.zcml" />
-    ...     <include package="zope.annotation" />
-    ...     
-    ...     <include package="plone.rfc822" />
-    ...     
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-Next, we'll create an interface which contains an instance of every field
-we support.
-
-    >>> from zope.interface import Interface
-    >>> from zope import schema
-    >>> from dateutil.tz import tzoffset
-    >>> tz = tzoffset('Europe/Oslo', 3600)
-
-    >>> class ITestContent(Interface):
-    ...     _text = schema.Text()
-    ...     _text2 = schema.Text()
-    ...     _textLine = schema.TextLine()
-    ...     _textLine2 = schema.TextLine()
-    ...     _password = schema.Password()
-    ...     _password2 = schema.Password()
-    ...     _bytes = schema.Bytes()
-    ...     _bytesLine = schema.BytesLine()
-    ...     _ascii = schema.ASCII()
-    ...     _asciiLine = schema.ASCIILine()
-    ...     _uri = schema.URI()
-    ...     _id = schema.Id()
-    ...     _dottedName = schema.DottedName()
-    ...     _bool = schema.Bool()
-    ...     _int = schema.Int()
-    ...     _float = schema.Float()
-    ...     _decimal = schema.Decimal()
-    ...     _choice1 = schema.Choice(values=[u"one", u"two", u"three"])
-    ...     _choice2 = schema.Choice(values=["one", "two", "three"])
-    ...     _datetime = schema.Datetime()
-    ...     _date = schema.Date()
-    ...     _timedelta = schema.Timedelta()
-    ...     _tuple = schema.Tuple(value_type=schema.TextLine())
-    ...     _list = schema.List(value_type=schema.ASCIILine())
-    ...     _set = schema.Set(value_type=schema.Bool())
-    ...     _frozenset = schema.FrozenSet(value_type=schema.Timedelta())
-
-This interface is implemented by a the following class:
-
-    >>> from zope.interface import implements
-    >>> import datetime
-    >>> from decimal import Decimal
-    >>> class TestContent(object):
-    ...     implements(ITestContent)
-    ...     _text = u"text\xd8"
-    ...     _text2 = u"text" # ascii safe
-    ...     _textLine = u"textline\xd8"
-    ...     _textLine2 = u"textline" # ascii safe
-    ...     _password = u"password\xd8"
-    ...     _password2 = u"password" # ascii safe
-    ...     _bytes = 'bytes'
-    ...     _bytesLine = 'bytesline'
-    ...     _ascii = 'ascii'
-    ...     _asciiLine = 'asciiline'
-    ...     _uri = 'http://plone.org'
-    ...     _id = 'some.id'
-    ...     _dottedName = 'dotted.name'
-    ...     _bool = True
-    ...     _int = -10l
-    ...     _float = 0.3
-    ...     _decimal = Decimal("5.0")
-    ...     _choice1 = u"two"
-    ...     _choice2 = 'two'
-    ...     _datetime = datetime.datetime(2009, 1, 2, 15, 10, 5, 1, tz)
-    ...     _date = datetime.date(2008, 2, 3)
-    ...     _timedelta = datetime.timedelta(3, 4, 5)
-    ...     _tuple = (u"one\xd8", u"two")
-    ...     _list = ['three', 'four']
-    ...     _set = set([True, False])
-    ...     _frozenset = frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])
-
-    >>> t = TestContent()
-
-We can now look up the marshaler for each one and test the marshalling and
-extraction methods.
-
-    >>> from zope.component import getMultiAdapter
-    >>> from plone.rfc822.interfaces import IFieldMarshaler
-
-Notes: 
-
-* Unicode \xd8 (capital letter O with stroke) is \xc3\x98 in UTF-8.
-* None of the default marshalers support getContentType(), i.e. they all
-  return None
-* For simplicity, we do not call ``demarshal()`` for each field. For all the
-  standard marshalers, this simply sets the value returned by ``extract()``
-  using the ``set()`` method on the field instance.
-
-Text
-----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_text']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'text\xc3\x98'
-    >>> marshaler.decode('text\xc3\x98')
-    u'text\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    False
-
-Text field types and derivatives will return True for the ``ascii`` property
-if the field value is within the ascii range.
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_text2']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'text'
-    >>> marshaler.decode('text\xc3\x98')
-    u'text\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    True
-
-TextLine
---------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_textLine']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'textline\xc3\x98'
-    >>> marshaler.decode('textline\xc3\x98')
-    u'textline\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    False
-
-Text field types and derivatives will return True for the ``ascii`` property
-if the field value is within the ascii range.
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_textLine2']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'textline'
-    >>> marshaler.decode('textline\xc3\x98')
-    u'textline\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    True
-
-Password
---------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_password']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'password\xc3\x98'
-    >>> marshaler.decode('password\xc3\x98')
-    u'password\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    False
-
-Text field types and derivatives will return True for the ``ascii`` property
-if the field value is within the ascii range.
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_password2']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'password'
-    >>> marshaler.decode('password\xc3\x98')
-    u'password\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    True
-
-Bytes
------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_bytes']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'bytes'
-    >>> marshaler.decode('bytes')
-    'bytes'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-BytesLine
----------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_bytesLine']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'bytesline'
-    >>> marshaler.decode('bytesline')
-    'bytesline'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-ASCII
------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_ascii']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'ascii'
-    >>> marshaler.decode('ascii')
-    'ascii'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-ASCIILine
----------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_asciiLine']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'asciiline'
-    >>> marshaler.decode('asciiline')
-    'asciiline'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-URI
----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_uri']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'http://plone.org'
-    >>> marshaler.decode('http://plone.org')
-    'http://plone.org'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Id
---
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_id']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'some.id'
-    >>> marshaler.decode('some.id')
-    'some.id'
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.ascii
-    True
-
-DottedName
-----------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_dottedName']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'dotted.name'
-    >>> marshaler.decode('dotted.name')
-    'dotted.name'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Bool
-----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_bool']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'True'
-    >>> t._bool = False
-    >>> marshaler.marshal()
-    'False'
-    >>> t._bool = True
-    >>> marshaler.decode('True')
-    True
-    >>> marshaler.decode('False')
-    False
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Int
----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_int']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '-10'
-    >>> marshaler.decode('-10')
-    -10
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Float
------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_float']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '0.3'
-    >>> marshaler.decode('0.25')
-    0.25
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Decimal
--------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_decimal']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '5.0'
-    >>> marshaler.decode('5.0')
-    Decimal('5.0')
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Choice
-------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_choice1']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'two'
-    >>> marshaler.decode('one')
-    u'one'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    True
-    
-    >>> marshaler = getMultiAdapter((t, ITestContent['_choice2']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'two'
-    >>> marshaler.decode('three')
-    u'three'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    True
-
-Datetime
---------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_datetime']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '2009-01-02T15:10:05.000001+01:00'
-    >>> marshaler.decode('2009-01-02T15:10:05.000001+01:00')
-    datetime.datetime(2009, 1, 2, 15, 10, 5, 1, tzinfo=tzoffset(None, 3600))
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Date
-----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_date']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '2008-02-03'
-    >>> marshaler.decode('2008-02-03')
-    datetime.date(2008, 2, 3)
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Timedelta
----------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_timedelta']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '3:4:5'
-    >>> marshaler.decode('3:4:5')
-    datetime.timedelta(3, 4, 5)
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Tuple
------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_tuple']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'one\xc3\x98||two'
-    >>> marshaler.decode('one\xc3\x98||two')
-    (u'one\xd8', u'two')
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    False
-
-List
-----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_list']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'three||four'
-    >>> marshaler.decode('three||four')
-    ['three', 'four']
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Set
----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_set']), IFieldMarshaler)
-    >>> marshaler.marshal() in ('False||True' or 'True||False',)
-    True
-    >>> marshaler.decode('True||False') == set([True, False])
-    True
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Frozenset
----------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_frozenset']), IFieldMarshaler)
-    >>> marshaler.marshal() in ('3:4:5||5:4:3', '5:4:3||3:4:5')
-    True
-    >>> marshaler.decode('3:4:5||5:4:3') == frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])
-    True
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
diff --git a/plone/rfc822/message.rst b/plone/rfc822/message.rst
new file mode 100644
index 0000000..d44a256
--- /dev/null
+++ b/plone/rfc822/message.rst
@@ -0,0 +1,605 @@
+Message construction and parsing
+================================
+
+This package contains helper methods to construct an RFC 2822 style message
+from a list of schema fields, and to parse a message and initialise an object
+based on its headers and body payload.
+
+Before we begin, let's load the default field marshalers and configure
+annotations, which we will use later in this test.
+
+    >>> configuration = """\
+    ... <configure
+    ...      xmlns="http://namespaces.zope.org/zope"
+    ...      i18n_domain="plone.rfc822.tests">
+    ...      
+    ...     <include package="zope.component" file="meta.zcml" />
+    ...     <include package="zope.annotation" />
+    ...     
+    ...     <include package="plone.rfc822" />
+    ...     
+    ... </configure>
+    ... """
+
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+The primary field
+-----------------
+
+The message body is assumed to originate from a "primary" field, which is
+indicated via a marker interface.
+
+To illustrate the pattern, consider the following schema interface:
+
+    >>> from zope.interface import Interface, alsoProvides
+    >>> from plone.rfc822.interfaces import IPrimaryField
+    >>> from zope import schema
+
+    >>> class ITestContent(Interface):
+    ...
+    ...     title = schema.TextLine(title=u"Title")
+    ...     description = schema.Text(title=u"Description")
+    ...     body = schema.Text(title=u"Body text")
+    ...     emptyfield = schema.TextLine(title=u"Empty field", missing_value=u'missing')
+
+The primary field instance is marked like this:
+
+    >>> alsoProvides(ITestContent['body'], IPrimaryField)
+
+Constructing a message
+----------------------
+
+Let's now say we have an instance providing this interface, which we want to
+marshal to a message.
+
+    >>> from zope.interface import implements
+    >>> class TestContent(object):
+    ...     implements(ITestContent)
+    ...     title = u""
+    ...     description = u""
+    ...     body = u""
+    ...     emptyfield = None
+
+    >>> content = TestContent()
+    >>> content.title = u"Test title"
+    >>> content.description = u"""Test description
+    ... with a newline"""
+    >>> content.body = u"<p>Test body</p>"
+
+We could create a message form this instance and schema like this:
+
+    >>> from plone.rfc822 import constructMessageFromSchema
+    >>> msg = constructMessageFromSchema(content, ITestContent)
+
+The output looks like this:
+
+    >>> from plone.rfc822 import renderMessage
+    >>> print renderMessage(msg)
+    title: Test title
+    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    emptyfield: 
+    Content-Type: text/plain; charset="utf-8"
+    <BLANKLINE>
+    <p>Test body</p>
+
+Notice how the non-ASCII header values are UTF-8 encoded. The encoding
+algorithm is clever enough to only encode the value if it is necessary,
+leaving more readable field values otherwise.
+
+The body here is of the default message type:
+
+    >>> msg.get_default_type()
+    'text/plain'
+
+This is because none of the default field types manage a content type.
+
+The body is also utf-8 encoded, because the primary field specified this
+encoding.
+
+If we want to use a different content type, we could set it explicitly:
+
+    >>> msg.set_type('text/html')
+    >>> print renderMessage(msg)
+    title: Test title
+    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    emptyfield: 
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>Test body</p>
+
+Alternatively, if we know that any ``IText`` field on an object providing
+our ``ITestContent`` interface always stores HTML, could register a custom
+``IFieldMarshaler`` adapter which would indicate this to the message
+constructor. Let's take a look at that now.
+
+Custom marshalers
+-----------------
+
+The default marshaler can be obtained by multi-adapting the content object
+and the field instance to ``IFieldMarshaler``:
+
+    >>> from zope.component import getMultiAdapter
+    >>> from plone.rfc822.interfaces import IFieldMarshaler
+    >>> getMultiAdapter((content, ITestContent['body'],), IFieldMarshaler)
+    <plone.rfc822.defaultfields.UnicodeValueFieldMarshaler object at ...>
+
+Let's now create our own marshaler by extending this class and overriding
+the ``getContentType()``:
+
+    >>> from plone.rfc822.defaultfields import UnicodeValueFieldMarshaler
+    >>> from zope.schema.interfaces import IText
+    >>> from zope.component import adapts
+
+    >>> class TestBodyMarshaler(UnicodeValueFieldMarshaler):
+    ...     adapts(ITestContent, IText)
+    ...     
+    ...     def getContentType(self):
+    ...         return 'text/html'
+
+Ordinarily, we'd register this with ZCML. For the purpose of the test, we'll
+register it using the ``zope.component`` API.
+
+    >>> from zope.component import provideAdapter
+    >>> provideAdapter(TestBodyMarshaler)
+
+Hint: If the schema contained multiple text fields, this adapter would apply
+to all of them. To avoid that, we could either mark the field with a custom
+marker interface (similary to the way we marked a field with ``IPrimaryField``
+above), or have the marshaler check the field name.
+
+Let's now try again:
+
+    >>> msg = constructMessageFromSchema(content, ITestContent)
+    >>> print renderMessage(msg)
+    title: Test title
+    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    emptyfield: 
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>Test body</p>
+
+Notice how the Content-Type has changed.
+
+Consuming a message
+-------------------
+
+A message can be used to initialise an object. The object has to be
+constructed first:
+
+    >>> newContent = TestContent()
+
+We then need to obtain a ``Message`` object. The ``email`` module contains
+helper functions for this purpose.
+
+    >>> messageBody = """\
+    ... title: Test title
+    ... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    ... Content-Type: text/html
+    ...
+    ... <p>Test body</p>"""
+
+    >>> from email import message_from_string
+    >>> msg = message_from_string(messageBody)
+
+The message can now be used to initialise the object according to the given
+schema. This should be the same schema as the one used to construct the
+message.
+
+    >>> from plone.rfc822 import initializeObjectFromSchema
+    >>> initializeObjectFromSchema(newContent, ITestContent, msg)
+
+    >>> newContent.title
+    u'Test title'
+    >>> newContent.description
+    u'Test description\nwith a newline'
+    >>> newContent.body
+    u'<p>Test body</p>'
+
+We can also consume messages with a transfer encoding and a charset:
+
+    >>> messageBody = """\
+    ... title: =?utf-8?q?Test_title?=
+    ... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    ... emptyfield: 
+    ... Content-Transfer-Encoding: base64
+    ... Content-Type: text/html; charset="utf-8"
+    ... <BLANKLINE>
+    ... PHA+VGVzdCBib2R5PC9wPg==
+    ... <BLANKLINE>"""
+
+    >>> msg = message_from_string(messageBody)
+    >>> msg.get_content_type()
+    'text/html'
+    >>> msg.get_content_charset()
+    'utf-8'
+    
+    >>> initializeObjectFromSchema(newContent, ITestContent, msg)
+
+    >>> newContent.title
+    u'Test title'
+    >>> newContent.description
+    u'Test description\nwith a newline'
+    >>> newContent.body
+    u'<p>Test body</p>'
+
+Note: Empty fields will result in the field's ``missing_value`` being used:
+
+    >>> newContent.emptyfield
+    u'missing'
+
+Handling multiple primary fields and duplicate field names
+----------------------------------------------------------
+
+It is possible that our type could have multiple primary fields or even
+duplicate field names.
+
+For example, consider the following schema interface, intended to be used
+in an annotation adapter:
+
+    >>> class IPersonalDetails(Interface):
+    ...     description = schema.Text(title=u"Personal description")
+    ...     currentAge = schema.Int(title=u"Age", min=0)
+    ...     personalProfile = schema.Text(title=u"Profile")
+    
+    >>> alsoProvides(IPersonalDetails['personalProfile'], IPrimaryField)
+    
+The annotation storage would look like this:
+
+    >>> from persistent import Persistent
+    >>> class PersonalDetailsAnnotation(Persistent):
+    ...     implements(IPersonalDetails)
+    ...     adapts(ITestContent)
+    ...     
+    ...     def __init__(self):
+    ...         self.description = None
+    ...         self.currentAge = None
+    ...         self.personalProfile = None
+
+    >>> from zope.annotation.factory import factory
+    >>> provideAdapter(factory(PersonalDetailsAnnotation))
+
+We should now be able to adapt a content instance to IPersonalDetails,
+provided it is annotatable.
+
+    >>> from zope.annotation.interfaces import IAttributeAnnotatable
+    >>> alsoProvides(content, IAttributeAnnotatable)
+
+    >>> personalDetails = IPersonalDetails(content)
+    >>> personalDetails.description = u"<p>My description</p>"
+    >>> personalDetails.currentAge = 21
+    >>> personalDetails.personalProfile = u"<p>My profile</p>"
+
+The default marshalers will attempt to adapt the context to the schema of
+a given field before getting or setting a value. If we pass multiple schemata
+(or a combined sequence of fields) to the message constructor, it will
+handle both duplicate field names (as duplicate headers) and multiple primary
+fields (as multipart message attachments).
+
+Here are the fields it will see:
+
+    >>> from zope.schema import getFieldsInOrder
+    >>> allFields = getFieldsInOrder(ITestContent) + \
+    ...             getFieldsInOrder(IPersonalDetails)
+
+    >>> [f[0] for f in allFields]
+    ['title', 'description', 'body', 'emptyfield', 'description', 'currentAge', 'personalProfile']
+
+    >>> [f[0] for f in allFields if IPrimaryField.providedBy(f[1])]
+    ['body', 'personalProfile']
+
+Let's now construct a message. Since we now have two fields called 
+``description``, we will get two headers by that name. Since we have two
+primary fields, we will get a multipart message with two attachments.
+
+    >>> from plone.rfc822 import constructMessageFromSchemata
+    >>> msg = constructMessageFromSchemata(content, (ITestContent, IPersonalDetails,))
+    >>> msgString = renderMessage(msg)
+    >>> print msgString
+    title: Test title
+    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    emptyfield: 
+    description: <p>My description</p>
+    currentAge: 21
+    MIME-Version: 1.0
+    Content-Type: multipart/mixed; boundary="===============...=="
+    <BLANKLINE>
+    --===============...==
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>Test body</p>
+    --===============...==
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>My profile</p>
+    --===============...==--...
+
+(Note that we've used ellipses here for the doctest to work with the generated
+boundary string).
+
+Notice how both messages have a MIME type of 'text/html' and no charset.
+That is because of the custom adapter for ``(ITestContent, IText)`` which we
+registered earlier.
+
+We can obviously read this message as well. Note that in this case, the order
+of fields passed to ``initializeObject()`` is important, both to determine
+which field gets which ``description`` header, and to match the two
+attachments to the two primary fields:
+
+    >>> newContent = TestContent()
+    >>> alsoProvides(newContent, IAttributeAnnotatable)
+
+    >>> from plone.rfc822 import initializeObjectFromSchemata
+    >>> msg = message_from_string(msgString)
+    >>> initializeObjectFromSchemata(newContent, [ITestContent, IPersonalDetails], msg)
+
+    >>> newContent.title
+    u'Test title'
+    
+    >>> newContent.description
+    u'Test description\nwith a newline'
+
+    >>> newContent.body
+    u'<p>Test body</p>'
+
+    >>> newPersonalDetails = IPersonalDetails(newContent)
+    >>> newPersonalDetails.description
+    u'<p>My description</p>'
+
+    >>> newPersonalDetails.currentAge
+    21
+    
+    >>> newPersonalDetails.personalProfile
+    u'<p>My profile</p>'
+    
+Alternative ways to deal with multiple schemata
+-----------------------------------------------
+
+In the example above, we created a single enveloping message with headers
+corresponding to the fields in both our schemata, and only the primary fields
+separated out into different attached payloads.
+
+An alternative approach would be to separate each schema out into its
+own multipart message. To do that, we would simply use the
+``constructMessage()`` function multiple times.
+
+    >>> mainMessage = constructMessageFromSchema(content, ITestContent)
+    >>> personalDetailsMessage = constructMessageFromSchema(content, IPersonalDetails)
+
+    >>> from email.MIMEMultipart import MIMEMultipart
+    >>> envelope = MIMEMultipart()
+    >>> envelope.attach(mainMessage)
+    >>> envelope.attach(personalDetailsMessage)
+
+    >>> envelopeString = renderMessage(envelope)
+    >>> print envelopeString
+    Content-Type: multipart/mixed; boundary="===============...=="
+    MIME-Version: 1.0
+    <BLANKLINE>
+    --===============...==
+    title: Test title
+    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    emptyfield: 
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>Test body</p>
+    --===============...==
+    description: <p>My description</p>
+    currentAge: 21
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>My profile</p>
+    --===============...==--...
+
+Which approach works best will depend largely on the intended recipient of
+the message.
+
+Encoding the payload and handling filenames
+-------------------------------------------
+
+Finally, let's consider a more complex example, inspired by the field
+marshaler in ``plone.namedfile``.
+
+Let's say we have a value type intended to represent a binary file with a
+filename and content type:
+
+    >>> from zope.interface import Interface, implements
+    >>> from zope import schema
+    
+    >>> class IFileValue(Interface):
+    ...     data = schema.Bytes(title=u"Raw data")
+    ...     contentType = schema.ASCIILine(title=u"MIME type")
+    ...     filename = schema.ASCIILine(title=u"Filename")
+
+    >>> class FileValue(object):
+    ...     implements(IFileValue)
+    ...     def __init__(self, data, contentType, filename):
+    ...         self.data = data
+    ...         self.contentType = contentType
+    ...         self.filename = filename
+
+Suppose we had a custom field type to represent this:
+
+    >>> from zope.schema.interfaces import IObject
+    >>> class IFileField(IObject):
+    ...     pass
+
+    >>> class FileField(schema.Object):
+    ...     implements(IFileField)
+    ...     schema = IFileValue
+    ...     def __init__(self, **kw):
+    ...         if 'schema' in kw:
+    ...             self.schema = kw.pop('schema')
+    ...         super(FileField, self).__init__(schema=self.schema, **kw)
+
+We can register a field marshaler for this field which will do the following:
+
+* Insist that the field is only used as a primary field, since it makes
+  little sense to encode a binary file in a header.
+* Save the filename in a Content-Disposition header.
+* Be capable of reading the filename again from this header.
+* Encode the payload using base64
+
+    >>> from plone.rfc822.interfaces import IFieldMarshaler
+    >>> from email.Encoders import encode_base64
+
+    >>> from zope.component import adapts
+    >>> from plone.rfc822.defaultfields import BaseFieldMarshaler
+    
+    >>> class FileFieldMarshaler(BaseFieldMarshaler):
+    ...     adapts(Interface, IFileField)
+    ...
+    ...     ascii = False
+    ...
+    ...     def encode(self, value, charset='utf-8', primary=False):
+    ...         if not primary:
+    ...             raise ValueError("File field cannot be marshaled as a non-primary field")
+    ...         if value is None:
+    ...             return None
+    ...         return value.data
+    ...     
+    ...     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+    ...         filename = None
+    ...         # get the filename from the Content-Disposition header if possible
+    ...         if primary and message is not None:
+    ...             filename = message.get_filename(None)
+    ...         return FileValue(value, contentType, filename)
+    ...     
+    ...     def getContentType(self):
+    ...         value = self._query()
+    ...         if value is None:
+    ...             return None
+    ...         return value.contentType
+    ...
+    ...     def getCharset(self, default='utf-8'):
+    ...         return None # this is not text data!
+    ...
+    ...     def postProcessMessage(self, message):
+    ...         value = self._query()
+    ...         if value is not None:
+    ...             filename = value.filename
+    ...             if filename:
+    ...                 # Add a new header storing the filename if we have one
+    ...                 message.add_header('Content-Disposition', 'attachment', filename=filename)
+    ...         # Apply base64 encoding
+    ...         encode_base64(message)
+    
+    >>> from zope.component import provideAdapter
+    >>> provideAdapter(FileFieldMarshaler)
+
+To illustrate marshaling, let's create a content object that contains two file
+fields.
+    
+    >>> class IFileContent(Interface):
+    ...     file1 = FileField()
+    ...     file2 = FileField()
+
+    >>> class FileContent(object):
+    ...     implements(IFileContent)
+    ...     file1 = None
+    ...     file2 = None
+
+    >>> fileContent = FileContent()
+    >>> fileContent.file1 = FileValue('dummy file', 'text/plain', 'dummy1.txt')
+    >>> fileContent.file2 = FileValue('<html><body>test</body></html>', 'text/html', 'dummy2.html')
+
+At this point, neither of these fields is marked as a primary field. Let's see
+what happens when we attempt to construct a message from this schema.
+
+    >>> from plone.rfc822 import constructMessageFromSchema
+    >>> message = constructMessageFromSchema(fileContent, IFileContent)
+    >>> print renderMessage(message)
+    <BLANKLINE>
+    <BLANKLINE>
+
+As expected, we got no message headers and no message body. Let's now mark one
+field as primary:
+
+    >>> from plone.rfc822.interfaces import IPrimaryField
+    >>> from zope.interface import alsoProvides
+    >>> alsoProvides(IFileContent['file1'], IPrimaryField)
+    
+    >>> message = constructMessageFromSchema(fileContent, IFileContent)
+    >>> messageBody = renderMessage(message)
+    >>> print messageBody
+    MIME-Version: 1.0
+    Content-Type: text/plain
+    Content-Disposition: attachment; filename="dummy1.txt"
+    Content-Transfer-Encoding: base64
+    <BLANKLINE>
+    ZHVtbXkgZmlsZQ==
+
+Here, we have a base64 encoded payload, a Content-Disposition header, and a
+Content-Type header according to the primary field.
+
+We can also reconstruct the object from this message.
+
+    >>> from plone.rfc822 import initializeObjectFromSchema
+    >>> from email import message_from_string
+    
+    >>> inputMessage = message_from_string(messageBody)
+    >>> newFileContent = FileContent()
+    >>> initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)
+    
+    >>> newFileContent.file1.data
+    'dummy file'
+    >>> newFileContent.file1.contentType
+    'text/plain'
+    >>> newFileContent.file1.filename
+    'dummy1.txt'
+
+    >>> newFileContent.file2 is None
+    True
+
+Let's now show what would happen if we encoded both files in the message.
+In this case, we should get a multipart document with two payloads.
+
+    >>> alsoProvides(IFileContent['file2'], IPrimaryField)
+    >>> message = constructMessageFromSchema(fileContent, IFileContent)
+    >>> messageBody = renderMessage(message)
+    >>> print messageBody # doctest: +ELLIPSIS
+    MIME-Version: 1.0
+    Content-Type: multipart/mixed; boundary="===============...=="
+    <BLANKLINE>
+    --===============...==
+    MIME-Version: 1.0
+    Content-Type: text/plain
+    Content-Disposition: attachment; filename="dummy1.txt"
+    Content-Transfer-Encoding: base64
+    <BLANKLINE>
+    ZHVtbXkgZmlsZQ==
+    --===============...==
+    MIME-Version: 1.0
+    Content-Type: text/html
+    Content-Disposition: attachment; filename="dummy2.html"
+    Content-Transfer-Encoding: base64
+    <BLANKLINE>
+    PGh0bWw+PGJvZHk+dGVzdDwvYm9keT48L2h0bWw+
+    --===============...==--...
+
+And again, we can reconstruct the object, this time with both fields:
+
+    >>> inputMessage = message_from_string(messageBody)
+    >>> newFileContent = FileContent()
+    >>> initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)
+    
+    >>> newFileContent.file1.data
+    'dummy file'
+    >>> newFileContent.file1.contentType
+    'text/plain'
+    >>> newFileContent.file1.filename
+    'dummy1.txt'
+
+    >>> newFileContent.file2.data
+    '<html><body>test</body></html>'
+    >>> newFileContent.file2.contentType
+    'text/html'
+    >>> newFileContent.file2.filename
+    'dummy2.html'
diff --git a/plone/rfc822/message.txt b/plone/rfc822/message.txt
deleted file mode 100644
index d44a256..0000000
--- a/plone/rfc822/message.txt
+++ /dev/null
@@ -1,605 +0,0 @@
-Message construction and parsing
-================================
-
-This package contains helper methods to construct an RFC 2822 style message
-from a list of schema fields, and to parse a message and initialise an object
-based on its headers and body payload.
-
-Before we begin, let's load the default field marshalers and configure
-annotations, which we will use later in this test.
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.rfc822.tests">
-    ...      
-    ...     <include package="zope.component" file="meta.zcml" />
-    ...     <include package="zope.annotation" />
-    ...     
-    ...     <include package="plone.rfc822" />
-    ...     
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-The primary field
------------------
-
-The message body is assumed to originate from a "primary" field, which is
-indicated via a marker interface.
-
-To illustrate the pattern, consider the following schema interface:
-
-    >>> from zope.interface import Interface, alsoProvides
-    >>> from plone.rfc822.interfaces import IPrimaryField
-    >>> from zope import schema
-
-    >>> class ITestContent(Interface):
-    ...
-    ...     title = schema.TextLine(title=u"Title")
-    ...     description = schema.Text(title=u"Description")
-    ...     body = schema.Text(title=u"Body text")
-    ...     emptyfield = schema.TextLine(title=u"Empty field", missing_value=u'missing')
-
-The primary field instance is marked like this:
-
-    >>> alsoProvides(ITestContent['body'], IPrimaryField)
-
-Constructing a message
-----------------------
-
-Let's now say we have an instance providing this interface, which we want to
-marshal to a message.
-
-    >>> from zope.interface import implements
-    >>> class TestContent(object):
-    ...     implements(ITestContent)
-    ...     title = u""
-    ...     description = u""
-    ...     body = u""
-    ...     emptyfield = None
-
-    >>> content = TestContent()
-    >>> content.title = u"Test title"
-    >>> content.description = u"""Test description
-    ... with a newline"""
-    >>> content.body = u"<p>Test body</p>"
-
-We could create a message form this instance and schema like this:
-
-    >>> from plone.rfc822 import constructMessageFromSchema
-    >>> msg = constructMessageFromSchema(content, ITestContent)
-
-The output looks like this:
-
-    >>> from plone.rfc822 import renderMessage
-    >>> print renderMessage(msg)
-    title: Test title
-    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    emptyfield: 
-    Content-Type: text/plain; charset="utf-8"
-    <BLANKLINE>
-    <p>Test body</p>
-
-Notice how the non-ASCII header values are UTF-8 encoded. The encoding
-algorithm is clever enough to only encode the value if it is necessary,
-leaving more readable field values otherwise.
-
-The body here is of the default message type:
-
-    >>> msg.get_default_type()
-    'text/plain'
-
-This is because none of the default field types manage a content type.
-
-The body is also utf-8 encoded, because the primary field specified this
-encoding.
-
-If we want to use a different content type, we could set it explicitly:
-
-    >>> msg.set_type('text/html')
-    >>> print renderMessage(msg)
-    title: Test title
-    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    emptyfield: 
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>Test body</p>
-
-Alternatively, if we know that any ``IText`` field on an object providing
-our ``ITestContent`` interface always stores HTML, could register a custom
-``IFieldMarshaler`` adapter which would indicate this to the message
-constructor. Let's take a look at that now.
-
-Custom marshalers
------------------
-
-The default marshaler can be obtained by multi-adapting the content object
-and the field instance to ``IFieldMarshaler``:
-
-    >>> from zope.component import getMultiAdapter
-    >>> from plone.rfc822.interfaces import IFieldMarshaler
-    >>> getMultiAdapter((content, ITestContent['body'],), IFieldMarshaler)
-    <plone.rfc822.defaultfields.UnicodeValueFieldMarshaler object at ...>
-
-Let's now create our own marshaler by extending this class and overriding
-the ``getContentType()``:
-
-    >>> from plone.rfc822.defaultfields import UnicodeValueFieldMarshaler
-    >>> from zope.schema.interfaces import IText
-    >>> from zope.component import adapts
-
-    >>> class TestBodyMarshaler(UnicodeValueFieldMarshaler):
-    ...     adapts(ITestContent, IText)
-    ...     
-    ...     def getContentType(self):
-    ...         return 'text/html'
-
-Ordinarily, we'd register this with ZCML. For the purpose of the test, we'll
-register it using the ``zope.component`` API.
-
-    >>> from zope.component import provideAdapter
-    >>> provideAdapter(TestBodyMarshaler)
-
-Hint: If the schema contained multiple text fields, this adapter would apply
-to all of them. To avoid that, we could either mark the field with a custom
-marker interface (similary to the way we marked a field with ``IPrimaryField``
-above), or have the marshaler check the field name.
-
-Let's now try again:
-
-    >>> msg = constructMessageFromSchema(content, ITestContent)
-    >>> print renderMessage(msg)
-    title: Test title
-    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    emptyfield: 
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>Test body</p>
-
-Notice how the Content-Type has changed.
-
-Consuming a message
--------------------
-
-A message can be used to initialise an object. The object has to be
-constructed first:
-
-    >>> newContent = TestContent()
-
-We then need to obtain a ``Message`` object. The ``email`` module contains
-helper functions for this purpose.
-
-    >>> messageBody = """\
-    ... title: Test title
-    ... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    ... Content-Type: text/html
-    ...
-    ... <p>Test body</p>"""
-
-    >>> from email import message_from_string
-    >>> msg = message_from_string(messageBody)
-
-The message can now be used to initialise the object according to the given
-schema. This should be the same schema as the one used to construct the
-message.
-
-    >>> from plone.rfc822 import initializeObjectFromSchema
-    >>> initializeObjectFromSchema(newContent, ITestContent, msg)
-
-    >>> newContent.title
-    u'Test title'
-    >>> newContent.description
-    u'Test description\nwith a newline'
-    >>> newContent.body
-    u'<p>Test body</p>'
-
-We can also consume messages with a transfer encoding and a charset:
-
-    >>> messageBody = """\
-    ... title: =?utf-8?q?Test_title?=
-    ... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    ... emptyfield: 
-    ... Content-Transfer-Encoding: base64
-    ... Content-Type: text/html; charset="utf-8"
-    ... <BLANKLINE>
-    ... PHA+VGVzdCBib2R5PC9wPg==
-    ... <BLANKLINE>"""
-
-    >>> msg = message_from_string(messageBody)
-    >>> msg.get_content_type()
-    'text/html'
-    >>> msg.get_content_charset()
-    'utf-8'
-    
-    >>> initializeObjectFromSchema(newContent, ITestContent, msg)
-
-    >>> newContent.title
-    u'Test title'
-    >>> newContent.description
-    u'Test description\nwith a newline'
-    >>> newContent.body
-    u'<p>Test body</p>'
-
-Note: Empty fields will result in the field's ``missing_value`` being used:
-
-    >>> newContent.emptyfield
-    u'missing'
-
-Handling multiple primary fields and duplicate field names
-----------------------------------------------------------
-
-It is possible that our type could have multiple primary fields or even
-duplicate field names.
-
-For example, consider the following schema interface, intended to be used
-in an annotation adapter:
-
-    >>> class IPersonalDetails(Interface):
-    ...     description = schema.Text(title=u"Personal description")
-    ...     currentAge = schema.Int(title=u"Age", min=0)
-    ...     personalProfile = schema.Text(title=u"Profile")
-    
-    >>> alsoProvides(IPersonalDetails['personalProfile'], IPrimaryField)
-    
-The annotation storage would look like this:
-
-    >>> from persistent import Persistent
-    >>> class PersonalDetailsAnnotation(Persistent):
-    ...     implements(IPersonalDetails)
-    ...     adapts(ITestContent)
-    ...     
-    ...     def __init__(self):
-    ...         self.description = None
-    ...         self.currentAge = None
-    ...         self.personalProfile = None
-
-    >>> from zope.annotation.factory import factory
-    >>> provideAdapter(factory(PersonalDetailsAnnotation))
-
-We should now be able to adapt a content instance to IPersonalDetails,
-provided it is annotatable.
-
-    >>> from zope.annotation.interfaces import IAttributeAnnotatable
-    >>> alsoProvides(content, IAttributeAnnotatable)
-
-    >>> personalDetails = IPersonalDetails(content)
-    >>> personalDetails.description = u"<p>My description</p>"
-    >>> personalDetails.currentAge = 21
-    >>> personalDetails.personalProfile = u"<p>My profile</p>"
-
-The default marshalers will attempt to adapt the context to the schema of
-a given field before getting or setting a value. If we pass multiple schemata
-(or a combined sequence of fields) to the message constructor, it will
-handle both duplicate field names (as duplicate headers) and multiple primary
-fields (as multipart message attachments).
-
-Here are the fields it will see:
-
-    >>> from zope.schema import getFieldsInOrder
-    >>> allFields = getFieldsInOrder(ITestContent) + \
-    ...             getFieldsInOrder(IPersonalDetails)
-
-    >>> [f[0] for f in allFields]
-    ['title', 'description', 'body', 'emptyfield', 'description', 'currentAge', 'personalProfile']
-
-    >>> [f[0] for f in allFields if IPrimaryField.providedBy(f[1])]
-    ['body', 'personalProfile']
-
-Let's now construct a message. Since we now have two fields called 
-``description``, we will get two headers by that name. Since we have two
-primary fields, we will get a multipart message with two attachments.
-
-    >>> from plone.rfc822 import constructMessageFromSchemata
-    >>> msg = constructMessageFromSchemata(content, (ITestContent, IPersonalDetails,))
-    >>> msgString = renderMessage(msg)
-    >>> print msgString
-    title: Test title
-    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    emptyfield: 
-    description: <p>My description</p>
-    currentAge: 21
-    MIME-Version: 1.0
-    Content-Type: multipart/mixed; boundary="===============...=="
-    <BLANKLINE>
-    --===============...==
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>Test body</p>
-    --===============...==
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>My profile</p>
-    --===============...==--...
-
-(Note that we've used ellipses here for the doctest to work with the generated
-boundary string).
-
-Notice how both messages have a MIME type of 'text/html' and no charset.
-That is because of the custom adapter for ``(ITestContent, IText)`` which we
-registered earlier.
-
-We can obviously read this message as well. Note that in this case, the order
-of fields passed to ``initializeObject()`` is important, both to determine
-which field gets which ``description`` header, and to match the two
-attachments to the two primary fields:
-
-    >>> newContent = TestContent()
-    >>> alsoProvides(newContent, IAttributeAnnotatable)
-
-    >>> from plone.rfc822 import initializeObjectFromSchemata
-    >>> msg = message_from_string(msgString)
-    >>> initializeObjectFromSchemata(newContent, [ITestContent, IPersonalDetails], msg)
-
-    >>> newContent.title
-    u'Test title'
-    
-    >>> newContent.description
-    u'Test description\nwith a newline'
-
-    >>> newContent.body
-    u'<p>Test body</p>'
-
-    >>> newPersonalDetails = IPersonalDetails(newContent)
-    >>> newPersonalDetails.description
-    u'<p>My description</p>'
-
-    >>> newPersonalDetails.currentAge
-    21
-    
-    >>> newPersonalDetails.personalProfile
-    u'<p>My profile</p>'
-    
-Alternative ways to deal with multiple schemata
------------------------------------------------
-
-In the example above, we created a single enveloping message with headers
-corresponding to the fields in both our schemata, and only the primary fields
-separated out into different attached payloads.
-
-An alternative approach would be to separate each schema out into its
-own multipart message. To do that, we would simply use the
-``constructMessage()`` function multiple times.
-
-    >>> mainMessage = constructMessageFromSchema(content, ITestContent)
-    >>> personalDetailsMessage = constructMessageFromSchema(content, IPersonalDetails)
-
-    >>> from email.MIMEMultipart import MIMEMultipart
-    >>> envelope = MIMEMultipart()
-    >>> envelope.attach(mainMessage)
-    >>> envelope.attach(personalDetailsMessage)
-
-    >>> envelopeString = renderMessage(envelope)
-    >>> print envelopeString
-    Content-Type: multipart/mixed; boundary="===============...=="
-    MIME-Version: 1.0
-    <BLANKLINE>
-    --===============...==
-    title: Test title
-    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    emptyfield: 
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>Test body</p>
-    --===============...==
-    description: <p>My description</p>
-    currentAge: 21
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>My profile</p>
-    --===============...==--...
-
-Which approach works best will depend largely on the intended recipient of
-the message.
-
-Encoding the payload and handling filenames
--------------------------------------------
-
-Finally, let's consider a more complex example, inspired by the field
-marshaler in ``plone.namedfile``.
-
-Let's say we have a value type intended to represent a binary file with a
-filename and content type:
-
-    >>> from zope.interface import Interface, implements
-    >>> from zope import schema
-    
-    >>> class IFileValue(Interface):
-    ...     data = schema.Bytes(title=u"Raw data")
-    ...     contentType = schema.ASCIILine(title=u"MIME type")
-    ...     filename = schema.ASCIILine(title=u"Filename")
-
-    >>> class FileValue(object):
-    ...     implements(IFileValue)
-    ...     def __init__(self, data, contentType, filename):
-    ...         self.data = data
-    ...         self.contentType = contentType
-    ...         self.filename = filename
-
-Suppose we had a custom field type to represent this:
-
-    >>> from zope.schema.interfaces import IObject
-    >>> class IFileField(IObject):
-    ...     pass
-
-    >>> class FileField(schema.Object):
-    ...     implements(IFileField)
-    ...     schema = IFileValue
-    ...     def __init__(self, **kw):
-    ...         if 'schema' in kw:
-    ...             self.schema = kw.pop('schema')
-    ...         super(FileField, self).__init__(schema=self.schema, **kw)
-
-We can register a field marshaler for this field which will do the following:
-
-* Insist that the field is only used as a primary field, since it makes
-  little sense to encode a binary file in a header.
-* Save the filename in a Content-Disposition header.
-* Be capable of reading the filename again from this header.
-* Encode the payload using base64
-
-    >>> from plone.rfc822.interfaces import IFieldMarshaler
-    >>> from email.Encoders import encode_base64
-
-    >>> from zope.component import adapts
-    >>> from plone.rfc822.defaultfields import BaseFieldMarshaler
-    
-    >>> class FileFieldMarshaler(BaseFieldMarshaler):
-    ...     adapts(Interface, IFileField)
-    ...
-    ...     ascii = False
-    ...
-    ...     def encode(self, value, charset='utf-8', primary=False):
-    ...         if not primary:
-    ...             raise ValueError("File field cannot be marshaled as a non-primary field")
-    ...         if value is None:
-    ...             return None
-    ...         return value.data
-    ...     
-    ...     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
-    ...         filename = None
-    ...         # get the filename from the Content-Disposition header if possible
-    ...         if primary and message is not None:
-    ...             filename = message.get_filename(None)
-    ...         return FileValue(value, contentType, filename)
-    ...     
-    ...     def getContentType(self):
-    ...         value = self._query()
-    ...         if value is None:
-    ...             return None
-    ...         return value.contentType
-    ...
-    ...     def getCharset(self, default='utf-8'):
-    ...         return None # this is not text data!
-    ...
-    ...     def postProcessMessage(self, message):
-    ...         value = self._query()
-    ...         if value is not None:
-    ...             filename = value.filename
-    ...             if filename:
-    ...                 # Add a new header storing the filename if we have one
-    ...                 message.add_header('Content-Disposition', 'attachment', filename=filename)
-    ...         # Apply base64 encoding
-    ...         encode_base64(message)
-    
-    >>> from zope.component import provideAdapter
-    >>> provideAdapter(FileFieldMarshaler)
-
-To illustrate marshaling, let's create a content object that contains two file
-fields.
-    
-    >>> class IFileContent(Interface):
-    ...     file1 = FileField()
-    ...     file2 = FileField()
-
-    >>> class FileContent(object):
-    ...     implements(IFileContent)
-    ...     file1 = None
-    ...     file2 = None
-
-    >>> fileContent = FileContent()
-    >>> fileContent.file1 = FileValue('dummy file', 'text/plain', 'dummy1.txt')
-    >>> fileContent.file2 = FileValue('<html><body>test</body></html>', 'text/html', 'dummy2.html')
-
-At this point, neither of these fields is marked as a primary field. Let's see
-what happens when we attempt to construct a message from this schema.
-
-    >>> from plone.rfc822 import constructMessageFromSchema
-    >>> message = constructMessageFromSchema(fileContent, IFileContent)
-    >>> print renderMessage(message)
-    <BLANKLINE>
-    <BLANKLINE>
-
-As expected, we got no message headers and no message body. Let's now mark one
-field as primary:
-
-    >>> from plone.rfc822.interfaces import IPrimaryField
-    >>> from zope.interface import alsoProvides
-    >>> alsoProvides(IFileContent['file1'], IPrimaryField)
-    
-    >>> message = constructMessageFromSchema(fileContent, IFileContent)
-    >>> messageBody = renderMessage(message)
-    >>> print messageBody
-    MIME-Version: 1.0
-    Content-Type: text/plain
-    Content-Disposition: attachment; filename="dummy1.txt"
-    Content-Transfer-Encoding: base64
-    <BLANKLINE>
-    ZHVtbXkgZmlsZQ==
-
-Here, we have a base64 encoded payload, a Content-Disposition header, and a
-Content-Type header according to the primary field.
-
-We can also reconstruct the object from this message.
-
-    >>> from plone.rfc822 import initializeObjectFromSchema
-    >>> from email import message_from_string
-    
-    >>> inputMessage = message_from_string(messageBody)
-    >>> newFileContent = FileContent()
-    >>> initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)
-    
-    >>> newFileContent.file1.data
-    'dummy file'
-    >>> newFileContent.file1.contentType
-    'text/plain'
-    >>> newFileContent.file1.filename
-    'dummy1.txt'
-
-    >>> newFileContent.file2 is None
-    True
-
-Let's now show what would happen if we encoded both files in the message.
-In this case, we should get a multipart document with two payloads.
-
-    >>> alsoProvides(IFileContent['file2'], IPrimaryField)
-    >>> message = constructMessageFromSchema(fileContent, IFileContent)
-    >>> messageBody = renderMessage(message)
-    >>> print messageBody # doctest: +ELLIPSIS
-    MIME-Version: 1.0
-    Content-Type: multipart/mixed; boundary="===============...=="
-    <BLANKLINE>
-    --===============...==
-    MIME-Version: 1.0
-    Content-Type: text/plain
-    Content-Disposition: attachment; filename="dummy1.txt"
-    Content-Transfer-Encoding: base64
-    <BLANKLINE>
-    ZHVtbXkgZmlsZQ==
-    --===============...==
-    MIME-Version: 1.0
-    Content-Type: text/html
-    Content-Disposition: attachment; filename="dummy2.html"
-    Content-Transfer-Encoding: base64
-    <BLANKLINE>
-    PGh0bWw+PGJvZHk+dGVzdDwvYm9keT48L2h0bWw+
-    --===============...==--...
-
-And again, we can reconstruct the object, this time with both fields:
-
-    >>> inputMessage = message_from_string(messageBody)
-    >>> newFileContent = FileContent()
-    >>> initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)
-    
-    >>> newFileContent.file1.data
-    'dummy file'
-    >>> newFileContent.file1.contentType
-    'text/plain'
-    >>> newFileContent.file1.filename
-    'dummy1.txt'
-
-    >>> newFileContent.file2.data
-    '<html><body>test</body></html>'
-    >>> newFileContent.file2.contentType
-    'text/html'
-    >>> newFileContent.file2.filename
-    'dummy2.html'
diff --git a/plone/rfc822/supermodel.rst b/plone/rfc822/supermodel.rst
new file mode 100644
index 0000000..ba726b6
--- /dev/null
+++ b/plone/rfc822/supermodel.rst
@@ -0,0 +1,76 @@
+Supermodel handler
+==================
+
+This package contains a handler for the ``marshal`` ``plone.supermodel``
+namespace, which can be used to mark the primary field of a schema.
+
+This handler is installed so long as ``plone.supermodel`` is installed.
+
+First, let's load this package's ZCML so that we can run the tests:
+
+    >>> configuration = """\
+    ... <configure xmlns="http://namespaces.zope.org/zope">
+    ...
+    ...     <include package="Products.Five" file="configure.zcml" />
+    ...     <include package="plone.supermodel" />
+    ...     <include package="plone.rfc822" />
+    ...
+    ... </configure>
+    ... """
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+Next, let's define a sample model that exercises the 'marshal' attribute.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
+    ...        xmlns:marshal="http://namespaces.plone.org/supermodel/marshal">
+    ...     <schema>
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title>title</title>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="body" marshal:primary="true">
+    ...             <title>Body</title>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+We can load this using plone.supermodel:
+
+    >>> from plone.supermodel import loadString
+    >>> model = loadString(schema)
+
+The ``body`` field should now be marked with the ``IPrimaryField`` marker:
+
+    >>> from plone.rfc822.interfaces import IPrimaryField
+    >>> schema = model.schema
+    >>> IPrimaryField.providedBy(schema['title'])
+    False
+    >>> IPrimaryField.providedBy(schema['body'])
+    True
+
+Naturally, we can also write out the primary field attribute from an interface
+on which it is marked:
+
+    >>> from zope.interface import Interface, alsoProvides
+    >>> from zope import schema
+    >>> class ITestSchema(Interface):
+    ...     title = schema.TextLine(title=u"Title")
+    ...     body = schema.Text(title=u"Body")
+    >>> alsoProvides(ITestSchema['body'], IPrimaryField)
+
+    >>> from plone.supermodel import serializeSchema
+    >>> print serializeSchema(ITestSchema) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:marshal="http://namespaces.plone.org/supermodel/marshal" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema based-on="zope.interface.Interface">
+        <field name="title" type="zope.schema.TextLine">
+          <title>Title</title>
+        </field>
+        <field name="body" type="zope.schema.Text" marshal:primary="true">
+          <title>Body</title>
+        </field>
+      </schema>
+    </model>
diff --git a/plone/rfc822/supermodel.txt b/plone/rfc822/supermodel.txt
deleted file mode 100644
index ba726b6..0000000
--- a/plone/rfc822/supermodel.txt
+++ /dev/null
@@ -1,76 +0,0 @@
-Supermodel handler
-==================
-
-This package contains a handler for the ``marshal`` ``plone.supermodel``
-namespace, which can be used to mark the primary field of a schema.
-
-This handler is installed so long as ``plone.supermodel`` is installed.
-
-First, let's load this package's ZCML so that we can run the tests:
-
-    >>> configuration = """\
-    ... <configure xmlns="http://namespaces.zope.org/zope">
-    ...
-    ...     <include package="Products.Five" file="configure.zcml" />
-    ...     <include package="plone.supermodel" />
-    ...     <include package="plone.rfc822" />
-    ...
-    ... </configure>
-    ... """
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-Next, let's define a sample model that exercises the 'marshal' attribute.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
-    ...        xmlns:marshal="http://namespaces.plone.org/supermodel/marshal">
-    ...     <schema>
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title>title</title>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="body" marshal:primary="true">
-    ...             <title>Body</title>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-We can load this using plone.supermodel:
-
-    >>> from plone.supermodel import loadString
-    >>> model = loadString(schema)
-
-The ``body`` field should now be marked with the ``IPrimaryField`` marker:
-
-    >>> from plone.rfc822.interfaces import IPrimaryField
-    >>> schema = model.schema
-    >>> IPrimaryField.providedBy(schema['title'])
-    False
-    >>> IPrimaryField.providedBy(schema['body'])
-    True
-
-Naturally, we can also write out the primary field attribute from an interface
-on which it is marked:
-
-    >>> from zope.interface import Interface, alsoProvides
-    >>> from zope import schema
-    >>> class ITestSchema(Interface):
-    ...     title = schema.TextLine(title=u"Title")
-    ...     body = schema.Text(title=u"Body")
-    >>> alsoProvides(ITestSchema['body'], IPrimaryField)
-
-    >>> from plone.supermodel import serializeSchema
-    >>> print serializeSchema(ITestSchema) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:marshal="http://namespaces.plone.org/supermodel/marshal" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema based-on="zope.interface.Interface">
-        <field name="title" type="zope.schema.TextLine">
-          <title>Title</title>
-        </field>
-        <field name="body" type="zope.schema.Text" marshal:primary="true">
-          <title>Body</title>
-        </field>
-      </schema>
-    </model>
diff --git a/plone/rfc822/tests.py b/plone/rfc822/tests.py
index e6acfff..c58dbb2 100644
--- a/plone/rfc822/tests.py
+++ b/plone/rfc822/tests.py
@@ -7,9 +7,9 @@
 
 
 DOCFILES = [
-    'message.txt',
-    'fields.txt',
-    'supermodel.txt',
+    'message.rst',
+    'fields.rst',
+    'supermodel.rst',
 ]
 
 optionflags = doctest.ELLIPSIS


Repository: plone.rfc822


Branch: refs/heads/master
Date: 2016-08-02T01:10:00+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.rfc822/commit/002b27227e863cf13b157c3c2d59dea9c8a476a4

manual cleanup

Files changed:
M CHANGES.rst
M plone/__init__.py
M plone/rfc822/_utils.py
M plone/rfc822/defaultfields.py
M plone/rfc822/interfaces.py
M plone/rfc822/supermodel.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 0c5801b..b18e138 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,6 +10,9 @@ New:
 
 Fixes:
 
+- code cleanup: pep8, isort, utf8 headers et al.
+  [jensens]
+
 - Use zope.interface decorator.
   [gforcada]
 
diff --git a/plone/__init__.py b/plone/__init__.py
index 85880ef..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,7 +1,2 @@
 # -*- coding: utf-8 -*-
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/rfc822/_utils.py b/plone/rfc822/_utils.py
index fc2b903..5753e44 100644
--- a/plone/rfc822/_utils.py
+++ b/plone/rfc822/_utils.py
@@ -143,12 +143,22 @@ def renderMessage(message, mangleFromHeader=False):
     return out.getvalue()
 
 
-def initializeObjectFromSchema(context, schema, message, defaultCharset='utf-8'):
+def initializeObjectFromSchema(
+    context,
+    schema,
+    message,
+    defaultCharset='utf-8'
+):
     initializeObject(context, getFieldsInOrder(
         schema), message, defaultCharset)
 
 
-def initializeObjectFromSchemata(context, schemata, message, defaultCharset='utf-8'):
+def initializeObjectFromSchemata(
+    context,
+    schemata,
+    message,
+    defaultCharset='utf-8'
+):
     """Convenience method which calls ``initializeObject()`` with all the
     fields in order, of all the given schemata (a sequence of schema
     interfaces).
@@ -207,8 +217,13 @@ def initializeObject(context, fields, message, defaultCharset='utf-8'):
         headerValue = headerValue.replace('\r\n', '\n')
 
         try:
-            marshaler.demarshal(headerValue, message=message,
-                                charset=headerCharset, contentType=contentType, primary=False)
+            marshaler.demarshal(
+                headerValue,
+                message=message,
+                charset=headerCharset,
+                contentType=contentType,
+                primary=False
+            )
         except ValueError, e:
             # interface allows demarshal() to raise ValueError to indicate
             # marshalling failed
@@ -228,7 +243,8 @@ def initializeObject(context, fields, message, defaultCharset='utf-8'):
     if isinstance(payload, str):
         if len(primary) != 1:
             raise ValueError(
-                "Got a single string payload for message, but no primary fields found for %s" % repr(context))
+                'Got a single string payload for message, but no primary '
+                'fields found for %s' % repr(context))
         else:
             name, field = primary[0]
 
@@ -241,7 +257,12 @@ def initializeObject(context, fields, message, defaultCharset='utf-8'):
                 payloadCharset = message.get_content_charset(charset)
                 try:
                     marshaler.demarshal(
-                        payloadValue, message=message, charset=payloadCharset, contentType=contentType, primary=True)
+                        payloadValue,
+                        message=message,
+                        charset=payloadCharset,
+                        contentType=contentType,
+                        primary=True
+                    )
                 except ValueError, e:
                     # interface allows demarshal() to raise ValueError to
                     # indicate marshalling failed
@@ -251,8 +272,14 @@ def initializeObject(context, fields, message, defaultCharset='utf-8'):
     # Multiple payloads
     elif isinstance(payload, (list, tuple,)):
         if len(payload) != len(primary):
-            raise ValueError("Got %d payloads for message, but %s primary fields found for %s" % (
-                len(payload), len(primary), repr(context),))
+            raise ValueError(
+                'Got %d payloads for message, but %s primary fields '
+                'found for %s' % (
+                    len(payload),
+                    len(primary),
+                    repr(context),
+                )
+            )
         else:
             for idx, msg in enumerate(payload):
                 name, field = primary[idx]
@@ -268,15 +295,24 @@ def initializeObject(context, fields, message, defaultCharset='utf-8'):
                 marshaler = queryMultiAdapter(
                     (context, field,), IFieldMarshaler)
                 if marshaler is None:
-                    LOG.debug("No marshaler found for primary field %s of %s" % (
-                        name, repr(context),))
+                    LOG.debug(
+                        'No marshaler found for primary field %s of %s' % (
+                            name,
+                            repr(context),
+                        )
+                    )
                     continue
 
                 payloadValue = msg.get_payload(decode=True)
                 payloadCharset = msg.get_content_charset(charset)
                 try:
                     marshaler.demarshal(
-                        payloadValue, message=msg, charset=payloadCharset, contentType=contentType, primary=True)
+                        payloadValue,
+                        message=msg,
+                        charset=payloadCharset,
+                        contentType=contentType,
+                        primary=True
+                    )
                 except ValueError, e:
                     # interface allows demarshal() to raise ValueError to
                     # indicate marshalling failed
diff --git a/plone/rfc822/defaultfields.py b/plone/rfc822/defaultfields.py
index 27bcddd..c775b9d 100644
--- a/plone/rfc822/defaultfields.py
+++ b/plone/rfc822/defaultfields.py
@@ -72,7 +72,14 @@ def marshal(self, charset='utf-8', primary=False):
             return None
         return self.encode(value, charset, primary)
 
-    def demarshal(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+    def demarshal(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         fieldValue = self.field.missing_value
         if value:
             fieldValue = self.decode(
@@ -82,7 +89,14 @@ def demarshal(self, value, message=None, charset='utf-8', contentType=None, prim
     def encode(self, value, charset='utf-8', primary=False):
         return None
 
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         raise ValueError("Demarshalling not implemented for %s" %
                          repr(self.field))
 
@@ -118,7 +132,14 @@ def encode(self, value, charset='utf-8', primary=False):
             return None
         return unicode(value).encode(charset)
 
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         unicodeValue = value.decode(charset)
         try:
             return self.field.fromUnicode(unicodeValue)
@@ -169,7 +190,14 @@ class BytesFieldMarshaler(BaseFieldMarshaler):
     def encode(self, value, charset='utf-8', primary=False):
         return value
 
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         return value
 
 
@@ -186,7 +214,14 @@ def encode(self, value, charset='utf-8', primary=False):
             return None
         return value.isoformat()
 
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         unicodeValue = value.decode(charset)
         try:
             return dateutil.parser.parse(unicodeValue)
@@ -211,7 +246,14 @@ def encode(self, value, charset='utf-8', primary=False):
             return None
         return value.isoformat()
 
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         unicodeValue = value.decode(charset)
         try:
             return dateutil.parser.parse(unicodeValue).date()
@@ -236,7 +278,16 @@ def encode(self, value, charset='utf-8', primary=False):
             return None
         return "%d:%d:%d" % (value.days, value.seconds, value.microseconds)
 
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
+        # this value is never used, should it be used later in the list
+        # comprehension?
         unicodeValue = value.decode(charset)
         try:
             days, seconds, microseconds = [int(v) for v in value.split(":")]
@@ -284,7 +335,14 @@ def encode(self, value, charset='utf-8', primary=False):
 
         return '||'.join(value_lines)
 
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         valueTypeMarshaler = queryMultiAdapter(
             (self.context, self.field.value_type,), IFieldMarshaler)
         if valueTypeMarshaler is None:
diff --git a/plone/rfc822/interfaces.py b/plone/rfc822/interfaces.py
index c46a8df..0d17c54 100644
--- a/plone/rfc822/interfaces.py
+++ b/plone/rfc822/interfaces.py
@@ -43,16 +43,16 @@ def constructMessage(context, fields, charset='utf-8'):
 
         ``context`` is a content object.
 
-        ``fields`` is a sequence of (name, field) pairs for the fields which make
-        up the message. This can be obtained from zope.schema.getFieldsInOrder,
-        for example.
+        ``fields`` is a sequence of (name, field) pairs for the fields which
+        make up the message. This can be obtained from
+        zope.schema.getFieldsInOrder, for example.
 
         ``charset`` is the message charset.
 
         The message body will be constructed from the primary field, i.e. the
         field which is marked with ``IPrimaryField``. If no such field exists,
-        the message will have no body. If multiple fields exist, the message will
-        be a multipart message. Otherwise, it will contain a scalar string
+        the message will have no body. If multiple fields exist, the message
+        will be a multipart message. Otherwise, it will contain a scalar string
         payload.
 
         A field will be ignored if ``(context, field)`` cannot be multi-adapted
@@ -63,12 +63,22 @@ def renderMessage(message, mangleFromHeader=False):
         """Render a message to a string
         """
 
-    def initializeObjectFromSchema(context, schema, message, defaultCharset='utf-8'):
+    def initializeObjectFromSchema(
+        context,
+        schema,
+        message,
+        defaultCharset='utf-8'
+    ):
         """Convenience method which calls ``initializeObject()`` with all the
         fields, in order, of the given schema interface
         """
 
-    def initializeObjectFromSchemata(context, schemata, message, defaultCharset='utf-8'):
+    def initializeObjectFromSchemata(
+        context,
+        schemata,
+        message,
+        defaultCharset='utf-8'
+    ):
         """Convenience method which calls ``initializeObject()`` with all the
         fields in order, of all the given schemata (a sequence of schema
         interfaces).
@@ -79,9 +89,9 @@ def initializeObject(context, fields, message, defaultCharset='utf-8'):
 
         ``context`` is the content object to initialise.
 
-        ``fields`` is a sequence of (name, field) pairs for the fields which make
-        up the message. This can be obtained from zope.schema.getFieldsInOrder,
-        for example.
+        ``fields`` is a sequence of (name, field) pairs for the fields which
+        make up the message. This can be obtained from
+        zope.schema.getFieldsInOrder, for example.
 
         ``message`` is a ``Message`` object.
 
@@ -97,7 +107,7 @@ class IFieldMarshaler(Interface):
     demarshalling from RFC2822 message headers.
 
     This interface deals in unicode strings, which will be encoded/decoded
-    elsewhere. 
+    elsewhere.
     """
 
     ascii = schema.Bool(
@@ -129,7 +139,13 @@ def marshal(charset='utf-8', primary=False):
         skipped.
         """
 
-    def demarshal(value, message=None, charset='utf-8', contentType=None, primary=False):
+    def demarshal(
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         """Update the value of the adapted field on the adapted context.
 
         Note: It may be necessary to adapt the context to the field's
@@ -163,7 +179,13 @@ def encode(value, charset='utf-8', primary=False):
         Return None if the value cannot be encoded.
         """
 
-    def decode(value, message=None, charset='utf-8', contentType=None, primary=False):
+    def decode(
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         """Like demarshal, but return the value instead of updating the field.
 
         This is only used for collection fields and other situations where
@@ -183,7 +205,7 @@ def getContentType():
     def getCharset(defualt='utf-8'):
         """Return the charset of the field. The value should be appropriate
         for the 'charset' parameter to the Content-Type HTTP header. This is
-        mainly used for marshalling 
+        mainly used for marshalling
 
         The ``default`` parameter contains the message's default charset.
 
diff --git a/plone/rfc822/supermodel.py b/plone/rfc822/supermodel.py
index af4e312..6d24d72 100644
--- a/plone/rfc822/supermodel.py
+++ b/plone/rfc822/supermodel.py
@@ -7,9 +7,10 @@
 
 if HAVE_SUPERMODEL:
 
-    from zope.interface import implementer, alsoProvides
-    from plone.supermodel.utils import ns
     from plone.rfc822.interfaces import IPrimaryField
+    from plone.supermodel.utils import ns
+    from zope.interface import alsoProvides
+    from zope.interface import implementer
 
     @implementer(IFieldMetadataHandler)
     class PrimaryFieldMetadataHandler(object):
@@ -23,8 +24,11 @@ class PrimaryFieldMetadataHandler(object):
         prefix = "marshal"
 
         def read(self, fieldNode, schema, field):
-            primary = fieldNode.get(ns('primary',  self.namespace))
-            if primary is not None and primary.lower() in ("true", "on", "yes", "y", "1"):
+            primary = fieldNode.get(ns('primary', self.namespace))
+            if (
+                primary is not None and
+                primary.lower() in ("true", "on", "yes", "y", "1")
+            ):
                 alsoProvides(field, IPrimaryField)
 
         def write(self, fieldNode, schema, field):
diff --git a/setup.py b/setup.py
index d3e2356..5a7a5a8 100644
--- a/setup.py
+++ b/setup.py
@@ -1,6 +1,10 @@
-from setuptools import setup, find_packages
+# -*- coding: utf-8 -*-
+from setuptools import find_packages
+from setuptools import setup
+
 import os
 
+
 version = '1.1.3.dev0'
 
 setup(
@@ -33,8 +37,8 @@
     include_package_data=True,
     zip_safe=False,
     extras_require={
-      'supermodel': ['plone.supermodel'],
-      'test': ['plone.testing'],
+        'supermodel': ['plone.supermodel'],
+        'test': ['plone.testing'],
     },
     install_requires=[
         'setuptools',
@@ -45,4 +49,4 @@
     ],
     entry_points="""
     """,
-    )
+)


Repository: plone.rfc822


Branch: refs/heads/master
Date: 2016-08-02T01:18:36+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.rfc822/commit/f2920c0e3397a33af0d7ea66d77ae7618418cb51

fixup for af9c57aef858bbcd7ae5af797405daa9803c0171

Files changed:
M setup.py

diff --git a/setup.py b/setup.py
index 5a7a5a8..b3dd81b 100644
--- a/setup.py
+++ b/setup.py
@@ -14,7 +14,7 @@
     long_description=(
         open("README.rst").read() + "\n" +
         open("CHANGES.rst").read() +
-        open(os.path.join("plone", "rfc822", "message.txt")).read()),
+        open(os.path.join("plone", "rfc822", "message.rst")).read()),
     # Get more strings from
     # https://pypi.python.org/pypi?%3Aaction=list_classifiers
     classifiers=[


Repository: plone.rfc822


Branch: refs/heads/master
Date: 2016-08-02T13:40:17+02:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.rfc822/commit/d5e16881eb2538b8bff876ad6ce98c906b4033ef

Merge pull request #3 from plone/cleanup

Cleanup

Files changed:
A plone/rfc822/fields.rst
A plone/rfc822/message.rst
A plone/rfc822/supermodel.rst
M CHANGES.rst
M plone/__init__.py
M plone/rfc822/__init__.py
M plone/rfc822/_utils.py
M plone/rfc822/defaultfields.py
M plone/rfc822/interfaces.py
M plone/rfc822/supermodel.py
M plone/rfc822/tests.py
M setup.py
D plone/rfc822/fields.txt
D plone/rfc822/message.txt
D plone/rfc822/supermodel.txt

diff --git a/CHANGES.rst b/CHANGES.rst
index 0c5801b..b18e138 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,6 +10,9 @@ New:
 
 Fixes:
 
+- code cleanup: pep8, isort, utf8 headers et al.
+  [jensens]
+
 - Use zope.interface decorator.
   [gforcada]
 
diff --git a/plone/__init__.py b/plone/__init__.py
index f48ad10..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,6 +1,2 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/rfc822/__init__.py b/plone/rfc822/__init__.py
index ff7c8e8..98157cb 100644
--- a/plone/rfc822/__init__.py
+++ b/plone/rfc822/__init__.py
@@ -1,14 +1,14 @@
-import zope.interface
-from plone.rfc822.interfaces import IMessageAPI
-
-zope.interface.moduleProvides(IMessageAPI)
-
+# -*- coding: utf-8 -*-
+from plone.rfc822._utils import constructMessage
 from plone.rfc822._utils import constructMessageFromSchema
 from plone.rfc822._utils import constructMessageFromSchemata
-from plone.rfc822._utils import constructMessage
-
-from plone.rfc822._utils import renderMessage
-
+from plone.rfc822._utils import initializeObject
 from plone.rfc822._utils import initializeObjectFromSchema
 from plone.rfc822._utils import initializeObjectFromSchemata
-from plone.rfc822._utils import initializeObject
+from plone.rfc822._utils import renderMessage
+from plone.rfc822.interfaces import IMessageAPI
+
+import zope.interface
+
+
+zope.interface.moduleProvides(IMessageAPI)
diff --git a/plone/rfc822/_utils.py b/plone/rfc822/_utils.py
index a6bcce3..5753e44 100644
--- a/plone/rfc822/_utils.py
+++ b/plone/rfc822/_utils.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 """Implementation of IMessageAPI methods.
 
 import these from plone.rfc822 directly, not from this module.
@@ -5,108 +6,114 @@
 See interfaces.py for details.
 """
 
-import logging
 from cStringIO import StringIO
-
-# Note: We use capitalised module names to be compatible with Python 2.4
-from email.Message import Message 
-from email.Header import Header, decode_header
 from email.Generator import Generator
-
+from email.Header import decode_header
+from email.Header import Header
+# Note: We use capitalised module names to be compatible with Python 2.4
+from email.Message import Message
+from plone.rfc822.interfaces import IFieldMarshaler
+from plone.rfc822.interfaces import IPrimaryField
 from zope.component import queryMultiAdapter
 from zope.schema import getFieldsInOrder
 
-from plone.rfc822.interfaces import IFieldMarshaler
-from plone.rfc822.interfaces import IPrimaryField
+import logging
+
 
 LOG = logging.getLogger('plone.rfc822')
 
+
 def constructMessageFromSchema(context, schema, charset='utf-8'):
     return constructMessage(context, getFieldsInOrder(schema), charset)
 
+
 def constructMessageFromSchemata(context, schemata, charset='utf-8'):
     fields = []
     for schema in schemata:
         fields.extend(getFieldsInOrder(schema))
     return constructMessage(context, fields, charset)
 
+
 def constructMessage(context, fields, charset='utf-8'):
     msg = Message()
-    
+
     primary = []
-    
+
     # First get all headers, storing primary fields for later
     for name, field in fields:
-        
+
         if IPrimaryField.providedBy(field):
             primary.append((name, field,))
             continue
-        
+
         marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
         if marshaler is None:
-            LOG.debug("No marshaler found for field %s of %s" % (name, repr(context)))
+            LOG.debug("No marshaler found for field %s of %s" %
+                      (name, repr(context)))
             continue
-        
+
         try:
             value = marshaler.marshal(charset, primary=False)
         except ValueError, e:
-            LOG.debug("Marshaling of %s for %s failed: %s" % (name, repr(context), str(e)))
+            LOG.debug("Marshaling of %s for %s failed: %s" %
+                      (name, repr(context), str(e)))
             continue
-        
+
         if value is None:
             value = ''
         elif not isinstance(value, str):
-            raise ValueError("Marshaler for field %s did not return a string" % name)
-        
+            raise ValueError(
+                "Marshaler for field %s did not return a string" % name)
+
         if marshaler.ascii and '\n' not in value:
             msg[name] = value
         else:
             msg[name] = Header(value, charset)
-    
+
     # Then deal with the primary field
-    
+
     # If there's a single primary field, we have a non-multipart message with
     # a string payload
 
     if len(primary) == 1:
         name, field = primary[0]
-        
+
         marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
         if marshaler is not None:
             contentType = marshaler.getContentType()
             payloadCharset = marshaler.getCharset(charset)
-            
+
             if contentType is not None:
                 msg.set_type(contentType)
-            
+
             if payloadCharset is not None:
                 # using set_charset() would also add transfer encoding,
                 # which we don't want to do always
                 msg.set_param('charset', payloadCharset)
-                
+
             value = marshaler.marshal(charset, primary=True)
             if value is not None:
                 msg.set_payload(value)
-            
+
             marshaler.postProcessMessage(msg)
-    
+
     # Otherwise, we return a multipart message
-    
+
     elif len(primary) > 1:
         msg.set_type('multipart/mixed')
-        
+
         for name, field in primary:
-            
+
             marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
             if marshaler is None:
                 continue
-            
+
             payload = Message()
             attach = False
-            
+
             contentType = marshaler.getContentType()
             payloadCharset = marshaler.getCharset(charset)
-            
+
             if contentType is not None:
                 payload.set_type(contentType)
                 attach = True
@@ -115,42 +122,57 @@ def constructMessage(context, fields, charset='utf-8'):
                 # which we don't want to do always
                 payload.set_param('charset', payloadCharset)
                 attach = True
-            
+
             value = marshaler.marshal(charset, primary=True)
-            
+
             if value is not None:
                 payload.set_payload(value)
                 attach = True
-            
+
             if attach:
                 marshaler.postProcessMessage(payload)
                 msg.attach(payload)
 
     return msg
 
+
 def renderMessage(message, mangleFromHeader=False):
     out = StringIO()
     generator = Generator(out, mangle_from_=mangleFromHeader)
     generator.flatten(message)
     return out.getvalue()
 
-def initializeObjectFromSchema(context, schema, message, defaultCharset='utf-8'):
-    initializeObject(context, getFieldsInOrder(schema), message, defaultCharset)
 
-def initializeObjectFromSchemata(context, schemata, message, defaultCharset='utf-8'):
+def initializeObjectFromSchema(
+    context,
+    schema,
+    message,
+    defaultCharset='utf-8'
+):
+    initializeObject(context, getFieldsInOrder(
+        schema), message, defaultCharset)
+
+
+def initializeObjectFromSchemata(
+    context,
+    schemata,
+    message,
+    defaultCharset='utf-8'
+):
     """Convenience method which calls ``initializeObject()`` with all the
     fields in order, of all the given schemata (a sequence of schema
     interfaces).
     """
-    
+
     fields = []
     for schema in schemata:
         fields.extend(getFieldsInOrder(schema))
     return initializeObject(context, fields, message, defaultCharset)
 
+
 def initializeObject(context, fields, message, defaultCharset='utf-8'):
     contentType = message.get_content_type()
-    
+
     charset = message.get_charset()
     if charset is None:
         charset = message.get_param('charset')
@@ -158,100 +180,142 @@ def initializeObject(context, fields, message, defaultCharset='utf-8'):
         charset = str(charset)
     else:
         charset = defaultCharset
-    
+
     headerFields = {}
     primary = []
-    
+
     for name, field in fields:
         if IPrimaryField.providedBy(field):
             primary.append((name, field))
         else:
             headerFields.setdefault(name.lower(), []).append(field)
-    
+
     # Demarshal each header
-    
+
     for name, value in message.items():
-        
+
         name = name.lower()
         fieldset = headerFields.get(name, None)
         if fieldset is None or len(fieldset) == 0:
             LOG.debug("No matching field found for header %s" % name)
             continue
-        
+
         field = fieldset.pop(0)
-        
+
         marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
         if marshaler is None:
-            LOG.debug("No marshaler found for field %s of %s" % (name, repr(context)))
+            LOG.debug("No marshaler found for field %s of %s" %
+                      (name, repr(context)))
             continue
-        
+
         headerValue, headerCharset = decode_header(value)[0]
         if headerCharset is None:
             headerCharset = charset
-        
-        # MIME messages always use CRLF. For headers, we're probably safer with \n
+
+        # MIME messages always use CRLF. For headers, we're probably safer with
+        # \n
         headerValue = headerValue.replace('\r\n', '\n')
-        
+
         try:
-            marshaler.demarshal(headerValue, message=message, charset=headerCharset, contentType=contentType, primary=False)
+            marshaler.demarshal(
+                headerValue,
+                message=message,
+                charset=headerCharset,
+                contentType=contentType,
+                primary=False
+            )
         except ValueError, e:
-            # interface allows demarshal() to raise ValueError to indicate marshalling failed
-            LOG.debug("Demarshalling of %s for %s failed: %s" % (name, repr(context), str(e)))
+            # interface allows demarshal() to raise ValueError to indicate
+            # marshalling failed
+            LOG.debug("Demarshalling of %s for %s failed: %s" %
+                      (name, repr(context), str(e)))
             continue
-        
+
     # Then demarshal the primary field
-    
+
     payload = message.get_payload()
-    
+
     # do nothing if we don't have a payload
     if not payload:
         return
-    
+
     # A single string payload
     if isinstance(payload, str):
         if len(primary) != 1:
-            raise ValueError("Got a single string payload for message, but no primary fields found for %s" % repr(context))
+            raise ValueError(
+                'Got a single string payload for message, but no primary '
+                'fields found for %s' % repr(context))
         else:
             name, field = primary[0]
-        
+
             marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
             if marshaler is None:
-                LOG.debug("No marshaler found for primary field %s of %s" % (name, repr(context),))
+                LOG.debug("No marshaler found for primary field %s of %s" %
+                          (name, repr(context),))
             else:
                 payloadValue = message.get_payload(decode=True)
                 payloadCharset = message.get_content_charset(charset)
                 try:
-                    marshaler.demarshal(payloadValue, message=message, charset=payloadCharset, contentType=contentType, primary=True)
+                    marshaler.demarshal(
+                        payloadValue,
+                        message=message,
+                        charset=payloadCharset,
+                        contentType=contentType,
+                        primary=True
+                    )
                 except ValueError, e:
-                    # interface allows demarshal() to raise ValueError to indicate marshalling failed
-                    LOG.debug("Demarshalling of %s for %s failed: %s" % (name, repr(context), str(e)))
-        
+                    # interface allows demarshal() to raise ValueError to
+                    # indicate marshalling failed
+                    LOG.debug("Demarshalling of %s for %s failed: %s" %
+                              (name, repr(context), str(e)))
+
     # Multiple payloads
     elif isinstance(payload, (list, tuple,)):
         if len(payload) != len(primary):
-            raise ValueError("Got %d payloads for message, but %s primary fields found for %s" %  (len(payload), len(primary), repr(context),))
+            raise ValueError(
+                'Got %d payloads for message, but %s primary fields '
+                'found for %s' % (
+                    len(payload),
+                    len(primary),
+                    repr(context),
+                )
+            )
         else:
             for idx, msg in enumerate(payload):
                 name, field = primary[idx]
-                
+
                 contentType = msg.get_content_type()
-    
+
                 charset = message.get_charset()
                 if charset is not None:
                     charset = str(charset)
                 else:
                     charset = 'utf-8'
-                
-                marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)
+
+                marshaler = queryMultiAdapter(
+                    (context, field,), IFieldMarshaler)
                 if marshaler is None:
-                    LOG.debug("No marshaler found for primary field %s of %s" % (name, repr(context),))
+                    LOG.debug(
+                        'No marshaler found for primary field %s of %s' % (
+                            name,
+                            repr(context),
+                        )
+                    )
                     continue
-                
+
                 payloadValue = msg.get_payload(decode=True)
                 payloadCharset = msg.get_content_charset(charset)
                 try:
-                    marshaler.demarshal(payloadValue, message=msg, charset=payloadCharset, contentType=contentType, primary=True)
+                    marshaler.demarshal(
+                        payloadValue,
+                        message=msg,
+                        charset=payloadCharset,
+                        contentType=contentType,
+                        primary=True
+                    )
                 except ValueError, e:
-                    # interface allows demarshal() to raise ValueError to indicate marshalling failed
-                    LOG.debug("Demarshalling of %s for %s failed: %s" % (name, repr(context), str(e)))
+                    # interface allows demarshal() to raise ValueError to
+                    # indicate marshalling failed
+                    LOG.debug("Demarshalling of %s for %s failed: %s" %
+                              (name, repr(context), str(e)))
                     continue
diff --git a/plone/rfc822/defaultfields.py b/plone/rfc822/defaultfields.py
index 9540238..c775b9d 100644
--- a/plone/rfc822/defaultfields.py
+++ b/plone/rfc822/defaultfields.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 """Default field marshalers for the fields in zope.schema.
 
 Note that none of the marshalers will return a value for getContentType(),
@@ -31,102 +32,129 @@
 * Dict - stores a dict
 """
 
-import datetime
-import dateutil.parser
-
-from zope.component import queryMultiAdapter
-
-from zope.interface import implementer, Interface
+from plone.rfc822.interfaces import IFieldMarshaler
 from zope.component import adapts
-
-from zope.schema.interfaces import IFromUnicode
+from zope.component import queryMultiAdapter
+from zope.interface import implementer
+from zope.interface import Interface
 from zope.schema.interfaces import IBytes
-from zope.schema.interfaces import IDatetime, IDate, ITimedelta
 from zope.schema.interfaces import ICollection
+from zope.schema.interfaces import IDate
+from zope.schema.interfaces import IDatetime
+from zope.schema.interfaces import IFromUnicode
+from zope.schema.interfaces import ITimedelta
+
+import datetime
+import dateutil.parser
 
-from plone.rfc822.interfaces import IFieldMarshaler
 
 _marker = object()
 
+
 @implementer(IFieldMarshaler)
 class BaseFieldMarshaler(object):
     """Base class for field marshalers
     """
-    
+
     ascii = False
-    
+
     def __init__(self, context, field):
         self.context = context
         self.field = field.bind(context)
-        
+
         self.instance = context
         if field.interface is not None:
             self.instance = field.interface(context, context)
-    
+
     def marshal(self, charset='utf-8', primary=False):
         value = self._query(_marker)
         if value is _marker:
             return None
         return self.encode(value, charset, primary)
-    
-    def demarshal(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+
+    def demarshal(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         fieldValue = self.field.missing_value
         if value:
-            fieldValue = self.decode(value, message, charset, contentType, primary)
+            fieldValue = self.decode(
+                value, message, charset, contentType, primary)
         self._set(fieldValue)
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         return None
-    
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
-        raise ValueError("Demarshalling not implemented for %s" % repr(self.field))
-    
+
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
+        raise ValueError("Demarshalling not implemented for %s" %
+                         repr(self.field))
+
     def getContentType(self):
         return None
-    
+
     def getCharset(self, default='utf-8'):
         return None
-    
+
     def postProcessMessage(self, message):
         pass
-    
+
     # Helper methods
-    
+
     def _query(self, default=None):
         return self.field.query(self.instance, default)
-    
+
     def _set(self, value):
         try:
             self.field.set(self.instance, value)
         except TypeError, e:
             raise ValueError(e)
 
+
 class UnicodeFieldMarshaler(BaseFieldMarshaler):
     """Default marshaler for fields that support IFromUnicode
     """
-    
+
     adapts(Interface, IFromUnicode)
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         if value is None:
             return None
         return unicode(value).encode(charset)
-    
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         unicodeValue = value.decode(charset)
         try:
             return self.field.fromUnicode(unicodeValue)
         except Exception, e:
             raise ValueError(e)
-    
+
     def getCharset(self, default='utf-8'):
         return default
 
+
 class UnicodeValueFieldMarshaler(UnicodeFieldMarshaler):
     """Default marshaler for fields that contain unicode data and so may be
     ASCII safe.
     """
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         value = super(UnicodeValueFieldMarshaler, self).encode(
             value, charset, primary)
@@ -137,94 +165,129 @@ def encode(self, value, charset='utf-8', primary=False):
         else:
             self.ascii = False
         return value
-    
+
+
 class ASCIISafeFieldMarshaler(UnicodeFieldMarshaler):
     """Default marshaler for fields that are ASCII safe, but still support
     IFromUnicode. This includes Int, Float, Decimal, and Bool.
     """
-    
+
     ascii = True
-    
+
     def getCharset(self, default='utf-8'):
         return None
-    
+
+
 class BytesFieldMarshaler(BaseFieldMarshaler):
     """Default marshaler for IBytes fields and children. These store str
     objects, so we will attempt to encode them directly.
     """
-    
+
     adapts(Interface, IBytes)
-    
+
     ascii = True
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         return value
-    
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         return value
 
+
 class DatetimeMarshaler(BaseFieldMarshaler):
     """Marshaler for Python datetime values
     """
-    
+
     adapts(Interface, IDatetime)
-    
+
     ascii = True
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         if value is None:
             return None
         return value.isoformat()
-    
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         unicodeValue = value.decode(charset)
         try:
             return dateutil.parser.parse(unicodeValue)
         except Exception, e:
             raise ValueError(e)
 
+
 class DateMarshaler(BaseFieldMarshaler):
     """Marshaler for Python date values.
-    
+
     Note: we don't use the date formatting support in the 'email' module as
     this does not seem to be capable of round-tripping values with time zone
     information.
     """
-    
+
     adapts(Interface, IDate)
-    
+
     ascii = True
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         if value is None:
             return None
         return value.isoformat()
-    
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         unicodeValue = value.decode(charset)
         try:
             return dateutil.parser.parse(unicodeValue).date()
         except Exception, e:
             raise ValueError(e)
 
+
 class TimedeltaMarshaler(BaseFieldMarshaler):
     """Marshaler for Python timedelta values
-    
+
     Note: we don't use the date formatting support in the 'email' module as
     this does not seem to be capable of round-tripping values with time zone
     information.
     """
-    
+
     adapts(Interface, ITimedelta)
-    
+
     ascii = True
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         if value is None:
             return None
         return "%d:%d:%d" % (value.days, value.seconds, value.microseconds)
-    
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
+        # this value is never used, should it be used later in the list
+        # comprehension?
         unicodeValue = value.decode(charset)
         try:
             days, seconds, microseconds = [int(v) for v in value.split(":")]
@@ -232,54 +295,68 @@ def decode(self, value, message=None, charset='utf-8', contentType=None, primary
         except Exception, e:
             raise ValueError(e)
 
+
 class CollectionMarshaler(BaseFieldMarshaler):
     """Marshaler for collection values
     """
-    
+
     adapts(Interface, ICollection)
 
     ascii = False
-    
+
     def getCharset(self, default='utf-8'):
-        valueTypeMarshaler = queryMultiAdapter((self.context, self.field.value_type,), IFieldMarshaler)
+        valueTypeMarshaler = queryMultiAdapter(
+            (self.context, self.field.value_type,), IFieldMarshaler)
         if valueTypeMarshaler is None:
             return None
         return valueTypeMarshaler.getCharset(default)
-    
+
     def encode(self, value, charset='utf-8', primary=False):
         if value is None:
             return None
-        
-        valueTypeMarshaler = queryMultiAdapter((self.context, self.field.value_type,), IFieldMarshaler)
+
+        valueTypeMarshaler = queryMultiAdapter(
+            (self.context, self.field.value_type,), IFieldMarshaler)
         if valueTypeMarshaler is None:
             return None
-        
+
         ascii = True
         value_lines = []
         for item in value:
-            marshaledValue = valueTypeMarshaler.encode(item, charset=charset, primary=primary)
+            marshaledValue = valueTypeMarshaler.encode(
+                item, charset=charset, primary=primary)
             if marshaledValue is None:
                 marshaledValue = ''
             value_lines.append(marshaledValue)
             if not valueTypeMarshaler.ascii:
                 ascii = False
-        
+
         self.ascii = ascii
 
         return '||'.join(value_lines)
-    
-    def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
-        valueTypeMarshaler = queryMultiAdapter((self.context, self.field.value_type,), IFieldMarshaler)
+
+    def decode(
+        self,
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
+        valueTypeMarshaler = queryMultiAdapter(
+            (self.context, self.field.value_type,), IFieldMarshaler)
         if valueTypeMarshaler is None:
-            raise ValueError("Cannot demarshal value type %s" % repr(self.field.value_type))
-        
+            raise ValueError("Cannot demarshal value type %s" %
+                             repr(self.field.value_type))
+
         listValue = []
-        
+
         for line in value.split('||'):
-            listValue.append(valueTypeMarshaler.decode(line, message, charset, contentType, primary))
-            
+            listValue.append(valueTypeMarshaler.decode(
+                line, message, charset, contentType, primary))
+
         sequenceType = self.field._type
         if isinstance(sequenceType, (list, tuple,)):
             sequenceType = sequenceType[-1]
-        
+
         return sequenceType(listValue)
diff --git a/plone/rfc822/fields.rst b/plone/rfc822/fields.rst
new file mode 100644
index 0000000..afb5617
--- /dev/null
+++ b/plone/rfc822/fields.rst
@@ -0,0 +1,503 @@
+Field marshaler tests
+=====================
+
+This test exercises the various standard field marshalers.
+
+First, we load the package's configuration:
+
+    >>> configuration = """\
+    ... <configure
+    ...      xmlns="http://namespaces.zope.org/zope"
+    ...      i18n_domain="plone.rfc822.tests">
+    ...      
+    ...     <include package="zope.component" file="meta.zcml" />
+    ...     <include package="zope.annotation" />
+    ...     
+    ...     <include package="plone.rfc822" />
+    ...     
+    ... </configure>
+    ... """
+
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+Next, we'll create an interface which contains an instance of every field
+we support.
+
+    >>> from zope.interface import Interface
+    >>> from zope import schema
+    >>> from dateutil.tz import tzoffset
+    >>> tz = tzoffset('Europe/Oslo', 3600)
+
+    >>> class ITestContent(Interface):
+    ...     _text = schema.Text()
+    ...     _text2 = schema.Text()
+    ...     _textLine = schema.TextLine()
+    ...     _textLine2 = schema.TextLine()
+    ...     _password = schema.Password()
+    ...     _password2 = schema.Password()
+    ...     _bytes = schema.Bytes()
+    ...     _bytesLine = schema.BytesLine()
+    ...     _ascii = schema.ASCII()
+    ...     _asciiLine = schema.ASCIILine()
+    ...     _uri = schema.URI()
+    ...     _id = schema.Id()
+    ...     _dottedName = schema.DottedName()
+    ...     _bool = schema.Bool()
+    ...     _int = schema.Int()
+    ...     _float = schema.Float()
+    ...     _decimal = schema.Decimal()
+    ...     _choice1 = schema.Choice(values=[u"one", u"two", u"three"])
+    ...     _choice2 = schema.Choice(values=["one", "two", "three"])
+    ...     _datetime = schema.Datetime()
+    ...     _date = schema.Date()
+    ...     _timedelta = schema.Timedelta()
+    ...     _tuple = schema.Tuple(value_type=schema.TextLine())
+    ...     _list = schema.List(value_type=schema.ASCIILine())
+    ...     _set = schema.Set(value_type=schema.Bool())
+    ...     _frozenset = schema.FrozenSet(value_type=schema.Timedelta())
+
+This interface is implemented by a the following class:
+
+    >>> from zope.interface import implements
+    >>> import datetime
+    >>> from decimal import Decimal
+    >>> class TestContent(object):
+    ...     implements(ITestContent)
+    ...     _text = u"text\xd8"
+    ...     _text2 = u"text" # ascii safe
+    ...     _textLine = u"textline\xd8"
+    ...     _textLine2 = u"textline" # ascii safe
+    ...     _password = u"password\xd8"
+    ...     _password2 = u"password" # ascii safe
+    ...     _bytes = 'bytes'
+    ...     _bytesLine = 'bytesline'
+    ...     _ascii = 'ascii'
+    ...     _asciiLine = 'asciiline'
+    ...     _uri = 'http://plone.org'
+    ...     _id = 'some.id'
+    ...     _dottedName = 'dotted.name'
+    ...     _bool = True
+    ...     _int = -10l
+    ...     _float = 0.3
+    ...     _decimal = Decimal("5.0")
+    ...     _choice1 = u"two"
+    ...     _choice2 = 'two'
+    ...     _datetime = datetime.datetime(2009, 1, 2, 15, 10, 5, 1, tz)
+    ...     _date = datetime.date(2008, 2, 3)
+    ...     _timedelta = datetime.timedelta(3, 4, 5)
+    ...     _tuple = (u"one\xd8", u"two")
+    ...     _list = ['three', 'four']
+    ...     _set = set([True, False])
+    ...     _frozenset = frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])
+
+    >>> t = TestContent()
+
+We can now look up the marshaler for each one and test the marshalling and
+extraction methods.
+
+    >>> from zope.component import getMultiAdapter
+    >>> from plone.rfc822.interfaces import IFieldMarshaler
+
+Notes: 
+
+* Unicode \xd8 (capital letter O with stroke) is \xc3\x98 in UTF-8.
+* None of the default marshalers support getContentType(), i.e. they all
+  return None
+* For simplicity, we do not call ``demarshal()`` for each field. For all the
+  standard marshalers, this simply sets the value returned by ``extract()``
+  using the ``set()`` method on the field instance.
+
+Text
+----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_text']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'text\xc3\x98'
+    >>> marshaler.decode('text\xc3\x98')
+    u'text\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    False
+
+Text field types and derivatives will return True for the ``ascii`` property
+if the field value is within the ascii range.
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_text2']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'text'
+    >>> marshaler.decode('text\xc3\x98')
+    u'text\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    True
+
+TextLine
+--------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_textLine']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'textline\xc3\x98'
+    >>> marshaler.decode('textline\xc3\x98')
+    u'textline\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    False
+
+Text field types and derivatives will return True for the ``ascii`` property
+if the field value is within the ascii range.
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_textLine2']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'textline'
+    >>> marshaler.decode('textline\xc3\x98')
+    u'textline\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    True
+
+Password
+--------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_password']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'password\xc3\x98'
+    >>> marshaler.decode('password\xc3\x98')
+    u'password\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    False
+
+Text field types and derivatives will return True for the ``ascii`` property
+if the field value is within the ascii range.
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_password2']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'password'
+    >>> marshaler.decode('password\xc3\x98')
+    u'password\xd8'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    True
+
+Bytes
+-----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_bytes']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'bytes'
+    >>> marshaler.decode('bytes')
+    'bytes'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+BytesLine
+---------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_bytesLine']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'bytesline'
+    >>> marshaler.decode('bytesline')
+    'bytesline'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+ASCII
+-----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_ascii']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'ascii'
+    >>> marshaler.decode('ascii')
+    'ascii'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+ASCIILine
+---------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_asciiLine']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'asciiline'
+    >>> marshaler.decode('asciiline')
+    'asciiline'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+URI
+---
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_uri']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'http://plone.org'
+    >>> marshaler.decode('http://plone.org')
+    'http://plone.org'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Id
+--
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_id']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'some.id'
+    >>> marshaler.decode('some.id')
+    'some.id'
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.ascii
+    True
+
+DottedName
+----------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_dottedName']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'dotted.name'
+    >>> marshaler.decode('dotted.name')
+    'dotted.name'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Bool
+----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_bool']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'True'
+    >>> t._bool = False
+    >>> marshaler.marshal()
+    'False'
+    >>> t._bool = True
+    >>> marshaler.decode('True')
+    True
+    >>> marshaler.decode('False')
+    False
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Int
+---
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_int']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '-10'
+    >>> marshaler.decode('-10')
+    -10
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Float
+-----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_float']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '0.3'
+    >>> marshaler.decode('0.25')
+    0.25
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Decimal
+-------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_decimal']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '5.0'
+    >>> marshaler.decode('5.0')
+    Decimal('5.0')
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Choice
+------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_choice1']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'two'
+    >>> marshaler.decode('one')
+    u'one'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    True
+    
+    >>> marshaler = getMultiAdapter((t, ITestContent['_choice2']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'two'
+    >>> marshaler.decode('three')
+    u'three'
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    True
+
+Datetime
+--------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_datetime']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '2009-01-02T15:10:05.000001+01:00'
+    >>> marshaler.decode('2009-01-02T15:10:05.000001+01:00')
+    datetime.datetime(2009, 1, 2, 15, 10, 5, 1, tzinfo=tzoffset(None, 3600))
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Date
+----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_date']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '2008-02-03'
+    >>> marshaler.decode('2008-02-03')
+    datetime.date(2008, 2, 3)
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Timedelta
+---------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_timedelta']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    '3:4:5'
+    >>> marshaler.decode('3:4:5')
+    datetime.timedelta(3, 4, 5)
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Tuple
+-----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_tuple']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'one\xc3\x98||two'
+    >>> marshaler.decode('one\xc3\x98||two')
+    (u'one\xd8', u'two')
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8')
+    'utf-8'
+    >>> marshaler.ascii
+    False
+
+List
+----
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_list']), IFieldMarshaler)
+    >>> marshaler.marshal()
+    'three||four'
+    >>> marshaler.decode('three||four')
+    ['three', 'four']
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Set
+---
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_set']), IFieldMarshaler)
+    >>> marshaler.marshal() in ('False||True' or 'True||False',)
+    True
+    >>> marshaler.decode('True||False') == set([True, False])
+    True
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
+
+Frozenset
+---------
+
+    >>> marshaler = getMultiAdapter((t, ITestContent['_frozenset']), IFieldMarshaler)
+    >>> marshaler.marshal() in ('3:4:5||5:4:3', '5:4:3||3:4:5')
+    True
+    >>> marshaler.decode('3:4:5||5:4:3') == frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])
+    True
+    >>> marshaler.getContentType() is None
+    True
+    >>> marshaler.getCharset('utf-8') is None
+    True
+    >>> marshaler.ascii
+    True
diff --git a/plone/rfc822/fields.txt b/plone/rfc822/fields.txt
deleted file mode 100644
index afb5617..0000000
--- a/plone/rfc822/fields.txt
+++ /dev/null
@@ -1,503 +0,0 @@
-Field marshaler tests
-=====================
-
-This test exercises the various standard field marshalers.
-
-First, we load the package's configuration:
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.rfc822.tests">
-    ...      
-    ...     <include package="zope.component" file="meta.zcml" />
-    ...     <include package="zope.annotation" />
-    ...     
-    ...     <include package="plone.rfc822" />
-    ...     
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-Next, we'll create an interface which contains an instance of every field
-we support.
-
-    >>> from zope.interface import Interface
-    >>> from zope import schema
-    >>> from dateutil.tz import tzoffset
-    >>> tz = tzoffset('Europe/Oslo', 3600)
-
-    >>> class ITestContent(Interface):
-    ...     _text = schema.Text()
-    ...     _text2 = schema.Text()
-    ...     _textLine = schema.TextLine()
-    ...     _textLine2 = schema.TextLine()
-    ...     _password = schema.Password()
-    ...     _password2 = schema.Password()
-    ...     _bytes = schema.Bytes()
-    ...     _bytesLine = schema.BytesLine()
-    ...     _ascii = schema.ASCII()
-    ...     _asciiLine = schema.ASCIILine()
-    ...     _uri = schema.URI()
-    ...     _id = schema.Id()
-    ...     _dottedName = schema.DottedName()
-    ...     _bool = schema.Bool()
-    ...     _int = schema.Int()
-    ...     _float = schema.Float()
-    ...     _decimal = schema.Decimal()
-    ...     _choice1 = schema.Choice(values=[u"one", u"two", u"three"])
-    ...     _choice2 = schema.Choice(values=["one", "two", "three"])
-    ...     _datetime = schema.Datetime()
-    ...     _date = schema.Date()
-    ...     _timedelta = schema.Timedelta()
-    ...     _tuple = schema.Tuple(value_type=schema.TextLine())
-    ...     _list = schema.List(value_type=schema.ASCIILine())
-    ...     _set = schema.Set(value_type=schema.Bool())
-    ...     _frozenset = schema.FrozenSet(value_type=schema.Timedelta())
-
-This interface is implemented by a the following class:
-
-    >>> from zope.interface import implements
-    >>> import datetime
-    >>> from decimal import Decimal
-    >>> class TestContent(object):
-    ...     implements(ITestContent)
-    ...     _text = u"text\xd8"
-    ...     _text2 = u"text" # ascii safe
-    ...     _textLine = u"textline\xd8"
-    ...     _textLine2 = u"textline" # ascii safe
-    ...     _password = u"password\xd8"
-    ...     _password2 = u"password" # ascii safe
-    ...     _bytes = 'bytes'
-    ...     _bytesLine = 'bytesline'
-    ...     _ascii = 'ascii'
-    ...     _asciiLine = 'asciiline'
-    ...     _uri = 'http://plone.org'
-    ...     _id = 'some.id'
-    ...     _dottedName = 'dotted.name'
-    ...     _bool = True
-    ...     _int = -10l
-    ...     _float = 0.3
-    ...     _decimal = Decimal("5.0")
-    ...     _choice1 = u"two"
-    ...     _choice2 = 'two'
-    ...     _datetime = datetime.datetime(2009, 1, 2, 15, 10, 5, 1, tz)
-    ...     _date = datetime.date(2008, 2, 3)
-    ...     _timedelta = datetime.timedelta(3, 4, 5)
-    ...     _tuple = (u"one\xd8", u"two")
-    ...     _list = ['three', 'four']
-    ...     _set = set([True, False])
-    ...     _frozenset = frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])
-
-    >>> t = TestContent()
-
-We can now look up the marshaler for each one and test the marshalling and
-extraction methods.
-
-    >>> from zope.component import getMultiAdapter
-    >>> from plone.rfc822.interfaces import IFieldMarshaler
-
-Notes: 
-
-* Unicode \xd8 (capital letter O with stroke) is \xc3\x98 in UTF-8.
-* None of the default marshalers support getContentType(), i.e. they all
-  return None
-* For simplicity, we do not call ``demarshal()`` for each field. For all the
-  standard marshalers, this simply sets the value returned by ``extract()``
-  using the ``set()`` method on the field instance.
-
-Text
-----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_text']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'text\xc3\x98'
-    >>> marshaler.decode('text\xc3\x98')
-    u'text\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    False
-
-Text field types and derivatives will return True for the ``ascii`` property
-if the field value is within the ascii range.
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_text2']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'text'
-    >>> marshaler.decode('text\xc3\x98')
-    u'text\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    True
-
-TextLine
---------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_textLine']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'textline\xc3\x98'
-    >>> marshaler.decode('textline\xc3\x98')
-    u'textline\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    False
-
-Text field types and derivatives will return True for the ``ascii`` property
-if the field value is within the ascii range.
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_textLine2']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'textline'
-    >>> marshaler.decode('textline\xc3\x98')
-    u'textline\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    True
-
-Password
---------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_password']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'password\xc3\x98'
-    >>> marshaler.decode('password\xc3\x98')
-    u'password\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    False
-
-Text field types and derivatives will return True for the ``ascii`` property
-if the field value is within the ascii range.
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_password2']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'password'
-    >>> marshaler.decode('password\xc3\x98')
-    u'password\xd8'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    True
-
-Bytes
------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_bytes']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'bytes'
-    >>> marshaler.decode('bytes')
-    'bytes'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-BytesLine
----------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_bytesLine']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'bytesline'
-    >>> marshaler.decode('bytesline')
-    'bytesline'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-ASCII
------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_ascii']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'ascii'
-    >>> marshaler.decode('ascii')
-    'ascii'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-ASCIILine
----------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_asciiLine']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'asciiline'
-    >>> marshaler.decode('asciiline')
-    'asciiline'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-URI
----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_uri']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'http://plone.org'
-    >>> marshaler.decode('http://plone.org')
-    'http://plone.org'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Id
---
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_id']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'some.id'
-    >>> marshaler.decode('some.id')
-    'some.id'
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.ascii
-    True
-
-DottedName
-----------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_dottedName']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'dotted.name'
-    >>> marshaler.decode('dotted.name')
-    'dotted.name'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Bool
-----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_bool']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'True'
-    >>> t._bool = False
-    >>> marshaler.marshal()
-    'False'
-    >>> t._bool = True
-    >>> marshaler.decode('True')
-    True
-    >>> marshaler.decode('False')
-    False
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Int
----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_int']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '-10'
-    >>> marshaler.decode('-10')
-    -10
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Float
------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_float']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '0.3'
-    >>> marshaler.decode('0.25')
-    0.25
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Decimal
--------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_decimal']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '5.0'
-    >>> marshaler.decode('5.0')
-    Decimal('5.0')
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Choice
-------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_choice1']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'two'
-    >>> marshaler.decode('one')
-    u'one'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    True
-    
-    >>> marshaler = getMultiAdapter((t, ITestContent['_choice2']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'two'
-    >>> marshaler.decode('three')
-    u'three'
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    True
-
-Datetime
---------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_datetime']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '2009-01-02T15:10:05.000001+01:00'
-    >>> marshaler.decode('2009-01-02T15:10:05.000001+01:00')
-    datetime.datetime(2009, 1, 2, 15, 10, 5, 1, tzinfo=tzoffset(None, 3600))
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Date
-----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_date']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '2008-02-03'
-    >>> marshaler.decode('2008-02-03')
-    datetime.date(2008, 2, 3)
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Timedelta
----------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_timedelta']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    '3:4:5'
-    >>> marshaler.decode('3:4:5')
-    datetime.timedelta(3, 4, 5)
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Tuple
------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_tuple']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'one\xc3\x98||two'
-    >>> marshaler.decode('one\xc3\x98||two')
-    (u'one\xd8', u'two')
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8')
-    'utf-8'
-    >>> marshaler.ascii
-    False
-
-List
-----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_list']), IFieldMarshaler)
-    >>> marshaler.marshal()
-    'three||four'
-    >>> marshaler.decode('three||four')
-    ['three', 'four']
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Set
----
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_set']), IFieldMarshaler)
-    >>> marshaler.marshal() in ('False||True' or 'True||False',)
-    True
-    >>> marshaler.decode('True||False') == set([True, False])
-    True
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
-
-Frozenset
----------
-
-    >>> marshaler = getMultiAdapter((t, ITestContent['_frozenset']), IFieldMarshaler)
-    >>> marshaler.marshal() in ('3:4:5||5:4:3', '5:4:3||3:4:5')
-    True
-    >>> marshaler.decode('3:4:5||5:4:3') == frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])
-    True
-    >>> marshaler.getContentType() is None
-    True
-    >>> marshaler.getCharset('utf-8') is None
-    True
-    >>> marshaler.ascii
-    True
diff --git a/plone/rfc822/interfaces.py b/plone/rfc822/interfaces.py
index 949ffd5..0d17c54 100644
--- a/plone/rfc822/interfaces.py
+++ b/plone/rfc822/interfaces.py
@@ -1,70 +1,84 @@
+# -*- coding: utf-8 -*-
+from zope import schema
 from zope.interface import Attribute
 from zope.interface import Interface
-from zope import schema
+
 
 class IPrimaryField(Interface):
     """Marker interface for the primary field in a schema
     """
 
+
 class IPrimaryFieldInfo(Interface):
     """Information about the primary field of a content item
-    
+
     Content type frameworks should register an adapter to this interface.
     """
     fieldname = Attribute("Field name")
     field = Attribute("Field")
     value = Attribute("Field value")
 
+
 class IMessageAPI(Interface):
     """Functions provided by this module
-    
+
     These can all be imported as::
-    
+
         >>> from plone.rfc822 import constructMessage
     """
-    
+
     def constructMessageFromSchema(context, schema, charset='utf-8'):
         """Convenience method which calls ``constructMessage()`` with all the
         fields, in order, of the given schema interface
         """
-    
+
     def constructMessageFromSchemata(context, schemata, charset='utf-8'):
         """Convenience method which calls ``constructMessage()`` with all the
         fields, in order, of all the given schemata (a sequence of schema
         interfaces).
         """
-    
+
     def constructMessage(context, fields, charset='utf-8'):
         """Helper method to construct a message.
-    
+
         ``context`` is a content object.
-    
-        ``fields`` is a sequence of (name, field) pairs for the fields which make
-        up the message. This can be obtained from zope.schema.getFieldsInOrder,
-        for example.
-    
+
+        ``fields`` is a sequence of (name, field) pairs for the fields which
+        make up the message. This can be obtained from
+        zope.schema.getFieldsInOrder, for example.
+
         ``charset`` is the message charset.
-    
+
         The message body will be constructed from the primary field, i.e. the
         field which is marked with ``IPrimaryField``. If no such field exists,
-        the message will have no body. If multiple fields exist, the message will
-        be a multipart message. Otherwise, it will contain a scalar string
+        the message will have no body. If multiple fields exist, the message
+        will be a multipart message. Otherwise, it will contain a scalar string
         payload.
-    
+
         A field will be ignored if ``(context, field)`` cannot be multi-adapted
         to ``IFieldMarshaler``, or if the ``marshal()`` method returns None.
         """
-    
+
     def renderMessage(message, mangleFromHeader=False):
         """Render a message to a string
         """
-        
-    def initializeObjectFromSchema(context, schema, message, defaultCharset='utf-8'):
+
+    def initializeObjectFromSchema(
+        context,
+        schema,
+        message,
+        defaultCharset='utf-8'
+    ):
         """Convenience method which calls ``initializeObject()`` with all the
         fields, in order, of the given schema interface
         """
-    
-    def initializeObjectFromSchemata(context, schemata, message, defaultCharset='utf-8'):
+
+    def initializeObjectFromSchemata(
+        context,
+        schemata,
+        message,
+        defaultCharset='utf-8'
+    ):
         """Convenience method which calls ``initializeObject()`` with all the
         fields in order, of all the given schemata (a sequence of schema
         interfaces).
@@ -72,122 +86,135 @@ def initializeObjectFromSchemata(context, schemata, message, defaultCharset='utf
 
     def initializeObject(context, fields, message, defaultCharset='utf-8'):
         """Initialise an object from a message.
-    
+
         ``context`` is the content object to initialise.
-    
-        ``fields`` is a sequence of (name, field) pairs for the fields which make
-        up the message. This can be obtained from zope.schema.getFieldsInOrder,
-        for example.
-    
+
+        ``fields`` is a sequence of (name, field) pairs for the fields which
+        make up the message. This can be obtained from
+        zope.schema.getFieldsInOrder, for example.
+
         ``message`` is a ``Message`` object.
-    
+
         ``defaultCharset`` is the default character set to use.
-    
+
         If the message is a multipart message, the primary fields will be read
         in order.
         """
 
+
 class IFieldMarshaler(Interface):
     """Multi-adapter on (context, field), used for marshalling to and
     demarshalling from RFC2822 message headers.
-    
+
     This interface deals in unicode strings, which will be encoded/decoded
-    elsewhere. 
+    elsewhere.
     """
-    
+
     ascii = schema.Bool(
-            title=u"ASCII only",
-            description=u"Set this to true if this marshaler is guaranteed "
-                         "to return ASCII characters only. This will allow "
-                         "a header to be rendered without an encoding wrapper",
-            default=False,
-            required=True,
-        )
-    
+        title=u"ASCII only",
+        description=u"Set this to true if this marshaler is guaranteed "
+        "to return ASCII characters only. This will allow "
+        "a header to be rendered without an encoding wrapper",
+        default=False,
+        required=True,
+    )
+
     def marshal(charset='utf-8', primary=False):
         """Return the value of the adapted field on the adapted context.
-        
+
         Note: It may be necessary to adapt the context to the field's
               interface (``field.interface``) before getting the value.
-        
+
         ``charset`` is the default message charset. For string values, you
         should use this charset to encode the string. For binary values,
         it may be appropriate to use a different encoding method.
-        
+
         ``primary`` is set to True if the field being marshalled is a primary
         field, i.e. it will be used in the message body.
-        
+
         The returned value must be a string, or None if there is no value
         in the field.
-        
+
         Raise ``ValueError`` if marshaling is impossible. The field will be
         skipped.
         """
-    
-    def demarshal(value, message=None, charset='utf-8', contentType=None, primary=False):
+
+    def demarshal(
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         """Update the value of the adapted field on the adapted context.
-        
+
         Note: It may be necessary to adapt the context to the field's
               interface (``field.interface``) before getting the value.
-        
+
         ``value`` is the string value from the message.
-        
+
         ``message`` is the message object itself. This may be None if the
         marshaler is being used in isolation.
-        
+
         ``charset`` is the default charset for the message. For string
         values, this is most likely the encoding of the string. For binary
         values, it may not be.
-        
+
         ``primary`` is set to True if the field being demarshalled is a primary
         field, i.e. it came from the message body.
-        
+
         ``contentType`` is the ``Content-Type`` header from the message, or
         None if this is not available. This is mainly used for primary fields.
-        
+
         Raise ``ValueError`` if the demarshalling cannot be completed.
         """
-    
+
     def encode(value, charset='utf-8', primary=False):
         """Like marshal(), but acts on the passed-in ``value`` instead of
         reading it from the field.
-        
+
         This is only used for collection fields and other situations where
         the value is not read from an instance.
-        
+
         Return None if the value cannot be encoded.
         """
-    
-    def decode(value, message=None, charset='utf-8', contentType=None, primary=False):
+
+    def decode(
+        value,
+        message=None,
+        charset='utf-8',
+        contentType=None,
+        primary=False
+    ):
         """Like demarshal, but return the value instead of updating the field.
-        
+
         This is only used for collection fields and other situations where
         the instance should not be updated directly.
-        
+
         Raise ValueError if the value cannot be extracted.
         """
-    
+
     def getContentType():
         """Return the MIME type of the field. The value should be appropriate
         for the Content-Type HTTP header. This is mainly used for marshalling
         the primary field to the message body.
-        
+
         May return None if a content type does not make sense.
         """
-    
+
     def getCharset(defualt='utf-8'):
         """Return the charset of the field. The value should be appropriate
         for the 'charset' parameter to the Content-Type HTTP header. This is
-        mainly used for marshalling 
-        
+        mainly used for marshalling
+
         The ``default`` parameter contains the message's default charset.
-        
+
         Must return None if the message should not have a charset, i.e. it
         is not text data.
         """
-    
+
     def postProcessMessage(message):
         """This is a chance to perform any post-processing of the message.
-        
+
         It is only called for primary fields.
         """
diff --git a/plone/rfc822/message.rst b/plone/rfc822/message.rst
new file mode 100644
index 0000000..d44a256
--- /dev/null
+++ b/plone/rfc822/message.rst
@@ -0,0 +1,605 @@
+Message construction and parsing
+================================
+
+This package contains helper methods to construct an RFC 2822 style message
+from a list of schema fields, and to parse a message and initialise an object
+based on its headers and body payload.
+
+Before we begin, let's load the default field marshalers and configure
+annotations, which we will use later in this test.
+
+    >>> configuration = """\
+    ... <configure
+    ...      xmlns="http://namespaces.zope.org/zope"
+    ...      i18n_domain="plone.rfc822.tests">
+    ...      
+    ...     <include package="zope.component" file="meta.zcml" />
+    ...     <include package="zope.annotation" />
+    ...     
+    ...     <include package="plone.rfc822" />
+    ...     
+    ... </configure>
+    ... """
+
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+The primary field
+-----------------
+
+The message body is assumed to originate from a "primary" field, which is
+indicated via a marker interface.
+
+To illustrate the pattern, consider the following schema interface:
+
+    >>> from zope.interface import Interface, alsoProvides
+    >>> from plone.rfc822.interfaces import IPrimaryField
+    >>> from zope import schema
+
+    >>> class ITestContent(Interface):
+    ...
+    ...     title = schema.TextLine(title=u"Title")
+    ...     description = schema.Text(title=u"Description")
+    ...     body = schema.Text(title=u"Body text")
+    ...     emptyfield = schema.TextLine(title=u"Empty field", missing_value=u'missing')
+
+The primary field instance is marked like this:
+
+    >>> alsoProvides(ITestContent['body'], IPrimaryField)
+
+Constructing a message
+----------------------
+
+Let's now say we have an instance providing this interface, which we want to
+marshal to a message.
+
+    >>> from zope.interface import implements
+    >>> class TestContent(object):
+    ...     implements(ITestContent)
+    ...     title = u""
+    ...     description = u""
+    ...     body = u""
+    ...     emptyfield = None
+
+    >>> content = TestContent()
+    >>> content.title = u"Test title"
+    >>> content.description = u"""Test description
+    ... with a newline"""
+    >>> content.body = u"<p>Test body</p>"
+
+We could create a message form this instance and schema like this:
+
+    >>> from plone.rfc822 import constructMessageFromSchema
+    >>> msg = constructMessageFromSchema(content, ITestContent)
+
+The output looks like this:
+
+    >>> from plone.rfc822 import renderMessage
+    >>> print renderMessage(msg)
+    title: Test title
+    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    emptyfield: 
+    Content-Type: text/plain; charset="utf-8"
+    <BLANKLINE>
+    <p>Test body</p>
+
+Notice how the non-ASCII header values are UTF-8 encoded. The encoding
+algorithm is clever enough to only encode the value if it is necessary,
+leaving more readable field values otherwise.
+
+The body here is of the default message type:
+
+    >>> msg.get_default_type()
+    'text/plain'
+
+This is because none of the default field types manage a content type.
+
+The body is also utf-8 encoded, because the primary field specified this
+encoding.
+
+If we want to use a different content type, we could set it explicitly:
+
+    >>> msg.set_type('text/html')
+    >>> print renderMessage(msg)
+    title: Test title
+    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    emptyfield: 
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>Test body</p>
+
+Alternatively, if we know that any ``IText`` field on an object providing
+our ``ITestContent`` interface always stores HTML, could register a custom
+``IFieldMarshaler`` adapter which would indicate this to the message
+constructor. Let's take a look at that now.
+
+Custom marshalers
+-----------------
+
+The default marshaler can be obtained by multi-adapting the content object
+and the field instance to ``IFieldMarshaler``:
+
+    >>> from zope.component import getMultiAdapter
+    >>> from plone.rfc822.interfaces import IFieldMarshaler
+    >>> getMultiAdapter((content, ITestContent['body'],), IFieldMarshaler)
+    <plone.rfc822.defaultfields.UnicodeValueFieldMarshaler object at ...>
+
+Let's now create our own marshaler by extending this class and overriding
+the ``getContentType()``:
+
+    >>> from plone.rfc822.defaultfields import UnicodeValueFieldMarshaler
+    >>> from zope.schema.interfaces import IText
+    >>> from zope.component import adapts
+
+    >>> class TestBodyMarshaler(UnicodeValueFieldMarshaler):
+    ...     adapts(ITestContent, IText)
+    ...     
+    ...     def getContentType(self):
+    ...         return 'text/html'
+
+Ordinarily, we'd register this with ZCML. For the purpose of the test, we'll
+register it using the ``zope.component`` API.
+
+    >>> from zope.component import provideAdapter
+    >>> provideAdapter(TestBodyMarshaler)
+
+Hint: If the schema contained multiple text fields, this adapter would apply
+to all of them. To avoid that, we could either mark the field with a custom
+marker interface (similary to the way we marked a field with ``IPrimaryField``
+above), or have the marshaler check the field name.
+
+Let's now try again:
+
+    >>> msg = constructMessageFromSchema(content, ITestContent)
+    >>> print renderMessage(msg)
+    title: Test title
+    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    emptyfield: 
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>Test body</p>
+
+Notice how the Content-Type has changed.
+
+Consuming a message
+-------------------
+
+A message can be used to initialise an object. The object has to be
+constructed first:
+
+    >>> newContent = TestContent()
+
+We then need to obtain a ``Message`` object. The ``email`` module contains
+helper functions for this purpose.
+
+    >>> messageBody = """\
+    ... title: Test title
+    ... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    ... Content-Type: text/html
+    ...
+    ... <p>Test body</p>"""
+
+    >>> from email import message_from_string
+    >>> msg = message_from_string(messageBody)
+
+The message can now be used to initialise the object according to the given
+schema. This should be the same schema as the one used to construct the
+message.
+
+    >>> from plone.rfc822 import initializeObjectFromSchema
+    >>> initializeObjectFromSchema(newContent, ITestContent, msg)
+
+    >>> newContent.title
+    u'Test title'
+    >>> newContent.description
+    u'Test description\nwith a newline'
+    >>> newContent.body
+    u'<p>Test body</p>'
+
+We can also consume messages with a transfer encoding and a charset:
+
+    >>> messageBody = """\
+    ... title: =?utf-8?q?Test_title?=
+    ... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    ... emptyfield: 
+    ... Content-Transfer-Encoding: base64
+    ... Content-Type: text/html; charset="utf-8"
+    ... <BLANKLINE>
+    ... PHA+VGVzdCBib2R5PC9wPg==
+    ... <BLANKLINE>"""
+
+    >>> msg = message_from_string(messageBody)
+    >>> msg.get_content_type()
+    'text/html'
+    >>> msg.get_content_charset()
+    'utf-8'
+    
+    >>> initializeObjectFromSchema(newContent, ITestContent, msg)
+
+    >>> newContent.title
+    u'Test title'
+    >>> newContent.description
+    u'Test description\nwith a newline'
+    >>> newContent.body
+    u'<p>Test body</p>'
+
+Note: Empty fields will result in the field's ``missing_value`` being used:
+
+    >>> newContent.emptyfield
+    u'missing'
+
+Handling multiple primary fields and duplicate field names
+----------------------------------------------------------
+
+It is possible that our type could have multiple primary fields or even
+duplicate field names.
+
+For example, consider the following schema interface, intended to be used
+in an annotation adapter:
+
+    >>> class IPersonalDetails(Interface):
+    ...     description = schema.Text(title=u"Personal description")
+    ...     currentAge = schema.Int(title=u"Age", min=0)
+    ...     personalProfile = schema.Text(title=u"Profile")
+    
+    >>> alsoProvides(IPersonalDetails['personalProfile'], IPrimaryField)
+    
+The annotation storage would look like this:
+
+    >>> from persistent import Persistent
+    >>> class PersonalDetailsAnnotation(Persistent):
+    ...     implements(IPersonalDetails)
+    ...     adapts(ITestContent)
+    ...     
+    ...     def __init__(self):
+    ...         self.description = None
+    ...         self.currentAge = None
+    ...         self.personalProfile = None
+
+    >>> from zope.annotation.factory import factory
+    >>> provideAdapter(factory(PersonalDetailsAnnotation))
+
+We should now be able to adapt a content instance to IPersonalDetails,
+provided it is annotatable.
+
+    >>> from zope.annotation.interfaces import IAttributeAnnotatable
+    >>> alsoProvides(content, IAttributeAnnotatable)
+
+    >>> personalDetails = IPersonalDetails(content)
+    >>> personalDetails.description = u"<p>My description</p>"
+    >>> personalDetails.currentAge = 21
+    >>> personalDetails.personalProfile = u"<p>My profile</p>"
+
+The default marshalers will attempt to adapt the context to the schema of
+a given field before getting or setting a value. If we pass multiple schemata
+(or a combined sequence of fields) to the message constructor, it will
+handle both duplicate field names (as duplicate headers) and multiple primary
+fields (as multipart message attachments).
+
+Here are the fields it will see:
+
+    >>> from zope.schema import getFieldsInOrder
+    >>> allFields = getFieldsInOrder(ITestContent) + \
+    ...             getFieldsInOrder(IPersonalDetails)
+
+    >>> [f[0] for f in allFields]
+    ['title', 'description', 'body', 'emptyfield', 'description', 'currentAge', 'personalProfile']
+
+    >>> [f[0] for f in allFields if IPrimaryField.providedBy(f[1])]
+    ['body', 'personalProfile']
+
+Let's now construct a message. Since we now have two fields called 
+``description``, we will get two headers by that name. Since we have two
+primary fields, we will get a multipart message with two attachments.
+
+    >>> from plone.rfc822 import constructMessageFromSchemata
+    >>> msg = constructMessageFromSchemata(content, (ITestContent, IPersonalDetails,))
+    >>> msgString = renderMessage(msg)
+    >>> print msgString
+    title: Test title
+    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    emptyfield: 
+    description: <p>My description</p>
+    currentAge: 21
+    MIME-Version: 1.0
+    Content-Type: multipart/mixed; boundary="===============...=="
+    <BLANKLINE>
+    --===============...==
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>Test body</p>
+    --===============...==
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>My profile</p>
+    --===============...==--...
+
+(Note that we've used ellipses here for the doctest to work with the generated
+boundary string).
+
+Notice how both messages have a MIME type of 'text/html' and no charset.
+That is because of the custom adapter for ``(ITestContent, IText)`` which we
+registered earlier.
+
+We can obviously read this message as well. Note that in this case, the order
+of fields passed to ``initializeObject()`` is important, both to determine
+which field gets which ``description`` header, and to match the two
+attachments to the two primary fields:
+
+    >>> newContent = TestContent()
+    >>> alsoProvides(newContent, IAttributeAnnotatable)
+
+    >>> from plone.rfc822 import initializeObjectFromSchemata
+    >>> msg = message_from_string(msgString)
+    >>> initializeObjectFromSchemata(newContent, [ITestContent, IPersonalDetails], msg)
+
+    >>> newContent.title
+    u'Test title'
+    
+    >>> newContent.description
+    u'Test description\nwith a newline'
+
+    >>> newContent.body
+    u'<p>Test body</p>'
+
+    >>> newPersonalDetails = IPersonalDetails(newContent)
+    >>> newPersonalDetails.description
+    u'<p>My description</p>'
+
+    >>> newPersonalDetails.currentAge
+    21
+    
+    >>> newPersonalDetails.personalProfile
+    u'<p>My profile</p>'
+    
+Alternative ways to deal with multiple schemata
+-----------------------------------------------
+
+In the example above, we created a single enveloping message with headers
+corresponding to the fields in both our schemata, and only the primary fields
+separated out into different attached payloads.
+
+An alternative approach would be to separate each schema out into its
+own multipart message. To do that, we would simply use the
+``constructMessage()`` function multiple times.
+
+    >>> mainMessage = constructMessageFromSchema(content, ITestContent)
+    >>> personalDetailsMessage = constructMessageFromSchema(content, IPersonalDetails)
+
+    >>> from email.MIMEMultipart import MIMEMultipart
+    >>> envelope = MIMEMultipart()
+    >>> envelope.attach(mainMessage)
+    >>> envelope.attach(personalDetailsMessage)
+
+    >>> envelopeString = renderMessage(envelope)
+    >>> print envelopeString
+    Content-Type: multipart/mixed; boundary="===============...=="
+    MIME-Version: 1.0
+    <BLANKLINE>
+    --===============...==
+    title: Test title
+    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
+    emptyfield: 
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>Test body</p>
+    --===============...==
+    description: <p>My description</p>
+    currentAge: 21
+    MIME-Version: 1.0
+    Content-Type: text/html; charset="utf-8"
+    <BLANKLINE>
+    <p>My profile</p>
+    --===============...==--...
+
+Which approach works best will depend largely on the intended recipient of
+the message.
+
+Encoding the payload and handling filenames
+-------------------------------------------
+
+Finally, let's consider a more complex example, inspired by the field
+marshaler in ``plone.namedfile``.
+
+Let's say we have a value type intended to represent a binary file with a
+filename and content type:
+
+    >>> from zope.interface import Interface, implements
+    >>> from zope import schema
+    
+    >>> class IFileValue(Interface):
+    ...     data = schema.Bytes(title=u"Raw data")
+    ...     contentType = schema.ASCIILine(title=u"MIME type")
+    ...     filename = schema.ASCIILine(title=u"Filename")
+
+    >>> class FileValue(object):
+    ...     implements(IFileValue)
+    ...     def __init__(self, data, contentType, filename):
+    ...         self.data = data
+    ...         self.contentType = contentType
+    ...         self.filename = filename
+
+Suppose we had a custom field type to represent this:
+
+    >>> from zope.schema.interfaces import IObject
+    >>> class IFileField(IObject):
+    ...     pass
+
+    >>> class FileField(schema.Object):
+    ...     implements(IFileField)
+    ...     schema = IFileValue
+    ...     def __init__(self, **kw):
+    ...         if 'schema' in kw:
+    ...             self.schema = kw.pop('schema')
+    ...         super(FileField, self).__init__(schema=self.schema, **kw)
+
+We can register a field marshaler for this field which will do the following:
+
+* Insist that the field is only used as a primary field, since it makes
+  little sense to encode a binary file in a header.
+* Save the filename in a Content-Disposition header.
+* Be capable of reading the filename again from this header.
+* Encode the payload using base64
+
+    >>> from plone.rfc822.interfaces import IFieldMarshaler
+    >>> from email.Encoders import encode_base64
+
+    >>> from zope.component import adapts
+    >>> from plone.rfc822.defaultfields import BaseFieldMarshaler
+    
+    >>> class FileFieldMarshaler(BaseFieldMarshaler):
+    ...     adapts(Interface, IFileField)
+    ...
+    ...     ascii = False
+    ...
+    ...     def encode(self, value, charset='utf-8', primary=False):
+    ...         if not primary:
+    ...             raise ValueError("File field cannot be marshaled as a non-primary field")
+    ...         if value is None:
+    ...             return None
+    ...         return value.data
+    ...     
+    ...     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
+    ...         filename = None
+    ...         # get the filename from the Content-Disposition header if possible
+    ...         if primary and message is not None:
+    ...             filename = message.get_filename(None)
+    ...         return FileValue(value, contentType, filename)
+    ...     
+    ...     def getContentType(self):
+    ...         value = self._query()
+    ...         if value is None:
+    ...             return None
+    ...         return value.contentType
+    ...
+    ...     def getCharset(self, default='utf-8'):
+    ...         return None # this is not text data!
+    ...
+    ...     def postProcessMessage(self, message):
+    ...         value = self._query()
+    ...         if value is not None:
+    ...             filename = value.filename
+    ...             if filename:
+    ...                 # Add a new header storing the filename if we have one
+    ...                 message.add_header('Content-Disposition', 'attachment', filename=filename)
+    ...         # Apply base64 encoding
+    ...         encode_base64(message)
+    
+    >>> from zope.component import provideAdapter
+    >>> provideAdapter(FileFieldMarshaler)
+
+To illustrate marshaling, let's create a content object that contains two file
+fields.
+    
+    >>> class IFileContent(Interface):
+    ...     file1 = FileField()
+    ...     file2 = FileField()
+
+    >>> class FileContent(object):
+    ...     implements(IFileContent)
+    ...     file1 = None
+    ...     file2 = None
+
+    >>> fileContent = FileContent()
+    >>> fileContent.file1 = FileValue('dummy file', 'text/plain', 'dummy1.txt')
+    >>> fileContent.file2 = FileValue('<html><body>test</body></html>', 'text/html', 'dummy2.html')
+
+At this point, neither of these fields is marked as a primary field. Let's see
+what happens when we attempt to construct a message from this schema.
+
+    >>> from plone.rfc822 import constructMessageFromSchema
+    >>> message = constructMessageFromSchema(fileContent, IFileContent)
+    >>> print renderMessage(message)
+    <BLANKLINE>
+    <BLANKLINE>
+
+As expected, we got no message headers and no message body. Let's now mark one
+field as primary:
+
+    >>> from plone.rfc822.interfaces import IPrimaryField
+    >>> from zope.interface import alsoProvides
+    >>> alsoProvides(IFileContent['file1'], IPrimaryField)
+    
+    >>> message = constructMessageFromSchema(fileContent, IFileContent)
+    >>> messageBody = renderMessage(message)
+    >>> print messageBody
+    MIME-Version: 1.0
+    Content-Type: text/plain
+    Content-Disposition: attachment; filename="dummy1.txt"
+    Content-Transfer-Encoding: base64
+    <BLANKLINE>
+    ZHVtbXkgZmlsZQ==
+
+Here, we have a base64 encoded payload, a Content-Disposition header, and a
+Content-Type header according to the primary field.
+
+We can also reconstruct the object from this message.
+
+    >>> from plone.rfc822 import initializeObjectFromSchema
+    >>> from email import message_from_string
+    
+    >>> inputMessage = message_from_string(messageBody)
+    >>> newFileContent = FileContent()
+    >>> initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)
+    
+    >>> newFileContent.file1.data
+    'dummy file'
+    >>> newFileContent.file1.contentType
+    'text/plain'
+    >>> newFileContent.file1.filename
+    'dummy1.txt'
+
+    >>> newFileContent.file2 is None
+    True
+
+Let's now show what would happen if we encoded both files in the message.
+In this case, we should get a multipart document with two payloads.
+
+    >>> alsoProvides(IFileContent['file2'], IPrimaryField)
+    >>> message = constructMessageFromSchema(fileContent, IFileContent)
+    >>> messageBody = renderMessage(message)
+    >>> print messageBody # doctest: +ELLIPSIS
+    MIME-Version: 1.0
+    Content-Type: multipart/mixed; boundary="===============...=="
+    <BLANKLINE>
+    --===============...==
+    MIME-Version: 1.0
+    Content-Type: text/plain
+    Content-Disposition: attachment; filename="dummy1.txt"
+    Content-Transfer-Encoding: base64
+    <BLANKLINE>
+    ZHVtbXkgZmlsZQ==
+    --===============...==
+    MIME-Version: 1.0
+    Content-Type: text/html
+    Content-Disposition: attachment; filename="dummy2.html"
+    Content-Transfer-Encoding: base64
+    <BLANKLINE>
+    PGh0bWw+PGJvZHk+dGVzdDwvYm9keT48L2h0bWw+
+    --===============...==--...
+
+And again, we can reconstruct the object, this time with both fields:
+
+    >>> inputMessage = message_from_string(messageBody)
+    >>> newFileContent = FileContent()
+    >>> initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)
+    
+    >>> newFileContent.file1.data
+    'dummy file'
+    >>> newFileContent.file1.contentType
+    'text/plain'
+    >>> newFileContent.file1.filename
+    'dummy1.txt'
+
+    >>> newFileContent.file2.data
+    '<html><body>test</body></html>'
+    >>> newFileContent.file2.contentType
+    'text/html'
+    >>> newFileContent.file2.filename
+    'dummy2.html'
diff --git a/plone/rfc822/message.txt b/plone/rfc822/message.txt
deleted file mode 100644
index d44a256..0000000
--- a/plone/rfc822/message.txt
+++ /dev/null
@@ -1,605 +0,0 @@
-Message construction and parsing
-================================
-
-This package contains helper methods to construct an RFC 2822 style message
-from a list of schema fields, and to parse a message and initialise an object
-based on its headers and body payload.
-
-Before we begin, let's load the default field marshalers and configure
-annotations, which we will use later in this test.
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.rfc822.tests">
-    ...      
-    ...     <include package="zope.component" file="meta.zcml" />
-    ...     <include package="zope.annotation" />
-    ...     
-    ...     <include package="plone.rfc822" />
-    ...     
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-The primary field
------------------
-
-The message body is assumed to originate from a "primary" field, which is
-indicated via a marker interface.
-
-To illustrate the pattern, consider the following schema interface:
-
-    >>> from zope.interface import Interface, alsoProvides
-    >>> from plone.rfc822.interfaces import IPrimaryField
-    >>> from zope import schema
-
-    >>> class ITestContent(Interface):
-    ...
-    ...     title = schema.TextLine(title=u"Title")
-    ...     description = schema.Text(title=u"Description")
-    ...     body = schema.Text(title=u"Body text")
-    ...     emptyfield = schema.TextLine(title=u"Empty field", missing_value=u'missing')
-
-The primary field instance is marked like this:
-
-    >>> alsoProvides(ITestContent['body'], IPrimaryField)
-
-Constructing a message
-----------------------
-
-Let's now say we have an instance providing this interface, which we want to
-marshal to a message.
-
-    >>> from zope.interface import implements
-    >>> class TestContent(object):
-    ...     implements(ITestContent)
-    ...     title = u""
-    ...     description = u""
-    ...     body = u""
-    ...     emptyfield = None
-
-    >>> content = TestContent()
-    >>> content.title = u"Test title"
-    >>> content.description = u"""Test description
-    ... with a newline"""
-    >>> content.body = u"<p>Test body</p>"
-
-We could create a message form this instance and schema like this:
-
-    >>> from plone.rfc822 import constructMessageFromSchema
-    >>> msg = constructMessageFromSchema(content, ITestContent)
-
-The output looks like this:
-
-    >>> from plone.rfc822 import renderMessage
-    >>> print renderMessage(msg)
-    title: Test title
-    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    emptyfield: 
-    Content-Type: text/plain; charset="utf-8"
-    <BLANKLINE>
-    <p>Test body</p>
-
-Notice how the non-ASCII header values are UTF-8 encoded. The encoding
-algorithm is clever enough to only encode the value if it is necessary,
-leaving more readable field values otherwise.
-
-The body here is of the default message type:
-
-    >>> msg.get_default_type()
-    'text/plain'
-
-This is because none of the default field types manage a content type.
-
-The body is also utf-8 encoded, because the primary field specified this
-encoding.
-
-If we want to use a different content type, we could set it explicitly:
-
-    >>> msg.set_type('text/html')
-    >>> print renderMessage(msg)
-    title: Test title
-    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    emptyfield: 
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>Test body</p>
-
-Alternatively, if we know that any ``IText`` field on an object providing
-our ``ITestContent`` interface always stores HTML, could register a custom
-``IFieldMarshaler`` adapter which would indicate this to the message
-constructor. Let's take a look at that now.
-
-Custom marshalers
------------------
-
-The default marshaler can be obtained by multi-adapting the content object
-and the field instance to ``IFieldMarshaler``:
-
-    >>> from zope.component import getMultiAdapter
-    >>> from plone.rfc822.interfaces import IFieldMarshaler
-    >>> getMultiAdapter((content, ITestContent['body'],), IFieldMarshaler)
-    <plone.rfc822.defaultfields.UnicodeValueFieldMarshaler object at ...>
-
-Let's now create our own marshaler by extending this class and overriding
-the ``getContentType()``:
-
-    >>> from plone.rfc822.defaultfields import UnicodeValueFieldMarshaler
-    >>> from zope.schema.interfaces import IText
-    >>> from zope.component import adapts
-
-    >>> class TestBodyMarshaler(UnicodeValueFieldMarshaler):
-    ...     adapts(ITestContent, IText)
-    ...     
-    ...     def getContentType(self):
-    ...         return 'text/html'
-
-Ordinarily, we'd register this with ZCML. For the purpose of the test, we'll
-register it using the ``zope.component`` API.
-
-    >>> from zope.component import provideAdapter
-    >>> provideAdapter(TestBodyMarshaler)
-
-Hint: If the schema contained multiple text fields, this adapter would apply
-to all of them. To avoid that, we could either mark the field with a custom
-marker interface (similary to the way we marked a field with ``IPrimaryField``
-above), or have the marshaler check the field name.
-
-Let's now try again:
-
-    >>> msg = constructMessageFromSchema(content, ITestContent)
-    >>> print renderMessage(msg)
-    title: Test title
-    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    emptyfield: 
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>Test body</p>
-
-Notice how the Content-Type has changed.
-
-Consuming a message
--------------------
-
-A message can be used to initialise an object. The object has to be
-constructed first:
-
-    >>> newContent = TestContent()
-
-We then need to obtain a ``Message`` object. The ``email`` module contains
-helper functions for this purpose.
-
-    >>> messageBody = """\
-    ... title: Test title
-    ... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    ... Content-Type: text/html
-    ...
-    ... <p>Test body</p>"""
-
-    >>> from email import message_from_string
-    >>> msg = message_from_string(messageBody)
-
-The message can now be used to initialise the object according to the given
-schema. This should be the same schema as the one used to construct the
-message.
-
-    >>> from plone.rfc822 import initializeObjectFromSchema
-    >>> initializeObjectFromSchema(newContent, ITestContent, msg)
-
-    >>> newContent.title
-    u'Test title'
-    >>> newContent.description
-    u'Test description\nwith a newline'
-    >>> newContent.body
-    u'<p>Test body</p>'
-
-We can also consume messages with a transfer encoding and a charset:
-
-    >>> messageBody = """\
-    ... title: =?utf-8?q?Test_title?=
-    ... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    ... emptyfield: 
-    ... Content-Transfer-Encoding: base64
-    ... Content-Type: text/html; charset="utf-8"
-    ... <BLANKLINE>
-    ... PHA+VGVzdCBib2R5PC9wPg==
-    ... <BLANKLINE>"""
-
-    >>> msg = message_from_string(messageBody)
-    >>> msg.get_content_type()
-    'text/html'
-    >>> msg.get_content_charset()
-    'utf-8'
-    
-    >>> initializeObjectFromSchema(newContent, ITestContent, msg)
-
-    >>> newContent.title
-    u'Test title'
-    >>> newContent.description
-    u'Test description\nwith a newline'
-    >>> newContent.body
-    u'<p>Test body</p>'
-
-Note: Empty fields will result in the field's ``missing_value`` being used:
-
-    >>> newContent.emptyfield
-    u'missing'
-
-Handling multiple primary fields and duplicate field names
-----------------------------------------------------------
-
-It is possible that our type could have multiple primary fields or even
-duplicate field names.
-
-For example, consider the following schema interface, intended to be used
-in an annotation adapter:
-
-    >>> class IPersonalDetails(Interface):
-    ...     description = schema.Text(title=u"Personal description")
-    ...     currentAge = schema.Int(title=u"Age", min=0)
-    ...     personalProfile = schema.Text(title=u"Profile")
-    
-    >>> alsoProvides(IPersonalDetails['personalProfile'], IPrimaryField)
-    
-The annotation storage would look like this:
-
-    >>> from persistent import Persistent
-    >>> class PersonalDetailsAnnotation(Persistent):
-    ...     implements(IPersonalDetails)
-    ...     adapts(ITestContent)
-    ...     
-    ...     def __init__(self):
-    ...         self.description = None
-    ...         self.currentAge = None
-    ...         self.personalProfile = None
-
-    >>> from zope.annotation.factory import factory
-    >>> provideAdapter(factory(PersonalDetailsAnnotation))
-
-We should now be able to adapt a content instance to IPersonalDetails,
-provided it is annotatable.
-
-    >>> from zope.annotation.interfaces import IAttributeAnnotatable
-    >>> alsoProvides(content, IAttributeAnnotatable)
-
-    >>> personalDetails = IPersonalDetails(content)
-    >>> personalDetails.description = u"<p>My description</p>"
-    >>> personalDetails.currentAge = 21
-    >>> personalDetails.personalProfile = u"<p>My profile</p>"
-
-The default marshalers will attempt to adapt the context to the schema of
-a given field before getting or setting a value. If we pass multiple schemata
-(or a combined sequence of fields) to the message constructor, it will
-handle both duplicate field names (as duplicate headers) and multiple primary
-fields (as multipart message attachments).
-
-Here are the fields it will see:
-
-    >>> from zope.schema import getFieldsInOrder
-    >>> allFields = getFieldsInOrder(ITestContent) + \
-    ...             getFieldsInOrder(IPersonalDetails)
-
-    >>> [f[0] for f in allFields]
-    ['title', 'description', 'body', 'emptyfield', 'description', 'currentAge', 'personalProfile']
-
-    >>> [f[0] for f in allFields if IPrimaryField.providedBy(f[1])]
-    ['body', 'personalProfile']
-
-Let's now construct a message. Since we now have two fields called 
-``description``, we will get two headers by that name. Since we have two
-primary fields, we will get a multipart message with two attachments.
-
-    >>> from plone.rfc822 import constructMessageFromSchemata
-    >>> msg = constructMessageFromSchemata(content, (ITestContent, IPersonalDetails,))
-    >>> msgString = renderMessage(msg)
-    >>> print msgString
-    title: Test title
-    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    emptyfield: 
-    description: <p>My description</p>
-    currentAge: 21
-    MIME-Version: 1.0
-    Content-Type: multipart/mixed; boundary="===============...=="
-    <BLANKLINE>
-    --===============...==
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>Test body</p>
-    --===============...==
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>My profile</p>
-    --===============...==--...
-
-(Note that we've used ellipses here for the doctest to work with the generated
-boundary string).
-
-Notice how both messages have a MIME type of 'text/html' and no charset.
-That is because of the custom adapter for ``(ITestContent, IText)`` which we
-registered earlier.
-
-We can obviously read this message as well. Note that in this case, the order
-of fields passed to ``initializeObject()`` is important, both to determine
-which field gets which ``description`` header, and to match the two
-attachments to the two primary fields:
-
-    >>> newContent = TestContent()
-    >>> alsoProvides(newContent, IAttributeAnnotatable)
-
-    >>> from plone.rfc822 import initializeObjectFromSchemata
-    >>> msg = message_from_string(msgString)
-    >>> initializeObjectFromSchemata(newContent, [ITestContent, IPersonalDetails], msg)
-
-    >>> newContent.title
-    u'Test title'
-    
-    >>> newContent.description
-    u'Test description\nwith a newline'
-
-    >>> newContent.body
-    u'<p>Test body</p>'
-
-    >>> newPersonalDetails = IPersonalDetails(newContent)
-    >>> newPersonalDetails.description
-    u'<p>My description</p>'
-
-    >>> newPersonalDetails.currentAge
-    21
-    
-    >>> newPersonalDetails.personalProfile
-    u'<p>My profile</p>'
-    
-Alternative ways to deal with multiple schemata
------------------------------------------------
-
-In the example above, we created a single enveloping message with headers
-corresponding to the fields in both our schemata, and only the primary fields
-separated out into different attached payloads.
-
-An alternative approach would be to separate each schema out into its
-own multipart message. To do that, we would simply use the
-``constructMessage()`` function multiple times.
-
-    >>> mainMessage = constructMessageFromSchema(content, ITestContent)
-    >>> personalDetailsMessage = constructMessageFromSchema(content, IPersonalDetails)
-
-    >>> from email.MIMEMultipart import MIMEMultipart
-    >>> envelope = MIMEMultipart()
-    >>> envelope.attach(mainMessage)
-    >>> envelope.attach(personalDetailsMessage)
-
-    >>> envelopeString = renderMessage(envelope)
-    >>> print envelopeString
-    Content-Type: multipart/mixed; boundary="===============...=="
-    MIME-Version: 1.0
-    <BLANKLINE>
-    --===============...==
-    title: Test title
-    description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=
-    emptyfield: 
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>Test body</p>
-    --===============...==
-    description: <p>My description</p>
-    currentAge: 21
-    MIME-Version: 1.0
-    Content-Type: text/html; charset="utf-8"
-    <BLANKLINE>
-    <p>My profile</p>
-    --===============...==--...
-
-Which approach works best will depend largely on the intended recipient of
-the message.
-
-Encoding the payload and handling filenames
--------------------------------------------
-
-Finally, let's consider a more complex example, inspired by the field
-marshaler in ``plone.namedfile``.
-
-Let's say we have a value type intended to represent a binary file with a
-filename and content type:
-
-    >>> from zope.interface import Interface, implements
-    >>> from zope import schema
-    
-    >>> class IFileValue(Interface):
-    ...     data = schema.Bytes(title=u"Raw data")
-    ...     contentType = schema.ASCIILine(title=u"MIME type")
-    ...     filename = schema.ASCIILine(title=u"Filename")
-
-    >>> class FileValue(object):
-    ...     implements(IFileValue)
-    ...     def __init__(self, data, contentType, filename):
-    ...         self.data = data
-    ...         self.contentType = contentType
-    ...         self.filename = filename
-
-Suppose we had a custom field type to represent this:
-
-    >>> from zope.schema.interfaces import IObject
-    >>> class IFileField(IObject):
-    ...     pass
-
-    >>> class FileField(schema.Object):
-    ...     implements(IFileField)
-    ...     schema = IFileValue
-    ...     def __init__(self, **kw):
-    ...         if 'schema' in kw:
-    ...             self.schema = kw.pop('schema')
-    ...         super(FileField, self).__init__(schema=self.schema, **kw)
-
-We can register a field marshaler for this field which will do the following:
-
-* Insist that the field is only used as a primary field, since it makes
-  little sense to encode a binary file in a header.
-* Save the filename in a Content-Disposition header.
-* Be capable of reading the filename again from this header.
-* Encode the payload using base64
-
-    >>> from plone.rfc822.interfaces import IFieldMarshaler
-    >>> from email.Encoders import encode_base64
-
-    >>> from zope.component import adapts
-    >>> from plone.rfc822.defaultfields import BaseFieldMarshaler
-    
-    >>> class FileFieldMarshaler(BaseFieldMarshaler):
-    ...     adapts(Interface, IFileField)
-    ...
-    ...     ascii = False
-    ...
-    ...     def encode(self, value, charset='utf-8', primary=False):
-    ...         if not primary:
-    ...             raise ValueError("File field cannot be marshaled as a non-primary field")
-    ...         if value is None:
-    ...             return None
-    ...         return value.data
-    ...     
-    ...     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):
-    ...         filename = None
-    ...         # get the filename from the Content-Disposition header if possible
-    ...         if primary and message is not None:
-    ...             filename = message.get_filename(None)
-    ...         return FileValue(value, contentType, filename)
-    ...     
-    ...     def getContentType(self):
-    ...         value = self._query()
-    ...         if value is None:
-    ...             return None
-    ...         return value.contentType
-    ...
-    ...     def getCharset(self, default='utf-8'):
-    ...         return None # this is not text data!
-    ...
-    ...     def postProcessMessage(self, message):
-    ...         value = self._query()
-    ...         if value is not None:
-    ...             filename = value.filename
-    ...             if filename:
-    ...                 # Add a new header storing the filename if we have one
-    ...                 message.add_header('Content-Disposition', 'attachment', filename=filename)
-    ...         # Apply base64 encoding
-    ...         encode_base64(message)
-    
-    >>> from zope.component import provideAdapter
-    >>> provideAdapter(FileFieldMarshaler)
-
-To illustrate marshaling, let's create a content object that contains two file
-fields.
-    
-    >>> class IFileContent(Interface):
-    ...     file1 = FileField()
-    ...     file2 = FileField()
-
-    >>> class FileContent(object):
-    ...     implements(IFileContent)
-    ...     file1 = None
-    ...     file2 = None
-
-    >>> fileContent = FileContent()
-    >>> fileContent.file1 = FileValue('dummy file', 'text/plain', 'dummy1.txt')
-    >>> fileContent.file2 = FileValue('<html><body>test</body></html>', 'text/html', 'dummy2.html')
-
-At this point, neither of these fields is marked as a primary field. Let's see
-what happens when we attempt to construct a message from this schema.
-
-    >>> from plone.rfc822 import constructMessageFromSchema
-    >>> message = constructMessageFromSchema(fileContent, IFileContent)
-    >>> print renderMessage(message)
-    <BLANKLINE>
-    <BLANKLINE>
-
-As expected, we got no message headers and no message body. Let's now mark one
-field as primary:
-
-    >>> from plone.rfc822.interfaces import IPrimaryField
-    >>> from zope.interface import alsoProvides
-    >>> alsoProvides(IFileContent['file1'], IPrimaryField)
-    
-    >>> message = constructMessageFromSchema(fileContent, IFileContent)
-    >>> messageBody = renderMessage(message)
-    >>> print messageBody
-    MIME-Version: 1.0
-    Content-Type: text/plain
-    Content-Disposition: attachment; filename="dummy1.txt"
-    Content-Transfer-Encoding: base64
-    <BLANKLINE>
-    ZHVtbXkgZmlsZQ==
-
-Here, we have a base64 encoded payload, a Content-Disposition header, and a
-Content-Type header according to the primary field.
-
-We can also reconstruct the object from this message.
-
-    >>> from plone.rfc822 import initializeObjectFromSchema
-    >>> from email import message_from_string
-    
-    >>> inputMessage = message_from_string(messageBody)
-    >>> newFileContent = FileContent()
-    >>> initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)
-    
-    >>> newFileContent.file1.data
-    'dummy file'
-    >>> newFileContent.file1.contentType
-    'text/plain'
-    >>> newFileContent.file1.filename
-    'dummy1.txt'
-
-    >>> newFileContent.file2 is None
-    True
-
-Let's now show what would happen if we encoded both files in the message.
-In this case, we should get a multipart document with two payloads.
-
-    >>> alsoProvides(IFileContent['file2'], IPrimaryField)
-    >>> message = constructMessageFromSchema(fileContent, IFileContent)
-    >>> messageBody = renderMessage(message)
-    >>> print messageBody # doctest: +ELLIPSIS
-    MIME-Version: 1.0
-    Content-Type: multipart/mixed; boundary="===============...=="
-    <BLANKLINE>
-    --===============...==
-    MIME-Version: 1.0
-    Content-Type: text/plain
-    Content-Disposition: attachment; filename="dummy1.txt"
-    Content-Transfer-Encoding: base64
-    <BLANKLINE>
-    ZHVtbXkgZmlsZQ==
-    --===============...==
-    MIME-Version: 1.0
-    Content-Type: text/html
-    Content-Disposition: attachment; filename="dummy2.html"
-    Content-Transfer-Encoding: base64
-    <BLANKLINE>
-    PGh0bWw+PGJvZHk+dGVzdDwvYm9keT48L2h0bWw+
-    --===============...==--...
-
-And again, we can reconstruct the object, this time with both fields:
-
-    >>> inputMessage = message_from_string(messageBody)
-    >>> newFileContent = FileContent()
-    >>> initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)
-    
-    >>> newFileContent.file1.data
-    'dummy file'
-    >>> newFileContent.file1.contentType
-    'text/plain'
-    >>> newFileContent.file1.filename
-    'dummy1.txt'
-
-    >>> newFileContent.file2.data
-    '<html><body>test</body></html>'
-    >>> newFileContent.file2.contentType
-    'text/html'
-    >>> newFileContent.file2.filename
-    'dummy2.html'
diff --git a/plone/rfc822/supermodel.py b/plone/rfc822/supermodel.py
index 47fadc0..6d24d72 100644
--- a/plone/rfc822/supermodel.py
+++ b/plone/rfc822/supermodel.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 try:
     from plone.supermodel.interfaces import IFieldMetadataHandler
     HAVE_SUPERMODEL = True
@@ -5,27 +6,31 @@
     HAVE_SUPERMODEL = False
 
 if HAVE_SUPERMODEL:
-    
-    from zope.interface import implementer, alsoProvides
-    from plone.supermodel.utils import ns
+
     from plone.rfc822.interfaces import IPrimaryField
-    
+    from plone.supermodel.utils import ns
+    from zope.interface import alsoProvides
+    from zope.interface import implementer
+
     @implementer(IFieldMetadataHandler)
     class PrimaryFieldMetadataHandler(object):
         """Define the ``marshal`` namespace.
-        
+
         This lets you write marshal:primary="true" on a field to mark it as
         a primary field.
         """
-        
+
         namespace = "http://namespaces.plone.org/supermodel/marshal"
         prefix = "marshal"
-    
+
         def read(self, fieldNode, schema, field):
-            primary = fieldNode.get(ns('primary',  self.namespace))
-            if primary is not None and primary.lower() in ("true", "on", "yes", "y", "1"):
+            primary = fieldNode.get(ns('primary', self.namespace))
+            if (
+                primary is not None and
+                primary.lower() in ("true", "on", "yes", "y", "1")
+            ):
                 alsoProvides(field, IPrimaryField)
-    
+
         def write(self, fieldNode, schema, field):
             if IPrimaryField.providedBy(field):
                 fieldNode.set(ns('primary', self.namespace), "true")
diff --git a/plone/rfc822/supermodel.rst b/plone/rfc822/supermodel.rst
new file mode 100644
index 0000000..ba726b6
--- /dev/null
+++ b/plone/rfc822/supermodel.rst
@@ -0,0 +1,76 @@
+Supermodel handler
+==================
+
+This package contains a handler for the ``marshal`` ``plone.supermodel``
+namespace, which can be used to mark the primary field of a schema.
+
+This handler is installed so long as ``plone.supermodel`` is installed.
+
+First, let's load this package's ZCML so that we can run the tests:
+
+    >>> configuration = """\
+    ... <configure xmlns="http://namespaces.zope.org/zope">
+    ...
+    ...     <include package="Products.Five" file="configure.zcml" />
+    ...     <include package="plone.supermodel" />
+    ...     <include package="plone.rfc822" />
+    ...
+    ... </configure>
+    ... """
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+Next, let's define a sample model that exercises the 'marshal' attribute.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
+    ...        xmlns:marshal="http://namespaces.plone.org/supermodel/marshal">
+    ...     <schema>
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title>title</title>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="body" marshal:primary="true">
+    ...             <title>Body</title>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+We can load this using plone.supermodel:
+
+    >>> from plone.supermodel import loadString
+    >>> model = loadString(schema)
+
+The ``body`` field should now be marked with the ``IPrimaryField`` marker:
+
+    >>> from plone.rfc822.interfaces import IPrimaryField
+    >>> schema = model.schema
+    >>> IPrimaryField.providedBy(schema['title'])
+    False
+    >>> IPrimaryField.providedBy(schema['body'])
+    True
+
+Naturally, we can also write out the primary field attribute from an interface
+on which it is marked:
+
+    >>> from zope.interface import Interface, alsoProvides
+    >>> from zope import schema
+    >>> class ITestSchema(Interface):
+    ...     title = schema.TextLine(title=u"Title")
+    ...     body = schema.Text(title=u"Body")
+    >>> alsoProvides(ITestSchema['body'], IPrimaryField)
+
+    >>> from plone.supermodel import serializeSchema
+    >>> print serializeSchema(ITestSchema) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:marshal="http://namespaces.plone.org/supermodel/marshal" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema based-on="zope.interface.Interface">
+        <field name="title" type="zope.schema.TextLine">
+          <title>Title</title>
+        </field>
+        <field name="body" type="zope.schema.Text" marshal:primary="true">
+          <title>Body</title>
+        </field>
+      </schema>
+    </model>
diff --git a/plone/rfc822/supermodel.txt b/plone/rfc822/supermodel.txt
deleted file mode 100644
index ba726b6..0000000
--- a/plone/rfc822/supermodel.txt
+++ /dev/null
@@ -1,76 +0,0 @@
-Supermodel handler
-==================
-
-This package contains a handler for the ``marshal`` ``plone.supermodel``
-namespace, which can be used to mark the primary field of a schema.
-
-This handler is installed so long as ``plone.supermodel`` is installed.
-
-First, let's load this package's ZCML so that we can run the tests:
-
-    >>> configuration = """\
-    ... <configure xmlns="http://namespaces.zope.org/zope">
-    ...
-    ...     <include package="Products.Five" file="configure.zcml" />
-    ...     <include package="plone.supermodel" />
-    ...     <include package="plone.rfc822" />
-    ...
-    ... </configure>
-    ... """
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-Next, let's define a sample model that exercises the 'marshal' attribute.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
-    ...        xmlns:marshal="http://namespaces.plone.org/supermodel/marshal">
-    ...     <schema>
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title>title</title>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="body" marshal:primary="true">
-    ...             <title>Body</title>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-We can load this using plone.supermodel:
-
-    >>> from plone.supermodel import loadString
-    >>> model = loadString(schema)
-
-The ``body`` field should now be marked with the ``IPrimaryField`` marker:
-
-    >>> from plone.rfc822.interfaces import IPrimaryField
-    >>> schema = model.schema
-    >>> IPrimaryField.providedBy(schema['title'])
-    False
-    >>> IPrimaryField.providedBy(schema['body'])
-    True
-
-Naturally, we can also write out the primary field attribute from an interface
-on which it is marked:
-
-    >>> from zope.interface import Interface, alsoProvides
-    >>> from zope import schema
-    >>> class ITestSchema(Interface):
-    ...     title = schema.TextLine(title=u"Title")
-    ...     body = schema.Text(title=u"Body")
-    >>> alsoProvides(ITestSchema['body'], IPrimaryField)
-
-    >>> from plone.supermodel import serializeSchema
-    >>> print serializeSchema(ITestSchema) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:marshal="http://namespaces.plone.org/supermodel/marshal" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema based-on="zope.interface.Interface">
-        <field name="title" type="zope.schema.TextLine">
-          <title>Title</title>
-        </field>
-        <field name="body" type="zope.schema.Text" marshal:primary="true">
-          <title>Body</title>
-        </field>
-      </schema>
-    </model>
diff --git a/plone/rfc822/tests.py b/plone/rfc822/tests.py
index 3679ca6..c58dbb2 100644
--- a/plone/rfc822/tests.py
+++ b/plone/rfc822/tests.py
@@ -1,13 +1,15 @@
-import unittest
-import doctest
+# -*- coding: utf-8 -*-
 from plone.testing import layered
 from plone.testing.zca import UNIT_TESTING
 
+import doctest
+import unittest
+
 
 DOCFILES = [
-    'message.txt',
-    'fields.txt',
-    'supermodel.txt',
+    'message.rst',
+    'fields.rst',
+    'supermodel.rst',
 ]
 
 optionflags = doctest.ELLIPSIS
diff --git a/setup.py b/setup.py
index d3e2356..b3dd81b 100644
--- a/setup.py
+++ b/setup.py
@@ -1,6 +1,10 @@
-from setuptools import setup, find_packages
+# -*- coding: utf-8 -*-
+from setuptools import find_packages
+from setuptools import setup
+
 import os
 
+
 version = '1.1.3.dev0'
 
 setup(
@@ -10,7 +14,7 @@
     long_description=(
         open("README.rst").read() + "\n" +
         open("CHANGES.rst").read() +
-        open(os.path.join("plone", "rfc822", "message.txt")).read()),
+        open(os.path.join("plone", "rfc822", "message.rst")).read()),
     # Get more strings from
     # https://pypi.python.org/pypi?%3Aaction=list_classifiers
     classifiers=[
@@ -33,8 +37,8 @@
     include_package_data=True,
     zip_safe=False,
     extras_require={
-      'supermodel': ['plone.supermodel'],
-      'test': ['plone.testing'],
+        'supermodel': ['plone.supermodel'],
+        'test': ['plone.testing'],
     },
     install_requires=[
         'setuptools',
@@ -45,4 +49,4 @@
     ],
     entry_points="""
     """,
-    )
+)


