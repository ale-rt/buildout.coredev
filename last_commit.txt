Repository: Products.CMFPlone


Branch: refs/heads/4.3.x
Date: 2016-05-04T14:51:37+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/a8a2a565bda3b6ed463923b01bfd78b115409495

Removed more docstrings.

Files changed:
M Products/CMFPlone/ActionsTool.py
M Products/CMFPlone/CatalogTool.py
M Products/CMFPlone/MigrationTool.py
M Products/CMFPlone/PloneBatch.py
M Products/CMFPlone/PloneControlPanel.py
M Products/CMFPlone/PloneFolder.py
M Products/CMFPlone/PloneTool.py
M Products/CMFPlone/Portal.py
M Products/CMFPlone/PropertiesTool.py
M Products/CMFPlone/QuickInstallerTool.py
M Products/CMFPlone/RegistrationTool.py
M Products/CMFPlone/SkinsTool.py
M Products/CMFPlone/TypesTool.py
M Products/CMFPlone/URLTool.py
M Products/CMFPlone/WorkflowTool.py
M Products/CMFPlone/utils.py
M docs/CHANGES.rst

diff --git a/Products/CMFPlone/ActionsTool.py b/Products/CMFPlone/ActionsTool.py
index 91d9b04..fa48841 100644
--- a/Products/CMFPlone/ActionsTool.py
+++ b/Products/CMFPlone/ActionsTool.py
@@ -91,8 +91,7 @@ def listActionInfos(self, action_chain=None, object=None,
     def listFilteredActionsFor(self, object=None,
                                ignore_providers=(),
                                ignore_categories=None):
-        """ List all actions available to the user.
-        """
+        # List all actions available to the user.
         actions = []
 
         providers = [name for name in self.listActionProviders()
diff --git a/Products/CMFPlone/CatalogTool.py b/Products/CMFPlone/CatalogTool.py
index da942de..b08bfcd 100644
--- a/Products/CMFPlone/CatalogTool.py
+++ b/Products/CMFPlone/CatalogTool.py
@@ -299,16 +299,14 @@ def __init__(self):
         ZCatalog.__init__(self, self.getId())
 
     def _removeIndex(self, index):
-        """Safe removal of an index.
-        """
+        # Safe removal of an index.
         try:
             self.manage_delIndex(index)
         except:
             pass
 
     def _listAllowedRolesAndUsers(self, user):
-        """Makes sure the list includes the user's groups.
-        """
+        # Makes sure the list includes the user's groups.
         result = user.getRoles()
         if 'Anonymous' in result:
             # The anonymous user has no further roles
@@ -325,11 +323,9 @@ def _listAllowedRolesAndUsers(self, user):
 
     security.declarePrivate('indexObject')
     def indexObject(self, object, idxs=None):
-        """Add object to catalog.
-
-        The optional idxs argument is a list of specific indexes
-        to populate (all of them by default).
-        """
+        # Add object to catalog.
+        # The optional idxs argument is a list of specific indexes
+        # to populate (all of them by default).
         if idxs is None:
             idxs = []
         self.reindexObject(object, idxs)
@@ -368,15 +364,15 @@ def getCounter(self):
 
     security.declareProtected(SearchZCatalog, 'searchResults')
     def searchResults(self, REQUEST=None, **kw):
-        """Calls ZCatalog.searchResults with extra arguments that
-        limit the results to what the user is allowed to see.
+        # Calls ZCatalog.searchResults with extra arguments that
+        # limit the results to what the user is allowed to see.
+        #
+        # This version uses the 'effectiveRange' DateRangeIndex.
+        #
+        # It also accepts a keyword argument show_inactive to disable
+        # effectiveRange checking entirely even for those without portal
+        # wide AccessInactivePortalContent permission.
 
-        This version uses the 'effectiveRange' DateRangeIndex.
-
-        It also accepts a keyword argument show_inactive to disable
-        effectiveRange checking entirely even for those without portal
-        wide AccessInactivePortalContent permission.
-        """
         kw = kw.copy()
         show_inactive = kw.get('show_inactive', False)
         if isinstance(REQUEST, dict) and not show_inactive:
@@ -417,10 +413,10 @@ def search(self, *args, **kw):
 
     security.declareProtected(ManageZCatalogEntries, 'clearFindAndRebuild')
     def clearFindAndRebuild(self):
-        """Empties catalog, then finds all contentish objects (i.e. objects
-           with an indexObject method), and reindexes them.
-           This may take a long time.
-        """
+        # Empties catalog, then finds all contentish objects (i.e. objects
+        # with an indexObject method), and reindexes them.
+        # This may take a long time.
+
         def indexObject(obj, path):
             if (base_hasattr(obj, 'indexObject') and
                 safe_callable(obj.indexObject)):
diff --git a/Products/CMFPlone/MigrationTool.py b/Products/CMFPlone/MigrationTool.py
index c705e79..9abde1b 100644
--- a/Products/CMFPlone/MigrationTool.py
+++ b/Products/CMFPlone/MigrationTool.py
@@ -53,16 +53,16 @@ def __repr__(self):
             self.__class__.__name__, self.profile_id)
 
     def safe(self):
-        """Is this addon safe to upgrade?
+        # Is this addon safe to upgrade?
 
-        Is it safe to pass its profile id to
-        portal_setup.upgradeProfile?  That method checks if the
-        profile is 'unknown' and in this case does nothing.
+        # Is it safe to pass its profile id to
+        # portal_setup.upgradeProfile?  That method checks if the
+        # profile is 'unknown' and in this case does nothing.
+
+        # But in some cases the profile may have been applied, but the
+        # package is gone.  For that case, you can set
+        # self.check_module.
 
-        But in some cases the profile may have been applied, but the
-        package is gone.  For that case, you can set
-        self.check_module.
-        """
         if self.check_module:
             # Can we import a module, as evidence that the code is
             # available?  Note that some modules may have been faked,
@@ -125,7 +125,7 @@ class MigrationTool(PloneBaseTool, UniqueObject, SimpleItem):
 
     security.declareProtected(ManagePortal, 'getInstanceVersion')
     def getInstanceVersion(self):
-        """ The version this instance of plone is on """
+        # The version this instance of plone is on.
         setup = getToolByName(self, 'portal_setup')
         version = setup.getLastVersionForProfile(_DEFAULT_PROFILE)
         if isinstance(version, tuple):
@@ -152,14 +152,14 @@ def getInstanceVersion(self):
 
     security.declareProtected(ManagePortal, 'setInstanceVersion')
     def setInstanceVersion(self, version):
-        """ The version this instance of plone is on """
+        # The version this instance of plone is on.
         setup = getToolByName(self, 'portal_setup')
         setup.setLastVersionForProfile(_DEFAULT_PROFILE, version)
         self._version = False
 
     security.declareProtected(ManagePortal, 'getFileSystemVersion')
     def getFileSystemVersion(self):
-        """ The version this instance of plone is on """
+        # The version this instance of plone is on.
         setup = getToolByName(self, 'portal_setup')
         try:
             return setup.getVersionForProfile(_DEFAULT_PROFILE)
@@ -169,18 +169,18 @@ def getFileSystemVersion(self):
 
     security.declareProtected(ManagePortal, 'getSoftwareVersion')
     def getSoftwareVersion(self):
-        """ The software version."""
+        # The software version.
         dist = pkg_resources.get_distribution('Products.CMFPlone')
         return dist.version
 
     security.declareProtected(ManagePortal, 'needUpgrading')
     def needUpgrading(self):
-        """ Need upgrading? """
+        # Need upgrading?
         return self.getInstanceVersion() != self.getFileSystemVersion()
 
     security.declareProtected(ManagePortal, 'coreVersions')
     def coreVersions(self):
-        """ Useful core information """
+        # Useful core information.
         vars = {}
         get_dist = pkg_resources.get_distribution
         vars['Zope'] = get_dist('Zope2').version
@@ -211,24 +211,24 @@ def coreVersions(self):
 
     security.declareProtected(ManagePortal, 'coreVersionsList')
     def coreVersionsList(self):
-        """ Useful core information """
+        # Useful core information.
         res = self.coreVersions().items()
         res.sort()
         return res
 
     security.declareProtected(ManagePortal, 'needUpdateRole')
     def needUpdateRole(self):
-        """ Do roles need to be updated? """
+        # Do roles need to be updated?
         return self._needUpdateRole
 
     security.declareProtected(ManagePortal, 'needRecatalog')
     def needRecatalog(self):
-        """ Does this thing now need recataloging? """
+        # Does this thing now need recataloging?
         return self._needRecatalog
 
     security.declareProtected(ManagePortal, 'upgrade')
     def upgrade(self, REQUEST=None, dry_run=None, swallow_errors=True):
-        """ perform the upgrade """
+        # Perform the upgrade.
         setup = getToolByName(self, 'portal_setup')
 
         # This sets the profile version if it wasn't set yet
diff --git a/Products/CMFPlone/PloneBatch.py b/Products/CMFPlone/PloneBatch.py
index 6471ae3..020b6b6 100644
--- a/Products/CMFPlone/PloneBatch.py
+++ b/Products/CMFPlone/PloneBatch.py
@@ -37,14 +37,14 @@ def initialize(self, start, end, size):
             calculate_pagerange(self.pagenumber, self.numpages, self.pagerange)
 
     def pageurl(self, formvariables, pagenumber=-1):
-        """ Makes the url for a given page """
+        # Makes the url for a given page.
         if pagenumber == -1:
             pagenumber = self.pagenumber
         b_start = pagenumber * (self.pagesize - self.overlap) - self.pagesize
         return make_query(formvariables, {self.b_start_str: b_start})
 
     def navurls(self, formvariables, navlist=None):
-        """ Returns the page number and url for the navigation quick links """
+        # Returns the page number and url for the navigation quick links.
         if navlist is None:
             navlist = []
         if not navlist:
@@ -53,11 +53,11 @@ def navurls(self, formvariables, navlist=None):
                 (x, self.pageurl(formvariables, x)), navlist)
 
     def prevurls(self, formvariables):
-        """ Helper method to get prev navigation list from templates """
+        # Helper method to get prev navigation list from templates.
         return self.navurls(formvariables, self.previous_pages)
 
     def nexturls(self, formvariables):
-        """ Helper method to get next navigation list from templates """
+        # Helper method to get next navigation list from templates.
         return self.navurls(formvariables, self.next_pages)
 
     prevlist = QuantumBatch.previous_pages
diff --git a/Products/CMFPlone/PloneControlPanel.py b/Products/CMFPlone/PloneControlPanel.py
index 451b73b..1649293 100644
--- a/Products/CMFPlone/PloneControlPanel.py
+++ b/Products/CMFPlone/PloneControlPanel.py
@@ -167,8 +167,7 @@ def unregisterApplication(self, appId):
                     actionicons.removeActionIcon('controlpanel', a.id)
 
     def _extractAction(self, properties, index):
-        """ Extract an ActionInformation from the funky form properties.
-        """
+        # Extract an ActionInformation from the funky form properties.
         id = str(properties.get('id_%d' % index, ''))
         name = str(properties.get('name_%d' % index, ''))
         action = str(properties.get('action_%d' % index, ''))
@@ -228,8 +227,7 @@ def addAction(self,
                   description='',
                   REQUEST=None,
                   ):
-        """ Add an action to our list.
-        """
+        # Add an action to our list.
         if not name:
             raise ValueError('A name is required.')
 
diff --git a/Products/CMFPlone/PloneFolder.py b/Products/CMFPlone/PloneFolder.py
index 286fb18..9256048 100644
--- a/Products/CMFPlone/PloneFolder.py
+++ b/Products/CMFPlone/PloneFolder.py
@@ -59,7 +59,7 @@ def moveObject(self, id, position):
 
     security.declarePrivate('getIdsSubset')
     def getIdsSubset(self, objs):
-        """Get the ids of only cmf objects (used for moveObjectsByDelta)."""
+        # Get the ids of only cmf objects (used for moveObjectsByDelta).
         ttool = getToolByName(self, 'portal_types')
         cmf_meta_types = [ti.Metatype() for ti in ttool.listTypeInfo()]
         return [obj['id'] for obj in objs
@@ -189,7 +189,7 @@ def __browser_default__(self, request):
 
     security.declarePublic('contentValues')
     def contentValues(self, filter=None, sort_on=None, reverse=0):
-        """Able to sort on field."""
+        # Able to sort on field.
         values = PortalFolderBase.contentValues(self, filter=filter)
         if sort_on is not None:
             values.sort(lambda x, y,
@@ -203,9 +203,8 @@ def contentValues(self, filter=None, sort_on=None, reverse=0):
     security.declareProtected(ListFolderContents, 'listFolderContents')
     def listFolderContents(self, contentFilter=None,
                            suppressHiddenFiles=0):
-        """Optionally you can suppress "hidden" files, or files that
-        begin with .
-        """
+        # Optionally you can suppress "hidden" files, or files that
+        # begin with '.'
         contents = PortalFolderBase.listFolderContents(self,
                                                   contentFilter=contentFilter)
         if suppressHiddenFiles:
@@ -216,17 +215,16 @@ def listFolderContents(self, contentFilter=None,
                               'folderlistingFolderContents')
     def folderlistingFolderContents(self, contentFilter=None,
                                     suppressHiddenFiles=0):
-        """Calls listFolderContents in protected only by ACI so that
-        folder_listing can work without the List folder contents permission,
-        as in CMFDefault.
-        """
+        # Calls listFolderContents in protected only by ACI so that
+        # folder_listing can work without the List folder contents permission,
+        # as in CMFDefault.
         return self.listFolderContents(contentFilter, suppressHiddenFiles)
 
     # Override CMFCore's invokeFactory to return the id returned by the
     # factory in case the factory modifies the id
     security.declareProtected(AddPortalContent, 'invokeFactory')
     def invokeFactory(self, type_name, id, RESPONSE=None, *args, **kw):
-        """Invokes the portal_types tool."""
+        # Invokes the portal_types tool.
         pt = getToolByName(self, 'portal_types')
         myType = pt.getTypeInfo(self)
         if myType is not None:
diff --git a/Products/CMFPlone/PloneTool.py b/Products/CMFPlone/PloneTool.py
index 2c63450..ed0b8e9 100644
--- a/Products/CMFPlone/PloneTool.py
+++ b/Products/CMFPlone/PloneTool.py
@@ -197,9 +197,8 @@ def sendto(self, send_to_address, send_from_address, comment,
 
     security.declarePublic('validateSingleNormalizedEmailAddress')
     def validateSingleNormalizedEmailAddress(self, address):
-        """Lower-level function to validate a single normalized email address,
-        see validateEmailAddress.
-        """
+        # Lower-level function to validate a single normalized email address,
+        # see validateEmailAddress.
         if not isinstance(address, basestring):
             return False
 
@@ -216,7 +215,7 @@ def validateSingleNormalizedEmailAddress(self, address):
 
     security.declarePublic('validateSingleEmailAddress')
     def validateSingleEmailAddress(self, address):
-        """Validate a single email address, see also validateEmailAddresses."""
+        # Validate a single email address, see also validateEmailAddresses.
         if not isinstance(address, basestring):
             return False
 
@@ -238,9 +237,8 @@ def validateSingleEmailAddress(self, address):
 
     security.declarePublic('validateEmailAddresses')
     def validateEmailAddresses(self, addresses):
-        """Validate a list of possibly several email addresses, see also
-        validateSingleEmailAddress.
-        """
+        # Validate a list of possibly several email addresses, see also
+        # validateSingleEmailAddress.
         if not isinstance(addresses, basestring):
             return False
 
@@ -261,10 +259,8 @@ def editMetadata(self, obj, allowDiscussion=None, title=None,
                      subject=None, description=None, contributors=None,
                      effective_date=None, expiration_date=None, format=None,
                      language=None, rights=None, **kwargs):
-        """Responsible for setting metadata on a content object.
-
-        We assume the obj implements IDublinCoreMetadata.
-        """
+        # Responsible for setting metadata on a content object.
+        # We assume the obj implements IDublinCoreMetadata.
         mt = getToolByName(self, 'portal_membership')
         if not mt.checkPermission(ModifyPortalContent, obj):
             # FIXME: Some scripts rely on this being string?
@@ -368,7 +364,7 @@ def _makeTransactionNote(self, obj, msg=''):
 
     security.declarePublic('contentEdit')
     def contentEdit(self, obj, **kwargs):
-        """Encapsulates how the editing of content occurs."""
+        # Encapsulates how the editing of content occurs.
         try:
             self.editMetadata(obj, **kwargs)
         except AttributeError, msg:
@@ -380,18 +376,15 @@ def contentEdit(self, obj, **kwargs):
 
     security.declarePublic('availableMIMETypes')
     def availableMIMETypes(self):
-        """Returns a map of mimetypes.
-
-        Requires mimetype registry from Archetypes >= 1.3.
-        """
+        # Returns a map of mimetypes.
+        # Requires mimetype registry from Archetypes >= 1.3.
         mtr = getToolByName(self, 'mimetypes_registry')
         return mtr.list_mimetypes()
 
     security.declareProtected(View, 'getWorkflowChainFor')
     def getWorkflowChainFor(self, object):
-        """Proxy the request for the chain to the workflow tool, as
-        this method is private there.
-        """
+        # Proxy the request for the chain to the workflow tool, as
+        # this method is private there.
         wftool = getToolByName(self, 'portal_workflow')
         wfs = ()
         try:
@@ -404,10 +397,9 @@ def getWorkflowChainFor(self, object):
 
     security.declareProtected(View, 'getIconFor')
     def getIconFor(self, category, id, default=_marker, context=None):
-        """Get an icon for an action. Prefer the icon_expr on the action
-        itself and if not specified fall back to the icon from the
-        action icons tool.
-        """
+        # Get an icon for an action. Prefer the icon_expr on the action
+        # itself and if not specified fall back to the icon from the
+        # action icons tool.
         if context is None:
             context = aq_parent(self)
         if category == 'controlpanel':
@@ -577,21 +569,18 @@ def exceptionString(self):
     # Provide a way of dumping an exception to the log even if we
     # catch it and otherwise ignore it
     def logException(self):
-        """Dumps most recent exception to the log.
-        """
+        # Dumps most recent exception to the log.
         log_exc()
 
     security.declarePublic('createSitemap')
     def createSitemap(self, context, request=None):
-        """Returns a sitemap navtree structure.
-        """
+        # Returns a sitemap navtree structure.
         if request is None:
             request = self.REQUEST
         return utils.createSiteMap(context, request)
 
     def _addToNavTreeResult(self, result, data):
-        """Adds a piece of content to the result tree.
-        """
+        # Adds a piece of content to the result tree.
         return utils.addToNavTreeResult(result, data)
 
     security.declareProtected(AccessContentsInformation, 'typesToList')
@@ -608,15 +597,14 @@ def createNavTree(self, context, sitemap=None, request=None):
 
     security.declarePublic('createBreadCrumbs')
     def createBreadCrumbs(self, context, request=None):
-        """Returns a structure for the portal breadcumbs.
-        """
+        # Returns a structure for the portal breadcumbs.
         if request is None:
             request = self.REQUEST
         return utils.createBreadCrumbs(context, request)
 
     security.declarePublic('good_id')
     def good_id(self, id):
-        """Exposes ObjectManager's bad_id test to skin scripts."""
+        # Exposes ObjectManager's bad_id test to skin scripts.
         m = bad_id(id)
         if m is not None:
             return 0
@@ -624,12 +612,12 @@ def good_id(self, id):
 
     security.declarePublic('bad_chars')
     def bad_chars(self, id):
-        """Returns a list of the Bad characters."""
+        # Returns a list of the Bad characters.
         return BAD_CHARS(id)
 
     security.declarePublic('getInheritedLocalRoles')
     def getInheritedLocalRoles(self, context):
-        """Returns a tuple with the acquired local roles."""
+        # Returns a tuple with the acquired local roles.
         portal = getToolByName(context, 'portal_url').getPortalObject()
         result = []
         cont = 1
@@ -683,33 +671,31 @@ def getInheritedLocalRoles(self, context):
 
     security.declarePublic('isDefaultPage')
     def isDefaultPage(self, obj, request=None):
-        """Finds out if the given obj is the default page in its parent folder.
-
-        Only considers explicitly contained objects, either set as index_html,
-        with the default_page property, or using IBrowserDefault.
-        """
+        # Finds out if the given obj is the default page in its parent folder.
+        # Only considers explicitly contained objects, either set as index_html,
+        # with the default_page property, or using IBrowserDefault.
         if request is None:
             request = self.REQUEST
         return utils.isDefaultPage(obj, request)
 
     security.declarePublic('getDefaultPage')
     def getDefaultPage(self, obj, request=None):
-        """Given a folderish item, find out if it has a default-page using
-        the following lookup rules:
-
-            1. A content object called 'index_html' wins
-            2. If the folder implements IBrowserDefault, query this
-            3. Else, look up the property default_page on the object
-                - Note that in this case, the returned id may *not* be of an
-                  object in the folder, since it could be acquired from a
-                  parent folder or skin layer
-            4. Else, look up the property default_page in site_properties for
-                magic ids and test these
-
-        The id of the first matching item is then used to lookup a translation
-        and if found, its id is returned. If no default page is set, None is
-        returned. If a non-folderish item is passed in, return None always.
-        """
+        # Given a folderish item, find out if it has a default-page using
+        # the following lookup rules:
+
+        #     1. A content object called 'index_html' wins
+        #     2. If the folder implements IBrowserDefault, query this
+        #     3. Else, look up the property default_page on the object
+        #         - Note that in this case, the returned id may *not* be of an
+        #           object in the folder, since it could be acquired from a
+        #           parent folder or skin layer
+        #     4. Else, look up the property default_page in site_properties for
+        #         magic ids and test these
+
+        # The id of the first matching item is then used to lookup a translation
+        # and if found, its id is returned. If no default page is set, None is
+        # returned. If a non-folderish item is passed in, return None always.
+
         if request is None:
             request = self.REQUEST
         return utils.getDefaultPage(obj, request)
@@ -755,14 +741,11 @@ def addPortalMessage(self, message, type='info', request=None):
 
     security.declarePublic('showPortalMessages')
     def showPortalMessages(self, request=None):
-        """\
-        Return portal status messages that will be displayed when the
-        response web page is rendered. Portal status messages are by default
-        rendered by the global_statusmessage.pt page template. They will be
-        removed after they have been shown.
-
-        See addPortalMessages for examples.
-        """
+        # Return portal status messages that will be displayed when the
+        # response web page is rendered. Portal status messages are by default
+        # rendered by the global_statusmessage.pt page template. They will be
+        # removed after they have been shown.
+        # See addPortalMessages for examples.
         if request is None:
             request = self.REQUEST
         return IStatusMessage(request).show()
@@ -942,12 +925,10 @@ def isStructuralFolder(self, obj):
 
     security.declarePublic('acquireLocalRoles')
     def acquireLocalRoles(self, obj, status=1, REQUEST=None):
-        """If status is 1, allow acquisition of local roles (regular
-        behaviour).
-
-        If it's 0, prohibit it (it will allow some kind of local role
-        blacklisting).
-        """
+        # If status is 1, allow acquisition of local roles (regular
+        # behaviour).
+        # If it's 0, prohibit it (it will allow some kind of local role
+        # blacklisting).
         mt = getToolByName(self, 'portal_membership')
         if not mt.checkPermission(ModifyPortalContent, obj):
             raise Unauthorized
@@ -966,10 +947,8 @@ def acquireLocalRoles(self, obj, status=1, REQUEST=None):
 
     security.declarePublic('isLocalRoleAcquired')
     def isLocalRoleAcquired(self, obj):
-        """Returns local role acquisition blocking status.
-
-        True if normal, false if blocked.
-        """
+        # Returns local role acquisition blocking status.
+        # True if normal, false if blocked.
         if getattr(obj, '__ac_local_roles_block__', None):
             return False
         return True
@@ -1048,10 +1027,8 @@ def normalizeString(self, text):
 
     security.declarePublic('listMetaTags')
     def listMetaTags(self, context):
-        """Lists meta tags helper.
-
-        Creates a mapping of meta tags -> values for the listMetaTags script.
-        """
+        # Lists meta tags helper.
+        # Creates a mapping of meta tags -> values for the listMetaTags script.
         result = {}
         site_props = getToolByName(self, 'portal_properties').site_properties
         mt = getToolByName(self, 'portal_membership')
@@ -1158,15 +1135,15 @@ def listMetaTags(self, context):
 
     security.declarePublic('getUserFriendlyTypes')
     def getUserFriendlyTypes(self, typesList=None):
-        """Get a list of types which are considered "user friendly" for search
-        and selection purposes.
-
-        This is the list of types available in the portal, minus those defined
-        in the types_not_searched property in site_properties, if it exists.
-
-        If typesList is given, this is used as the base list; else all types
-        from portal_types are used.
-        """
+        # Get a list of types which are considered "user friendly" for search
+        # and selection purposes.
+        #
+        # This is the list of types available in the portal, minus those
+        # defined in the types_not_searched property in site_properties, if it
+        # exists.
+        #
+        # If typesList is given, this is used as the base list; else all types
+        # from portal_types are used.
         if typesList is None:
             typesList = []
         ptool = getToolByName(self, 'portal_properties')
@@ -1185,13 +1162,13 @@ def getUserFriendlyTypes(self, typesList=None):
 
     security.declarePublic('reindexOnReorder')
     def reindexOnReorder(self, parent):
-        """ reindexing of "gopip" isn't needed any longer,
-        but some extensions might need the info anyway :("""
+        # Reindexing of "gopip" isn't needed any longer,
+        # but some extensions might need the info anyway. :(
         notify(ReorderedEvent(parent))
 
     security.declarePublic('isIDAutoGenerated')
     def isIDAutoGenerated(self, id):
-        """Determine if an id is autogenerated"""
+        # Determine if an id is autogenerated.
         return utils.isIDAutoGenerated(self, id)
 
     security.declarePublic('getEmptyTitle')
@@ -1207,17 +1184,16 @@ def getEmptyTitle(self, translated=True):
 
     security.declarePublic('pretty_title_or_id')
     def pretty_title_or_id(self, obj, empty_value=_marker):
-        """Return the best possible title or id of an item, regardless
-        of whether obj is a catalog brain or an object, but returning an
-        empty title marker if the id is not set (i.e. it's auto-generated).
-        """
+        # Return the best possible title or id of an item, regardless
+        # of whether obj is a catalog brain or an object, but returning an
+        # empty title marker if the id is not set (i.e. it's auto-generated).
         return utils.pretty_title_or_id(self, obj, empty_value=empty_value)
 
     security.declarePublic('getMethodAliases')
     def getMethodAliases(self, typeInfo):
-        """Given an FTI, return the dict of method aliases defined on that
-        FTI. If there are no method aliases (i.e. this FTI doesn't support it),
-        return None"""
+        # Given an FTI, return the dict of method aliases defined on that
+        # FTI. If there are no method aliases (i.e. this FTI doesn't support
+        # it), return None.
         getMethodAliases = getattr(typeInfo, 'getMethodAliases', None)
         if getMethodAliases is not None \
                 and utils.safe_callable(getMethodAliases):
diff --git a/Products/CMFPlone/Portal.py b/Products/CMFPlone/Portal.py
index 51eff0f..9223449 100644
--- a/Products/CMFPlone/Portal.py
+++ b/Products/CMFPlone/Portal.py
@@ -94,7 +94,7 @@ def index_html(self):
     index_html = ComputedAttribute(index_html, 1)
 
     def manage_beforeDelete(self, container, item):
-        """ Should send out an Event before Site is being deleted """
+        # Should send out an Event before Site is being deleted.
         self.removal_inprogress = 1
         PloneSite.inheritedAttribute('manage_beforeDelete')(self, container,
                                                             item)
diff --git a/Products/CMFPlone/PropertiesTool.py b/Products/CMFPlone/PropertiesTool.py
index b42dfff..daf80ce 100644
--- a/Products/CMFPlone/PropertiesTool.py
+++ b/Products/CMFPlone/PropertiesTool.py
@@ -46,8 +46,7 @@ def title(self):
 
     security.declareProtected(ManagePortal, 'addPropertySheet')
     def addPropertySheet(self, id, title='', propertysheet=None):
-        """ Add a new PropertySheet
-        """
+        # Add a new PropertySheet.
         o = SimpleItemWithProperties(id, title)
 
         # copy the propertysheet values onto the new instance
@@ -80,8 +79,7 @@ def manage_addPropertySheet(self, id, title='',
     #
     security.declareProtected(ManagePortal, 'editProperties')
     def editProperties(self, props):
-        """Change portal settings
-        """
+        # Change portal settings.
         aq_parent(aq_inner(self)).manage_changeProperties(props)
         if hasattr(self, 'propertysheets'):
             ps = self.propertysheets
diff --git a/Products/CMFPlone/QuickInstallerTool.py b/Products/CMFPlone/QuickInstallerTool.py
index d15e507..7b53367 100644
--- a/Products/CMFPlone/QuickInstallerTool.py
+++ b/Products/CMFPlone/QuickInstallerTool.py
@@ -19,9 +19,8 @@ class QuickInstallerTool(PloneBaseTool, BaseTool):
 
     security.declareProtected(ManagePortal, 'upgradeInfo')
     def upgradeInfo(self, pid):
-        """Returns a dict with two booleans values, stating if an upgrade
-        is required and available.
-        """
+        # Returns a dict with two booleans values, stating if an upgrade
+        # required and available.
         available = self.isProductAvailable(pid)
         if not available:
             return False
diff --git a/Products/CMFPlone/RegistrationTool.py b/Products/CMFPlone/RegistrationTool.py
index 079765c..a3b24e1 100644
--- a/Products/CMFPlone/RegistrationTool.py
+++ b/Products/CMFPlone/RegistrationTool.py
@@ -143,7 +143,7 @@ def getPassword(self, length=5, s=None):
 
     security.declarePublic('isValidEmail')
     def isValidEmail(self, email):
-        """ checks for valid email """
+        # Checks for valid email.
         if EMAIL_RE.search(email) == None:
             return 0
         try:
@@ -158,12 +158,10 @@ def isValidEmail(self, email):
     #
     security.declarePublic( 'testPasswordValidity' )
     def testPasswordValidity(self, password, confirm=None):
-
-        """ Verify that the password satisfies the portal's requirements.
-
-        o If the password is valid, return None.
-        o If not, return a string explaining why.
-        """
+        # Verify that the password satisfies the portal's requirements.
+        #
+        # o If the password is valid, return None.
+        # o If not, return a string explaining why.
         err = self.pasValidation('password', password)
         if err and (password == '' or not _checkPermission(ManagePortal, self)):
             return err
@@ -176,7 +174,7 @@ def testPasswordValidity(self, password, confirm=None):
 
 
     def pasValidation(self, property, password):
-        """ @return None if no PAS password validators exist or a list of errors """
+        # @return None if no PAS password validators exist or a list of errors.
         portal = getUtility(ISiteRoot)
         pas_instance = portal.acl_users
         validators = pas_instance.plugins.listPlugins(IValidationPlugin)
@@ -206,15 +204,14 @@ def pasValidation(self, property, password):
 
     security.declarePublic('testPropertiesValidity')
     def testPropertiesValidity(self, props, member=None):
+        # Verify that the properties supplied satisfy portal's requirements.
 
-        """ Verify that the properties supplied satisfy portal's requirements.
+        # o If the properties are valid, return None.
+        # o If not, return a string explaining why.
 
-        o If the properties are valid, return None.
-        o If not, return a string explaining why.
+        # This is a customized version of the CMFDefault version:
+        # we also check if the email property is writable before verifying it.
 
-        This is a customized version of the CMFDefault version: we also
-        check if the email property is writable before verifying it.
-        """
         if member is None:  # New member.
 
             username = props.get('username', '')
@@ -294,15 +291,15 @@ def isMemberIdAllowed(self, id):
 
     security.declarePublic('generatePassword')
     def generatePassword(self):
-        """Generate a strong default password. The user never gets sent
-        this so we can make it very long."""
+        # Generate a strong default password. The user never gets sent
+        # this so we can make it very long.
 
         return self.getPassword(56)
 
     security.declarePublic('generateResetCode')
     def generateResetCode(self, salt, length=14):
-        """Generates a reset code which is guaranteed to return the
-        same value for a given length and salt, every time."""
+        # Generates a reset code which is guaranteed to return the
+        # same value for a given length and salt, every time.
         return self.getPassword(length, salt)
 
     security.declarePublic('mailPassword')
@@ -383,7 +380,7 @@ def mailPassword(self, login, REQUEST, immediate=False):
 
     security.declarePublic('registeredNotify')
     def registeredNotify(self, new_member_id):
-        """ Wrapper around registeredNotify """
+        # Wrapper around registeredNotify.
         membership = getToolByName(self, 'portal_membership')
         utils = getToolByName(self, 'plone_utils')
         member = membership.getMemberById(new_member_id)
diff --git a/Products/CMFPlone/SkinsTool.py b/Products/CMFPlone/SkinsTool.py
index 899f899..332c1c8 100644
--- a/Products/CMFPlone/SkinsTool.py
+++ b/Products/CMFPlone/SkinsTool.py
@@ -19,8 +19,7 @@ class SkinsTool(PloneBaseTool, BaseTool):
 
     security.declareProtected(ManagePortal, 'addSkinSelection')
     def addSkinSelection(self, skinname, skinpath, test=0, make_default=0):
-        """ adds a skin selection 
-        """
+        # Adds a skin selection.
         super(SkinsTool, self).addSkinSelection(skinname, skinpath,
             test=test, make_default=make_default)
         # when adding a new skin, we need to tell RR about it
diff --git a/Products/CMFPlone/TypesTool.py b/Products/CMFPlone/TypesTool.py
index e72ed31..07734db 100644
--- a/Products/CMFPlone/TypesTool.py
+++ b/Products/CMFPlone/TypesTool.py
@@ -16,7 +16,7 @@ class TypesTool(PloneBaseTool, BaseTool):
 
     security.declarePublic('listTypeTitles')
     def listTypeTitles(self, container=None):
-        """ Return a dictionary of id/Title combinations """
+        # Return a dictionary of id/Title combinations.
         typenames = {}
         for t in self.listTypeInfo(container):
             name = t.getId()
@@ -27,8 +27,7 @@ def listTypeTitles(self, container=None):
 
     security.declarePrivate('listActions')
     def listActions(self, info=None, object=None, category=None):
-        """ List all the actions defined by a provider.
-        """
+        # List all the actions defined by a provider.
         actions = []
         if object is None and info is not None:
             object = info.object
diff --git a/Products/CMFPlone/URLTool.py b/Products/CMFPlone/URLTool.py
index bb0b9e8..34259fd 100644
--- a/Products/CMFPlone/URLTool.py
+++ b/Products/CMFPlone/URLTool.py
@@ -17,17 +17,17 @@ class URLTool(PloneBaseTool, BaseTool):
 
     security.declarePublic('isURLInPortal')
     def isURLInPortal(self, url, context=None):
-        """ Check if a given url is on the same host and contains the portal
-            path.  Used to ensure that login forms can determine relevant
-            referrers (i.e. in portal).  Also return true for some relative
-            urls if context is passed in to allow for url parsing. When context
-            is not provided, assume that relative urls are in the portal. It is
-            assumed that http://portal is the same portal as https://portal.
+        # Check if a given url is on the same host and contains the portal
+        # path.  Used to ensure that login forms can determine relevant
+        # referrers (i.e. in portal).  Also return true for some relative
+        # urls if context is passed in to allow for url parsing. When context
+        # is not provided, assume that relative urls are in the portal. It is
+        # assumed that http://portal is the same portal as https://portal.
+
+        # External sites listed in 'allow_external_login_sites' of
+        # site_properties are also considered within the portal to allow for
+        # single sign on.
 
-            External sites listed in 'allow_external_login_sites' of
-            site_properties are also considered within the portal to allow for
-            single sign on.
-        """
         # sanitize url
         url = re.sub('^[\x00-\x20]+', '', url).strip()
         if ('<script' in url or '%3Cscript' in url or 'javascript:' in url or
diff --git a/Products/CMFPlone/WorkflowTool.py b/Products/CMFPlone/WorkflowTool.py
index 3d812a7..a691ff2 100644
--- a/Products/CMFPlone/WorkflowTool.py
+++ b/Products/CMFPlone/WorkflowTool.py
@@ -23,7 +23,7 @@ class WorkflowTool(PloneBaseTool, BaseTool):
     # TODO this should not make it into 1.0
     # Refactor me, my maker was tired
     def flattenTransitions(self, objs, container=None):
-        """ this is really hokey - hold on!!"""
+        # This is really hokey - hold on!!
         if hasattr(objs, 'startswith'):
             return ()
 
@@ -52,7 +52,7 @@ def flattenTransitions(self, objs, container=None):
         return tuple(transitions[:])
 
     def flattenTransitionsForPaths(self, paths):
-        """ this is even more hokey!!"""
+        # This is even more hokey!!
         if hasattr(paths, 'startswith'):
             return ()
 
@@ -107,9 +107,8 @@ def getTransitionsFor(self, obj=None, container=None, REQUEST=None):
         return tuple(result.values())
 
     def workflows_in_use(self):
-        """ gathers all the available workflow chains (sequence
-        of workflow ids).
-        """
+        # Gathers all the available workflow chains (sequence
+        # of workflow ids).
         in_use = []
 
         in_use.append(self._default_chain)
@@ -122,17 +121,17 @@ def workflows_in_use(self):
 
     security.declarePublic('getWorklists')
     def getWorklists(self):
-        """ instead of manually scraping actions_box, lets:
-            query for all worklists in all workflow definitions.
-            Returns a dictionary whos value is sequence of dictionaries
-
-            i.e. map[workflow_id]=(workflow definition map, )
-            each workflow defintion map contains the following:
-            (worklist)id, guard (Guard instance), guard_permissions (permission
-            of Guard instance), guard_roles (roles of Guard instance),
-            catalog_vars (mapping), actbox_name (actions box label),
-            actbox_url (actions box url) and types (list of portal types)
-        """
+        # Instead of manually scraping actions_box, let's
+        # query for all worklists in all workflow definitions.
+        # Returns a dictionary whose value is a sequence of dictionaries.
+
+        # i.e. map[workflow_id]=(workflow definition map, )
+        # each workflow defintion map contains the following:
+        # (worklist)id, guard (Guard instance), guard_permissions (permission
+        # of Guard instance), guard_roles (roles of Guard instance),
+        # catalog_vars (mapping), actbox_name (actions box label),
+        # actbox_url (actions box url) and types (list of portal types)
+
         # We want to know which types use the workflows with worklists
         # This for example avoids displaying 'pending' of multiple workflows in
         # the same worklist
@@ -186,13 +185,12 @@ def getWorklists(self):
 
     security.declarePublic('getWorklistsResults')
     def getWorklistsResults(self):
-        """Return all the objects concerned by one or more worklists
-
-        This method replace 'getWorklists' by implementing the whole worklists
-        work for the script.
-        An object is returned only once, even if is return by several
-        worklists. Make the whole work as expensive it is.
-        """
+        # Return all the objects concerned by one or more worklists.
+        #
+        # This method replace 'getWorklists' by implementing the whole
+        # worklists work for the script.  An object is returned only once, even
+        # if is return by several worklists. Make the whole work as expensive
+        # it is.
         sm = getSecurityManager()
         # We want to know which types use the workflows with worklists
         # This for example avoids displaying 'pending' of multiple workflows in
@@ -245,8 +243,7 @@ def getWorklistsResults(self):
 
     security.declareProtected(ManagePortal, 'getChainForPortalType')
     def getChainForPortalType(self, pt_name, managescreen=0):
-        """ Get a chain for a specific portal type.
-        """
+        # Get a chain for a specific portal type.
         if pt_name in self._chains_by_type:
             return self._chains_by_type[pt_name]
         else:
@@ -259,15 +256,13 @@ def getChainForPortalType(self, pt_name, managescreen=0):
 
     security.declareProtected(ManagePortal, 'listWorkflows')
     def listWorkflows(self):
-        """ Return the list of workflows
-        """
+        # Return the list of workflows.
         return self.keys()
 
     security.declarePublic('getTitleForStateOnType')
     def getTitleForStateOnType(self, state_name, p_type):
-        """Returns the workflow state title for a given state name,
-           uses a portal_type to determine which workflow to use
-        """
+        # Returns the workflow state title for a given state name,
+        # uses a portal_type to determine which workflow to use.
         if state_name and p_type is not None:
             chain = self.getChainForPortalType(p_type)
             for wf_id in chain:
@@ -282,9 +277,8 @@ def getTitleForStateOnType(self, state_name, p_type):
 
     security.declarePublic('getTitleForTransitionOnType')
     def getTitleForTransitionOnType(self, trans_name, p_type):
-        """Returns the workflow transition title for a given transition name,
-           uses a portal_type to determine which workflow to use
-        """
+        # Returns the workflow transition title for a given transition name,
+        # uses a portal_type to determine which workflow to use.
         if trans_name and p_type is not None:
             chain = self.getChainForPortalType(p_type)
             for wf_id in chain:
@@ -299,8 +293,8 @@ def getTitleForTransitionOnType(self, trans_name, p_type):
 
     security.declarePublic('listWFStatesByTitle')
     def listWFStatesByTitle(self, filter_similar=False):
-        """Returns the states of all available workflows, optionally filtering
-           out states with matching title and id"""
+        # Returns the states of all available workflows, optionally filtering
+        # out states with matching title and id.
         states = []
         dup_list = {}
         for wf in self.values():
@@ -318,11 +312,9 @@ def listWFStatesByTitle(self, filter_similar=False):
 
     # PLIP 217 Workflow by adaptation
     def getChainFor(self, ob):
-        """
-        Returns the chain that applies to the given object.
-        If we get a string as the ob parameter, use it as
-        the portal_type.
-        """
+        # Returns the chain that applies to the given object.
+        # If we get a string as the ob parameter, use it as
+        # the portal_type.
         return getMultiAdapter((ob, self), IWorkflowChain)
 
     security.declarePrivate('listActions')
diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py
index fa66328..0354c95 100644
--- a/Products/CMFPlone/utils.py
+++ b/Products/CMFPlone/utils.py
@@ -290,7 +290,7 @@ def getIcon(self, context, path):
         return icon
 
     def initialize(self, context):
-        """ Wrap the CMFCore Tool Init method """
+        # Wrap the CMFCore Tool Init method.
         CMFCoreToolInit.initialize(self, context)
         for tool in self.tools:
             # Get the icon path from the tool
diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index 06cc836..5f15872 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -14,6 +14,8 @@ Changelog
 
 Fixes:
 
+- Removed docstrings from some methods to avoid publishing them.  [maurits]
+
 - Ensured front-page is English when creating an English site.
   Previously, when creating an English site with a browser that
   prefers a different language, the body text ended up being in the


Repository: Products.CMFPlone


Branch: refs/heads/4.3.x
Date: 2016-05-04T14:53:15+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/f91ccf1ba33d46a5cabacdfed1e8d3ab31002341

Fixed one security test.

Files changed:
M Products/CMFPlone/tests/testSecurity.py

diff --git a/Products/CMFPlone/tests/testSecurity.py b/Products/CMFPlone/tests/testSecurity.py
index ad14575a..aedfb0c 100644
--- a/Products/CMFPlone/tests/testSecurity.py
+++ b/Products/CMFPlone/tests/testSecurity.py
@@ -75,7 +75,7 @@ def test_widget_traversal_2(self):
     def test_registerConfiglet_1(self):
         VECTOR = "/plone/portal_controlpanel/registerConfiglet?id=cake&name=Cakey&action=woo&permission=View&icon_expr="
         res = self.publish(VECTOR)
-        self.assertTrue(res.headers['location'].startswith('http://nohost/plone/acl_users/credentials_cookie_auth/require_login'))
+        self.assertEqual(404, res.status)
 
     def test_registerConfiglet_2(self):
         VECTOR = "/plone/portal_controlpanel/registerConfiglet?id=cake&name=Cakey&action=woo&permission=View&icon_expr="


