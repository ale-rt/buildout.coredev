Repository: Products.CMFPlone


Branch: refs/heads/5.0.x
Date: 2016-09-19T14:43:05+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/cae3e716f0e8987118f8273c3111fe96770745ea

Apply security hotfix 20160830 for z3c.form widgets.

Files changed:
A Products/CMFPlone/patches/z3c_form.py
A Products/CMFPlone/tests/test_z3c_form_widgets.py
M CHANGES.rst
M Products/CMFPlone/patches/__init__.py

diff --git a/CHANGES.rst b/CHANGES.rst
index d8ff190..135e57c 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -19,6 +19,8 @@ New features:
 
 Bug fixes:
 
+- Apply security hotfix 20160830 for ``z3c.form`` widgets.  [maurits]
+
 - Fixed tests in combination with newer CMFFormController which has the hotfix.  [maurits]
 
 - Apply security hotfix 20160830 for ``@@plone-root-login``.  [maurits]
diff --git a/Products/CMFPlone/patches/__init__.py b/Products/CMFPlone/patches/__init__.py
index ec14a45..f6b5981 100644
--- a/Products/CMFPlone/patches/__init__.py
+++ b/Products/CMFPlone/patches/__init__.py
@@ -29,3 +29,5 @@
 # production sites
 
 import publishing
+
+import z3c_form
diff --git a/Products/CMFPlone/patches/z3c_form.py b/Products/CMFPlone/patches/z3c_form.py
new file mode 100644
index 0000000..1b61598
--- /dev/null
+++ b/Products/CMFPlone/patches/z3c_form.py
@@ -0,0 +1,50 @@
+# This is from Products.PloneHotfix20160830.
+from urlparse import urlparse
+from z3c.form import widget
+
+
+# Attribute name to allow prefilling a widget with a value from a GET request.
+# Usually all forms are only for POST, and we disallow filling it with GET
+# data.  This works the way around too: allow prefilling from a POST request
+# when the form only handles GET.  But that is unlikely.
+ALLOW_PREFILL = 'allow_prefill_from_GET_request'
+
+
+def _wrap_update(update):
+    def _wrapped(self):
+        # If we are ignoring the request on the form, we should also ignore it
+        # on the widget.  This means that when on the first widget we conclude
+        # that the form should be ignored, we quickly ignore it on all widgets,
+        # without needing to check the referer and method again and again.
+        # When we do not ignore the request, we do still run these checks for
+        # all widgets.  But it seems an international sport to override the
+        # update or updateWidgets method of the base z3c form, which makes it
+        # hard to fix all occurrences by one check on the form.
+        if not self.ignoreRequest and getattr(self.form, 'ignoreRequest', False):
+            self.ignoreRequest = True
+        # If we are not already ignoring the request, check the request method.
+        if (not self.ignoreRequest
+                and hasattr(self.form, 'method')
+                and hasattr(self.request, 'REQUEST_METHOD')):
+            if self.request.REQUEST_METHOD.lower() != self.form.method.lower():
+                # This is an unexpected request method.
+                # For special cases we allow a form to bail out.
+                if not getattr(self.form, ALLOW_PREFILL, False):
+                    self.ignoreRequest = True
+                    self.form.ignoreRequest = True
+        # If we are not already ignoring the request, check the referer.
+        if not self.ignoreRequest and hasattr(self.request, 'environ'):
+            env = self.request.environ
+            referrer = env.get('HTTP_REFERER', env.get('HTTP_REFERRER'))
+            if referrer:
+                req_url_parsed = urlparse(self.request.URL)
+                referrer_parsed = urlparse(referrer)
+                if req_url_parsed.netloc != referrer_parsed.netloc:
+                    # We do not trust data from outside referrers.
+                    self.ignoreRequest = True
+                    self.form.ignoreRequest = True
+        return update(self)
+    return _wrapped
+
+
+widget.Widget.update = _wrap_update(widget.Widget.update)
diff --git a/Products/CMFPlone/tests/test_z3c_form_widgets.py b/Products/CMFPlone/tests/test_z3c_form_widgets.py
new file mode 100644
index 0000000..38de318
--- /dev/null
+++ b/Products/CMFPlone/tests/test_z3c_form_widgets.py
@@ -0,0 +1,116 @@
+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING
+from z3c.form import widget
+from z3c.form.browser.text import TextWidget
+
+import unittest
+
+
+WIDGETS_TO_TEST = [
+    TextWidget,
+    widget.Widget,
+    widget.MultiWidget,
+    widget.SequenceWidget,
+]
+
+_marker = object()
+
+
+class FakeForm(object):
+    method = 'post'
+    ignoreRequest = False
+
+
+class TestAttackVector(unittest.TestCase):
+    layer = PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING
+    _widgets_to_test = WIDGETS_TO_TEST
+    _attack = '</textarea><script>alert("form.widgets.class_blacklist")</script>'  # noqa
+
+    def _terms(self):
+        # For the SequenceWidget we need basic terms.
+        # We make dummy (dumb) terms.
+        from z3c.form.term import Terms
+
+        class DummyTerms(Terms):
+            def getTermByToken(self, token):
+                return token
+
+        return DummyTerms()
+
+    def test_regression(self):
+        request = self.layer['request']
+        for Widget in self._widgets_to_test:
+            wi = Widget(request)
+            wi.name = 'foo'
+            request.REQUEST_METHOD = 'POST'
+            request.form.update({
+                'foo': 'bar'
+            })
+            wi.form = FakeForm()
+            self.assertEquals(wi.ignoreRequest, False)
+            # The SequenceWidget needs terms.  It will have terms=None,
+            # where the others have no terms attribute.
+            if getattr(wi, 'terms', _marker) is None:
+                wi.terms = self._terms()
+            wi.update()
+            self.assertEquals(wi.ignoreRequest, False)
+
+    def test_only_get_data_from_valid_request_method(self):
+        request = self.layer['request']
+        for Widget in self._widgets_to_test:
+            wi = Widget(request)
+            wi.name = 'foobar'
+            request.REQUEST_METHOD = 'GET'
+            request.form.update({
+                'foobar': self._attack
+            })
+            wi.form = FakeForm()
+            self.assertEquals(wi.ignoreRequest, False)
+            # The SequenceWidget needs terms.  It will have terms=None,
+            # where the others have no terms attribute.
+            if getattr(wi, 'terms', _marker) is None:
+                wi.terms = self._terms()
+            wi.update()
+            self.assertEquals(wi.ignoreRequest, True)
+
+    def test_explicitly_allow_data_from_invalid_request_method(self):
+        request = self.layer['request']
+        for Widget in self._widgets_to_test:
+            wi = Widget(request)
+            wi.name = 'foobar'
+            request.REQUEST_METHOD = 'GET'
+            request.form.update({
+                'foobar': self._attack
+            })
+            wi.form = FakeForm()
+            # Set attribute on form to explicitly allow prefill.
+            from Products.CMFPlone.patches.z3c_form import ALLOW_PREFILL
+            setattr(wi.form, ALLOW_PREFILL, True)
+            self.assertEquals(wi.ignoreRequest, False)
+            # The SequenceWidget needs terms.  It will have terms=None,
+            # where the others have no terms attribute.
+            if getattr(wi, 'terms', _marker) is None:
+                wi.terms = self._terms()
+            wi.update()
+            self.assertEquals(wi.ignoreRequest, False)
+
+    def test_only_get_data_from_valid_referrer(self):
+        # this handles the use case where hijacker gets user to click on
+        # button that submits to plone site
+        request = self.layer['request']
+
+        for Widget in self._widgets_to_test:
+            wi = Widget(request)
+            wi.name = 'foobar'
+            request.REQUEST_METHOD = 'POST'
+            request.form.update({
+                'foobar': self._attack
+            })
+            request.environ['HTTP_REFERER'] = 'http://attacker.com'
+            wi.form = FakeForm()
+            self.assertEquals(wi.ignoreRequest, False)
+            # The SequenceWidget needs terms.  It will have terms=None,
+            # where the others have no terms attribute.
+            if getattr(wi, 'terms', _marker) is None:
+                wi.terms = self._terms()
+            wi.update()
+            self.assertEquals(wi.ignoreRequest, True)


Repository: Products.CMFPlone


Branch: refs/heads/5.0.x
Date: 2016-09-20T10:54:44+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFPlone/commit/46bccfe976bc1a826829833f4c33a743ff7c1a8c

Merge pull request #1768 from plone/apply-hotfix-20160830-z3cform-50

Apply security hotfix 20160830 for z3c.form widgets. [5.0]

Files changed:
A Products/CMFPlone/patches/z3c_form.py
A Products/CMFPlone/tests/test_z3c_form_widgets.py
M CHANGES.rst
M Products/CMFPlone/patches/__init__.py

diff --git a/CHANGES.rst b/CHANGES.rst
index d8ff190..135e57c 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -19,6 +19,8 @@ New features:
 
 Bug fixes:
 
+- Apply security hotfix 20160830 for ``z3c.form`` widgets.  [maurits]
+
 - Fixed tests in combination with newer CMFFormController which has the hotfix.  [maurits]
 
 - Apply security hotfix 20160830 for ``@@plone-root-login``.  [maurits]
diff --git a/Products/CMFPlone/patches/__init__.py b/Products/CMFPlone/patches/__init__.py
index ec14a45..f6b5981 100644
--- a/Products/CMFPlone/patches/__init__.py
+++ b/Products/CMFPlone/patches/__init__.py
@@ -29,3 +29,5 @@
 # production sites
 
 import publishing
+
+import z3c_form
diff --git a/Products/CMFPlone/patches/z3c_form.py b/Products/CMFPlone/patches/z3c_form.py
new file mode 100644
index 0000000..1b61598
--- /dev/null
+++ b/Products/CMFPlone/patches/z3c_form.py
@@ -0,0 +1,50 @@
+# This is from Products.PloneHotfix20160830.
+from urlparse import urlparse
+from z3c.form import widget
+
+
+# Attribute name to allow prefilling a widget with a value from a GET request.
+# Usually all forms are only for POST, and we disallow filling it with GET
+# data.  This works the way around too: allow prefilling from a POST request
+# when the form only handles GET.  But that is unlikely.
+ALLOW_PREFILL = 'allow_prefill_from_GET_request'
+
+
+def _wrap_update(update):
+    def _wrapped(self):
+        # If we are ignoring the request on the form, we should also ignore it
+        # on the widget.  This means that when on the first widget we conclude
+        # that the form should be ignored, we quickly ignore it on all widgets,
+        # without needing to check the referer and method again and again.
+        # When we do not ignore the request, we do still run these checks for
+        # all widgets.  But it seems an international sport to override the
+        # update or updateWidgets method of the base z3c form, which makes it
+        # hard to fix all occurrences by one check on the form.
+        if not self.ignoreRequest and getattr(self.form, 'ignoreRequest', False):
+            self.ignoreRequest = True
+        # If we are not already ignoring the request, check the request method.
+        if (not self.ignoreRequest
+                and hasattr(self.form, 'method')
+                and hasattr(self.request, 'REQUEST_METHOD')):
+            if self.request.REQUEST_METHOD.lower() != self.form.method.lower():
+                # This is an unexpected request method.
+                # For special cases we allow a form to bail out.
+                if not getattr(self.form, ALLOW_PREFILL, False):
+                    self.ignoreRequest = True
+                    self.form.ignoreRequest = True
+        # If we are not already ignoring the request, check the referer.
+        if not self.ignoreRequest and hasattr(self.request, 'environ'):
+            env = self.request.environ
+            referrer = env.get('HTTP_REFERER', env.get('HTTP_REFERRER'))
+            if referrer:
+                req_url_parsed = urlparse(self.request.URL)
+                referrer_parsed = urlparse(referrer)
+                if req_url_parsed.netloc != referrer_parsed.netloc:
+                    # We do not trust data from outside referrers.
+                    self.ignoreRequest = True
+                    self.form.ignoreRequest = True
+        return update(self)
+    return _wrapped
+
+
+widget.Widget.update = _wrap_update(widget.Widget.update)
diff --git a/Products/CMFPlone/tests/test_z3c_form_widgets.py b/Products/CMFPlone/tests/test_z3c_form_widgets.py
new file mode 100644
index 0000000..38de318
--- /dev/null
+++ b/Products/CMFPlone/tests/test_z3c_form_widgets.py
@@ -0,0 +1,116 @@
+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING
+from z3c.form import widget
+from z3c.form.browser.text import TextWidget
+
+import unittest
+
+
+WIDGETS_TO_TEST = [
+    TextWidget,
+    widget.Widget,
+    widget.MultiWidget,
+    widget.SequenceWidget,
+]
+
+_marker = object()
+
+
+class FakeForm(object):
+    method = 'post'
+    ignoreRequest = False
+
+
+class TestAttackVector(unittest.TestCase):
+    layer = PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING
+    _widgets_to_test = WIDGETS_TO_TEST
+    _attack = '</textarea><script>alert("form.widgets.class_blacklist")</script>'  # noqa
+
+    def _terms(self):
+        # For the SequenceWidget we need basic terms.
+        # We make dummy (dumb) terms.
+        from z3c.form.term import Terms
+
+        class DummyTerms(Terms):
+            def getTermByToken(self, token):
+                return token
+
+        return DummyTerms()
+
+    def test_regression(self):
+        request = self.layer['request']
+        for Widget in self._widgets_to_test:
+            wi = Widget(request)
+            wi.name = 'foo'
+            request.REQUEST_METHOD = 'POST'
+            request.form.update({
+                'foo': 'bar'
+            })
+            wi.form = FakeForm()
+            self.assertEquals(wi.ignoreRequest, False)
+            # The SequenceWidget needs terms.  It will have terms=None,
+            # where the others have no terms attribute.
+            if getattr(wi, 'terms', _marker) is None:
+                wi.terms = self._terms()
+            wi.update()
+            self.assertEquals(wi.ignoreRequest, False)
+
+    def test_only_get_data_from_valid_request_method(self):
+        request = self.layer['request']
+        for Widget in self._widgets_to_test:
+            wi = Widget(request)
+            wi.name = 'foobar'
+            request.REQUEST_METHOD = 'GET'
+            request.form.update({
+                'foobar': self._attack
+            })
+            wi.form = FakeForm()
+            self.assertEquals(wi.ignoreRequest, False)
+            # The SequenceWidget needs terms.  It will have terms=None,
+            # where the others have no terms attribute.
+            if getattr(wi, 'terms', _marker) is None:
+                wi.terms = self._terms()
+            wi.update()
+            self.assertEquals(wi.ignoreRequest, True)
+
+    def test_explicitly_allow_data_from_invalid_request_method(self):
+        request = self.layer['request']
+        for Widget in self._widgets_to_test:
+            wi = Widget(request)
+            wi.name = 'foobar'
+            request.REQUEST_METHOD = 'GET'
+            request.form.update({
+                'foobar': self._attack
+            })
+            wi.form = FakeForm()
+            # Set attribute on form to explicitly allow prefill.
+            from Products.CMFPlone.patches.z3c_form import ALLOW_PREFILL
+            setattr(wi.form, ALLOW_PREFILL, True)
+            self.assertEquals(wi.ignoreRequest, False)
+            # The SequenceWidget needs terms.  It will have terms=None,
+            # where the others have no terms attribute.
+            if getattr(wi, 'terms', _marker) is None:
+                wi.terms = self._terms()
+            wi.update()
+            self.assertEquals(wi.ignoreRequest, False)
+
+    def test_only_get_data_from_valid_referrer(self):
+        # this handles the use case where hijacker gets user to click on
+        # button that submits to plone site
+        request = self.layer['request']
+
+        for Widget in self._widgets_to_test:
+            wi = Widget(request)
+            wi.name = 'foobar'
+            request.REQUEST_METHOD = 'POST'
+            request.form.update({
+                'foobar': self._attack
+            })
+            request.environ['HTTP_REFERER'] = 'http://attacker.com'
+            wi.form = FakeForm()
+            self.assertEquals(wi.ignoreRequest, False)
+            # The SequenceWidget needs terms.  It will have terms=None,
+            # where the others have no terms attribute.
+            if getattr(wi, 'terms', _marker) is None:
+                wi.terms = self._terms()
+            wi.update()
+            self.assertEquals(wi.ignoreRequest, True)


