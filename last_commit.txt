Repository: plone.event


Branch: refs/heads/master
Date: 2016-12-05T21:28:32+01:00
Author: Gil Forcada (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/79e944eb579810ad6e913e7f0da27310bd65af1a

Update code to follow Plone styleguide

Files changed:
M CHANGES.rst
M plone/__init__.py
M plone/event/adapters.py
M plone/event/interfaces.py
M plone/event/recurrence.py
M plone/event/tests/test_adapters.py
M plone/event/tests/test_doctest.py
M plone/event/tests/test_recurrence_int_sequence.py
M plone/event/tests/test_recurrence_sequence_ical.py
M plone/event/tests/test_recurrence_sequence_timedelta.py
M plone/event/tests/test_utils.py
M plone/event/utils.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 08eeca0..b41692e 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -14,8 +14,8 @@ New features:
 
 Bug fixes:
 
-- *add item here*
-
+- Update code to follow Plone styleguide.
+  [gforcada]
 
 1.3.2 (2016-11-17)
 ------------------
diff --git a/plone/__init__.py b/plone/__init__.py
index f48ad10..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,6 +1,2 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/event/adapters.py b/plone/event/adapters.py
index 5772ad1..717657a 100644
--- a/plone/event/adapters.py
+++ b/plone/event/adapters.py
@@ -1,18 +1,18 @@
+# -*- coding: utf-8 -*-
 from plone.event.interfaces import IEvent
 from plone.event.interfaces import IEventAccessor
-from zope.component import adapts
+from zope.component import adapter
 from zope.interface import implementer
 
 
 @implementer(IEventAccessor)
+@adapter(IEvent)
 class EventAccessor(object):
     """Simple event accessor adapter implementation for generic events, which
     follow the IEvent interface closely.
 
     Concrete implementations adapt a content type to the IEvent specification.
-
     """
-    adapts(IEvent)
 
     def __init__(self, context):
         object.__setattr__(self, 'context', context)
diff --git a/plone/event/interfaces.py b/plone/event/interfaces.py
index 024b996..fa88995 100644
--- a/plone/event/interfaces.py
+++ b/plone/event/interfaces.py
@@ -1,4 +1,6 @@
-from zope.interface import Interface, Attribute
+# -*- coding: utf-8 -*-
+from zope.interface import Attribute
+from zope.interface import Interface
 
 
 class IEvent(Interface):
@@ -19,8 +21,8 @@ class IOccurrence(Interface):
     occurrence.
 
     """
-    start = Attribute(u"Occurrence start date")
-    end = Attribute(u"Occurrence end date")
+    start = Attribute(u'Occurrence start date')
+    end = Attribute(u'Occurrence end date')
 
 
 class ICalendarAccessor(Interface):
@@ -29,11 +31,11 @@ class ICalendarAccessor(Interface):
     A calendar is a collection of calendar components, like events.
 
     """
-    uid = Attribute(u"UID of the calendar. Autogenerated, read only.")
+    uid = Attribute(u'UID of the calendar. Autogenerated, read only.')
     # rw attributes
-    title = Attribute(u"Calendar title.")
-    description = Attribute(u"Calendar description text.")
-    timezone = Attribute(u"Default timezone of the calendar.")
+    title = Attribute(u'Calendar title.')
+    description = Attribute(u'Calendar description text.')
+    timezone = Attribute(u'Default timezone of the calendar.')
 
     def items(self):
         """Return a list of calendar component items, like events.
@@ -50,33 +52,34 @@ class IEventAccessor(Interface):
     """
 
     # ro attributes
-    uid = Attribute(u"UID of the event. Autogenerated, read only.")
-    created = Attribute(u"Python datetime of the event creation timestamp.")
-    duration = Attribute(u"Duration of the event. Computed attribute.")
+    uid = Attribute(u'UID of the event. Autogenerated, read only.')
+    created = Attribute(u'Python datetime of the event creation timestamp.')
+    duration = Attribute(u'Duration of the event. Computed attribute.')
 
     # reference
-    url = Attribute(u"Cannonical, unique url of the event. External events "
-                    u"are referenced by the origin url unless explicitly "
-                    u"set.")
+    url = Attribute(
+        u'Cannonical, unique url of the event. External events '
+        u'are referenced by the origin url unless explicitly set.'
+    )
 
     # rw attributes
-    last_modified = Attribute(u"Last modified Python datetime.")
-    title = Attribute(u"Event title.")
-    description = Attribute(u"Event description text.")
-    start = Attribute(u"Event start date as Python datetime.")
-    end = Attribute(u"Event end date as Python datetime.")
-    whole_day = Attribute(u"Event lasts whole day.")
-    open_end = Attribute(u"Event has no defined end time.")
-    timezone = Attribute(u"Timezone of the event. A pytz timezone identifier.")
-    recurrence = Attribute(u"RFC5545 compatible recurrence definition.")
-    location = Attribute(u"Location of the event.")
-    attendees = Attribute(u"List of attendees.")
-    contact_name = Attribute(u"Contact name.")
-    contact_email = Attribute(u"Contact email.")
-    contact_phone = Attribute(u"Contact phone.")
-    event_url = Attribute(u"Website of the event.")
-    subjects = Attribute(u"Categories.")
-    text = Attribute(u"Body text of the event.")
+    last_modified = Attribute(u'Last modified Python datetime.')
+    title = Attribute(u'Event title.')
+    description = Attribute(u'Event description text.')
+    start = Attribute(u'Event start date as Python datetime.')
+    end = Attribute(u'Event end date as Python datetime.')
+    whole_day = Attribute(u'Event lasts whole day.')
+    open_end = Attribute(u'Event has no defined end time.')
+    timezone = Attribute(u'Timezone of the event. A pytz timezone identifier.')
+    recurrence = Attribute(u'RFC5545 compatible recurrence definition.')
+    location = Attribute(u'Location of the event.')
+    attendees = Attribute(u'List of attendees.')
+    contact_name = Attribute(u'Contact name.')
+    contact_email = Attribute(u'Contact email.')
+    contact_phone = Attribute(u'Contact phone.')
+    event_url = Attribute(u'Website of the event.')
+    subjects = Attribute(u'Categories.')
+    text = Attribute(u'Body text of the event.')
 
 
 class IRecurrenceSupport(Interface):
@@ -153,37 +156,37 @@ class / created / description / geo /
     resources / rdate / x-prop / iana-prop
 
     """
-    dtstart = Attribute(u"Start Date/Time")
-    dtend = Attribute(u"End Date/Time")
-    duration = Attribute(u"Duration")
-    rrule = Attribute(u"Recurrence Rule")
-    description = Attribute(u"Description")
-    location = Attribute(u"Location")
-    summary = Attribute(u"Summary")
-    url = Attribute(u"Url")
-    attendee = Attribute(u"Attendee")
-    categories = Attribute(u"Categories")
-    contact = Attribute(u"Contact")
-
-    exdate = Attribute(u"Exdate")
-    rdate = Attribute(u"Rdate")
-
-    dtstamp = Attribute(u"Timestamp")
-    uid = Attribute(u"Unique identifier")
-    klass = Attribute(u"Class")  # class
-    created = Attribute(u"Created")
-    geo = Attribute(u"Geo")
-    last_mod = Attribute(u"Last Modified")  # last-mod
-    organizer = Attribute(u"Organizer")
-    priority = Attribute(u"Priority")
-    seq = Attribute(u"Seq")
-    status = Attribute(u"Status")
-    transp = Attribute(u"Transp")
-    recurid = Attribute(u"Recurid")
-    attach = Attribute(u"Attach")
-    comment = Attribute(u"Comment")
-    rstatus = Attribute(u"Rstatus")
-    related = Attribute(u"Related")
-    resources = Attribute(u"Resources")
-    x_prop = Attribute(u"X Prop")  # x-prop
-    iana_prop = Attribute(u"Iana Prop")  # iana-prop
+    dtstart = Attribute(u'Start Date/Time')
+    dtend = Attribute(u'End Date/Time')
+    duration = Attribute(u'Duration')
+    rrule = Attribute(u'Recurrence Rule')
+    description = Attribute(u'Description')
+    location = Attribute(u'Location')
+    summary = Attribute(u'Summary')
+    url = Attribute(u'Url')
+    attendee = Attribute(u'Attendee')
+    categories = Attribute(u'Categories')
+    contact = Attribute(u'Contact')
+
+    exdate = Attribute(u'Exdate')
+    rdate = Attribute(u'Rdate')
+
+    dtstamp = Attribute(u'Timestamp')
+    uid = Attribute(u'Unique identifier')
+    klass = Attribute(u'Class')  # class
+    created = Attribute(u'Created')
+    geo = Attribute(u'Geo')
+    last_mod = Attribute(u'Last Modified')  # last-mod
+    organizer = Attribute(u'Organizer')
+    priority = Attribute(u'Priority')
+    seq = Attribute(u'Seq')
+    status = Attribute(u'Status')
+    transp = Attribute(u'Transp')
+    recurid = Attribute(u'Recurid')
+    attach = Attribute(u'Attach')
+    comment = Attribute(u'Comment')
+    rstatus = Attribute(u'Rstatus')
+    related = Attribute(u'Related')
+    resources = Attribute(u'Resources')
+    x_prop = Attribute(u'X Prop')  # x-prop
+    iana_prop = Attribute(u'Iana Prop')  # iana-prop
diff --git a/plone/event/recurrence.py b/plone/event/recurrence.py
index 5e47d0e..0bb42ce 100644
--- a/plone/event/recurrence.py
+++ b/plone/event/recurrence.py
@@ -15,10 +15,14 @@
 MAXCOUNT = 1000  # Maximum number of occurrences
 
 
-def recurrence_sequence_ical(start, recrule=None,
-                             from_=None, until=None,
-                             count=None, duration=None):
-
+def recurrence_sequence_ical(
+        start,
+        recrule=None,
+        from_=None,
+        until=None,
+        count=None,
+        duration=None,
+):
     """Calculates a sequence of datetime objects from a recurrence rule
     following the RFC2445 specification, using python-dateutil recurrence
     rules.  The resolution of the resulting datetime objects is one second,
@@ -64,7 +68,7 @@ def recurrence_sequence_ical(start, recrule=None,
     _from = tzdel(from_)
     _until = tzdel(until)
     if duration:
-        assert(isinstance(duration, datetime.timedelta))
+        assert (isinstance(duration, datetime.timedelta))
     else:
         duration = datetime.timedelta(0)
 
@@ -84,15 +88,18 @@ def recurrence_sequence_ical(start, recrule=None,
         # time for UNTIL, RDATE and EXDATE.
         t0 = start.time()  # set initial time information.
         # First, replace all times in the recurring rule with starttime
-        t0str = 'T%02d%02d%02d' % (t0.hour, t0.minute, t0.second)
+        t0str = 'T{0:02d}{1:02d}{2:02d}'.format(t0.hour, t0.minute, t0.second)
         # Replace any times set to 000000 with start time, not all
         # rrules are set by a specific broken widget.  Don't waste time
         # subbing if the start time is already 000000.
         if t0str != 'T000000':
             recrule = re.sub(r'T000000', t0str, recrule)
         # Then, replace incorrect until times with the end of the day
-        recrule = re.sub(r'(UNTIL[^T]*[0-9]{8})T(000000)', r'\1T235959',
-                         recrule)
+        recrule = re.sub(
+            r'(UNTIL[^T]*[0-9]{8})T(000000)',
+            r'\1T235959',
+            recrule,
+        )
 
         # RFC2445 string
         # forceset: always return a rruleset
@@ -100,12 +107,13 @@ def recurrence_sequence_ical(start, recrule=None,
         #          dtstart is given as timezone naive time. timezones are
         #          applied afterwards, since rrulestr doesn't normalize
         #          timezones over DST boundaries
-        rset = rrule.rrulestr(recrule,
-                              dtstart=start,
-                              forceset=True,
-                              ignoretz=True
-                              # compatible=True # RFC2445 compatibility
-                              )
+        rset = rrule.rrulestr(
+            recrule,
+            dtstart=start,
+            forceset=True,
+            ignoretz=True,
+            # compatible=True # RFC2445 compatibility
+        )
     else:
         rset = rrule.rruleset()
     rset.rdate(start)  # RCF2445: always include start date
@@ -113,7 +121,7 @@ def recurrence_sequence_ical(start, recrule=None,
     # limit
     if _from and _until:
         # between doesn't add a ruleset but returns a list
-        rset = rset.between(_from-duration, _until, inc=True)
+        rset = rset.between(_from - duration, _until, inc=True)
     for cnt, date in enumerate(rset):
         # Localize tznaive dates from rrulestr sequence
         date = tz.localize(date)
@@ -123,7 +131,7 @@ def recurrence_sequence_ical(start, recrule=None,
             break
         if count and cnt + 1 > count:
             break
-        if from_ and utc(date)+duration < utc(from_):
+        if from_ and utc(date) + duration < utc(from_):
             continue
         if until and utc(date) > utc(until):
             break
@@ -132,8 +140,13 @@ def recurrence_sequence_ical(start, recrule=None,
     return
 
 
-def recurrence_sequence_timedelta(start, delta=None, until=None, count=None,
-                                  dst=DSTAUTO):
+def recurrence_sequence_timedelta(
+        start,
+        delta=None,
+        until=None,
+        count=None,
+        dst=DSTAUTO,
+):
     """ Calculates a sequence of datetime objects from a timedelta integer,
     which defines the minutes between each occurence.
 
diff --git a/plone/event/tests/test_adapters.py b/plone/event/tests/test_adapters.py
index cfda1df..b302192 100644
--- a/plone/event/tests/test_adapters.py
+++ b/plone/event/tests/test_adapters.py
@@ -1,29 +1,30 @@
-from zope.configuration import xmlconfig
-from plone.event.interfaces import IEvent, IEventAccessor
+# -*- coding: utf-8 -*-
 from datetime import datetime
+from plone.event.interfaces import IEvent
+from plone.event.interfaces import IEventAccessor
+from zope.configuration import xmlconfig
+
 import pytz
 import unittest
 import zope.interface
 
 
 class MockObject(object):
-    """ Mock object
-    """
+    """Mock object"""
 
 
 class TestAdapters(unittest.TestCase):
-
     def setUp(self):
         import zope.component
         context = xmlconfig.file('meta.zcml', zope.component)
         xmlconfig.file('configure.zcml', zope.component, context=context)
 
         import plone.event
-        xmlconfig.file("configure.zcml", plone.event, context=context)
+        xmlconfig.file('configure.zcml', plone.event, context=context)
 
     def test_event_accessor(self):
         obj = MockObject()
-        tz = pytz.timezone("Europe/Vienna")
+        tz = pytz.timezone('Europe/Vienna')
         obj.start = datetime(2012, 12, 12, 10, 0, tzinfo=tz)
         obj.end = datetime(2012, 12, 12, 12, 0, tzinfo=tz)
         zope.interface.alsoProvides(obj, IEvent)
@@ -46,11 +47,11 @@ def test_event_accessor(self):
 
         # Accessor deletor
         acc.something = True
-        self.assertTrue(acc.something == obj.something == True)
+        self.assertTrue(acc.something == obj.something is True)
         del acc.something
-        self.assertTrue(hasattr(acc, 'something') == False)
-        self.assertTrue(hasattr(obj, 'something') == False)
+        self.assertTrue(hasattr(acc, 'something') is False)
+        self.assertTrue(hasattr(obj, 'something') is False)
 
         del acc.start
-        self.assertTrue(hasattr(acc, 'start') == False)
-        self.assertTrue(hasattr(obj, 'start') == False)
+        self.assertTrue(hasattr(acc, 'start') is False)
+        self.assertTrue(hasattr(obj, 'start') is False)
diff --git a/plone/event/tests/test_doctest.py b/plone/event/tests/test_doctest.py
index c4a2991..fa375c4 100644
--- a/plone/event/tests/test_doctest.py
+++ b/plone/event/tests/test_doctest.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from zope.component.testing import tearDown
 
 import doctest
@@ -11,25 +12,30 @@
     'recurrence_dateutil.txt',
     'utils.txt',
 ]
-DOCMODS = [
-    'plone.event.utils',
-]
+DOCMODS = ['plone.event.utils', ]
 
 
 def test_suite():
     suite = unittest.TestSuite()
-    suite.addTests([
-        doctest.DocFileSuite(
-            os.path.join(os.path.dirname(__file__), '..', docfile),
-            module_relative=False,
-            optionflags=OPTIONFLAGS,
-            tearDown=tearDown
-        ) for docfile in DOCFILES
-    ])
-    suite.addTests([
-        doctest.DocTestSuite(docmod, optionflags=OPTIONFLAGS)
-        for docmod in DOCMODS
-    ])
+    suite.addTests(
+        [
+            doctest.DocFileSuite(
+                os.path.join(os.path.dirname(__file__), '..', docfile),
+                module_relative=False,
+                optionflags=OPTIONFLAGS,
+                tearDown=tearDown
+            )
+            for docfile in DOCFILES
+        ]
+    )
+    suite.addTests(
+        [
+            doctest.DocTestSuite(
+                docmod, optionflags=OPTIONFLAGS
+            )
+            for docmod in DOCMODS
+        ]
+    )
     return suite
 
 
diff --git a/plone/event/tests/test_recurrence_int_sequence.py b/plone/event/tests/test_recurrence_int_sequence.py
index 203bafb..ccd072c 100644
--- a/plone/event/tests/test_recurrence_int_sequence.py
+++ b/plone/event/tests/test_recurrence_int_sequence.py
@@ -1,9 +1,9 @@
+# -*- coding: utf-8 -*-
 import mock
 import unittest
 
 
 class TestRecurrenceIntSequence(unittest.TestCase):
-
     @mock.patch('plone.event.recurrence.dt2int')
     def test_recrule_str_(self, dt2int):
         from plone.event.recurrence import recurrence_int_sequence
diff --git a/plone/event/tests/test_recurrence_sequence_ical.py b/plone/event/tests/test_recurrence_sequence_ical.py
index 4a75ff5..6f2ed8e 100644
--- a/plone/event/tests/test_recurrence_sequence_ical.py
+++ b/plone/event/tests/test_recurrence_sequence_ical.py
@@ -1,8 +1,8 @@
+# -*- coding: utf-8 -*-
 import unittest
 
 
 class TestRecurrenceSequenceIcal(unittest.TestCase):
-
     def test_start(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
@@ -15,7 +15,7 @@ def test_recrule_str(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 23)
-        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=5"
+        recrule = 'FREQ=DAILY;INTERVAL=10;COUNT=5'
         seq = recurrence_sequence_ical(start, recrule=recrule)
         results = [res for res in seq]
         self.assertEqual(len(results), 5)
@@ -27,8 +27,7 @@ def test_recrule_str_rdate(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 23, 10, 10)
-        recrule =\
-"""FREQ=DAILY;INTERVAL=1;COUNT=3
+        recrule = """FREQ=DAILY;INTERVAL=1;COUNT=3
 RDATE:20111129T000000"""
         seq = recurrence_sequence_ical(start, recrule=recrule)
         results = [res for res in seq]
@@ -41,15 +40,17 @@ def test_recrule_str_exdate(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         import pytz
-        at = pytz.timezone("Europe/Vienna")
+        at = pytz.timezone('Europe/Vienna')
         start = at.localize(datetime(2013, 6, 29, 10, 10))
-        recrule = 'RRULE:FREQ=DAILY;COUNT=4\r\nEXDATE:20130630T000000,20130701T000000\r\nRDATE:20130706T000000,20130809T000000'
+        recrule = 'RRULE:FREQ=DAILY;COUNT=4\r\nEXDATE:20130630T000000,20130701T000000\r\nRDATE:20130706T000000,20130809T000000'  # noqa
         seq = recurrence_sequence_ical(start, recrule=recrule)
         res = [res for res in seq]
-        res_test = [at.localize(datetime(2013, 6, 29, 10, 10)),
-                    at.localize(datetime(2013, 7, 2, 10, 10)),
-                    at.localize(datetime(2013, 7, 6, 10, 10)),
-                    at.localize(datetime(2013, 8, 9, 10, 10))]
+        res_test = [
+            at.localize(datetime(2013, 6, 29, 10, 10)),
+            at.localize(datetime(2013, 7, 2, 10, 10)),
+            at.localize(datetime(2013, 7, 6, 10, 10)),
+            at.localize(datetime(2013, 8, 9, 10, 10))
+        ]
         self.assertEqual(len(res), 4)
         self.assertEqual(res, res_test)
 
@@ -60,15 +61,17 @@ def test_recrule_str_until(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         import pytz
-        at = pytz.timezone("Europe/Vienna")
+        at = pytz.timezone('Europe/Vienna')
         start = at.localize(datetime(2013, 6, 29, 10, 10))
         recrule = 'RRULE:FREQ=DAILY;UNTIL=20130702T000000'
         seq = recurrence_sequence_ical(start, recrule=recrule)
         res = [res for res in seq]
-        res_test = [at.localize(datetime(2013, 6, 29, 10, 10)),
-                    at.localize(datetime(2013, 6, 30, 10, 10)),
-                    at.localize(datetime(2013, 7, 1, 10, 10)),
-                    at.localize(datetime(2013, 7, 2, 10, 10))]
+        res_test = [
+            at.localize(datetime(2013, 6, 29, 10, 10)),
+            at.localize(datetime(2013, 6, 30, 10, 10)),
+            at.localize(datetime(2013, 7, 1, 10, 10)),
+            at.localize(datetime(2013, 7, 2, 10, 10))
+        ]
         self.assertEqual(len(res), 4)
         self.assertEqual(res, res_test)
 
@@ -79,8 +82,12 @@ def test_recrule_from_until(self):
         recrule = None
         from_ = datetime(2011, 11, 1)
         until = datetime(2011, 12, 31)
-        seq = recurrence_sequence_ical(start, recrule=recrule,
-                                       from_=from_, until=until)
+        seq = recurrence_sequence_ical(
+            start,
+            recrule=recrule,
+            from_=from_,
+            until=until,
+        )
         results = [res for res in seq]
         self.assertEqual(len(results), 1)
 
@@ -88,7 +95,7 @@ def test_recrule_str_more_than_MAXCOUNT(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 23)
-        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=1001"
+        recrule = 'FREQ=DAILY;INTERVAL=10;COUNT=1001'
         seq = recurrence_sequence_ical(start, recrule=recrule)
         results = [res for res in seq]
         self.assertEqual(len(results), 1000)
@@ -97,7 +104,7 @@ def test_recrule_str_more_than_count(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 23)
-        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=10"
+        recrule = 'FREQ=DAILY;INTERVAL=10;COUNT=10'
         count = 5
         seq = recurrence_sequence_ical(start, recrule=recrule, count=count)
         results = [res for res in seq]
@@ -107,11 +114,15 @@ def test_recrule_from(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 23)
-        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"
+        recrule = 'FREQ=DAILY;INTERVAL=1;COUNT=5'
         from_ = datetime(2011, 11, 25)
         until = datetime(2011, 11, 27)
-        seq = recurrence_sequence_ical(start, recrule=recrule,
-                                       from_=from_, until=until)
+        seq = recurrence_sequence_ical(
+            start,
+            recrule=recrule,
+            from_=from_,
+            until=until,
+        )
         results = [res for res in seq]
         self.assertEqual(len(results), 3)
 
@@ -119,11 +130,15 @@ def test_recrule_until(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 24)
-        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"
+        recrule = 'FREQ=DAILY;INTERVAL=1;COUNT=5'
         from_ = datetime(2011, 11, 23)
         until = datetime(2011, 11, 27)
-        seq = recurrence_sequence_ical(start, recrule=recrule,
-                                       from_=from_, until=until)
+        seq = recurrence_sequence_ical(
+            start,
+            recrule=recrule,
+            from_=from_,
+            until=until,
+        )
         results = [res for res in seq]
         self.assertEqual(len(results), 4)
 
@@ -134,12 +149,16 @@ def test_recrule_from_until_with_duration(self):
         from datetime import datetime
         from datetime import timedelta
         start = datetime(2011, 11, 23)
-        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"
+        recrule = 'FREQ=DAILY;INTERVAL=1;COUNT=5'
         from_ = datetime(2011, 11, 26)
         until = datetime(2011, 11, 27)
-        seq = recurrence_sequence_ical(start, recrule=recrule,
-                                       from_=from_, until=until,
-                                       duration=timedelta(days=2))
+        seq = recurrence_sequence_ical(
+            start,
+            recrule=recrule,
+            from_=from_,
+            until=until,
+            duration=timedelta(days=2),
+        )
         results = [res for res in seq]
         self.assertEqual(len(results), 4)
 
@@ -148,6 +167,6 @@ def test_recrule_until_with_timezone(self):
         from datetime import datetime
 
         start = datetime(2011, 11, 24)
-        recrule = "RRULE:FREQ=DAILY;UNTIL=20111130T000000Z"
+        recrule = 'RRULE:FREQ=DAILY;UNTIL=20111130T000000Z'
         seq = list(recurrence_sequence_ical(start, recrule=recrule))
         self.assertEqual(len(seq), 7)
diff --git a/plone/event/tests/test_recurrence_sequence_timedelta.py b/plone/event/tests/test_recurrence_sequence_timedelta.py
index 71880b9..c9493f7 100644
--- a/plone/event/tests/test_recurrence_sequence_timedelta.py
+++ b/plone/event/tests/test_recurrence_sequence_timedelta.py
@@ -1,8 +1,8 @@
+# -*- coding: utf-8 -*-
 import unittest
 
 
 class TestRecurrenceSequenceTimedelta(unittest.TestCase):
-
     def test_delta_None(self):
         from plone.event.recurrence import recurrence_sequence_timedelta
         from datetime import datetime
@@ -58,7 +58,11 @@ def test_recur_more_than_count(self):
         delta = 1
         until = datetime(2011, 11, 24)
         count = 20
-        td = recurrence_sequence_timedelta(start, delta=delta,
-                                           until=until, count=count)
+        td = recurrence_sequence_timedelta(
+            start,
+            delta=delta,
+            until=until,
+            count=count,
+        )
         results = [res for res in td]
         self.assertEqual(len(results), 21)
diff --git a/plone/event/tests/test_utils.py b/plone/event/tests/test_utils.py
index fdf0472..f90fedd 100644
--- a/plone/event/tests/test_utils.py
+++ b/plone/event/tests/test_utils.py
@@ -1,9 +1,9 @@
+# -*- coding: utf-8 -*-
 import mock
 import unittest
 
 
 class TestUtils(unittest.TestCase):
-
     @mock.patch('plone.event.utils.pytz')
     @mock.patch('plone.event.utils.os')
     def test_default_timezone(self, os, pytz):
@@ -17,10 +17,7 @@ def test_utcoffset_normalize(self):
         from plone.event.utils import utcoffset_normalize
         date = mock.Mock()
         date.replace = mock.Mock(side_effect=KeyError)
-        self.assertEqual(
-            utcoffset_normalize(date),
-            date
-        )
+        self.assertEqual(utcoffset_normalize(date), date)
 
     @mock.patch('plone.event.utils.guesstz')
     @mock.patch('plone.event.utils.utctz')
diff --git a/plone/event/utils.py b/plone/event/utils.py
index be5ce92..d5c4ebc 100644
--- a/plone/event/utils.py
+++ b/plone/event/utils.py
@@ -1,17 +1,18 @@
 # -*- coding: utf-8 -*-
+from datetime import date
+from datetime import datetime
+from datetime import timedelta
 
 import logging
 import os
 import pytz
 import time
-from datetime import date
-from datetime import datetime
-from datetime import timedelta
+
 
 DSTADJUST = 'adjust'
 DSTKEEP = 'keep'
 DSTAUTO = 'auto'
-MAX32 = int(2 ** 31 - 1)
+MAX32 = int(2**31 - 1)
 
 logger = logging.getLogger('plone.event')
 
@@ -55,15 +56,21 @@ def validated_timezone(timezone, fallback=None):
     try:
         # following statement ensures, that timezone is a valid pytz/Olson zone
         return pytz.timezone(timezone).zone
-    except:
+    except Exception:
         if fallback:
-            logger.warn('The timezone %s is not a valid timezone from the '
-                        'Olson database or pytz. Falling back to %s.'
-                        % (timezone, fallback))
+            logger.warn(
+                'The timezone {0} is not a valid timezone from the '
+                'Olson database or pytz. Falling back to {1}.'.format(
+                    timezone,
+                    fallback,
+                )
+            )
             return fallback
         else:
-            raise ValueError('The timezone %s is not a valid timezone from '
-                             'the Olson database or pytz.' % timezone)
+            raise ValueError(
+                'The timezone {0} is not a valid timezone from '
+                'the Olson database or pytz.'.format(timezone)
+            )
 
 
 def default_timezone(fallback='UTC'):
@@ -123,12 +130,14 @@ def default_timezone(fallback='UTC'):
             timezone = zones[0]
         else:
             # Default fallback = UTC
-            logger.warn("Operating system's timezone cannot be found. "
-                        "Falling back to UTC.")
+            logger.warn(
+                'Operating system\'s timezone cannot be found. '
+                'Falling back to UTC.'
+            )
     return validated_timezone(timezone, fallback)
 
 
-### Display helpers
+# Display helpers
 def is_same_time(start, end, exact=False):
     """ Test if event starts and ends at same time.
 
@@ -207,7 +216,7 @@ def is_same_day(start, end):
     return start.date() == end.date()
 
 
-### Timezone helpers
+# Timezone helpers
 def utctz():
     """ Return the UTVC zone as a pytz.UTC instance.
 
@@ -266,12 +275,12 @@ def utcoffset_normalize(date, delta=None, dstmode=DSTAUTO):
                   used - otherwise DSTADJUST. This behavior is the default.
     """
     try:
-        assert(bool(date.tzinfo))
-    except:
+        assert (bool(date.tzinfo))
+    except Exception:
         raise TypeError('Cannot normalize timezone naive dates')
-    assert(dstmode in [DSTADJUST, DSTKEEP, DSTAUTO])
+    assert (dstmode in [DSTADJUST, DSTKEEP, DSTAUTO])
     if delta:
-        assert(isinstance(delta, timedelta))  # Easier in Java
+        assert (isinstance(delta, timedelta))  # Easier in Java
         delta = delta.seconds + delta.days * 24 * 3600  # total delta in secs
         if dstmode == DSTAUTO and delta < 24 * 60 * 60:
             dstmode = DSTKEEP
@@ -283,7 +292,7 @@ def utcoffset_normalize(date, delta=None, dstmode=DSTAUTO):
             return date.tzinfo.normalize(date)
         else:  # DSTADJUST
             return date.replace(tzinfo=date.tzinfo.normalize(date).tzinfo)
-    except:
+    except Exception:
         # TODO: python-datetime converts e.g RDATE:20100119T230000Z to
         # datetime.datetime(2010, 1, 19, 23, 0, tzinfo=tzutc())
         # should that be a real utc zoneinfo?
@@ -383,7 +392,7 @@ def date_to_datetime(value):
     elif is_datetime(value):
         return value
     else:
-        raise ValueError("Value must be a date or datetime object.")
+        raise ValueError('Value must be a date or datetime object.')
 
 
 def pydt(dt, missing_zone=None, exact=False):
@@ -451,7 +460,7 @@ def pydt(dt, missing_zone=None, exact=False):
         else:
             ret = utcoffset_normalize(dt, dstmode=DSTADJUST)
 
-    if "DateTime" in str(dt.__class__):
+    if 'DateTime' in str(dt.__class__):
         # Zope DateTime
         # TODO: do we need to support subclasses of DateTime too? the check
         #       above would fail.
@@ -478,14 +487,17 @@ def pydt(dt, missing_zone=None, exact=False):
         # tz is equal to <DstTzInfo 'Europe/Paris' PMT+0:09:00 STD>
         dt = datetime(year, month, day, hour, min, sec, micro, tzinfo=tz)
         # before:
-        # datetime.datetime(2011, 3, 14, 14, 19, tzinfo=<DstTzInfo 'Europe/Paris' PMT+0:09:00 STD>)
+        # datetime.datetime(2011, 3, 14, 14, 19,
+        # tzinfo=<DstTzInfo 'Europe/Paris' PMT+0:09:00 STD>)
         # dt = dt.tzinfo.normalize(dt)
-        # after: datetime.datetime(2011, 3, 14, 15, 10, tzinfo=<DstTzInfo 'Europe/Paris' CET+1:00:00 STD>
+        # after: datetime.datetime(2011, 3, 14, 15, 10,
+        # tzinfo=<DstTzInfo 'Europe/Paris' CET+1:00:00 STD>
         dt = utcoffset_normalize(dt, dstmode=DSTADJUST)
-        # after: datetime.datetime(2011, 3, 14, 19, tzinfo=<DstTzInfo 'Europe/Paris' CET+1:00:00 STD>
+        # after: datetime.datetime(2011, 3, 14, 19,
+        # tzinfo=<DstTzInfo 'Europe/Paris' CET+1:00:00 STD>
         ret = dt
 
-    if ret and exact == False:
+    if ret and exact is False:
         ret = ret.replace(microsecond=0)
 
     return ret
@@ -522,7 +534,7 @@ def guesstz(DT):
     return None
 
 
-### Date as integer representation helpers
+# Date as integer representation helpers
 def dt2int(dt):
     """ Calculates an integer from a datetime, resolution is one minute.
     The datetime is always converted to the UTC zone.
@@ -537,14 +549,15 @@ def dt2int(dt):
         return 0
     # TODO: if dt has not timezone information, guess and set it
     dt = utc(dt)
-    value = (((dt.year*12+dt.month)*31+dt.day)*24+dt.hour)*60+dt.minute
+    value = (((dt.year * 12 + dt.month) * 31 + dt.day) * 24 + dt.hour
+             ) * 60 + dt.minute
 
     # TODO: unit test me
     if value > MAX32:
         # value must be integer fitting in the 32bit range
         raise OverflowError(
-            """%s is not within the range of indexable dates,<<
-            exceeding 32bit range.""" % dt
+            """{0} is not within the range of indexable dates,<<
+            exceeding 32bit range.""".format(dt)
         )
     return value
 
@@ -582,7 +595,7 @@ def dt_to_zone(dt, tzstring):
     return dt.astimezone(pytz.timezone(tzstring))
 
 
-### RFC2445 export helpers
+# RFC2445 export helpers
 def rfc2445dt(dt, mode='utc', date=True, time=True):
     """ Convert a datetime or DateTime object into an RFC2445 compatible
     datetime string.
@@ -646,10 +659,12 @@ def rfc2445dt(dt, mode='utc', date=True, time=True):
     dt = pydt(dt)
     if mode == 'utc':
         dt = utc(dt)
-    date = "%s%s%s%s" % (date and dt.strftime("%Y%m%d") or '',
-                         date and time and 'T' or '',
-                         time and dt.strftime("%H%M%S") or '',
-                         mode=='utc' and 'Z' or '')
+    date = '{0}{1}{2}{3}'.format(
+        date and dt.strftime('%Y%m%d') or '',
+        date and time and 'T' or '',
+        time and dt.strftime('%H%M%S') or '',
+        mode == 'utc' and 'Z' or '',
+    )
     if mode == 'local':
         return date, dt.tzinfo.zone
     return date
diff --git a/setup.py b/setup.py
index def71d5..7fa0b80 100644
--- a/setup.py
+++ b/setup.py
@@ -1,14 +1,27 @@
+# -*- coding: utf-8 -*-
 from setuptools import find_packages
 from setuptools import setup
 
+
 version = '1.3.3.dev0'
 
+a = (
+    'bla',
+    'bli',
+    'bli',
+    'bli',
+    'bli',
+    'bli',
+    'bliaad asdf asd asd asda sd asd asd sd ',
+)
+
 setup(
     name='plone.event',
     version=version,
     description="Event and calendaring related tools not bound to Plone",
-    long_description=(open("README.rst").read() + "\n" +
-                      open(("CHANGES.rst")).read()),
+    long_description=(
+        open("README.rst").read() + "\n" + open(("CHANGES.rst")).read()
+    ),
     classifiers=[
         "Framework :: Plone",
         "Framework :: Plone :: 5.0",
@@ -33,11 +46,9 @@
         'zope.component',
         'zope.interface',
     ],
-    extras_require={
-        'test': [
-            'DateTime',
-            'mock',
-            'zope.configuration',
-        ],
-    },
+    extras_require={'test': [
+        'DateTime',
+        'mock',
+        'zope.configuration',
+    ], },
 )


Repository: plone.event


Branch: refs/heads/master
Date: 2016-12-08T16:05:36+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/bddf6b3f02d0590ed749bd1b5ec98c6b3cf73eaf

Merge pull request #8 from plone/gforcada-cleanup

Update code to follow Plone styleguide

Files changed:
M CHANGES.rst
M plone/__init__.py
M plone/event/adapters.py
M plone/event/interfaces.py
M plone/event/recurrence.py
M plone/event/tests/test_adapters.py
M plone/event/tests/test_doctest.py
M plone/event/tests/test_recurrence_int_sequence.py
M plone/event/tests/test_recurrence_sequence_ical.py
M plone/event/tests/test_recurrence_sequence_timedelta.py
M plone/event/tests/test_utils.py
M plone/event/utils.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 08eeca0..b41692e 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -14,8 +14,8 @@ New features:
 
 Bug fixes:
 
-- *add item here*
-
+- Update code to follow Plone styleguide.
+  [gforcada]
 
 1.3.2 (2016-11-17)
 ------------------
diff --git a/plone/__init__.py b/plone/__init__.py
index f48ad10..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,6 +1,2 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/event/adapters.py b/plone/event/adapters.py
index 5772ad1..717657a 100644
--- a/plone/event/adapters.py
+++ b/plone/event/adapters.py
@@ -1,18 +1,18 @@
+# -*- coding: utf-8 -*-
 from plone.event.interfaces import IEvent
 from plone.event.interfaces import IEventAccessor
-from zope.component import adapts
+from zope.component import adapter
 from zope.interface import implementer
 
 
 @implementer(IEventAccessor)
+@adapter(IEvent)
 class EventAccessor(object):
     """Simple event accessor adapter implementation for generic events, which
     follow the IEvent interface closely.
 
     Concrete implementations adapt a content type to the IEvent specification.
-
     """
-    adapts(IEvent)
 
     def __init__(self, context):
         object.__setattr__(self, 'context', context)
diff --git a/plone/event/interfaces.py b/plone/event/interfaces.py
index 024b996..fa88995 100644
--- a/plone/event/interfaces.py
+++ b/plone/event/interfaces.py
@@ -1,4 +1,6 @@
-from zope.interface import Interface, Attribute
+# -*- coding: utf-8 -*-
+from zope.interface import Attribute
+from zope.interface import Interface
 
 
 class IEvent(Interface):
@@ -19,8 +21,8 @@ class IOccurrence(Interface):
     occurrence.
 
     """
-    start = Attribute(u"Occurrence start date")
-    end = Attribute(u"Occurrence end date")
+    start = Attribute(u'Occurrence start date')
+    end = Attribute(u'Occurrence end date')
 
 
 class ICalendarAccessor(Interface):
@@ -29,11 +31,11 @@ class ICalendarAccessor(Interface):
     A calendar is a collection of calendar components, like events.
 
     """
-    uid = Attribute(u"UID of the calendar. Autogenerated, read only.")
+    uid = Attribute(u'UID of the calendar. Autogenerated, read only.')
     # rw attributes
-    title = Attribute(u"Calendar title.")
-    description = Attribute(u"Calendar description text.")
-    timezone = Attribute(u"Default timezone of the calendar.")
+    title = Attribute(u'Calendar title.')
+    description = Attribute(u'Calendar description text.')
+    timezone = Attribute(u'Default timezone of the calendar.')
 
     def items(self):
         """Return a list of calendar component items, like events.
@@ -50,33 +52,34 @@ class IEventAccessor(Interface):
     """
 
     # ro attributes
-    uid = Attribute(u"UID of the event. Autogenerated, read only.")
-    created = Attribute(u"Python datetime of the event creation timestamp.")
-    duration = Attribute(u"Duration of the event. Computed attribute.")
+    uid = Attribute(u'UID of the event. Autogenerated, read only.')
+    created = Attribute(u'Python datetime of the event creation timestamp.')
+    duration = Attribute(u'Duration of the event. Computed attribute.')
 
     # reference
-    url = Attribute(u"Cannonical, unique url of the event. External events "
-                    u"are referenced by the origin url unless explicitly "
-                    u"set.")
+    url = Attribute(
+        u'Cannonical, unique url of the event. External events '
+        u'are referenced by the origin url unless explicitly set.'
+    )
 
     # rw attributes
-    last_modified = Attribute(u"Last modified Python datetime.")
-    title = Attribute(u"Event title.")
-    description = Attribute(u"Event description text.")
-    start = Attribute(u"Event start date as Python datetime.")
-    end = Attribute(u"Event end date as Python datetime.")
-    whole_day = Attribute(u"Event lasts whole day.")
-    open_end = Attribute(u"Event has no defined end time.")
-    timezone = Attribute(u"Timezone of the event. A pytz timezone identifier.")
-    recurrence = Attribute(u"RFC5545 compatible recurrence definition.")
-    location = Attribute(u"Location of the event.")
-    attendees = Attribute(u"List of attendees.")
-    contact_name = Attribute(u"Contact name.")
-    contact_email = Attribute(u"Contact email.")
-    contact_phone = Attribute(u"Contact phone.")
-    event_url = Attribute(u"Website of the event.")
-    subjects = Attribute(u"Categories.")
-    text = Attribute(u"Body text of the event.")
+    last_modified = Attribute(u'Last modified Python datetime.')
+    title = Attribute(u'Event title.')
+    description = Attribute(u'Event description text.')
+    start = Attribute(u'Event start date as Python datetime.')
+    end = Attribute(u'Event end date as Python datetime.')
+    whole_day = Attribute(u'Event lasts whole day.')
+    open_end = Attribute(u'Event has no defined end time.')
+    timezone = Attribute(u'Timezone of the event. A pytz timezone identifier.')
+    recurrence = Attribute(u'RFC5545 compatible recurrence definition.')
+    location = Attribute(u'Location of the event.')
+    attendees = Attribute(u'List of attendees.')
+    contact_name = Attribute(u'Contact name.')
+    contact_email = Attribute(u'Contact email.')
+    contact_phone = Attribute(u'Contact phone.')
+    event_url = Attribute(u'Website of the event.')
+    subjects = Attribute(u'Categories.')
+    text = Attribute(u'Body text of the event.')
 
 
 class IRecurrenceSupport(Interface):
@@ -153,37 +156,37 @@ class / created / description / geo /
     resources / rdate / x-prop / iana-prop
 
     """
-    dtstart = Attribute(u"Start Date/Time")
-    dtend = Attribute(u"End Date/Time")
-    duration = Attribute(u"Duration")
-    rrule = Attribute(u"Recurrence Rule")
-    description = Attribute(u"Description")
-    location = Attribute(u"Location")
-    summary = Attribute(u"Summary")
-    url = Attribute(u"Url")
-    attendee = Attribute(u"Attendee")
-    categories = Attribute(u"Categories")
-    contact = Attribute(u"Contact")
-
-    exdate = Attribute(u"Exdate")
-    rdate = Attribute(u"Rdate")
-
-    dtstamp = Attribute(u"Timestamp")
-    uid = Attribute(u"Unique identifier")
-    klass = Attribute(u"Class")  # class
-    created = Attribute(u"Created")
-    geo = Attribute(u"Geo")
-    last_mod = Attribute(u"Last Modified")  # last-mod
-    organizer = Attribute(u"Organizer")
-    priority = Attribute(u"Priority")
-    seq = Attribute(u"Seq")
-    status = Attribute(u"Status")
-    transp = Attribute(u"Transp")
-    recurid = Attribute(u"Recurid")
-    attach = Attribute(u"Attach")
-    comment = Attribute(u"Comment")
-    rstatus = Attribute(u"Rstatus")
-    related = Attribute(u"Related")
-    resources = Attribute(u"Resources")
-    x_prop = Attribute(u"X Prop")  # x-prop
-    iana_prop = Attribute(u"Iana Prop")  # iana-prop
+    dtstart = Attribute(u'Start Date/Time')
+    dtend = Attribute(u'End Date/Time')
+    duration = Attribute(u'Duration')
+    rrule = Attribute(u'Recurrence Rule')
+    description = Attribute(u'Description')
+    location = Attribute(u'Location')
+    summary = Attribute(u'Summary')
+    url = Attribute(u'Url')
+    attendee = Attribute(u'Attendee')
+    categories = Attribute(u'Categories')
+    contact = Attribute(u'Contact')
+
+    exdate = Attribute(u'Exdate')
+    rdate = Attribute(u'Rdate')
+
+    dtstamp = Attribute(u'Timestamp')
+    uid = Attribute(u'Unique identifier')
+    klass = Attribute(u'Class')  # class
+    created = Attribute(u'Created')
+    geo = Attribute(u'Geo')
+    last_mod = Attribute(u'Last Modified')  # last-mod
+    organizer = Attribute(u'Organizer')
+    priority = Attribute(u'Priority')
+    seq = Attribute(u'Seq')
+    status = Attribute(u'Status')
+    transp = Attribute(u'Transp')
+    recurid = Attribute(u'Recurid')
+    attach = Attribute(u'Attach')
+    comment = Attribute(u'Comment')
+    rstatus = Attribute(u'Rstatus')
+    related = Attribute(u'Related')
+    resources = Attribute(u'Resources')
+    x_prop = Attribute(u'X Prop')  # x-prop
+    iana_prop = Attribute(u'Iana Prop')  # iana-prop
diff --git a/plone/event/recurrence.py b/plone/event/recurrence.py
index 5e47d0e..0bb42ce 100644
--- a/plone/event/recurrence.py
+++ b/plone/event/recurrence.py
@@ -15,10 +15,14 @@
 MAXCOUNT = 1000  # Maximum number of occurrences
 
 
-def recurrence_sequence_ical(start, recrule=None,
-                             from_=None, until=None,
-                             count=None, duration=None):
-
+def recurrence_sequence_ical(
+        start,
+        recrule=None,
+        from_=None,
+        until=None,
+        count=None,
+        duration=None,
+):
     """Calculates a sequence of datetime objects from a recurrence rule
     following the RFC2445 specification, using python-dateutil recurrence
     rules.  The resolution of the resulting datetime objects is one second,
@@ -64,7 +68,7 @@ def recurrence_sequence_ical(start, recrule=None,
     _from = tzdel(from_)
     _until = tzdel(until)
     if duration:
-        assert(isinstance(duration, datetime.timedelta))
+        assert (isinstance(duration, datetime.timedelta))
     else:
         duration = datetime.timedelta(0)
 
@@ -84,15 +88,18 @@ def recurrence_sequence_ical(start, recrule=None,
         # time for UNTIL, RDATE and EXDATE.
         t0 = start.time()  # set initial time information.
         # First, replace all times in the recurring rule with starttime
-        t0str = 'T%02d%02d%02d' % (t0.hour, t0.minute, t0.second)
+        t0str = 'T{0:02d}{1:02d}{2:02d}'.format(t0.hour, t0.minute, t0.second)
         # Replace any times set to 000000 with start time, not all
         # rrules are set by a specific broken widget.  Don't waste time
         # subbing if the start time is already 000000.
         if t0str != 'T000000':
             recrule = re.sub(r'T000000', t0str, recrule)
         # Then, replace incorrect until times with the end of the day
-        recrule = re.sub(r'(UNTIL[^T]*[0-9]{8})T(000000)', r'\1T235959',
-                         recrule)
+        recrule = re.sub(
+            r'(UNTIL[^T]*[0-9]{8})T(000000)',
+            r'\1T235959',
+            recrule,
+        )
 
         # RFC2445 string
         # forceset: always return a rruleset
@@ -100,12 +107,13 @@ def recurrence_sequence_ical(start, recrule=None,
         #          dtstart is given as timezone naive time. timezones are
         #          applied afterwards, since rrulestr doesn't normalize
         #          timezones over DST boundaries
-        rset = rrule.rrulestr(recrule,
-                              dtstart=start,
-                              forceset=True,
-                              ignoretz=True
-                              # compatible=True # RFC2445 compatibility
-                              )
+        rset = rrule.rrulestr(
+            recrule,
+            dtstart=start,
+            forceset=True,
+            ignoretz=True,
+            # compatible=True # RFC2445 compatibility
+        )
     else:
         rset = rrule.rruleset()
     rset.rdate(start)  # RCF2445: always include start date
@@ -113,7 +121,7 @@ def recurrence_sequence_ical(start, recrule=None,
     # limit
     if _from and _until:
         # between doesn't add a ruleset but returns a list
-        rset = rset.between(_from-duration, _until, inc=True)
+        rset = rset.between(_from - duration, _until, inc=True)
     for cnt, date in enumerate(rset):
         # Localize tznaive dates from rrulestr sequence
         date = tz.localize(date)
@@ -123,7 +131,7 @@ def recurrence_sequence_ical(start, recrule=None,
             break
         if count and cnt + 1 > count:
             break
-        if from_ and utc(date)+duration < utc(from_):
+        if from_ and utc(date) + duration < utc(from_):
             continue
         if until and utc(date) > utc(until):
             break
@@ -132,8 +140,13 @@ def recurrence_sequence_ical(start, recrule=None,
     return
 
 
-def recurrence_sequence_timedelta(start, delta=None, until=None, count=None,
-                                  dst=DSTAUTO):
+def recurrence_sequence_timedelta(
+        start,
+        delta=None,
+        until=None,
+        count=None,
+        dst=DSTAUTO,
+):
     """ Calculates a sequence of datetime objects from a timedelta integer,
     which defines the minutes between each occurence.
 
diff --git a/plone/event/tests/test_adapters.py b/plone/event/tests/test_adapters.py
index cfda1df..b302192 100644
--- a/plone/event/tests/test_adapters.py
+++ b/plone/event/tests/test_adapters.py
@@ -1,29 +1,30 @@
-from zope.configuration import xmlconfig
-from plone.event.interfaces import IEvent, IEventAccessor
+# -*- coding: utf-8 -*-
 from datetime import datetime
+from plone.event.interfaces import IEvent
+from plone.event.interfaces import IEventAccessor
+from zope.configuration import xmlconfig
+
 import pytz
 import unittest
 import zope.interface
 
 
 class MockObject(object):
-    """ Mock object
-    """
+    """Mock object"""
 
 
 class TestAdapters(unittest.TestCase):
-
     def setUp(self):
         import zope.component
         context = xmlconfig.file('meta.zcml', zope.component)
         xmlconfig.file('configure.zcml', zope.component, context=context)
 
         import plone.event
-        xmlconfig.file("configure.zcml", plone.event, context=context)
+        xmlconfig.file('configure.zcml', plone.event, context=context)
 
     def test_event_accessor(self):
         obj = MockObject()
-        tz = pytz.timezone("Europe/Vienna")
+        tz = pytz.timezone('Europe/Vienna')
         obj.start = datetime(2012, 12, 12, 10, 0, tzinfo=tz)
         obj.end = datetime(2012, 12, 12, 12, 0, tzinfo=tz)
         zope.interface.alsoProvides(obj, IEvent)
@@ -46,11 +47,11 @@ def test_event_accessor(self):
 
         # Accessor deletor
         acc.something = True
-        self.assertTrue(acc.something == obj.something == True)
+        self.assertTrue(acc.something == obj.something is True)
         del acc.something
-        self.assertTrue(hasattr(acc, 'something') == False)
-        self.assertTrue(hasattr(obj, 'something') == False)
+        self.assertTrue(hasattr(acc, 'something') is False)
+        self.assertTrue(hasattr(obj, 'something') is False)
 
         del acc.start
-        self.assertTrue(hasattr(acc, 'start') == False)
-        self.assertTrue(hasattr(obj, 'start') == False)
+        self.assertTrue(hasattr(acc, 'start') is False)
+        self.assertTrue(hasattr(obj, 'start') is False)
diff --git a/plone/event/tests/test_doctest.py b/plone/event/tests/test_doctest.py
index c4a2991..fa375c4 100644
--- a/plone/event/tests/test_doctest.py
+++ b/plone/event/tests/test_doctest.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from zope.component.testing import tearDown
 
 import doctest
@@ -11,25 +12,30 @@
     'recurrence_dateutil.txt',
     'utils.txt',
 ]
-DOCMODS = [
-    'plone.event.utils',
-]
+DOCMODS = ['plone.event.utils', ]
 
 
 def test_suite():
     suite = unittest.TestSuite()
-    suite.addTests([
-        doctest.DocFileSuite(
-            os.path.join(os.path.dirname(__file__), '..', docfile),
-            module_relative=False,
-            optionflags=OPTIONFLAGS,
-            tearDown=tearDown
-        ) for docfile in DOCFILES
-    ])
-    suite.addTests([
-        doctest.DocTestSuite(docmod, optionflags=OPTIONFLAGS)
-        for docmod in DOCMODS
-    ])
+    suite.addTests(
+        [
+            doctest.DocFileSuite(
+                os.path.join(os.path.dirname(__file__), '..', docfile),
+                module_relative=False,
+                optionflags=OPTIONFLAGS,
+                tearDown=tearDown
+            )
+            for docfile in DOCFILES
+        ]
+    )
+    suite.addTests(
+        [
+            doctest.DocTestSuite(
+                docmod, optionflags=OPTIONFLAGS
+            )
+            for docmod in DOCMODS
+        ]
+    )
     return suite
 
 
diff --git a/plone/event/tests/test_recurrence_int_sequence.py b/plone/event/tests/test_recurrence_int_sequence.py
index 203bafb..ccd072c 100644
--- a/plone/event/tests/test_recurrence_int_sequence.py
+++ b/plone/event/tests/test_recurrence_int_sequence.py
@@ -1,9 +1,9 @@
+# -*- coding: utf-8 -*-
 import mock
 import unittest
 
 
 class TestRecurrenceIntSequence(unittest.TestCase):
-
     @mock.patch('plone.event.recurrence.dt2int')
     def test_recrule_str_(self, dt2int):
         from plone.event.recurrence import recurrence_int_sequence
diff --git a/plone/event/tests/test_recurrence_sequence_ical.py b/plone/event/tests/test_recurrence_sequence_ical.py
index 4a75ff5..6f2ed8e 100644
--- a/plone/event/tests/test_recurrence_sequence_ical.py
+++ b/plone/event/tests/test_recurrence_sequence_ical.py
@@ -1,8 +1,8 @@
+# -*- coding: utf-8 -*-
 import unittest
 
 
 class TestRecurrenceSequenceIcal(unittest.TestCase):
-
     def test_start(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
@@ -15,7 +15,7 @@ def test_recrule_str(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 23)
-        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=5"
+        recrule = 'FREQ=DAILY;INTERVAL=10;COUNT=5'
         seq = recurrence_sequence_ical(start, recrule=recrule)
         results = [res for res in seq]
         self.assertEqual(len(results), 5)
@@ -27,8 +27,7 @@ def test_recrule_str_rdate(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 23, 10, 10)
-        recrule =\
-"""FREQ=DAILY;INTERVAL=1;COUNT=3
+        recrule = """FREQ=DAILY;INTERVAL=1;COUNT=3
 RDATE:20111129T000000"""
         seq = recurrence_sequence_ical(start, recrule=recrule)
         results = [res for res in seq]
@@ -41,15 +40,17 @@ def test_recrule_str_exdate(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         import pytz
-        at = pytz.timezone("Europe/Vienna")
+        at = pytz.timezone('Europe/Vienna')
         start = at.localize(datetime(2013, 6, 29, 10, 10))
-        recrule = 'RRULE:FREQ=DAILY;COUNT=4\r\nEXDATE:20130630T000000,20130701T000000\r\nRDATE:20130706T000000,20130809T000000'
+        recrule = 'RRULE:FREQ=DAILY;COUNT=4\r\nEXDATE:20130630T000000,20130701T000000\r\nRDATE:20130706T000000,20130809T000000'  # noqa
         seq = recurrence_sequence_ical(start, recrule=recrule)
         res = [res for res in seq]
-        res_test = [at.localize(datetime(2013, 6, 29, 10, 10)),
-                    at.localize(datetime(2013, 7, 2, 10, 10)),
-                    at.localize(datetime(2013, 7, 6, 10, 10)),
-                    at.localize(datetime(2013, 8, 9, 10, 10))]
+        res_test = [
+            at.localize(datetime(2013, 6, 29, 10, 10)),
+            at.localize(datetime(2013, 7, 2, 10, 10)),
+            at.localize(datetime(2013, 7, 6, 10, 10)),
+            at.localize(datetime(2013, 8, 9, 10, 10))
+        ]
         self.assertEqual(len(res), 4)
         self.assertEqual(res, res_test)
 
@@ -60,15 +61,17 @@ def test_recrule_str_until(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         import pytz
-        at = pytz.timezone("Europe/Vienna")
+        at = pytz.timezone('Europe/Vienna')
         start = at.localize(datetime(2013, 6, 29, 10, 10))
         recrule = 'RRULE:FREQ=DAILY;UNTIL=20130702T000000'
         seq = recurrence_sequence_ical(start, recrule=recrule)
         res = [res for res in seq]
-        res_test = [at.localize(datetime(2013, 6, 29, 10, 10)),
-                    at.localize(datetime(2013, 6, 30, 10, 10)),
-                    at.localize(datetime(2013, 7, 1, 10, 10)),
-                    at.localize(datetime(2013, 7, 2, 10, 10))]
+        res_test = [
+            at.localize(datetime(2013, 6, 29, 10, 10)),
+            at.localize(datetime(2013, 6, 30, 10, 10)),
+            at.localize(datetime(2013, 7, 1, 10, 10)),
+            at.localize(datetime(2013, 7, 2, 10, 10))
+        ]
         self.assertEqual(len(res), 4)
         self.assertEqual(res, res_test)
 
@@ -79,8 +82,12 @@ def test_recrule_from_until(self):
         recrule = None
         from_ = datetime(2011, 11, 1)
         until = datetime(2011, 12, 31)
-        seq = recurrence_sequence_ical(start, recrule=recrule,
-                                       from_=from_, until=until)
+        seq = recurrence_sequence_ical(
+            start,
+            recrule=recrule,
+            from_=from_,
+            until=until,
+        )
         results = [res for res in seq]
         self.assertEqual(len(results), 1)
 
@@ -88,7 +95,7 @@ def test_recrule_str_more_than_MAXCOUNT(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 23)
-        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=1001"
+        recrule = 'FREQ=DAILY;INTERVAL=10;COUNT=1001'
         seq = recurrence_sequence_ical(start, recrule=recrule)
         results = [res for res in seq]
         self.assertEqual(len(results), 1000)
@@ -97,7 +104,7 @@ def test_recrule_str_more_than_count(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 23)
-        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=10"
+        recrule = 'FREQ=DAILY;INTERVAL=10;COUNT=10'
         count = 5
         seq = recurrence_sequence_ical(start, recrule=recrule, count=count)
         results = [res for res in seq]
@@ -107,11 +114,15 @@ def test_recrule_from(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 23)
-        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"
+        recrule = 'FREQ=DAILY;INTERVAL=1;COUNT=5'
         from_ = datetime(2011, 11, 25)
         until = datetime(2011, 11, 27)
-        seq = recurrence_sequence_ical(start, recrule=recrule,
-                                       from_=from_, until=until)
+        seq = recurrence_sequence_ical(
+            start,
+            recrule=recrule,
+            from_=from_,
+            until=until,
+        )
         results = [res for res in seq]
         self.assertEqual(len(results), 3)
 
@@ -119,11 +130,15 @@ def test_recrule_until(self):
         from plone.event.recurrence import recurrence_sequence_ical
         from datetime import datetime
         start = datetime(2011, 11, 24)
-        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"
+        recrule = 'FREQ=DAILY;INTERVAL=1;COUNT=5'
         from_ = datetime(2011, 11, 23)
         until = datetime(2011, 11, 27)
-        seq = recurrence_sequence_ical(start, recrule=recrule,
-                                       from_=from_, until=until)
+        seq = recurrence_sequence_ical(
+            start,
+            recrule=recrule,
+            from_=from_,
+            until=until,
+        )
         results = [res for res in seq]
         self.assertEqual(len(results), 4)
 
@@ -134,12 +149,16 @@ def test_recrule_from_until_with_duration(self):
         from datetime import datetime
         from datetime import timedelta
         start = datetime(2011, 11, 23)
-        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"
+        recrule = 'FREQ=DAILY;INTERVAL=1;COUNT=5'
         from_ = datetime(2011, 11, 26)
         until = datetime(2011, 11, 27)
-        seq = recurrence_sequence_ical(start, recrule=recrule,
-                                       from_=from_, until=until,
-                                       duration=timedelta(days=2))
+        seq = recurrence_sequence_ical(
+            start,
+            recrule=recrule,
+            from_=from_,
+            until=until,
+            duration=timedelta(days=2),
+        )
         results = [res for res in seq]
         self.assertEqual(len(results), 4)
 
@@ -148,6 +167,6 @@ def test_recrule_until_with_timezone(self):
         from datetime import datetime
 
         start = datetime(2011, 11, 24)
-        recrule = "RRULE:FREQ=DAILY;UNTIL=20111130T000000Z"
+        recrule = 'RRULE:FREQ=DAILY;UNTIL=20111130T000000Z'
         seq = list(recurrence_sequence_ical(start, recrule=recrule))
         self.assertEqual(len(seq), 7)
diff --git a/plone/event/tests/test_recurrence_sequence_timedelta.py b/plone/event/tests/test_recurrence_sequence_timedelta.py
index 71880b9..c9493f7 100644
--- a/plone/event/tests/test_recurrence_sequence_timedelta.py
+++ b/plone/event/tests/test_recurrence_sequence_timedelta.py
@@ -1,8 +1,8 @@
+# -*- coding: utf-8 -*-
 import unittest
 
 
 class TestRecurrenceSequenceTimedelta(unittest.TestCase):
-
     def test_delta_None(self):
         from plone.event.recurrence import recurrence_sequence_timedelta
         from datetime import datetime
@@ -58,7 +58,11 @@ def test_recur_more_than_count(self):
         delta = 1
         until = datetime(2011, 11, 24)
         count = 20
-        td = recurrence_sequence_timedelta(start, delta=delta,
-                                           until=until, count=count)
+        td = recurrence_sequence_timedelta(
+            start,
+            delta=delta,
+            until=until,
+            count=count,
+        )
         results = [res for res in td]
         self.assertEqual(len(results), 21)
diff --git a/plone/event/tests/test_utils.py b/plone/event/tests/test_utils.py
index fdf0472..f90fedd 100644
--- a/plone/event/tests/test_utils.py
+++ b/plone/event/tests/test_utils.py
@@ -1,9 +1,9 @@
+# -*- coding: utf-8 -*-
 import mock
 import unittest
 
 
 class TestUtils(unittest.TestCase):
-
     @mock.patch('plone.event.utils.pytz')
     @mock.patch('plone.event.utils.os')
     def test_default_timezone(self, os, pytz):
@@ -17,10 +17,7 @@ def test_utcoffset_normalize(self):
         from plone.event.utils import utcoffset_normalize
         date = mock.Mock()
         date.replace = mock.Mock(side_effect=KeyError)
-        self.assertEqual(
-            utcoffset_normalize(date),
-            date
-        )
+        self.assertEqual(utcoffset_normalize(date), date)
 
     @mock.patch('plone.event.utils.guesstz')
     @mock.patch('plone.event.utils.utctz')
diff --git a/plone/event/utils.py b/plone/event/utils.py
index be5ce92..d5c4ebc 100644
--- a/plone/event/utils.py
+++ b/plone/event/utils.py
@@ -1,17 +1,18 @@
 # -*- coding: utf-8 -*-
+from datetime import date
+from datetime import datetime
+from datetime import timedelta
 
 import logging
 import os
 import pytz
 import time
-from datetime import date
-from datetime import datetime
-from datetime import timedelta
+
 
 DSTADJUST = 'adjust'
 DSTKEEP = 'keep'
 DSTAUTO = 'auto'
-MAX32 = int(2 ** 31 - 1)
+MAX32 = int(2**31 - 1)
 
 logger = logging.getLogger('plone.event')
 
@@ -55,15 +56,21 @@ def validated_timezone(timezone, fallback=None):
     try:
         # following statement ensures, that timezone is a valid pytz/Olson zone
         return pytz.timezone(timezone).zone
-    except:
+    except Exception:
         if fallback:
-            logger.warn('The timezone %s is not a valid timezone from the '
-                        'Olson database or pytz. Falling back to %s.'
-                        % (timezone, fallback))
+            logger.warn(
+                'The timezone {0} is not a valid timezone from the '
+                'Olson database or pytz. Falling back to {1}.'.format(
+                    timezone,
+                    fallback,
+                )
+            )
             return fallback
         else:
-            raise ValueError('The timezone %s is not a valid timezone from '
-                             'the Olson database or pytz.' % timezone)
+            raise ValueError(
+                'The timezone {0} is not a valid timezone from '
+                'the Olson database or pytz.'.format(timezone)
+            )
 
 
 def default_timezone(fallback='UTC'):
@@ -123,12 +130,14 @@ def default_timezone(fallback='UTC'):
             timezone = zones[0]
         else:
             # Default fallback = UTC
-            logger.warn("Operating system's timezone cannot be found. "
-                        "Falling back to UTC.")
+            logger.warn(
+                'Operating system\'s timezone cannot be found. '
+                'Falling back to UTC.'
+            )
     return validated_timezone(timezone, fallback)
 
 
-### Display helpers
+# Display helpers
 def is_same_time(start, end, exact=False):
     """ Test if event starts and ends at same time.
 
@@ -207,7 +216,7 @@ def is_same_day(start, end):
     return start.date() == end.date()
 
 
-### Timezone helpers
+# Timezone helpers
 def utctz():
     """ Return the UTVC zone as a pytz.UTC instance.
 
@@ -266,12 +275,12 @@ def utcoffset_normalize(date, delta=None, dstmode=DSTAUTO):
                   used - otherwise DSTADJUST. This behavior is the default.
     """
     try:
-        assert(bool(date.tzinfo))
-    except:
+        assert (bool(date.tzinfo))
+    except Exception:
         raise TypeError('Cannot normalize timezone naive dates')
-    assert(dstmode in [DSTADJUST, DSTKEEP, DSTAUTO])
+    assert (dstmode in [DSTADJUST, DSTKEEP, DSTAUTO])
     if delta:
-        assert(isinstance(delta, timedelta))  # Easier in Java
+        assert (isinstance(delta, timedelta))  # Easier in Java
         delta = delta.seconds + delta.days * 24 * 3600  # total delta in secs
         if dstmode == DSTAUTO and delta < 24 * 60 * 60:
             dstmode = DSTKEEP
@@ -283,7 +292,7 @@ def utcoffset_normalize(date, delta=None, dstmode=DSTAUTO):
             return date.tzinfo.normalize(date)
         else:  # DSTADJUST
             return date.replace(tzinfo=date.tzinfo.normalize(date).tzinfo)
-    except:
+    except Exception:
         # TODO: python-datetime converts e.g RDATE:20100119T230000Z to
         # datetime.datetime(2010, 1, 19, 23, 0, tzinfo=tzutc())
         # should that be a real utc zoneinfo?
@@ -383,7 +392,7 @@ def date_to_datetime(value):
     elif is_datetime(value):
         return value
     else:
-        raise ValueError("Value must be a date or datetime object.")
+        raise ValueError('Value must be a date or datetime object.')
 
 
 def pydt(dt, missing_zone=None, exact=False):
@@ -451,7 +460,7 @@ def pydt(dt, missing_zone=None, exact=False):
         else:
             ret = utcoffset_normalize(dt, dstmode=DSTADJUST)
 
-    if "DateTime" in str(dt.__class__):
+    if 'DateTime' in str(dt.__class__):
         # Zope DateTime
         # TODO: do we need to support subclasses of DateTime too? the check
         #       above would fail.
@@ -478,14 +487,17 @@ def pydt(dt, missing_zone=None, exact=False):
         # tz is equal to <DstTzInfo 'Europe/Paris' PMT+0:09:00 STD>
         dt = datetime(year, month, day, hour, min, sec, micro, tzinfo=tz)
         # before:
-        # datetime.datetime(2011, 3, 14, 14, 19, tzinfo=<DstTzInfo 'Europe/Paris' PMT+0:09:00 STD>)
+        # datetime.datetime(2011, 3, 14, 14, 19,
+        # tzinfo=<DstTzInfo 'Europe/Paris' PMT+0:09:00 STD>)
         # dt = dt.tzinfo.normalize(dt)
-        # after: datetime.datetime(2011, 3, 14, 15, 10, tzinfo=<DstTzInfo 'Europe/Paris' CET+1:00:00 STD>
+        # after: datetime.datetime(2011, 3, 14, 15, 10,
+        # tzinfo=<DstTzInfo 'Europe/Paris' CET+1:00:00 STD>
         dt = utcoffset_normalize(dt, dstmode=DSTADJUST)
-        # after: datetime.datetime(2011, 3, 14, 19, tzinfo=<DstTzInfo 'Europe/Paris' CET+1:00:00 STD>
+        # after: datetime.datetime(2011, 3, 14, 19,
+        # tzinfo=<DstTzInfo 'Europe/Paris' CET+1:00:00 STD>
         ret = dt
 
-    if ret and exact == False:
+    if ret and exact is False:
         ret = ret.replace(microsecond=0)
 
     return ret
@@ -522,7 +534,7 @@ def guesstz(DT):
     return None
 
 
-### Date as integer representation helpers
+# Date as integer representation helpers
 def dt2int(dt):
     """ Calculates an integer from a datetime, resolution is one minute.
     The datetime is always converted to the UTC zone.
@@ -537,14 +549,15 @@ def dt2int(dt):
         return 0
     # TODO: if dt has not timezone information, guess and set it
     dt = utc(dt)
-    value = (((dt.year*12+dt.month)*31+dt.day)*24+dt.hour)*60+dt.minute
+    value = (((dt.year * 12 + dt.month) * 31 + dt.day) * 24 + dt.hour
+             ) * 60 + dt.minute
 
     # TODO: unit test me
     if value > MAX32:
         # value must be integer fitting in the 32bit range
         raise OverflowError(
-            """%s is not within the range of indexable dates,<<
-            exceeding 32bit range.""" % dt
+            """{0} is not within the range of indexable dates,<<
+            exceeding 32bit range.""".format(dt)
         )
     return value
 
@@ -582,7 +595,7 @@ def dt_to_zone(dt, tzstring):
     return dt.astimezone(pytz.timezone(tzstring))
 
 
-### RFC2445 export helpers
+# RFC2445 export helpers
 def rfc2445dt(dt, mode='utc', date=True, time=True):
     """ Convert a datetime or DateTime object into an RFC2445 compatible
     datetime string.
@@ -646,10 +659,12 @@ def rfc2445dt(dt, mode='utc', date=True, time=True):
     dt = pydt(dt)
     if mode == 'utc':
         dt = utc(dt)
-    date = "%s%s%s%s" % (date and dt.strftime("%Y%m%d") or '',
-                         date and time and 'T' or '',
-                         time and dt.strftime("%H%M%S") or '',
-                         mode=='utc' and 'Z' or '')
+    date = '{0}{1}{2}{3}'.format(
+        date and dt.strftime('%Y%m%d') or '',
+        date and time and 'T' or '',
+        time and dt.strftime('%H%M%S') or '',
+        mode == 'utc' and 'Z' or '',
+    )
     if mode == 'local':
         return date, dt.tzinfo.zone
     return date
diff --git a/setup.py b/setup.py
index def71d5..7fa0b80 100644
--- a/setup.py
+++ b/setup.py
@@ -1,14 +1,27 @@
+# -*- coding: utf-8 -*-
 from setuptools import find_packages
 from setuptools import setup
 
+
 version = '1.3.3.dev0'
 
+a = (
+    'bla',
+    'bli',
+    'bli',
+    'bli',
+    'bli',
+    'bli',
+    'bliaad asdf asd asd asda sd asd asd sd ',
+)
+
 setup(
     name='plone.event',
     version=version,
     description="Event and calendaring related tools not bound to Plone",
-    long_description=(open("README.rst").read() + "\n" +
-                      open(("CHANGES.rst")).read()),
+    long_description=(
+        open("README.rst").read() + "\n" + open(("CHANGES.rst")).read()
+    ),
     classifiers=[
         "Framework :: Plone",
         "Framework :: Plone :: 5.0",
@@ -33,11 +46,9 @@
         'zope.component',
         'zope.interface',
     ],
-    extras_require={
-        'test': [
-            'DateTime',
-            'mock',
-            'zope.configuration',
-        ],
-    },
+    extras_require={'test': [
+        'DateTime',
+        'mock',
+        'zope.configuration',
+    ], },
 )


