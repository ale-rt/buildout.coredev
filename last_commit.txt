Repository: plone.indexer


Branch: refs/heads/master
Date: 2016-02-15T13:13:53+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.indexer/commit/0a73762a5d163feb97af0b4b98deb70b55dfea16

Reformat according to the Plone styleguide while reading.

Files changed:
M CHANGES.rst
M plone/indexer/README.rst
M plone/indexer/decorator.py
M plone/indexer/delegate.py
M plone/indexer/tests.py
M plone/indexer/wrapper.py

diff --git a/CHANGES.rst b/CHANGES.rst
index ad6aac6..1f0e97e 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -15,6 +15,9 @@ Fixes:
   module from stdlib.
   [thet]
 
+- Reformat according to the Plone styleguide.
+  [thet]
+
 
 1.0.3 (2015-05-05)
 ------------------
diff --git a/plone/indexer/README.rst b/plone/indexer/README.rst
index 6e3db94..3b1daf1 100644
--- a/plone/indexer/README.rst
+++ b/plone/indexer/README.rst
@@ -1,19 +1,19 @@
 Writing indexers
 ================
 
-An indexer is a named adapter that adapts the type of an object and provides
-a value to be indexed when the catalog attempts to index the attribute with
-that name.
+An indexer is a named adapter that adapts the type of an object and provides a value to be indexed when the catalog attempts to index the attribute with that name.
 
-For example, let's say we have two types, page and news item:
+For example, let's say we have two types, page and news item::
 
-    >>> from zope.interface import implements, Interface
+    >>> from zope.interface import Interface
+    >>> from zope.interface import implementer
     >>> from zope import schema
 
     >>> class IPage(Interface):
     ...     text = schema.Text(title=u"Body text")
-    >>> class Page(object):
-    ...     implements(IPage)
+
+    >>> @implementer(IPage)
+    ... class Page(object):
     ...     def __init__(self, text):
     ...         self.text = text
 
@@ -22,20 +22,18 @@ For example, let's say we have two types, page and news item:
     ...     story = schema.Text(title=u"Body text")
     ...     audience = schema.TextLine(title=u"Audience")
 
-    >>> class NewsItem(object):
-    ...     implements(INewsItem)
+    >>> @implementer(INewsItem)
+    ... class NewsItem(object):
     ...     def __init__(self, summary, story, audience):
     ...         self.summary = summary
     ...         self.story = story
     ...         self.audience = audience
 
-Now, pretend that our catalog had an index 'description', which for a page
-should contain the first 10 characters from the body text, and for a news
-item should contain the contents of the 'summary' field. Furthermore, there
-is an index 'audience' that should contain the value of the corresponding
-field for news items, in all uppercase. It should do nothing for pages.
+Now, pretend that our catalog had an index 'description', which for a page should contain the first 10 characters from the body text, and for a news item should contain the contents of the 'summary' field.
+Furthermore, there is an index 'audience' that should contain the value of the corresponding field for news items, in all uppercase.
+It should do nothing for pages.
 
-We could write indexers for all of these like this
+We could write indexers for all of these like this::
 
     >>> from plone.indexer import indexer
 
@@ -51,69 +49,61 @@ We could write indexers for all of these like this
     ... def newsitem_audience(object):
     ...     return object.audience.upper()
 
-These need to be registered as named adapters, where the name corresponds to
-the index name. In ZCML, that may be::
+These need to be registered as named adapters, where the name corresponds to the index name.
+In ZCML, that may be::
 
     <adapter name="description" factory=".indexers.page_description" />
     <adapter name="description" factory=".indexers.newsitem_description" />
     <adapter name="audience" factory=".indexers.newsitem_audience" />
 
-We can omit the 'for' attribute because we passed this to the @indexer
-decorator, and we can omit the 'provides' attribute because the thing
-returned by the decorator is actually a class providing the required IIndexer
-interface.
+We can omit the 'for' attribute because we passed this to the @indexer decorator, and we can omit the 'provides' attribute because the thing returned by the decorator is actually a class providing the required IIndexer interface.
 
-For the purposes of the ensuing tests, we'll register these directly.
+For the purposes of the ensuing tests, we'll register these directly::
 
     >>> from zope.component import provideAdapter
     >>> provideAdapter(page_description, name='description')
     >>> provideAdapter(newsitem_description, name='description')
     >>> provideAdapter(newsitem_audience, name='audience')
 
+
 Testing your indexers (or calling them directly)
 ------------------------------------------------
 
-If you are writing tests for your indexers (as you should!), then you should
-be aware of the following:
+If you are writing tests for your indexers (as you should!), then you should be aware of the following:
 
-When the @indexer decorator returns, it turns your function into an instance
-of type DelegatingIndexerFactory. This is an adapter factory that can create
-a DelegatingIndexer, which in turn will call your function when asked to
-perform indexing operations.
+When the @indexer decorator returns, it turns your function into an instance of type DelegatingIndexerFactory.
+This is an adapter factory that can create a DelegatingIndexer, which in turn will call your function when asked to perform indexing operations.
 
 This means that you can't just call your function to test the indexer.
-Instead, you need to instantiate the adapter and then call the delegating
-indexer with the portal root as the first argument. For example:
+Instead, you need to instantiate the adapter and then call the delegating indexer with the portal root as the first argument.
+For example::
 
     >>> test_page = Page(text=u"My page with some text")
     >>> page_description(test_page)()
     u'My page wi'
 
-This will suffice in most cases. Note that there is actually a second
-parameter, catalog, which defaults to None. If you need to write an indexer
-that acts on catalog, you'll need to register a conventional adapter, as
-described in the next section.
+This will suffice in most cases.
+Note that there is actually a second parameter, catalog, which defaults to None.
+If you need to write an indexer that acts on catalog, you'll need to register a conventional adapter, as described in the next section.
+
 
 Other means of registering indexers
 -----------------------------------
 
-At the end of the day, an indexer is just a named multi-adapter from the
-indexable object (e.g. INewsItem or IPage above) and the catalog (usually
-portal_catalog in a CMF application) to IIndexer, where the name is the name
-of the indexed attribute in the catalog. Thus, you could register your
-indexers as more conventional adapters:
+At the end of the day, an indexer is just a named multi-adapter from the indexable object (e.g.
+INewsItem or IPage above) and the catalog (usually portal_catalog in a CMF application) to IIndexer, where the name is the name of the indexed attribute in the catalog.
+Thus, you could register your indexers as more conventional adapters::
 
     >>> from plone.indexer.interfaces import IIndexer
     >>> from Products.ZCatalog.interfaces import IZCatalog
+    >>> from zope.component import adapter
+    >>> from zope.interface import implementer
 
-    >>> from zope.interface import implements
-    >>> from zope.component import adapts
-    >>> class LengthIndexer(object):
+    >>> @implementer(IIndexer)
+    ... @adapter(IPage, IZCatalog)
+    ... class LengthIndexer(object):
     ...     """Index the length of the body text
     ...     """
-    ...     implements(IIndexer)
-    ...     adapts(IPage, IZCatalog)
-    ...
     ...     def __init__(self, context, catalog):
     ...         self.context = context
     ...         self.catalog = catalog
@@ -121,42 +111,41 @@ indexers as more conventional adapters:
     ...     def __call__(self):
     ...         return len(self.context.text)
 
-We normally just use IZCatalog for the catalog adaptation, to apply to any
-catalog. However, if you want different indexers for different types of
-catalogs, there is an example later in this test.
+We normally just use IZCatalog for the catalog adaptation, to apply to any catalog.
+However, if you want different indexers for different types of catalogs, there is an example later in this test.
 
 You'd register this with ZCML like so::
 
     <adapter factory=".indexers.LengthIndexer" name="length" />
 
-Or in a test:
+Or in a test::
 
     >>> provideAdapter(LengthIndexer, name="length")
 
-If you're only curious about how to write indexers, you can probably stop
-here. If you want to know more about how they work and how they are wired into
-a framework, read on.
+If you're only curious about how to write indexers, you can probably stop here.
+If you want to know more about how they work and how they are wired into a framework, read on.
+
 
 Hooking up indexers to the framework
 =====================================
 
-Here is a mock implementation of a ZCatalog.catalog_object() override, based
-on the one in Plone. We'll use this for testing. We won't bother with the full
-ZCatalog interface, only catalog_object(), and we'll stub out a few things.
-This really is for illustration purposes only, to show the intended usage
-pattern.
+Here is a mock implementation of a ZCatalog.catalog_object() override, based on the one in Plone.
+We'll use this for testing.
+We won't bother with the full ZCatalog interface, only catalog_object(), and we'll stub out a few things.
+This really is for illustration purposes only, to show the intended usage pattern.
+
+In CMF 2.2, there is an IIndexableObject marker interface defined in Products.CMFCore.interfaces.
+We have a compatibility alias in this package for use with CMF 2.1.
 
-In CMF 2.2, there is an IIndexableObject marker interface defined in
-Products.CMFCore.interfaces. We have a compatibility alias in this package
-for use with CMF 2.1.
+::
 
     >>> from OFS.interfaces import IItem
-    >>> from Products.ZCatalog.interfaces import IZCatalog
     >>> from plone.indexer.interfaces import IIndexableObject
+    >>> from Products.ZCatalog.interfaces import IZCatalog
     >>> from zope.component import queryMultiAdapter
 
-    >>> class FauxCatalog(object):
-    ...     implements(IZCatalog, IItem)
+    >>> @implementer(IZCatalog, IItem)
+    ... class FauxCatalog(object):
     ...
     ...     def catalog_object(self, object, uid, idxs=[]):
     ...         """Pretend to index 'object' under the key 'uid'. We'll
@@ -181,37 +170,32 @@ for use with CMF 2.1.
 The important things here are:
 
     - We attempt to obtain an IIndexableObject for the object to be indexed.
-      This is just a way to get hold of an implementation of this interface
-      (we'll register one in a moment) and allow some coarse-grained overrides.
+      This is just a way to get hold of an implementation of this interface (we'll register one in a moment) and allow some coarse-grained overrides.
 
-    - Cataloging involves looking up attributes on the indexable object
-      wrapper matching the names of indexes (in the real ZCatalog, this is
-      actually decoupled, but let's not get carried away). If they are
-      callable, they should be called. This is just mimicking what ZCatalog's
-      implementation does.
+    - Cataloging involves looking up attributes on the indexable object wrapper matching the names of indexes (in the real ZCatalog, this is actually decoupled, but let's not get carried away).
+      If they are callable, they should be called.
+      This is just mimicking what ZCatalog's implementation does.
 
-This package comes with an implementation of an IIndexableObject adapter that
-knows how to delegate to an IIndexer. Let's now register that as the default
-IIndexableObject wrapper adapter so that the code above will find it.
+This package comes with an implementation of an IIndexableObject adapter that knows how to delegate to an IIndexer.
+Let's now register that as the default IIndexableObject wrapper adapter so that the code above will find it::
 
-    >>> from plone.indexer.wrapper import IndexableObjectWrapper
     >>> from plone.indexer.interfaces import IIndexableObject
+    >>> from plone.indexer.wrapper import IndexableObjectWrapper
     >>> provideAdapter(factory=IndexableObjectWrapper, adapts=(Interface, IZCatalog,), provides=IIndexableObject)
 
 Seeing it in action
 ===================
 
-Now for the testing. First, we need a faux catalog:
+Now for the testing. First, we need a faux catalog::
 
     >>> catalog = FauxCatalog()
 
-Finally, let's create some objects to index.
+Finally, let's create some objects to index::
 
     >>> page = Page(u"The page body text here")
     >>> news = NewsItem(u"News summary", u"News body text", u"Audience")
 
-First of all, let's demonstrate that our indexers work and apply only to
-the types for which they are registered.
+First of all, let's demonstrate that our indexers work and apply only to the types for which they are registered::
 
     >>> catalog.catalog_object(page, 'p1', idxs=['description', 'audience', 'length'])
     description = The page b
@@ -221,38 +205,36 @@ the types for which they are registered.
     description = News summary
     audience = AUDIENCE
 
-Our custom indexable object wrapper is capable of looking up workflow
-variables if the portal_workflow tool is available. For testing purposes,
-we'll create a fake minimal workflow tool and stash it onto the fake catalog
-so that it can be found by getToolByName. In real life, it would of course be
-acquirable as normal.
+Our custom indexable object wrapper is capable of looking up workflow variables if the portal_workflow tool is available.
+For testing purposes, we'll create a fake minimal workflow tool and stash it onto the fake catalog so that it can be found by getToolByName.
+In real life, it would of course be acquirable as normal::
 
-    >>> class FauxWorkflowTool(object):
-    ...     implements(IItem)
+    >>> @implementer(IItem)
+    ... class FauxWorkflowTool(object):
     ...     def getCatalogVariablesFor(self, object):
     ...         return dict(review_state='published', audience='Somebody')
     >>> catalog.portal_workflow = FauxWorkflowTool()
 
-If we now index 'review_state', it will be obtained from the workflow
-variables. However, a custom indexer still overrides workflow variables.
+If we now index 'review_state', it will be obtained from the workflow variables.
+However, a custom indexer still overrides workflow variables::
 
     >>> catalog.catalog_object(news, 'n1', idxs=['description', 'audience', 'review_state'])
     description = News summary
     audience = AUDIENCE
     review_state = published
 
-Finally, if not adapter can be found, we fall back on getattr() on the object.
+Finally, if not adapter can be found, we fall back on getattr() on the object::
 
     >>> catalog.catalog_object(page, 'p3', idxs=['description', 'text'])
     description = The page b
     text = The page body text here
 
+
 Customising indexers based on the catalog type
 ==============================================
 
 It is possible to provide a custom indexer for a different type of catalog.
-To test that, let's create a secondary catalog and mark it with a marker
-interface.
+To test that, let's create a secondary catalog and mark it with a marker interface::
 
     >>> from zope.interface import Interface
     >>> class IAlternateCatalog(Interface):
@@ -261,34 +243,36 @@ interface.
     >>> catalog2 = FauxCatalog()
     >>> alsoProvides(catalog2, IAlternateCatalog)
 
-Let's say that we did not want the news item audience uppercased here. We
-could provide a custom indexer for just this catalog:
+Let's say that we did not want the news item audience uppercased here.
+We could provide a custom indexer for just this catalog::
 
     >>> @indexer(INewsItem, IAlternateCatalog)
     ... def alternate_newsitem_audience(object):
     ...     return object.audience.lower()
     >>> provideAdapter(alternate_newsitem_audience, name='audience')
 
-This does not affect the first catalog:
+This does not affect the first catalog::
 
     >>> catalog.catalog_object(news, 'n1', idxs=['description', 'audience', 'length'])
     description = News summary
     audience = AUDIENCE
 
-However, the second catalog gets the audience in lowercase.
+However, the second catalog gets the audience in lowercase::
 
     >>> catalog2.catalog_object(news, 'n1', idxs=['description', 'audience', 'length'])
     description = News summary
     audience = audience
 
+
 Interfaces provided by the wrapper
 ==================================
 
-The indexable object wrapper has one particular feature: instances of the
-wrapper will provide the same interfaces as instances of the wrapped object.
-For example:
+The indexable object wrapper has one particular feature: instances of the wrapper will provide the same interfaces as instances of the wrapped object.
+For example::
+
+    >>> from plone.indexer.interfaces import IIndexableObject
+    >>> from plone.indexer.interfaces import IIndexableObjectWrapper
 
-    >>> from plone.indexer.interfaces import IIndexableObjectWrapper, IIndexableObject
     >>> wrapper = IndexableObjectWrapper(page, catalog)
     >>> IIndexableObjectWrapper.providedBy(wrapper)
     True
@@ -307,11 +291,13 @@ For example:
     >>> INewsItem.providedBy(wrapper)
     True
 
+
 Unboxing
 ========
 
-It is possible to obtain the wrapped object from the wrapper:
+It is possible to obtain the wrapped object from the wrapper::
 
     >>> wrapper = IndexableObjectWrapper(page, catalog)
     >>> wrapper._getWrappedObject() is page
     True
+
diff --git a/plone/indexer/decorator.py b/plone/indexer/decorator.py
index bde1e56..54c4ce5 100644
--- a/plone/indexer/decorator.py
+++ b/plone/indexer/decorator.py
@@ -1,9 +1,9 @@
 """This module defines a decorator that
 """
 
-from zope.component import adapter
 from plone.indexer.delegate import DelegatingIndexerFactory
 from Products.ZCatalog.interfaces import IZCatalog
+from zope.component import adapter
 
 
 class indexer(adapter):
diff --git a/plone/indexer/delegate.py b/plone/indexer/delegate.py
index c70b9cd..4e64ab1 100644
--- a/plone/indexer/delegate.py
+++ b/plone/indexer/delegate.py
@@ -1,7 +1,8 @@
-from zope.interface import implements
-from zope.interface.declarations import Implements, implementedBy
-from plone.indexer.interfaces import IIndexer
 from functools import update_wrapper
+from plone.indexer.interfaces import IIndexer
+from zope.interface import implements
+from zope.interface.declarations import implementedBy
+from zope.interface.declarations import Implements
 
 
 class DelegatingIndexer(object):
diff --git a/plone/indexer/tests.py b/plone/indexer/tests.py
index dfde0f4..4dd4611 100644
--- a/plone/indexer/tests.py
+++ b/plone/indexer/tests.py
@@ -1,8 +1,8 @@
-import unittest
-import doctest
-
 from zope.component import testing
 
+import doctest
+import unittest
+
 
 class TestWrapperUpdate(unittest.TestCase):
 
@@ -25,7 +25,7 @@ def test_suite():
             'README.rst', package='plone.indexer',
             setUp=testing.setUp, tearDown=testing.tearDown),
         unittest.makeSuite(TestWrapperUpdate),
-        ])
+    ])
 
 if __name__ == '__main__':
     unittest.main(defaultTest='test_suite')
diff --git a/plone/indexer/wrapper.py b/plone/indexer/wrapper.py
index 54c3832..25c2b7e 100644
--- a/plone/indexer/wrapper.py
+++ b/plone/indexer/wrapper.py
@@ -1,20 +1,17 @@
+from plone.indexer.interfaces import IIndexableObject
+from plone.indexer.interfaces import IIndexableObjectWrapper
+from plone.indexer.interfaces import IIndexer
+from Products.CMFCore.utils import getToolByName
+from Products.ZCatalog.interfaces import IZCatalog
+from zope.component import adapts
+from zope.component import queryMultiAdapter
 from zope.interface import implements
-from zope.interface import providedBy
 from zope.interface import Interface
+from zope.interface import providedBy
 from zope.interface.declarations import getObjectSpecification
 from zope.interface.declarations import ObjectSpecification
 from zope.interface.declarations import ObjectSpecificationDescriptor
 
-from zope.component import adapts
-from zope.component import queryMultiAdapter
-
-from plone.indexer.interfaces import IIndexableObjectWrapper
-from plone.indexer.interfaces import IIndexableObject
-from plone.indexer.interfaces import IIndexer
-
-from Products.ZCatalog.interfaces import IZCatalog
-from Products.CMFCore.utils import getToolByName
-
 
 class WrapperSpecification(ObjectSpecificationDescriptor):
     """A __providedBy__ decorator that returns the interfaces provided by
@@ -60,7 +57,9 @@ def __str__(self):
 
     def __getattr__(self, name):
         # First, try to look up an indexer adapter
-        indexer = queryMultiAdapter((self.__object, self.__catalog), IIndexer, name=name)
+        indexer = queryMultiAdapter(
+            (self.__object, self.__catalog), IIndexer, name=name
+        )
         if indexer is not None:
             return indexer()
 


Repository: plone.indexer


Branch: refs/heads/master
Date: 2016-02-15T13:19:36+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.indexer/commit/60ed385865ac659bd5ab3f48b89f828db7d13758

use adatper/implementer instead of adapts/implements

Files changed:
M plone/indexer/delegate.py
M plone/indexer/wrapper.py

diff --git a/plone/indexer/delegate.py b/plone/indexer/delegate.py
index 4e64ab1..00f0008 100644
--- a/plone/indexer/delegate.py
+++ b/plone/indexer/delegate.py
@@ -1,14 +1,14 @@
 from functools import update_wrapper
 from plone.indexer.interfaces import IIndexer
-from zope.interface import implements
+from zope.interface import implementer
 from zope.interface.declarations import implementedBy
 from zope.interface.declarations import Implements
 
 
+@implementer(IIndexer)
 class DelegatingIndexer(object):
     """An indexer that delegates to a given callable
     """
-    implements(IIndexer)
 
     def __init__(self, context, catalog, callable):
         self.context = context
diff --git a/plone/indexer/wrapper.py b/plone/indexer/wrapper.py
index 25c2b7e..8f686be 100644
--- a/plone/indexer/wrapper.py
+++ b/plone/indexer/wrapper.py
@@ -3,9 +3,9 @@
 from plone.indexer.interfaces import IIndexer
 from Products.CMFCore.utils import getToolByName
 from Products.ZCatalog.interfaces import IZCatalog
-from zope.component import adapts
+from zope.component import adapter
 from zope.component import queryMultiAdapter
-from zope.interface import implements
+from zope.interface import implementer
 from zope.interface import Interface
 from zope.interface import providedBy
 from zope.interface.declarations import getObjectSpecification
@@ -27,14 +27,12 @@ def __get__(self, inst, cls=None):
             return ObjectSpecification(provided, cls)
 
 
+@implementer(IIndexableObject, IIndexableObjectWrapper)
+@adapter(Interface, IZCatalog)
 class IndexableObjectWrapper(object):
     """A simple wrapper for indexable objects that will delegate to IIndexer
     adapters as appropriate.
     """
-
-    implements(IIndexableObject, IIndexableObjectWrapper)
-    adapts(Interface, IZCatalog)
-
     __providedBy__ = WrapperSpecification()
 
     def __init__(self, object, catalog):


Repository: plone.indexer


Branch: refs/heads/master
Date: 2016-02-23T13:20:49+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.indexer/commit/8f9b6583d5f25367cc0006542b0ad8f211bf160f

fix jenkins qa errors

Files changed:
M plone/__init__.py
M plone/indexer/__init__.py
M plone/indexer/configure.zcml
M plone/indexer/decorator.py
M plone/indexer/delegate.py
M plone/indexer/interfaces.py
M plone/indexer/tests.py
M plone/indexer/wrapper.py
M setup.py

diff --git a/plone/__init__.py b/plone/__init__.py
index f48ad10..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,6 +1,2 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/indexer/__init__.py b/plone/indexer/__init__.py
index ac9cc58..5fc65fb 100644
--- a/plone/indexer/__init__.py
+++ b/plone/indexer/__init__.py
@@ -1 +1,2 @@
-from plone.indexer.decorator import indexer
\ No newline at end of file
+# -*- coding: utf-8 -*-
+from plone.indexer.decorator import indexer  # noqa
diff --git a/plone/indexer/configure.zcml b/plone/indexer/configure.zcml
index bd871f0..f9de1e4 100644
--- a/plone/indexer/configure.zcml
+++ b/plone/indexer/configure.zcml
@@ -1,7 +1,3 @@
-<configure
-    xmlns="http://namespaces.zope.org/zope"
-    xmlns:five="http://namespaces.zope.org/five"
-    i18n_domain="plone.indexer">
-
-
+<configure xmlns="http://namespaces.zope.org/zope">
+  <!-- empty to not break packages, who use zcml include on this package -->
 </configure>
diff --git a/plone/indexer/decorator.py b/plone/indexer/decorator.py
index 54c4ce5..2536ee5 100644
--- a/plone/indexer/decorator.py
+++ b/plone/indexer/decorator.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 """This module defines a decorator that
 """
 
@@ -12,7 +13,7 @@ class indexer(adapter):
         >>> from plone.indexer.decorator import indexer
         >>> @indexer(IMyType)
         ... def some_attribute(object):
-        ...     return "some indexable value"
+        ...     return 'some indexable value'
 
     Note that the @indexer decorator is a superset of the @adapter decorator
     from zope.component.
@@ -22,7 +23,7 @@ class indexer(adapter):
         >>> from plone.indexer.decorator import indexer
         >>> @indexer(IMyType, IMyCatalog)
         ... def some_attribute(object):
-        ...     return "some indexable value"
+        ...     return 'some indexable value'
 
     The default is to register the indexer for all IZCatalog catalogs.
 
@@ -38,7 +39,10 @@ def __init__(self, *interfaces):
         if len(interfaces) == 1:
             interfaces += (IZCatalog, )
         elif len(interfaces) > 2:
-            raise ValueError(u"The @indexer decorator takes at most two interfaces as arguments")
+            raise ValueError(
+                u'The @indexer decorator takes at most two interfaces as '
+                u'arguments.'
+            )
         adapter.__init__(self, *interfaces)
 
     def __call__(self, callable):
diff --git a/plone/indexer/delegate.py b/plone/indexer/delegate.py
index 00f0008..1bd6d6e 100644
--- a/plone/indexer/delegate.py
+++ b/plone/indexer/delegate.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from functools import update_wrapper
 from plone.indexer.interfaces import IIndexer
 from zope.interface import implementer
diff --git a/plone/indexer/interfaces.py b/plone/indexer/interfaces.py
index 2ae29d4..08b0ce8 100644
--- a/plone/indexer/interfaces.py
+++ b/plone/indexer/interfaces.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from zope.interface import Interface
 
 # NOTE: CMF 2.2 provides standard interfaces for indexing. We provide
diff --git a/plone/indexer/tests.py b/plone/indexer/tests.py
index 4dd4611..f8aadfa 100644
--- a/plone/indexer/tests.py
+++ b/plone/indexer/tests.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from zope.component import testing
 
 import doctest
diff --git a/plone/indexer/wrapper.py b/plone/indexer/wrapper.py
index 8f686be..6188ff9 100644
--- a/plone/indexer/wrapper.py
+++ b/plone/indexer/wrapper.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.indexer.interfaces import IIndexableObject
 from plone.indexer.interfaces import IIndexableObjectWrapper
 from plone.indexer.interfaces import IIndexer
diff --git a/setup.py b/setup.py
index 196ea44..bed5705 100644
--- a/setup.py
+++ b/setup.py
@@ -1,27 +1,24 @@
-import os
-from setuptools import setup, find_packages
-
+# -*- coding: utf-8 -*-
+from setuptools import find_packages
+from setuptools import setup
 
-def read(*rnames):
-    return open(os.path.join(os.path.dirname(__file__), *rnames)).read()
+import os
 
 
 version = '1.0.4.dev0'
+description = 'Hooks to facilitate managing custom index values in Zope 2/CMF applications'  # noqa
+long_description = ('\n\n'.join([
+    open('README.rst').read(),
+    open('CHANGES.rst').read(),
+    open(os.path.join("plone", "indexer", "README.rst")).read(),
+
+]))
 
-long_description = (
-    read('README.rst')
-    + '\n' +
-    read('plone', 'indexer', 'README.rst')
-    + '\n' +
-    read('CHANGES.rst')
-    + '\n'
-    )
 
 setup(
     name='plone.indexer',
     version=version,
-    description="Hooks to facilitate managing custom index values in "
-                "Zope 2/CMF applications",
+    description=description,
     long_description=long_description,
     classifiers=[
         "Environment :: Web Environment",
@@ -51,4 +48,4 @@ def read(*rnames):
         'Products.CMFCore',
         'Products.ZCatalog',
     ],
-    )
+)


Repository: plone.indexer


Branch: refs/heads/master
Date: 2016-02-23T15:43:09+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.indexer/commit/688cf9d0ab16ef69d072703bc3ed1276dd152d9f

Merge pull request #4 from plone/thet-reformat

Reformat according to the Plone styleguide while reading.

Files changed:
M CHANGES.rst
M plone/__init__.py
M plone/indexer/README.rst
M plone/indexer/__init__.py
M plone/indexer/configure.zcml
M plone/indexer/decorator.py
M plone/indexer/delegate.py
M plone/indexer/interfaces.py
M plone/indexer/tests.py
M plone/indexer/wrapper.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index ad6aac6..1f0e97e 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -15,6 +15,9 @@ Fixes:
   module from stdlib.
   [thet]
 
+- Reformat according to the Plone styleguide.
+  [thet]
+
 
 1.0.3 (2015-05-05)
 ------------------
diff --git a/plone/__init__.py b/plone/__init__.py
index f48ad10..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,6 +1,2 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/indexer/README.rst b/plone/indexer/README.rst
index 6e3db94..3b1daf1 100644
--- a/plone/indexer/README.rst
+++ b/plone/indexer/README.rst
@@ -1,19 +1,19 @@
 Writing indexers
 ================
 
-An indexer is a named adapter that adapts the type of an object and provides
-a value to be indexed when the catalog attempts to index the attribute with
-that name.
+An indexer is a named adapter that adapts the type of an object and provides a value to be indexed when the catalog attempts to index the attribute with that name.
 
-For example, let's say we have two types, page and news item:
+For example, let's say we have two types, page and news item::
 
-    >>> from zope.interface import implements, Interface
+    >>> from zope.interface import Interface
+    >>> from zope.interface import implementer
     >>> from zope import schema
 
     >>> class IPage(Interface):
     ...     text = schema.Text(title=u"Body text")
-    >>> class Page(object):
-    ...     implements(IPage)
+
+    >>> @implementer(IPage)
+    ... class Page(object):
     ...     def __init__(self, text):
     ...         self.text = text
 
@@ -22,20 +22,18 @@ For example, let's say we have two types, page and news item:
     ...     story = schema.Text(title=u"Body text")
     ...     audience = schema.TextLine(title=u"Audience")
 
-    >>> class NewsItem(object):
-    ...     implements(INewsItem)
+    >>> @implementer(INewsItem)
+    ... class NewsItem(object):
     ...     def __init__(self, summary, story, audience):
     ...         self.summary = summary
     ...         self.story = story
     ...         self.audience = audience
 
-Now, pretend that our catalog had an index 'description', which for a page
-should contain the first 10 characters from the body text, and for a news
-item should contain the contents of the 'summary' field. Furthermore, there
-is an index 'audience' that should contain the value of the corresponding
-field for news items, in all uppercase. It should do nothing for pages.
+Now, pretend that our catalog had an index 'description', which for a page should contain the first 10 characters from the body text, and for a news item should contain the contents of the 'summary' field.
+Furthermore, there is an index 'audience' that should contain the value of the corresponding field for news items, in all uppercase.
+It should do nothing for pages.
 
-We could write indexers for all of these like this
+We could write indexers for all of these like this::
 
     >>> from plone.indexer import indexer
 
@@ -51,69 +49,61 @@ We could write indexers for all of these like this
     ... def newsitem_audience(object):
     ...     return object.audience.upper()
 
-These need to be registered as named adapters, where the name corresponds to
-the index name. In ZCML, that may be::
+These need to be registered as named adapters, where the name corresponds to the index name.
+In ZCML, that may be::
 
     <adapter name="description" factory=".indexers.page_description" />
     <adapter name="description" factory=".indexers.newsitem_description" />
     <adapter name="audience" factory=".indexers.newsitem_audience" />
 
-We can omit the 'for' attribute because we passed this to the @indexer
-decorator, and we can omit the 'provides' attribute because the thing
-returned by the decorator is actually a class providing the required IIndexer
-interface.
+We can omit the 'for' attribute because we passed this to the @indexer decorator, and we can omit the 'provides' attribute because the thing returned by the decorator is actually a class providing the required IIndexer interface.
 
-For the purposes of the ensuing tests, we'll register these directly.
+For the purposes of the ensuing tests, we'll register these directly::
 
     >>> from zope.component import provideAdapter
     >>> provideAdapter(page_description, name='description')
     >>> provideAdapter(newsitem_description, name='description')
     >>> provideAdapter(newsitem_audience, name='audience')
 
+
 Testing your indexers (or calling them directly)
 ------------------------------------------------
 
-If you are writing tests for your indexers (as you should!), then you should
-be aware of the following:
+If you are writing tests for your indexers (as you should!), then you should be aware of the following:
 
-When the @indexer decorator returns, it turns your function into an instance
-of type DelegatingIndexerFactory. This is an adapter factory that can create
-a DelegatingIndexer, which in turn will call your function when asked to
-perform indexing operations.
+When the @indexer decorator returns, it turns your function into an instance of type DelegatingIndexerFactory.
+This is an adapter factory that can create a DelegatingIndexer, which in turn will call your function when asked to perform indexing operations.
 
 This means that you can't just call your function to test the indexer.
-Instead, you need to instantiate the adapter and then call the delegating
-indexer with the portal root as the first argument. For example:
+Instead, you need to instantiate the adapter and then call the delegating indexer with the portal root as the first argument.
+For example::
 
     >>> test_page = Page(text=u"My page with some text")
     >>> page_description(test_page)()
     u'My page wi'
 
-This will suffice in most cases. Note that there is actually a second
-parameter, catalog, which defaults to None. If you need to write an indexer
-that acts on catalog, you'll need to register a conventional adapter, as
-described in the next section.
+This will suffice in most cases.
+Note that there is actually a second parameter, catalog, which defaults to None.
+If you need to write an indexer that acts on catalog, you'll need to register a conventional adapter, as described in the next section.
+
 
 Other means of registering indexers
 -----------------------------------
 
-At the end of the day, an indexer is just a named multi-adapter from the
-indexable object (e.g. INewsItem or IPage above) and the catalog (usually
-portal_catalog in a CMF application) to IIndexer, where the name is the name
-of the indexed attribute in the catalog. Thus, you could register your
-indexers as more conventional adapters:
+At the end of the day, an indexer is just a named multi-adapter from the indexable object (e.g.
+INewsItem or IPage above) and the catalog (usually portal_catalog in a CMF application) to IIndexer, where the name is the name of the indexed attribute in the catalog.
+Thus, you could register your indexers as more conventional adapters::
 
     >>> from plone.indexer.interfaces import IIndexer
     >>> from Products.ZCatalog.interfaces import IZCatalog
+    >>> from zope.component import adapter
+    >>> from zope.interface import implementer
 
-    >>> from zope.interface import implements
-    >>> from zope.component import adapts
-    >>> class LengthIndexer(object):
+    >>> @implementer(IIndexer)
+    ... @adapter(IPage, IZCatalog)
+    ... class LengthIndexer(object):
     ...     """Index the length of the body text
     ...     """
-    ...     implements(IIndexer)
-    ...     adapts(IPage, IZCatalog)
-    ...
     ...     def __init__(self, context, catalog):
     ...         self.context = context
     ...         self.catalog = catalog
@@ -121,42 +111,41 @@ indexers as more conventional adapters:
     ...     def __call__(self):
     ...         return len(self.context.text)
 
-We normally just use IZCatalog for the catalog adaptation, to apply to any
-catalog. However, if you want different indexers for different types of
-catalogs, there is an example later in this test.
+We normally just use IZCatalog for the catalog adaptation, to apply to any catalog.
+However, if you want different indexers for different types of catalogs, there is an example later in this test.
 
 You'd register this with ZCML like so::
 
     <adapter factory=".indexers.LengthIndexer" name="length" />
 
-Or in a test:
+Or in a test::
 
     >>> provideAdapter(LengthIndexer, name="length")
 
-If you're only curious about how to write indexers, you can probably stop
-here. If you want to know more about how they work and how they are wired into
-a framework, read on.
+If you're only curious about how to write indexers, you can probably stop here.
+If you want to know more about how they work and how they are wired into a framework, read on.
+
 
 Hooking up indexers to the framework
 =====================================
 
-Here is a mock implementation of a ZCatalog.catalog_object() override, based
-on the one in Plone. We'll use this for testing. We won't bother with the full
-ZCatalog interface, only catalog_object(), and we'll stub out a few things.
-This really is for illustration purposes only, to show the intended usage
-pattern.
+Here is a mock implementation of a ZCatalog.catalog_object() override, based on the one in Plone.
+We'll use this for testing.
+We won't bother with the full ZCatalog interface, only catalog_object(), and we'll stub out a few things.
+This really is for illustration purposes only, to show the intended usage pattern.
+
+In CMF 2.2, there is an IIndexableObject marker interface defined in Products.CMFCore.interfaces.
+We have a compatibility alias in this package for use with CMF 2.1.
 
-In CMF 2.2, there is an IIndexableObject marker interface defined in
-Products.CMFCore.interfaces. We have a compatibility alias in this package
-for use with CMF 2.1.
+::
 
     >>> from OFS.interfaces import IItem
-    >>> from Products.ZCatalog.interfaces import IZCatalog
     >>> from plone.indexer.interfaces import IIndexableObject
+    >>> from Products.ZCatalog.interfaces import IZCatalog
     >>> from zope.component import queryMultiAdapter
 
-    >>> class FauxCatalog(object):
-    ...     implements(IZCatalog, IItem)
+    >>> @implementer(IZCatalog, IItem)
+    ... class FauxCatalog(object):
     ...
     ...     def catalog_object(self, object, uid, idxs=[]):
     ...         """Pretend to index 'object' under the key 'uid'. We'll
@@ -181,37 +170,32 @@ for use with CMF 2.1.
 The important things here are:
 
     - We attempt to obtain an IIndexableObject for the object to be indexed.
-      This is just a way to get hold of an implementation of this interface
-      (we'll register one in a moment) and allow some coarse-grained overrides.
+      This is just a way to get hold of an implementation of this interface (we'll register one in a moment) and allow some coarse-grained overrides.
 
-    - Cataloging involves looking up attributes on the indexable object
-      wrapper matching the names of indexes (in the real ZCatalog, this is
-      actually decoupled, but let's not get carried away). If they are
-      callable, they should be called. This is just mimicking what ZCatalog's
-      implementation does.
+    - Cataloging involves looking up attributes on the indexable object wrapper matching the names of indexes (in the real ZCatalog, this is actually decoupled, but let's not get carried away).
+      If they are callable, they should be called.
+      This is just mimicking what ZCatalog's implementation does.
 
-This package comes with an implementation of an IIndexableObject adapter that
-knows how to delegate to an IIndexer. Let's now register that as the default
-IIndexableObject wrapper adapter so that the code above will find it.
+This package comes with an implementation of an IIndexableObject adapter that knows how to delegate to an IIndexer.
+Let's now register that as the default IIndexableObject wrapper adapter so that the code above will find it::
 
-    >>> from plone.indexer.wrapper import IndexableObjectWrapper
     >>> from plone.indexer.interfaces import IIndexableObject
+    >>> from plone.indexer.wrapper import IndexableObjectWrapper
     >>> provideAdapter(factory=IndexableObjectWrapper, adapts=(Interface, IZCatalog,), provides=IIndexableObject)
 
 Seeing it in action
 ===================
 
-Now for the testing. First, we need a faux catalog:
+Now for the testing. First, we need a faux catalog::
 
     >>> catalog = FauxCatalog()
 
-Finally, let's create some objects to index.
+Finally, let's create some objects to index::
 
     >>> page = Page(u"The page body text here")
     >>> news = NewsItem(u"News summary", u"News body text", u"Audience")
 
-First of all, let's demonstrate that our indexers work and apply only to
-the types for which they are registered.
+First of all, let's demonstrate that our indexers work and apply only to the types for which they are registered::
 
     >>> catalog.catalog_object(page, 'p1', idxs=['description', 'audience', 'length'])
     description = The page b
@@ -221,38 +205,36 @@ the types for which they are registered.
     description = News summary
     audience = AUDIENCE
 
-Our custom indexable object wrapper is capable of looking up workflow
-variables if the portal_workflow tool is available. For testing purposes,
-we'll create a fake minimal workflow tool and stash it onto the fake catalog
-so that it can be found by getToolByName. In real life, it would of course be
-acquirable as normal.
+Our custom indexable object wrapper is capable of looking up workflow variables if the portal_workflow tool is available.
+For testing purposes, we'll create a fake minimal workflow tool and stash it onto the fake catalog so that it can be found by getToolByName.
+In real life, it would of course be acquirable as normal::
 
-    >>> class FauxWorkflowTool(object):
-    ...     implements(IItem)
+    >>> @implementer(IItem)
+    ... class FauxWorkflowTool(object):
     ...     def getCatalogVariablesFor(self, object):
     ...         return dict(review_state='published', audience='Somebody')
     >>> catalog.portal_workflow = FauxWorkflowTool()
 
-If we now index 'review_state', it will be obtained from the workflow
-variables. However, a custom indexer still overrides workflow variables.
+If we now index 'review_state', it will be obtained from the workflow variables.
+However, a custom indexer still overrides workflow variables::
 
     >>> catalog.catalog_object(news, 'n1', idxs=['description', 'audience', 'review_state'])
     description = News summary
     audience = AUDIENCE
     review_state = published
 
-Finally, if not adapter can be found, we fall back on getattr() on the object.
+Finally, if not adapter can be found, we fall back on getattr() on the object::
 
     >>> catalog.catalog_object(page, 'p3', idxs=['description', 'text'])
     description = The page b
     text = The page body text here
 
+
 Customising indexers based on the catalog type
 ==============================================
 
 It is possible to provide a custom indexer for a different type of catalog.
-To test that, let's create a secondary catalog and mark it with a marker
-interface.
+To test that, let's create a secondary catalog and mark it with a marker interface::
 
     >>> from zope.interface import Interface
     >>> class IAlternateCatalog(Interface):
@@ -261,34 +243,36 @@ interface.
     >>> catalog2 = FauxCatalog()
     >>> alsoProvides(catalog2, IAlternateCatalog)
 
-Let's say that we did not want the news item audience uppercased here. We
-could provide a custom indexer for just this catalog:
+Let's say that we did not want the news item audience uppercased here.
+We could provide a custom indexer for just this catalog::
 
     >>> @indexer(INewsItem, IAlternateCatalog)
     ... def alternate_newsitem_audience(object):
     ...     return object.audience.lower()
     >>> provideAdapter(alternate_newsitem_audience, name='audience')
 
-This does not affect the first catalog:
+This does not affect the first catalog::
 
     >>> catalog.catalog_object(news, 'n1', idxs=['description', 'audience', 'length'])
     description = News summary
     audience = AUDIENCE
 
-However, the second catalog gets the audience in lowercase.
+However, the second catalog gets the audience in lowercase::
 
     >>> catalog2.catalog_object(news, 'n1', idxs=['description', 'audience', 'length'])
     description = News summary
     audience = audience
 
+
 Interfaces provided by the wrapper
 ==================================
 
-The indexable object wrapper has one particular feature: instances of the
-wrapper will provide the same interfaces as instances of the wrapped object.
-For example:
+The indexable object wrapper has one particular feature: instances of the wrapper will provide the same interfaces as instances of the wrapped object.
+For example::
+
+    >>> from plone.indexer.interfaces import IIndexableObject
+    >>> from plone.indexer.interfaces import IIndexableObjectWrapper
 
-    >>> from plone.indexer.interfaces import IIndexableObjectWrapper, IIndexableObject
     >>> wrapper = IndexableObjectWrapper(page, catalog)
     >>> IIndexableObjectWrapper.providedBy(wrapper)
     True
@@ -307,11 +291,13 @@ For example:
     >>> INewsItem.providedBy(wrapper)
     True
 
+
 Unboxing
 ========
 
-It is possible to obtain the wrapped object from the wrapper:
+It is possible to obtain the wrapped object from the wrapper::
 
     >>> wrapper = IndexableObjectWrapper(page, catalog)
     >>> wrapper._getWrappedObject() is page
     True
+
diff --git a/plone/indexer/__init__.py b/plone/indexer/__init__.py
index ac9cc58..5fc65fb 100644
--- a/plone/indexer/__init__.py
+++ b/plone/indexer/__init__.py
@@ -1 +1,2 @@
-from plone.indexer.decorator import indexer
\ No newline at end of file
+# -*- coding: utf-8 -*-
+from plone.indexer.decorator import indexer  # noqa
diff --git a/plone/indexer/configure.zcml b/plone/indexer/configure.zcml
index bd871f0..f9de1e4 100644
--- a/plone/indexer/configure.zcml
+++ b/plone/indexer/configure.zcml
@@ -1,7 +1,3 @@
-<configure
-    xmlns="http://namespaces.zope.org/zope"
-    xmlns:five="http://namespaces.zope.org/five"
-    i18n_domain="plone.indexer">
-
-
+<configure xmlns="http://namespaces.zope.org/zope">
+  <!-- empty to not break packages, who use zcml include on this package -->
 </configure>
diff --git a/plone/indexer/decorator.py b/plone/indexer/decorator.py
index bde1e56..2536ee5 100644
--- a/plone/indexer/decorator.py
+++ b/plone/indexer/decorator.py
@@ -1,9 +1,10 @@
+# -*- coding: utf-8 -*-
 """This module defines a decorator that
 """
 
-from zope.component import adapter
 from plone.indexer.delegate import DelegatingIndexerFactory
 from Products.ZCatalog.interfaces import IZCatalog
+from zope.component import adapter
 
 
 class indexer(adapter):
@@ -12,7 +13,7 @@ class indexer(adapter):
         >>> from plone.indexer.decorator import indexer
         >>> @indexer(IMyType)
         ... def some_attribute(object):
-        ...     return "some indexable value"
+        ...     return 'some indexable value'
 
     Note that the @indexer decorator is a superset of the @adapter decorator
     from zope.component.
@@ -22,7 +23,7 @@ class indexer(adapter):
         >>> from plone.indexer.decorator import indexer
         >>> @indexer(IMyType, IMyCatalog)
         ... def some_attribute(object):
-        ...     return "some indexable value"
+        ...     return 'some indexable value'
 
     The default is to register the indexer for all IZCatalog catalogs.
 
@@ -38,7 +39,10 @@ def __init__(self, *interfaces):
         if len(interfaces) == 1:
             interfaces += (IZCatalog, )
         elif len(interfaces) > 2:
-            raise ValueError(u"The @indexer decorator takes at most two interfaces as arguments")
+            raise ValueError(
+                u'The @indexer decorator takes at most two interfaces as '
+                u'arguments.'
+            )
         adapter.__init__(self, *interfaces)
 
     def __call__(self, callable):
diff --git a/plone/indexer/delegate.py b/plone/indexer/delegate.py
index c70b9cd..1bd6d6e 100644
--- a/plone/indexer/delegate.py
+++ b/plone/indexer/delegate.py
@@ -1,13 +1,15 @@
-from zope.interface import implements
-from zope.interface.declarations import Implements, implementedBy
-from plone.indexer.interfaces import IIndexer
+# -*- coding: utf-8 -*-
 from functools import update_wrapper
+from plone.indexer.interfaces import IIndexer
+from zope.interface import implementer
+from zope.interface.declarations import implementedBy
+from zope.interface.declarations import Implements
 
 
+@implementer(IIndexer)
 class DelegatingIndexer(object):
     """An indexer that delegates to a given callable
     """
-    implements(IIndexer)
 
     def __init__(self, context, catalog, callable):
         self.context = context
diff --git a/plone/indexer/interfaces.py b/plone/indexer/interfaces.py
index 2ae29d4..08b0ce8 100644
--- a/plone/indexer/interfaces.py
+++ b/plone/indexer/interfaces.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from zope.interface import Interface
 
 # NOTE: CMF 2.2 provides standard interfaces for indexing. We provide
diff --git a/plone/indexer/tests.py b/plone/indexer/tests.py
index dfde0f4..f8aadfa 100644
--- a/plone/indexer/tests.py
+++ b/plone/indexer/tests.py
@@ -1,8 +1,9 @@
-import unittest
-import doctest
-
+# -*- coding: utf-8 -*-
 from zope.component import testing
 
+import doctest
+import unittest
+
 
 class TestWrapperUpdate(unittest.TestCase):
 
@@ -25,7 +26,7 @@ def test_suite():
             'README.rst', package='plone.indexer',
             setUp=testing.setUp, tearDown=testing.tearDown),
         unittest.makeSuite(TestWrapperUpdate),
-        ])
+    ])
 
 if __name__ == '__main__':
     unittest.main(defaultTest='test_suite')
diff --git a/plone/indexer/wrapper.py b/plone/indexer/wrapper.py
index 54c3832..6188ff9 100644
--- a/plone/indexer/wrapper.py
+++ b/plone/indexer/wrapper.py
@@ -1,20 +1,18 @@
-from zope.interface import implements
-from zope.interface import providedBy
+# -*- coding: utf-8 -*-
+from plone.indexer.interfaces import IIndexableObject
+from plone.indexer.interfaces import IIndexableObjectWrapper
+from plone.indexer.interfaces import IIndexer
+from Products.CMFCore.utils import getToolByName
+from Products.ZCatalog.interfaces import IZCatalog
+from zope.component import adapter
+from zope.component import queryMultiAdapter
+from zope.interface import implementer
 from zope.interface import Interface
+from zope.interface import providedBy
 from zope.interface.declarations import getObjectSpecification
 from zope.interface.declarations import ObjectSpecification
 from zope.interface.declarations import ObjectSpecificationDescriptor
 
-from zope.component import adapts
-from zope.component import queryMultiAdapter
-
-from plone.indexer.interfaces import IIndexableObjectWrapper
-from plone.indexer.interfaces import IIndexableObject
-from plone.indexer.interfaces import IIndexer
-
-from Products.ZCatalog.interfaces import IZCatalog
-from Products.CMFCore.utils import getToolByName
-
 
 class WrapperSpecification(ObjectSpecificationDescriptor):
     """A __providedBy__ decorator that returns the interfaces provided by
@@ -30,14 +28,12 @@ def __get__(self, inst, cls=None):
             return ObjectSpecification(provided, cls)
 
 
+@implementer(IIndexableObject, IIndexableObjectWrapper)
+@adapter(Interface, IZCatalog)
 class IndexableObjectWrapper(object):
     """A simple wrapper for indexable objects that will delegate to IIndexer
     adapters as appropriate.
     """
-
-    implements(IIndexableObject, IIndexableObjectWrapper)
-    adapts(Interface, IZCatalog)
-
     __providedBy__ = WrapperSpecification()
 
     def __init__(self, object, catalog):
@@ -60,7 +56,9 @@ def __str__(self):
 
     def __getattr__(self, name):
         # First, try to look up an indexer adapter
-        indexer = queryMultiAdapter((self.__object, self.__catalog), IIndexer, name=name)
+        indexer = queryMultiAdapter(
+            (self.__object, self.__catalog), IIndexer, name=name
+        )
         if indexer is not None:
             return indexer()
 
diff --git a/setup.py b/setup.py
index 196ea44..bed5705 100644
--- a/setup.py
+++ b/setup.py
@@ -1,27 +1,24 @@
-import os
-from setuptools import setup, find_packages
-
+# -*- coding: utf-8 -*-
+from setuptools import find_packages
+from setuptools import setup
 
-def read(*rnames):
-    return open(os.path.join(os.path.dirname(__file__), *rnames)).read()
+import os
 
 
 version = '1.0.4.dev0'
+description = 'Hooks to facilitate managing custom index values in Zope 2/CMF applications'  # noqa
+long_description = ('\n\n'.join([
+    open('README.rst').read(),
+    open('CHANGES.rst').read(),
+    open(os.path.join("plone", "indexer", "README.rst")).read(),
+
+]))
 
-long_description = (
-    read('README.rst')
-    + '\n' +
-    read('plone', 'indexer', 'README.rst')
-    + '\n' +
-    read('CHANGES.rst')
-    + '\n'
-    )
 
 setup(
     name='plone.indexer',
     version=version,
-    description="Hooks to facilitate managing custom index values in "
-                "Zope 2/CMF applications",
+    description=description,
     long_description=long_description,
     classifiers=[
         "Environment :: Web Environment",
@@ -51,4 +48,4 @@ def read(*rnames):
         'Products.CMFCore',
         'Products.ZCatalog',
     ],
-    )
+)


