Repository: plone.namedfile


Branch: refs/heads/master
Date: 2016-04-18T22:02:40+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.namedfile/commit/192fc39d543bc5a2361a1fba91aa7062a24abec1

debugging

Files changed:
M plone/namedfile/file.py

diff --git a/plone/namedfile/file.py b/plone/namedfile/file.py
index 44b24d3..a7960aa 100644
--- a/plone/namedfile/file.py
+++ b/plone/namedfile/file.py
@@ -3,6 +3,7 @@
 # from zope.app.file and z3c.blobfile
 # and are licensed under the ZPL.
 from cStringIO import StringIO
+from logging import getLogger
 from persistent import Persistent
 from plone.namedfile.interfaces import INamedBlobFile
 from plone.namedfile.interfaces import INamedBlobImage
@@ -22,6 +23,9 @@
 import transaction
 
 
+log = getLogger(__name__)
+
+
 MAXCHUNKSIZE = 1 << 16
 IMAGE_INFO_BYTES = 1024
 MAX_INFO_BYTES = 1 << 16
@@ -332,6 +336,7 @@ def _setData(self, data):
         # Search for a storable that is able to store the data
         dottedName = '.'.join((data.__class__.__module__,
                                data.__class__.__name__))
+        log.info("safe data as: %s", dottedName)
         storable = getUtility(IStorage, name=dottedName)
         storable.store(data, self._blob)
 


Repository: plone.namedfile


Branch: refs/heads/master
Date: 2016-04-18T22:16:06+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.namedfile/commit/0214e720f7caf01be74b37884d7195678bf3b6f6

Revert "Automatic image rotation based on Exif data"

This reverts commit f3f3bc39e433e7a41df20cdc5034b41c782288ab.
Sorry I have accidently push to master.

Files changed:
M CHANGES.rst
M plone/namedfile/file.py
M plone/namedfile/utils.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index f35a798..b975dd7 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -11,12 +11,6 @@ Incompatibilities:
 New:
 
 - *add item here*
-- Add automatic image rotation baed on EXIF data for all images.
-  Based on piexif library and ideas of maartenkling and ezvirtual.
-  Choosen piexif as it allow read and write of exif data for future enhancements.
-  http://piexif.readthedocs.org/en/latest/
-  For Orientation examples and description see http://www.daveperrett.com/articles/2012/07/28/exif-orientation-handling-is-a-ghetto/ test data https://github.com/recurser/exif-orientation-examples
-  [loechel]
 
 Fixes:
 
diff --git a/plone/namedfile/file.py b/plone/namedfile/file.py
index a7960aa..5280cfa 100644
--- a/plone/namedfile/file.py
+++ b/plone/namedfile/file.py
@@ -11,15 +11,12 @@
 from plone.namedfile.interfaces import INamedImage
 from plone.namedfile.interfaces import IStorage
 from plone.namedfile.utils import get_contenttype
-from plone.namedfile.utils import get_exif
-from plone.namedfile.utils import getImageInfo
-from plone.namedfile.utils import rotate_image
 from ZODB.blob import Blob
 from zope.component import getUtility
 from zope.interface import implementer
 from zope.schema.fieldproperty import FieldProperty
 
-import piexif
+import struct
 import transaction
 
 
@@ -273,21 +270,14 @@ class NamedImage(NamedFile):
     filename = FieldProperty(INamedFile['filename'])
 
     def __init__(self, data='', contentType='', filename=None):
+        self.contentType, self._width, self._height = getImageInfo(data)
+        self.data = data
         self.filename = filename
-        self._setData(data)
 
         # Allow override of the image sniffer
         if contentType:
             self.contentType = contentType
 
-        if contentType in ['image/jpeg', 'image/tiff']:
-            _exif_data = get_exif(data)
-            if _exif_data is not None:
-                orientation = _exif_data['0th'].get(piexif.ImageIFD.Orientation, 1)
-                if 1 < orientation <= 8:
-                    data = rotate_image(data)
-                self.exif_data = _exif_data
-
     def _setData(self, data):
         super(NamedImage, self)._setData(data)
 
@@ -302,6 +292,81 @@ def getImageSize(self):
     data = property(NamedFile._getData, _setData)
 
 
+def getImageInfo(data):
+    data = str(data)
+    size = len(data)
+    height = -1
+    width = -1
+    content_type = ''
+
+    # handle GIFs
+    if (size >= 10) and data[:6] in ('GIF87a', 'GIF89a'):
+        # Check to see if content_type is correct
+        content_type = 'image/gif'
+        w, h = struct.unpack('<HH', data[6:10])
+        width = int(w)
+        height = int(h)
+
+    # See PNG 2. Edition spec (http://www.w3.org/TR/PNG/)
+    # Bytes 0-7 are below, 4-byte chunk length, then 'IHDR'
+    # and finally the 4-byte width, height
+    elif (
+        (size >= 24) and data.startswith('\211PNG\r\n\032\n') and
+        (data[12:16] == 'IHDR')
+    ):
+        content_type = 'image/png'
+        w, h = struct.unpack('>LL', data[16:24])
+        width = int(w)
+        height = int(h)
+
+    # Maybe this is for an older PNG version.
+    elif (size >= 16) and data.startswith('\211PNG\r\n\032\n'):
+        # Check to see if we have the right content type
+        content_type = 'image/png'
+        w, h = struct.unpack('>LL', data[8:16])
+        width = int(w)
+        height = int(h)
+
+    # handle JPEGs
+    elif (size >= 2) and data.startswith('\377\330'):
+        content_type = 'image/jpeg'
+        jpeg = StringIO(data)
+        jpeg.read(2)
+        b = jpeg.read(1)
+        try:
+            w = -1
+            h = -1
+            while (b and ord(b) != 0xDA):
+                while (ord(b) != 0xFF):
+                    b = jpeg.read(1)
+                while (ord(b) == 0xFF):
+                    b = jpeg.read(1)
+                if (ord(b) >= 0xC0 and ord(b) <= 0xC3):
+                    jpeg.read(3)
+                    h, w = struct.unpack('>HH', jpeg.read(4))
+                    break
+                else:
+                    jpeg.read(int(struct.unpack('>H', jpeg.read(2))[0]) - 2)
+                b = jpeg.read(1)
+            width = int(w)
+            height = int(h)
+        except struct.error:
+            pass
+        except ValueError:
+            pass
+        except TypeError:
+            pass
+
+    # handle BMPs
+    elif (size >= 30) and data.startswith('BM'):
+        kind = struct.unpack('<H', data[14:16])[0]
+        if kind == 40:  # Windows 3.x bitmap
+            content_type = 'image/x-ms-bmp'
+            width, height = struct.unpack('<LL', data[18:26])
+
+    return content_type, width, height
+
+
 @implementer(INamedBlobFile)
 class NamedBlobFile(Persistent):
     """A file stored in a ZODB BLOB, with a filename"""
@@ -370,21 +435,12 @@ class NamedBlobImage(NamedBlobFile):
     """
 
     def __init__(self, data='', contentType='', filename=None):
-        super(NamedBlobImage, self).__init__(data, contentType=contentType, filename=filename)
+        super(NamedBlobImage, self).__init__(data, filename=filename)
 
         # Allow override of the image sniffer
         if contentType:
             self.contentType = contentType
 
-        if contentType in ['image/jpeg', 'image/tiff']:
-            exif_data = get_exif(self.data)
-            if exif_data is not None:
-                orientation = exif_data['0th'].get(piexif.ImageIFD.Orientation, 1)
-                if 1 < orientation <= 8:
-                    self.data, self._width, self._height, self.exif = rotate_image(self.data)
-                else:
-                    self.exif = exif_data
-
     def _setData(self, data):
         super(NamedBlobImage, self)._setData(data)
         firstbytes = self.getFirstBytes()
@@ -417,5 +473,6 @@ def getImageSize(self):
         if (self._width, self._height) != (-1, -1):
             return (self._width, self._height)
 
-        contentType, self._width, self._height = getImageInfo(self.data)
+        res = getImageInfo(self.data)
+        contentType, self._width, self._height = res
         return (self._width, self._height)
diff --git a/plone/namedfile/utils.py b/plone/namedfile/utils.py
index c4b3a08..08317b2 100644
--- a/plone/namedfile/utils.py
+++ b/plone/namedfile/utils.py
@@ -1,20 +1,11 @@
 # -*- coding: utf-8 -*-
-
-from logging import getLogger
 from plone.namedfile.interfaces import IBlobby
-from StringIO import StringIO
 
 import mimetypes
 import os.path
-import piexif
-import PIL.Image
-import struct
 import urllib
 
 
-log = getLogger(__name__)
-
-
 try:
     # use this to stream data if we can
     from ZPublisher.Iterators import filestream_iterator
@@ -86,154 +77,3 @@ def stream_data(file):
         return filestream_iterator(filename, 'rb')
 
     return file.data
-
-
-def getImageInfo(data):
-    data = str(data)
-    size = len(data)
-    height = -1
-    width = -1
-    content_type = ''
-
-    # handle GIFs
-    if (size >= 10) and data[:6] in ('GIF87a', 'GIF89a'):
-        # Check to see if content_type is correct
-        content_type = 'image/gif'
-        w, h = struct.unpack('<HH', data[6:10])
-        width = int(w)
-        height = int(h)
-
-    # See PNG 2. Edition spec (http://www.w3.org/TR/PNG/)
-    # Bytes 0-7 are below, 4-byte chunk length, then 'IHDR'
-    # and finally the 4-byte width, height
-    elif (
-        (size >= 24) and data.startswith('\211PNG\r\n\032\n') and
-        (data[12:16] == 'IHDR')
-    ):
-        content_type = 'image/png'
-        w, h = struct.unpack('>LL', data[16:24])
-        width = int(w)
-        height = int(h)
-
-    # Maybe this is for an older PNG version.
-    elif (size >= 16) and data.startswith('\211PNG\r\n\032\n'):
-        # Check to see if we have the right content type
-        content_type = 'image/png'
-        w, h = struct.unpack('>LL', data[8:16])
-        width = int(w)
-        height = int(h)
-
-    # handle JPEGs
-    elif (size >= 2) and data.startswith('\377\330'):
-        content_type = 'image/jpeg'
-        jpeg = StringIO(data)
-        jpeg.read(2)
-        b = jpeg.read(1)
-        try:
-            w = -1
-            h = -1
-            while (b and ord(b) != 0xDA):
-                while (ord(b) != 0xFF):
-                    b = jpeg.read(1)
-                while (ord(b) == 0xFF):
-                    b = jpeg.read(1)
-                if (ord(b) >= 0xC0 and ord(b) <= 0xC3):
-                    jpeg.read(3)
-                    h, w = struct.unpack('>HH', jpeg.read(4))
-                    break
-                else:
-                    jpeg.read(int(struct.unpack('>H', jpeg.read(2))[0]) - 2)
-                b = jpeg.read(1)
-            width = int(w)
-            height = int(h)
-        except struct.error:
-            pass
-        except ValueError:
-            pass
-        except TypeError:
-            pass
-
-    # handle BMPs
-    elif (size >= 30) and data.startswith('BM'):
-        kind = struct.unpack('<H', data[14:16])[0]
-        if kind == 40:  # Windows 3.x bitmap
-            content_type = 'image/x-ms-bmp'
-            width, height = struct.unpack('<LL', data[18:26])
-
-    return content_type, width, height
-
-
-def get_exif(image):
-    if getattr(image, 'read', None):
-        exif_data = piexif.load(image.read())
-    else:
-        exif_data = piexif.load(image)
-    return exif_data
-
-
-def rotate_image(image_data, method=None, REQUEST=None):
-    if getattr(image_data, 'read', None):
-        img = PIL.Image.open(image_data)
-    else:
-        img = PIL.Image.open(StringIO(image_data))
-
-    if 'exif' in img.info:
-        exif_data = piexif.load(img.info['exif'])
-
-        if piexif.ImageIFD.Orientation in exif_data['0th']:
-            orientation = exif_data['0th'][piexif.ImageIFD.Orientation]
-    else:
-        width, height = im.size()
-        exif_data = {
-            '0th': {
-                piexif.ImageIFD.XResolution: (width, 1),
-                piexif.ImageIFD.YResolution: (height, 1),
-            }
-        }
-
-    if method is not None:
-        orientation = method
-
-    log.debug('Rotate image with input orientation: %s', orientation)
-
-    fmt = img.format
-    if orientation == 1:  # not transform necessary
-        #img = img
-        pass
-    elif orientation == 2:
-        img = img.transpose(PIL.Image.FLIP_LEFT_RIGHT)
-    elif orientation == 3:
-        #img = img.rotate(180)
-        img = img.transpose(PIL.Image.ROTATE_180)
-    elif orientation == 4:
-        #img = img.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT)
-        img = img.transpose(PIL.Image.ROTATE_180).transpose(PIL.Image.FLIP_LEFT_RIGHT)
-    elif orientation == 5:
-        #img = img.rotate(-90).transpose(PIL.Image.FLIP_LEFT_RIGHT)
-        img = img.transpose(PIL.Image.ROTATE_270).transpose(PIL.Image.FLIP_LEFT_RIGHT)
-        #exif_data['0th'][piexif.ImageIFD.XResolution], exif_data['0th'][piexif.ImageIFD.YResolution] = exif_data['0th'][piexif.ImageIFD.YResolution], exif_data['0th'][piexif.ImageIFD.XResolution]
-    elif orientation == 6:
-        #img = img.rotate(-90)
-        img = img.transpose(PIL.Image.ROTATE_270)
-        #exif_data['0th'][piexif.ImageIFD.XResolution], exif_data['0th'][piexif.ImageIFD.YResolution] = exif_data['0th'][piexif.ImageIFD.YResolution], exif_data['0th'][piexif.ImageIFD.XResolution]
-    elif orientation == 7:
-        #img = img.rotate(90).transpose(PIL.Image.FLIP_LEFT_RIGHT)
-        img = img.transpose(PIL.Image.ROTATE_90).transpose(PIL.Image.FLIP_LEFT_RIGHT)
-        #exif_data['0th'][piexif.ImageIFD.XResolution], exif_data['0th'][piexif.ImageIFD.YResolution] = exif_data['0th'][piexif.ImageIFD.YResolution], exif_data['0th'][piexif.ImageIFD.XResolution]
-    elif orientation == 8:
-        #img = img.rotate(90)
-        img = img.transpose(PIL.Image.ROTATE_90)
-        #exif_data['0th'][piexif.ImageIFD.XResolution], exif_data['0th'][piexif.ImageIFD.YResolution] = exif_data['0th'][piexif.ImageIFD.YResolution], exif_data['0th'][piexif.ImageIFD.XResolution]
-
-    exif_data['0th'][piexif.ImageIFD.Orientation] = 1  # delete orientation
-    #del(exif_data['0th'][piexif.ImageIFD.Orientation])
-
-    try:
-        exif_bytes = piexif.dump(exif_data)
-    except:
-        del(exif_data['Exif'][41729])  # This Elemnt piexif.ExifIFD.SceneType cause error on dump
-        exif_bytes = piexif.dump(exif_data)
-    output_image_data = StringIO()
-    img.save(output_image_data, format=fmt, exif=exif_bytes)
-    width, height = img.size
-    return output_image_data.getvalue(), width, height, exif_data
diff --git a/setup.py b/setup.py
index a2eb11a..c1a84f2 100644
--- a/setup.py
+++ b/setup.py
@@ -44,7 +44,6 @@
         'zope.copy',
         'zope.security',
         'zope.traversing',
-        'piexif',
     ],
     extras_require={
         'editor': ['plone.schemaeditor'],


Repository: plone.namedfile


Branch: refs/heads/master
Date: 2016-04-18T22:17:44+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.namedfile/commit/fe13ac86c478724c8c756007e1b9cfe707300b98

Revert "debugging"

This reverts commit 192fc39d543bc5a2361a1fba91aa7062a24abec1.

Files changed:
M plone/namedfile/file.py

diff --git a/plone/namedfile/file.py b/plone/namedfile/file.py
index 5280cfa..bef3519 100644
--- a/plone/namedfile/file.py
+++ b/plone/namedfile/file.py
@@ -3,7 +3,6 @@
 # from zope.app.file and z3c.blobfile
 # and are licensed under the ZPL.
 from cStringIO import StringIO
-from logging import getLogger
 from persistent import Persistent
 from plone.namedfile.interfaces import INamedBlobFile
 from plone.namedfile.interfaces import INamedBlobImage
@@ -20,9 +19,6 @@
 import transaction
 
 
-log = getLogger(__name__)
-
-
 MAXCHUNKSIZE = 1 << 16
 IMAGE_INFO_BYTES = 1024
 MAX_INFO_BYTES = 1 << 16
@@ -401,7 +397,6 @@ def _setData(self, data):
         # Search for a storable that is able to store the data
         dottedName = '.'.join((data.__class__.__module__,
                                data.__class__.__name__))
-        log.info("safe data as: %s", dottedName)
         storable = getUtility(IStorage, name=dottedName)
         storable.store(data, self._blob)
 


