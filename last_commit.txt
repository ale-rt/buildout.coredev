Repository: plone.app.caching


Branch: refs/heads/master
Date: 2016-09-27T15:15:31+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.caching/commit/79d9fe062f84199b10a673f4631f92b5c26338ed

isort

Files changed:
M plone/app/caching/browser/controlpanel.py
M plone/app/caching/browser/edit.py
M plone/app/caching/interfaces.py
M plone/app/caching/lastmodified.py
M plone/app/caching/lookup.py
M plone/app/caching/operations/default.py
M plone/app/caching/operations/etags.py
M plone/app/caching/operations/ramcache.py
M plone/app/caching/operations/utils.py
M plone/app/caching/purge.py
M plone/app/caching/setuphandlers.py
M plone/app/caching/testing.py
M plone/app/caching/tests/test_etags.py
M plone/app/caching/tests/test_integration.py
M plone/app/caching/tests/test_lastmodified.py
M plone/app/caching/tests/test_lookup.py
M plone/app/caching/tests/test_operation_default.py
M plone/app/caching/tests/test_operation_parameters.py
M plone/app/caching/tests/test_operation_utils.py
M plone/app/caching/tests/test_profile_with_caching_proxy.py
M plone/app/caching/tests/test_profile_without_caching_proxy.py
M plone/app/caching/tests/test_purge.py
M plone/app/caching/tests/test_utils.py
M plone/app/caching/utils.py
M setup.cfg

diff --git a/plone/app/caching/browser/controlpanel.py b/plone/app/caching/browser/controlpanel.py
index 6ad76dc..3456b80 100644
--- a/plone/app/caching/browser/controlpanel.py
+++ b/plone/app/caching/browser/controlpanel.py
@@ -1,43 +1,34 @@
-import re
-import datetime
-
-from zope.interface import implementer
-from zope.component import getUtility
+from plone.app.caching.browser.edit import EditForm
+from plone.app.caching.interfaces import _
+from plone.app.caching.interfaces import ICacheProfiles
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.cachepurging.interfaces import ICachePurgingSettings
+from plone.cachepurging.interfaces import IPurger
+from plone.cachepurging.utils import getPathsToPurge
+from plone.cachepurging.utils import getURLsToPurge
+from plone.cachepurging.utils import isCachePurgingEnabled
+from plone.caching.interfaces import ICacheSettings
+from plone.caching.interfaces import ICachingOperationType
+from plone.memoize.instance import memoize
+from plone.protect import CheckAuthenticator
+from plone.registry.interfaces import IRegistry
+from Products.CMFCore.utils import getToolByName
+from Products.GenericSetup.interfaces import BASE
+from Products.GenericSetup.interfaces import EXTENSION
+from Products.statusmessages.interfaces import IStatusMessage
+from z3c.caching.interfaces import IRulesetType
+from z3c.caching.registry import enumerateTypes
 from zope.component import getUtilitiesFor
+from zope.component import getUtility
 from zope.component import queryUtility
-
+from zope.interface import implementer
 from zope.publisher.interfaces import IPublishTraverse
 from zope.publisher.interfaces import NotFound
-
 from zope.ramcache.interfaces.ram import IRAMCache
 
-from plone.memoize.instance import memoize
-
-from plone.registry.interfaces import IRegistry
-
-from z3c.caching.interfaces import IRulesetType
-from z3c.caching.registry import enumerateTypes
-
-from plone.protect import CheckAuthenticator
-
-from plone.caching.interfaces import ICacheSettings
-from plone.caching.interfaces import ICachingOperationType
-
-from plone.cachepurging.interfaces import IPurger
-from plone.cachepurging.interfaces import ICachePurgingSettings
-
-from plone.cachepurging.utils import isCachePurgingEnabled
-from plone.cachepurging.utils import getPathsToPurge
-from plone.cachepurging.utils import getURLsToPurge
-
-from plone.app.caching.interfaces import IPloneCacheSettings
-from plone.app.caching.interfaces import ICacheProfiles
-from plone.app.caching.interfaces import _
-from plone.app.caching.browser.edit import EditForm
+import datetime
+import re
 
-from Products.GenericSetup.interfaces import BASE, EXTENSION
-from Products.CMFCore.utils import getToolByName
-from Products.statusmessages.interfaces import IStatusMessage
 
 # Borrowed from zope.schema to avoid an import of a private name
 _isuri = re.compile(
diff --git a/plone/app/caching/browser/edit.py b/plone/app/caching/browser/edit.py
index 7af321c..a6f6ddb 100644
--- a/plone/app/caching/browser/edit.py
+++ b/plone/app/caching/browser/edit.py
@@ -1,21 +1,18 @@
-from zope.component import getUtility
-from zope.interface import alsoProvides
-
-from zope.schema.interfaces import IField
-
-from z3c.form.interfaces import IFormLayer
-from z3c.form import form, button, field
-
+from plone.app.caching.interfaces import _
 from plone.memoize.instance import memoize
-
-from plone.registry.interfaces import IRegistry
-from plone.registry import Record
 from plone.registry import FieldRef
-
-from plone.app.caching.interfaces import _
-
+from plone.registry import Record
+from plone.registry.interfaces import IRegistry
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
 from Products.statusmessages.interfaces import IStatusMessage
+from z3c.form import button
+from z3c.form import field
+from z3c.form import form
+from z3c.form.interfaces import IFormLayer
+from zope.component import getUtility
+from zope.interface import alsoProvides
+from zope.schema.interfaces import IField
+
 
 class EditForm(form.Form):
     """General edit form for operations.
diff --git a/plone/app/caching/interfaces.py b/plone/app/caching/interfaces.py
index 71552a9..46fab81 100644
--- a/plone/app/caching/interfaces.py
+++ b/plone/app/caching/interfaces.py
@@ -1,7 +1,8 @@
+from zope import schema
+from zope.interface import Interface
+
 import zope.i18nmessageid
 
-from zope.interface import Interface
-from zope import schema
 
 _ = zope.i18nmessageid.MessageFactory('plone.app.caching')
 
diff --git a/plone/app/caching/lastmodified.py b/plone/app/caching/lastmodified.py
index 252dcf2..a835808 100644
--- a/plone/app/caching/lastmodified.py
+++ b/plone/app/caching/lastmodified.py
@@ -1,12 +1,24 @@
+from Acquisition import aq_base
+from Acquisition import aq_inner
+from Acquisition import aq_parent
 from datetime import datetime
 from dateutil.tz import tzlocal
-
-from zope.interface import implementer, implementer, Interface
-from zope.component import adapter, adapts
-
+from OFS.Image import File
+from plone.app.caching.operations.utils import getContext
+from Products.Archetypes.Field import Image as ImageScale
+from Products.CMFCore.FSObject import FSObject
+from Products.CMFCore.FSPageTemplate import FSPageTemplate
+from Products.CMFCore.interfaces import ICatalogableDublinCore
+from Products.ResourceRegistries.interfaces import ICookedFile
+from Products.ResourceRegistries.interfaces import IResourceRegistry
+from z3c.caching.interfaces import ILastModified
 from zope.browserresource.interfaces import IResource
+from zope.component import adapter
+from zope.component import adapts
+from zope.interface import implementer
+from zope.interface import Interface
 from zope.pagetemplate.interfaces import IPageTemplate
-from z3c.caching.interfaces import ILastModified
+
 
 try:
     from zope.dublincore.interfaces import IDCTimes
@@ -14,19 +26,8 @@
     class IDCTimes(Interface):
         pass
 
-from Acquisition import aq_base
-from Acquisition import aq_parent
-from Acquisition import aq_inner
 
-from OFS.Image import File
-from Products.Archetypes.Field import Image as ImageScale
-from Products.CMFCore.interfaces import ICatalogableDublinCore
-from Products.CMFCore.FSObject import FSObject
-from Products.CMFCore.FSPageTemplate import FSPageTemplate
 
-from plone.app.caching.operations.utils import getContext
-from Products.ResourceRegistries.interfaces import ICookedFile
-from Products.ResourceRegistries.interfaces import IResourceRegistry
 
 
 @implementer(ILastModified)
diff --git a/plone/app/caching/lookup.py b/plone/app/caching/lookup.py
index ddbbc44..102e55f 100644
--- a/plone/app/caching/lookup.py
+++ b/plone/app/caching/lookup.py
@@ -1,15 +1,12 @@
-from zope.interface import implementer
-from zope.component import queryUtility
-
+from Acquisition import aq_base
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.utils import getObjectDefaultView
+from plone.caching.interfaces import IRulesetLookup
 from plone.registry.interfaces import IRegistry
-
 from z3c.caching.registry import lookup
-from plone.caching.interfaces import IRulesetLookup
-from plone.app.caching.interfaces import IPloneCacheSettings
-
-from Acquisition import aq_base
+from zope.component import queryUtility
+from zope.interface import implementer
 
-from plone.app.caching.utils import getObjectDefaultView
 
 @implementer(IRulesetLookup)
 class ContentItemLookup(object):
diff --git a/plone/app/caching/operations/default.py b/plone/app/caching/operations/default.py
index 2b4b06a..dce359a 100644
--- a/plone/app/caching/operations/default.py
+++ b/plone/app/caching/operations/default.py
@@ -1,35 +1,29 @@
-import time
-import random
-
-from zope.interface import implementer
-from zope.interface import provider
-from zope.interface import Interface
-from zope.component import adapts
-from zope.component import getMultiAdapter
-
-from zope.publisher.interfaces.http import IHTTPRequest
-
-from plone.caching.interfaces import ICachingOperation
-from plone.caching.interfaces import ICachingOperationType
-from plone.caching.utils import lookupOptions
-
-from plone.app.caching.operations.utils import setCacheHeaders
-from plone.app.caching.operations.utils import doNotCache
+from plone.app.caching.interfaces import _
+from plone.app.caching.operations.utils import cachedResponse
 from plone.app.caching.operations.utils import cacheInRAM
 from plone.app.caching.operations.utils import cacheStop
-
-from plone.app.caching.operations.utils import cachedResponse
-from plone.app.caching.operations.utils import notModified
-
-from plone.app.caching.operations.utils import getETagAnnotation
+from plone.app.caching.operations.utils import doNotCache
+from plone.app.caching.operations.utils import fetchFromRAMCache
 from plone.app.caching.operations.utils import getContext
+from plone.app.caching.operations.utils import getETagAnnotation
 from plone.app.caching.operations.utils import getLastModifiedAnnotation
-
-from plone.app.caching.operations.utils import fetchFromRAMCache
 from plone.app.caching.operations.utils import isModified
+from plone.app.caching.operations.utils import notModified
+from plone.app.caching.operations.utils import setCacheHeaders
 from plone.app.caching.operations.utils import visibleToRole
+from plone.caching.interfaces import ICachingOperation
+from plone.caching.interfaces import ICachingOperationType
+from plone.caching.utils import lookupOptions
+from zope.component import adapts
+from zope.component import getMultiAdapter
+from zope.interface import implementer
+from zope.interface import Interface
+from zope.interface import provider
+from zope.publisher.interfaces.http import IHTTPRequest
+
+import random
+import time
 
-from plone.app.caching.interfaces import _
 
 try:
     from Products.ResourceRegistries.interfaces import ICookedFile
diff --git a/plone/app/caching/operations/etags.py b/plone/app/caching/operations/etags.py
index 1a346da..4e61040 100644
--- a/plone/app/caching/operations/etags.py
+++ b/plone/app/caching/operations/etags.py
@@ -1,22 +1,18 @@
-import random
-import time
-
-from zope.interface import implementer
-from zope.interface import Interface
-
-from zope.component import adapts
-from zope.component import queryMultiAdapter
-from zope.component import queryUtility
-
-from plone.registry.interfaces import IRegistry
-
 from plone.app.caching.interfaces import IETagValue
 from plone.app.caching.interfaces import IPloneCacheSettings
-
 from plone.app.caching.operations.utils import getContext
 from plone.app.caching.operations.utils import getLastModifiedAnnotation
-
+from plone.registry.interfaces import IRegistry
 from Products.CMFCore.utils import getToolByName
+from zope.component import adapts
+from zope.component import queryMultiAdapter
+from zope.component import queryUtility
+from zope.interface import implementer
+from zope.interface import Interface
+
+import random
+import time
+
 
 @implementer(IETagValue)
 class UserID(object):
diff --git a/plone/app/caching/operations/ramcache.py b/plone/app/caching/operations/ramcache.py
index 80beb87..50ea391 100644
--- a/plone/app/caching/operations/ramcache.py
+++ b/plone/app/caching/operations/ramcache.py
@@ -1,12 +1,10 @@
+from plone.app.caching.interfaces import IRAMCached
+from plone.app.caching.operations.utils import storeResponseInRAMCache
+from plone.transformchain.interfaces import ITransform
+from zope.component import adapts
 from zope.interface import implementer
 from zope.interface import Interface
 
-from zope.component import adapts
-from plone.transformchain.interfaces import ITransform
-
-from plone.app.caching.interfaces import IRAMCached
-
-from plone.app.caching.operations.utils import storeResponseInRAMCache
 
 GLOBAL_KEY = 'plone.app.caching.operations.ramcache'
 
diff --git a/plone/app/caching/operations/utils.py b/plone/app/caching/operations/utils.py
index 686000f..3679e38 100644
--- a/plone/app/caching/operations/utils.py
+++ b/plone/app/caching/operations/utils.py
@@ -1,30 +1,27 @@
-import re
-import time
-import datetime
-import logging
-import dateutil.parser
-import dateutil.tz
-import wsgiref.handlers
-
+from AccessControl.PermissionRole import rolesForPermissionOn
+from plone.app.caching.interfaces import IETagValue
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.interfaces import IRAMCached
+from plone.memoize.interfaces import ICacheChooser
+from plone.registry.interfaces import IRegistry
+from Products.CMFCore.interfaces import IContentish
+from Products.CMFCore.interfaces import ISiteRoot
 from thread import allocate_lock
-
-from zope.interface import alsoProvides
+from z3c.caching.interfaces import ILastModified
+from zope.annotation.interfaces import IAnnotations
+from zope.component import getUtility
 from zope.component import queryMultiAdapter
 from zope.component import queryUtility
-from zope.component import getUtility
-
-from zope.annotation.interfaces import IAnnotations
-from z3c.caching.interfaces import ILastModified
-from plone.registry.interfaces import IRegistry
-from plone.memoize.interfaces import ICacheChooser
+from zope.interface import alsoProvides
 
-from plone.app.caching.interfaces import IRAMCached
-from plone.app.caching.interfaces import IETagValue
-from plone.app.caching.interfaces import IPloneCacheSettings
+import datetime
+import dateutil.parser
+import dateutil.tz
+import logging
+import re
+import time
+import wsgiref.handlers
 
-from AccessControl.PermissionRole import rolesForPermissionOn
-from Products.CMFCore.interfaces import IContentish
-from Products.CMFCore.interfaces import ISiteRoot
 
 PAGE_CACHE_KEY = 'plone.app.caching.operations.ramcache'
 PAGE_CACHE_ANNOTATION_KEY = 'plone.app.caching.operations.ramcache.key'
diff --git a/plone/app/caching/purge.py b/plone/app/caching/purge.py
index 37e7542..078d693 100644
--- a/plone/app/caching/purge.py
+++ b/plone/app/caching/purge.py
@@ -1,27 +1,23 @@
-from zope.interface import implementer
-from zope.component import adapts, adapter, getAdapters
-from zope.event import notify
-from zope.globalrequest import getRequest
-
-from zope.lifecycleevent.interfaces import IObjectModifiedEvent
-from zope.lifecycleevent.interfaces import IObjectMovedEvent
-
-from z3c.caching.purge import Purge
-from z3c.caching.interfaces import IPurgePaths
-
+from Acquisition import aq_parent
+from plone.app.caching.utils import getObjectDefaultView
+from plone.app.caching.utils import isPurged
 from plone.cachepurging.interfaces import IPurgePathRewriter
-
-from Products.CMFCore.interfaces import IDiscussionResponse
+from plone.memoize.instance import memoize
 from Products.CMFCore.interfaces import IContentish
+from Products.CMFCore.interfaces import IDiscussionResponse
 from Products.CMFCore.interfaces import IDynamicType
 from Products.CMFCore.utils import getToolByName
+from z3c.caching.interfaces import IPurgePaths
+from z3c.caching.purge import Purge
+from zope.component import adapter
+from zope.component import adapts
+from zope.component import getAdapters
+from zope.event import notify
+from zope.globalrequest import getRequest
+from zope.interface import implementer
+from zope.lifecycleevent.interfaces import IObjectModifiedEvent
+from zope.lifecycleevent.interfaces import IObjectMovedEvent
 
-from plone.app.caching.utils import isPurged
-from plone.app.caching.utils import getObjectDefaultView
-
-from plone.memoize.instance import memoize
-
-from Acquisition import aq_parent
 
 try:
     from plone.app.blob.interfaces import IBlobField
diff --git a/plone/app/caching/setuphandlers.py b/plone/app/caching/setuphandlers.py
index 3ecc843..fe67ae0 100644
--- a/plone/app/caching/setuphandlers.py
+++ b/plone/app/caching/setuphandlers.py
@@ -1,5 +1,6 @@
 from Products.CMFCore.utils import getToolByName
 
+
 def enableExplicitMode():
     """ZCML startup hook to put the ruleset registry into explict mode.
     This means we require people to declare ruleset types before using them.
diff --git a/plone/app/caching/testing.py b/plone/app/caching/testing.py
index a3968be..9e14db8 100644
--- a/plone/app/caching/testing.py
+++ b/plone/app/caching/testing.py
@@ -1,17 +1,17 @@
+from hashlib import sha1 as sha
 from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE
-from plone.app.testing import PloneSandboxLayer
-from plone.app.testing import IntegrationTesting
-from plone.app.testing import FunctionalTesting
 from plone.app.testing import applyProfile
-
-from zope.interface import implementer
-
+from plone.app.testing import FunctionalTesting
+from plone.app.testing import IntegrationTesting
+from plone.app.testing import PloneSandboxLayer
+from plone.cachepurging.interfaces import IPurger
 from zope.component import getUtility
 from zope.component import provideUtility
-
 from zope.configuration import xmlconfig
+from zope.interface import implementer
+
+import hmac
 
-from plone.cachepurging.interfaces import IPurger
 
 try:
     from plone.protect.authenticator import _getKeyring
@@ -22,8 +22,6 @@ def _getKeyring(username):
         manager = getUtility(IKeyManager)
         return manager['_system']
 
-import hmac
-from hashlib import sha1 as sha
 
 
 @implementer(IPurger)
diff --git a/plone/app/caching/tests/test_etags.py b/plone/app/caching/tests/test_etags.py
index 835e9d8..df1d73e 100644
--- a/plone/app/caching/tests/test_etags.py
+++ b/plone/app/caching/tests/test_etags.py
@@ -1,31 +1,26 @@
-import unittest2 as unittest
-from plone.testing.zca import UNIT_TESTING
-
-import time
+from Acquisition import Explicit
 from datetime import datetime
 from dateutil.tz import tzlocal
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.registry import Registry
+from plone.registry.fieldfactory import persistentFieldAdapter
+from plone.registry.interfaces import IRegistry
+from plone.testing.zca import UNIT_TESTING
+from Products.CMFCore.interfaces import IContentish
 from StringIO import StringIO
-
-from zope.interface import implementer
-from zope.interface import Interface
-
+from z3c.caching.interfaces import ILastModified
+from zope.component import adapts
 from zope.component import getUtility
 from zope.component import provideAdapter
 from zope.component import provideUtility
-from zope.component import adapts
-
-from z3c.caching.interfaces import ILastModified
-
-from plone.registry.interfaces import IRegistry
-from plone.registry.fieldfactory import persistentFieldAdapter
-from plone.registry import Registry
-
-from plone.app.caching.interfaces import IPloneCacheSettings
-
-from Acquisition import Explicit
+from zope.interface import implementer
+from zope.interface import Interface
 from ZPublisher.HTTPRequest import HTTPRequest
 from ZPublisher.HTTPResponse import HTTPResponse
-from Products.CMFCore.interfaces import IContentish
+
+import time
+import unittest2 as unittest
+
 
 @implementer(IContentish)
 class DummyContext(Explicit):
diff --git a/plone/app/caching/tests/test_integration.py b/plone/app/caching/tests/test_integration.py
index 38c8830..1336747 100644
--- a/plone/app/caching/tests/test_integration.py
+++ b/plone/app/caching/tests/test_integration.py
@@ -1,29 +1,24 @@
-import unittest2 as unittest
-
-from plone.testing.z2 import Browser
-
-from plone.app.testing import TEST_USER_ID, TEST_USER_NAME, TEST_USER_PASSWORD
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.testing import getToken
+from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.testing import applyProfile
 from plone.app.testing import setRoles
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
 from plone.app.textfield.value import RichTextValue
-
-import pkg_resources
-
-import OFS.Image
-
-from zope.component import getUtility
-
-from zope.globalrequest import setRequest
-
-from plone.namedfile.file import NamedImage
-from plone.registry.interfaces import IRegistry
-from plone.caching.interfaces import ICacheSettings
 from plone.cachepurging.interfaces import ICachePurgingSettings
 from plone.cachepurging.interfaces import IPurger
-from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.caching.interfaces import ICacheSettings
+from plone.namedfile.file import NamedImage
+from plone.registry.interfaces import IRegistry
+from plone.testing.z2 import Browser
+from zope.component import getUtility
+from zope.globalrequest import setRequest
 
-from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
-from plone.app.caching.testing import getToken
+import OFS.Image
+import pkg_resources
+import unittest2 as unittest
 
 
 TEST_IMAGE = pkg_resources.resource_filename(
diff --git a/plone/app/caching/tests/test_lastmodified.py b/plone/app/caching/tests/test_lastmodified.py
index 7bc8970..e8b1aee 100644
--- a/plone/app/caching/tests/test_lastmodified.py
+++ b/plone/app/caching/tests/test_lastmodified.py
@@ -1,19 +1,16 @@
-import unittest2 as unittest
+from dateutil.tz import tzlocal
+from persistent.TimeStamp import TimeStamp
+from plone.app.caching import lastmodified
 from plone.testing.zca import UNIT_TESTING
+from z3c.caching.interfaces import ILastModified
+from zope.component import provideAdapter
 
-import os
-import time
 import datetime
 import DateTime
+import os
+import time
+import unittest2 as unittest
 
-from dateutil.tz import tzlocal
-
-from persistent.TimeStamp import TimeStamp
-
-from zope.component import provideAdapter
-from z3c.caching.interfaces import ILastModified
-
-from plone.app.caching import lastmodified
 
 class FauxDataManager(object):
 
diff --git a/plone/app/caching/tests/test_lookup.py b/plone/app/caching/tests/test_lookup.py
index f999f22..8f6915f 100644
--- a/plone/app/caching/tests/test_lookup.py
+++ b/plone/app/caching/tests/test_lookup.py
@@ -1,26 +1,23 @@
-import unittest2 as unittest
+from Acquisition import Explicit
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.lookup import ContentItemLookup
 from plone.caching.testing import IMPLICIT_RULESET_REGISTRY_UNIT_TESTING
-
-from z3c.caching.registry import RulesetRegistry
-import z3c.caching.registry
-
-from zope.component import provideUtility, provideAdapter, getUtility
-from zope.interface import implementer
-
-from plone.registry.interfaces import IRegistry
-
 from plone.registry import Registry
 from plone.registry.fieldfactory import persistentFieldAdapter
-
-from plone.app.caching.interfaces import IPloneCacheSettings
-
-from plone.app.caching.lookup import ContentItemLookup
-
-from Acquisition import Explicit
-from Products.PageTemplates.ZopePageTemplate import ZopePageTemplate
+from plone.registry.interfaces import IRegistry
 from Products.CMFCore.interfaces import IDynamicType
 from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
 from Products.Five.browser import BrowserView
+from Products.PageTemplates.ZopePageTemplate import ZopePageTemplate
+from z3c.caching.registry import RulesetRegistry
+from zope.component import getUtility
+from zope.component import provideAdapter
+from zope.component import provideUtility
+from zope.interface import implementer
+
+import unittest2 as unittest
+import z3c.caching.registry
+
 
 @implementer(IBrowserDefault, IDynamicType)
 class DummyContent(Explicit):
diff --git a/plone/app/caching/tests/test_operation_default.py b/plone/app/caching/tests/test_operation_default.py
index b2fa70b..f3a6a1f 100644
--- a/plone/app/caching/tests/test_operation_default.py
+++ b/plone/app/caching/tests/test_operation_default.py
@@ -1,19 +1,16 @@
-import unittest2 as unittest
-
-from plone.testing.z2 import Browser
-
-from plone.app.testing import TEST_USER_ID, TEST_USER_NAME, TEST_USER_PASSWORD
+from plone.app.caching.testing import getToken
+from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.testing import setRoles
-
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
+from plone.caching.interfaces import ICacheSettings
+from plone.registry.interfaces import IRegistry
+from plone.testing.z2 import Browser
 from zope.component import getUtility
-
 from zope.globalrequest import setRequest
 
-from plone.registry.interfaces import IRegistry
-from plone.caching.interfaces import ICacheSettings
-
-from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
-from plone.app.caching.testing import getToken
+import unittest2 as unittest
 
 
 class TestOperationDefault(unittest.TestCase):
diff --git a/plone/app/caching/tests/test_operation_parameters.py b/plone/app/caching/tests/test_operation_parameters.py
index a1b88ae..8380e81 100644
--- a/plone/app/caching/tests/test_operation_parameters.py
+++ b/plone/app/caching/tests/test_operation_parameters.py
@@ -1,21 +1,18 @@
-import unittest2 as unittest
-
-import transaction;
-
-from plone.testing.z2 import Browser
-
-from plone.app.testing import TEST_USER_ID, TEST_USER_NAME, TEST_USER_PASSWORD
+from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.testing import setRoles
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
 from plone.app.textfield.value import RichTextValue
-
+from plone.caching.interfaces import ICacheSettings
+from plone.registry.interfaces import IRegistry
+from plone.testing.z2 import Browser
 from zope.component import getUtility
-
 from zope.globalrequest import setRequest
 
-from plone.registry.interfaces import IRegistry
-from plone.caching.interfaces import ICacheSettings
+import transaction
+import unittest2 as unittest
 
-from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 
 class TestOperationParameters(unittest.TestCase):
     """This test aims to test the effect of changing various caching operation
diff --git a/plone/app/caching/tests/test_operation_utils.py b/plone/app/caching/tests/test_operation_utils.py
index 413aaf6..4ea16c1 100644
--- a/plone/app/caching/tests/test_operation_utils.py
+++ b/plone/app/caching/tests/test_operation_utils.py
@@ -1,36 +1,29 @@
-import unittest2 as unittest
+from OFS.SimpleItem import SimpleItem
+from plone.memoize.interfaces import ICacheChooser
 from plone.testing.zca import UNIT_TESTING
-
-import time
-import datetime
-import dateutil.parser
-import dateutil.tz
-import wsgiref.handlers
+from Products.CMFCore.interfaces import IContentish
 from StringIO import StringIO
-
-from zope.interface import implementer
-from zope.interface import Interface
-from zope.interface import classImplements
-from zope.interface import alsoProvides
-
-from zope.component import provideAdapter
-from zope.component import provideUtility
-from zope.component import adapts
-
-from plone.memoize.interfaces import ICacheChooser
-
 from z3c.caching.interfaces import ILastModified
-
+from zope.annotation.attribute import AttributeAnnotations
 from zope.annotation.interfaces import IAnnotations
 from zope.annotation.interfaces import IAttributeAnnotatable
-from zope.annotation.attribute import AttributeAnnotations
-
+from zope.component import adapts
+from zope.component import provideAdapter
+from zope.component import provideUtility
+from zope.interface import alsoProvides
+from zope.interface import classImplements
+from zope.interface import implementer
+from zope.interface import Interface
 from ZPublisher.HTTPRequest import HTTPRequest
 from ZPublisher.HTTPResponse import HTTPResponse
 
-from OFS.SimpleItem import SimpleItem
+import datetime
+import dateutil.parser
+import dateutil.tz
+import time
+import unittest2 as unittest
+import wsgiref.handlers
 
-from Products.CMFCore.interfaces import IContentish
 
 class DummyPublished(object):
 
diff --git a/plone/app/caching/tests/test_profile_with_caching_proxy.py b/plone/app/caching/tests/test_profile_with_caching_proxy.py
index 168cd2b..8228c4f 100644
--- a/plone/app/caching/tests/test_profile_with_caching_proxy.py
+++ b/plone/app/caching/tests/test_profile_with_caching_proxy.py
@@ -1,40 +1,34 @@
-import pkg_resources
-
-import unittest2 as unittest
-
-from plone.testing.z2 import Browser
-
+from cStringIO import StringIO
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.caching.tests.test_utils import stable_now
-from plone.app.testing import TEST_USER_ID, TEST_USER_NAME, TEST_USER_PASSWORD
-from plone.app.testing import SITE_OWNER_NAME, SITE_OWNER_PASSWORD
-from plone.app.testing import setRoles
 from plone.app.testing import applyProfile
-
-from cStringIO import StringIO
+from plone.app.testing import setRoles
+from plone.app.testing import SITE_OWNER_NAME
+from plone.app.testing import SITE_OWNER_PASSWORD
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
+from plone.app.textfield.value import RichTextValue
+from plone.cachepurging.interfaces import ICachePurgingSettings
+from plone.cachepurging.interfaces import IPurger
+from plone.caching.interfaces import ICacheSettings
+from plone.registry.interfaces import IRegistry
+from plone.testing.z2 import Browser
+from Products.CMFCore.FSFile import FSFile
+from Products.CMFCore.utils import getToolByName
+from zope.component import getUtility
+from zope.globalrequest import setRequest
 
 import datetime
 import dateutil.parser
 import dateutil.tz
-
+import OFS.Image
 import os
+import pkg_resources
+import unittest2 as unittest
 import urllib
 
-import OFS.Image
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.FSFile import FSFile
-
-from zope.component import getUtility
-
-from zope.globalrequest import setRequest
-
-from plone.app.textfield.value import RichTextValue
-from plone.registry.interfaces import IRegistry
-from plone.caching.interfaces import ICacheSettings
-from plone.cachepurging.interfaces import ICachePurgingSettings
-from plone.cachepurging.interfaces import IPurger
-from plone.app.caching.interfaces import IPloneCacheSettings
-
-from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 
 TEST_FILE = pkg_resources.resource_filename('plone.app.caching.tests', 'test.gif')
 
diff --git a/plone/app/caching/tests/test_profile_without_caching_proxy.py b/plone/app/caching/tests/test_profile_without_caching_proxy.py
index f827ff1..e5b7026 100644
--- a/plone/app/caching/tests/test_profile_without_caching_proxy.py
+++ b/plone/app/caching/tests/test_profile_without_caching_proxy.py
@@ -1,38 +1,31 @@
-import pkg_resources
-
-import unittest2 as unittest
-
-from plone.testing.z2 import Browser
-
+from cStringIO import StringIO
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.caching.tests.test_utils import stable_now
-from plone.app.textfield.value import RichTextValue
-from plone.app.testing import TEST_USER_ID, TEST_USER_NAME, TEST_USER_PASSWORD
-from plone.app.testing import setRoles
 from plone.app.testing import applyProfile
-
-from cStringIO import StringIO
+from plone.app.testing import setRoles
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
+from plone.app.textfield.value import RichTextValue
+from plone.cachepurging.interfaces import ICachePurgingSettings
+from plone.caching.interfaces import ICacheSettings
+from plone.registry.interfaces import IRegistry
+from plone.testing.z2 import Browser
+from Products.CMFCore.FSFile import FSFile
+from Products.CMFCore.utils import getToolByName
+from zope.component import getUtility
+from zope.globalrequest import setRequest
 
 import datetime
 import dateutil.parser
 import dateutil.tz
-
+import OFS.Image
 import os
+import pkg_resources
+import unittest2 as unittest
 import urllib
 
-import OFS.Image
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.FSFile import FSFile
-
-from zope.component import getUtility
-
-from zope.globalrequest import setRequest
-
-from plone.registry.interfaces import IRegistry
-from plone.caching.interfaces import ICacheSettings
-from plone.cachepurging.interfaces import ICachePurgingSettings
-from plone.app.caching.interfaces import IPloneCacheSettings
-
-from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 
 TEST_FILE = pkg_resources.resource_filename('plone.app.caching.tests', 'test.gif')
 
diff --git a/plone/app/caching/tests/test_purge.py b/plone/app/caching/tests/test_purge.py
index d35cc2e..3980d75 100644
--- a/plone/app/caching/tests/test_purge.py
+++ b/plone/app/caching/tests/test_purge.py
@@ -1,48 +1,39 @@
-import unittest2 as unittest
+from Acquisition import aq_base
+from Acquisition import Explicit
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.purge import ContentPurgePaths
+from plone.app.caching.purge import DiscussionItemPurgePaths
+from plone.app.caching.purge import ObjectFieldPurgePaths
+from plone.app.caching.purge import purgeOnModified
+from plone.app.caching.purge import purgeOnMovedOrRemoved
+from plone.registry import Registry
+from plone.registry.fieldfactory import persistentFieldAdapter
+from plone.registry.interfaces import IRegistry
 from plone.testing.zca import UNIT_TESTING
-
-from zope.interface import implementer
-
-from zope.component import getUtility
+from Products.Archetypes import atapi
+from Products.Archetypes.Schema.factory import instanceSchemaFactory
+from Products.CMFCore.interfaces import IContentish
+from Products.CMFCore.interfaces import IDiscussionResponse
+from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+from z3c.caching.interfaces import IPurgeEvent
+from z3c.caching.interfaces import IPurgePaths
 from zope.component import adapter
 from zope.component import adapts
+from zope.component import getUtility
+from zope.component import provideAdapter
 from zope.component import provideHandler
 from zope.component import provideUtility
-from zope.component import provideAdapter
-
 from zope.component.event import objectEventNotify
-
 from zope.event import notify
-
-from zope.lifecycleevent import ObjectModifiedEvent
+from zope.globalrequest import setRequest
+from zope.interface import implementer
 from zope.lifecycleevent import ObjectAddedEvent
-from zope.lifecycleevent import ObjectRemovedEvent
+from zope.lifecycleevent import ObjectModifiedEvent
 from zope.lifecycleevent import ObjectMovedEvent
+from zope.lifecycleevent import ObjectRemovedEvent
 
-from zope.globalrequest import setRequest
-
-from plone.registry.interfaces import IRegistry
-from plone.registry.fieldfactory import persistentFieldAdapter
-from plone.registry import Registry
-
-from z3c.caching.interfaces import IPurgeEvent
-from z3c.caching.interfaces import IPurgePaths
-
-from plone.app.caching.interfaces import IPloneCacheSettings
-
-from Acquisition import Explicit, aq_base
-from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
-from Products.CMFCore.interfaces import IContentish
-from Products.CMFCore.interfaces import IDiscussionResponse
-from Products.Archetypes import atapi
-from Products.Archetypes.Schema.factory import instanceSchemaFactory
-
-from plone.app.caching.purge import purgeOnModified
-from plone.app.caching.purge import purgeOnMovedOrRemoved
+import unittest2 as unittest
 
-from plone.app.caching.purge import ContentPurgePaths
-from plone.app.caching.purge import DiscussionItemPurgePaths
-from plone.app.caching.purge import ObjectFieldPurgePaths
 
 class Handler(object):
 
diff --git a/plone/app/caching/tests/test_utils.py b/plone/app/caching/tests/test_utils.py
index fd8261a..d23c44b 100644
--- a/plone/app/caching/tests/test_utils.py
+++ b/plone/app/caching/tests/test_utils.py
@@ -1,6 +1,5 @@
 from Acquisition import Explicit
-from Products.CMFCore.interfaces import IDynamicType
-from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+from datetime import datetime
 from plone.app.caching.interfaces import IPloneCacheSettings
 from plone.app.caching.utils import getObjectDefaultView
 from plone.app.caching.utils import isPurged
@@ -8,8 +7,11 @@
 from plone.registry.fieldfactory import persistentFieldAdapter
 from plone.registry.interfaces import IRegistry
 from plone.testing.zca import UNIT_TESTING
-from datetime import datetime
-from zope.component import provideUtility, provideAdapter, getUtility
+from Products.CMFCore.interfaces import IDynamicType
+from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+from zope.component import getUtility
+from zope.component import provideAdapter
+from zope.component import provideUtility
 from zope.interface import implementer
 
 import pytz
diff --git a/plone/app/caching/utils.py b/plone/app/caching/utils.py
index ad37cc6..3f0bb03 100644
--- a/plone/app/caching/utils.py
+++ b/plone/app/caching/utils.py
@@ -1,11 +1,10 @@
-from zope.component import queryUtility
-
-from plone.registry.interfaces import IRegistry
-from plone.app.caching.interfaces import IPloneCacheSettings
-
 from Acquisition import aq_base
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.registry.interfaces import IRegistry
 from Products.CMFCore.interfaces import IDynamicType
 from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+from zope.component import queryUtility
+
 
 def isPurged(object):
     """Determine if object is of a content type that should be purged.
diff --git a/setup.cfg b/setup.cfg
index 0278fad..ec22f27 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -10,3 +10,11 @@ upload-dir = docs/html
 ignore =
     bootstrap.py
     buildout.cfg
+
+[isort]
+force_alphabetical_sort=True
+force_single_line=True
+lines_after_imports=2
+line_length=200
+not_skip=__init__.py
+


Repository: plone.app.caching


Branch: refs/heads/master
Date: 2016-09-27T15:16:09+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.caching/commit/c8a0cafd29f5d1c0737b78b3474e83fb4d828c08

utf8 headers

Files changed:
M plone/__init__.py
M plone/app/__init__.py
M plone/app/caching/browser/controlpanel.py
M plone/app/caching/browser/edit.py
M plone/app/caching/interfaces.py
M plone/app/caching/lastmodified.py
M plone/app/caching/lookup.py
M plone/app/caching/operations/default.py
M plone/app/caching/operations/etags.py
M plone/app/caching/operations/ramcache.py
M plone/app/caching/operations/utils.py
M plone/app/caching/purge.py
M plone/app/caching/setuphandlers.py
M plone/app/caching/testing.py
M plone/app/caching/tests/test_etags.py
M plone/app/caching/tests/test_integration.py
M plone/app/caching/tests/test_lastmodified.py
M plone/app/caching/tests/test_lookup.py
M plone/app/caching/tests/test_operation_default.py
M plone/app/caching/tests/test_operation_parameters.py
M plone/app/caching/tests/test_operation_utils.py
M plone/app/caching/tests/test_profile_with_caching_proxy.py
M plone/app/caching/tests/test_profile_without_caching_proxy.py
M plone/app/caching/tests/test_purge.py
M plone/app/caching/tests/test_utils.py
M plone/app/caching/utils.py

diff --git a/plone/__init__.py b/plone/__init__.py
index de40ea7..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1 +1,2 @@
+# -*- coding: utf-8 -*-
 __import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/app/__init__.py b/plone/app/__init__.py
index de40ea7..68c04af 100644
--- a/plone/app/__init__.py
+++ b/plone/app/__init__.py
@@ -1 +1,2 @@
+# -*- coding: utf-8 -*-
 __import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/app/caching/browser/controlpanel.py b/plone/app/caching/browser/controlpanel.py
index 3456b80..5e4583d 100644
--- a/plone/app/caching/browser/controlpanel.py
+++ b/plone/app/caching/browser/controlpanel.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.app.caching.browser.edit import EditForm
 from plone.app.caching.interfaces import _
 from plone.app.caching.interfaces import ICacheProfiles
diff --git a/plone/app/caching/browser/edit.py b/plone/app/caching/browser/edit.py
index a6f6ddb..7c472b3 100644
--- a/plone/app/caching/browser/edit.py
+++ b/plone/app/caching/browser/edit.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.app.caching.interfaces import _
 from plone.memoize.instance import memoize
 from plone.registry import FieldRef
diff --git a/plone/app/caching/interfaces.py b/plone/app/caching/interfaces.py
index 46fab81..ea762b4 100644
--- a/plone/app/caching/interfaces.py
+++ b/plone/app/caching/interfaces.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from zope import schema
 from zope.interface import Interface
 
diff --git a/plone/app/caching/lastmodified.py b/plone/app/caching/lastmodified.py
index a835808..2ecf1dd 100644
--- a/plone/app/caching/lastmodified.py
+++ b/plone/app/caching/lastmodified.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Acquisition import aq_base
 from Acquisition import aq_inner
 from Acquisition import aq_parent
diff --git a/plone/app/caching/lookup.py b/plone/app/caching/lookup.py
index 102e55f..4232249 100644
--- a/plone/app/caching/lookup.py
+++ b/plone/app/caching/lookup.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Acquisition import aq_base
 from plone.app.caching.interfaces import IPloneCacheSettings
 from plone.app.caching.utils import getObjectDefaultView
diff --git a/plone/app/caching/operations/default.py b/plone/app/caching/operations/default.py
index dce359a..3337f5d 100644
--- a/plone/app/caching/operations/default.py
+++ b/plone/app/caching/operations/default.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.app.caching.interfaces import _
 from plone.app.caching.operations.utils import cachedResponse
 from plone.app.caching.operations.utils import cacheInRAM
diff --git a/plone/app/caching/operations/etags.py b/plone/app/caching/operations/etags.py
index 4e61040..a82b987 100644
--- a/plone/app/caching/operations/etags.py
+++ b/plone/app/caching/operations/etags.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.app.caching.interfaces import IETagValue
 from plone.app.caching.interfaces import IPloneCacheSettings
 from plone.app.caching.operations.utils import getContext
diff --git a/plone/app/caching/operations/ramcache.py b/plone/app/caching/operations/ramcache.py
index 50ea391..2d7671f 100644
--- a/plone/app/caching/operations/ramcache.py
+++ b/plone/app/caching/operations/ramcache.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.app.caching.interfaces import IRAMCached
 from plone.app.caching.operations.utils import storeResponseInRAMCache
 from plone.transformchain.interfaces import ITransform
diff --git a/plone/app/caching/operations/utils.py b/plone/app/caching/operations/utils.py
index 3679e38..2e51c88 100644
--- a/plone/app/caching/operations/utils.py
+++ b/plone/app/caching/operations/utils.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from AccessControl.PermissionRole import rolesForPermissionOn
 from plone.app.caching.interfaces import IETagValue
 from plone.app.caching.interfaces import IPloneCacheSettings
diff --git a/plone/app/caching/purge.py b/plone/app/caching/purge.py
index 078d693..80a50fc 100644
--- a/plone/app/caching/purge.py
+++ b/plone/app/caching/purge.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Acquisition import aq_parent
 from plone.app.caching.utils import getObjectDefaultView
 from plone.app.caching.utils import isPurged
diff --git a/plone/app/caching/setuphandlers.py b/plone/app/caching/setuphandlers.py
index fe67ae0..9d2f5c1 100644
--- a/plone/app/caching/setuphandlers.py
+++ b/plone/app/caching/setuphandlers.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Products.CMFCore.utils import getToolByName
 
 
diff --git a/plone/app/caching/testing.py b/plone/app/caching/testing.py
index 9e14db8..623631e 100644
--- a/plone/app/caching/testing.py
+++ b/plone/app/caching/testing.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from hashlib import sha1 as sha
 from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE
 from plone.app.testing import applyProfile
diff --git a/plone/app/caching/tests/test_etags.py b/plone/app/caching/tests/test_etags.py
index df1d73e..504d24d 100644
--- a/plone/app/caching/tests/test_etags.py
+++ b/plone/app/caching/tests/test_etags.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Acquisition import Explicit
 from datetime import datetime
 from dateutil.tz import tzlocal
diff --git a/plone/app/caching/tests/test_integration.py b/plone/app/caching/tests/test_integration.py
index 1336747..ab852e9 100644
--- a/plone/app/caching/tests/test_integration.py
+++ b/plone/app/caching/tests/test_integration.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.app.caching.interfaces import IPloneCacheSettings
 from plone.app.caching.testing import getToken
 from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
diff --git a/plone/app/caching/tests/test_lastmodified.py b/plone/app/caching/tests/test_lastmodified.py
index e8b1aee..028ab5f 100644
--- a/plone/app/caching/tests/test_lastmodified.py
+++ b/plone/app/caching/tests/test_lastmodified.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from dateutil.tz import tzlocal
 from persistent.TimeStamp import TimeStamp
 from plone.app.caching import lastmodified
diff --git a/plone/app/caching/tests/test_lookup.py b/plone/app/caching/tests/test_lookup.py
index 8f6915f..d57f954 100644
--- a/plone/app/caching/tests/test_lookup.py
+++ b/plone/app/caching/tests/test_lookup.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Acquisition import Explicit
 from plone.app.caching.interfaces import IPloneCacheSettings
 from plone.app.caching.lookup import ContentItemLookup
diff --git a/plone/app/caching/tests/test_operation_default.py b/plone/app/caching/tests/test_operation_default.py
index f3a6a1f..8c79997 100644
--- a/plone/app/caching/tests/test_operation_default.py
+++ b/plone/app/caching/tests/test_operation_default.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.app.caching.testing import getToken
 from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.testing import setRoles
diff --git a/plone/app/caching/tests/test_operation_parameters.py b/plone/app/caching/tests/test_operation_parameters.py
index 8380e81..2bf0b2c 100644
--- a/plone/app/caching/tests/test_operation_parameters.py
+++ b/plone/app/caching/tests/test_operation_parameters.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.testing import setRoles
 from plone.app.testing import TEST_USER_ID
diff --git a/plone/app/caching/tests/test_operation_utils.py b/plone/app/caching/tests/test_operation_utils.py
index 4ea16c1..a5d90d6 100644
--- a/plone/app/caching/tests/test_operation_utils.py
+++ b/plone/app/caching/tests/test_operation_utils.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from OFS.SimpleItem import SimpleItem
 from plone.memoize.interfaces import ICacheChooser
 from plone.testing.zca import UNIT_TESTING
diff --git a/plone/app/caching/tests/test_profile_with_caching_proxy.py b/plone/app/caching/tests/test_profile_with_caching_proxy.py
index 8228c4f..9143980 100644
--- a/plone/app/caching/tests/test_profile_with_caching_proxy.py
+++ b/plone/app/caching/tests/test_profile_with_caching_proxy.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from cStringIO import StringIO
 from plone.app.caching.interfaces import IPloneCacheSettings
 from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
diff --git a/plone/app/caching/tests/test_profile_without_caching_proxy.py b/plone/app/caching/tests/test_profile_without_caching_proxy.py
index e5b7026..f8848a1 100644
--- a/plone/app/caching/tests/test_profile_without_caching_proxy.py
+++ b/plone/app/caching/tests/test_profile_without_caching_proxy.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from cStringIO import StringIO
 from plone.app.caching.interfaces import IPloneCacheSettings
 from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
diff --git a/plone/app/caching/tests/test_purge.py b/plone/app/caching/tests/test_purge.py
index 3980d75..3d046bf 100644
--- a/plone/app/caching/tests/test_purge.py
+++ b/plone/app/caching/tests/test_purge.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Acquisition import aq_base
 from Acquisition import Explicit
 from plone.app.caching.interfaces import IPloneCacheSettings
diff --git a/plone/app/caching/tests/test_utils.py b/plone/app/caching/tests/test_utils.py
index d23c44b..925baec 100644
--- a/plone/app/caching/tests/test_utils.py
+++ b/plone/app/caching/tests/test_utils.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Acquisition import Explicit
 from datetime import datetime
 from plone.app.caching.interfaces import IPloneCacheSettings
diff --git a/plone/app/caching/utils.py b/plone/app/caching/utils.py
index 3f0bb03..9317c05 100644
--- a/plone/app/caching/utils.py
+++ b/plone/app/caching/utils.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Acquisition import aq_base
 from plone.app.caching.interfaces import IPloneCacheSettings
 from plone.registry.interfaces import IRegistry


Repository: plone.app.caching


Branch: refs/heads/master
Date: 2016-09-27T15:17:15+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.caching/commit/bdde6444168ff37fe1a81d85c7457e1ef861aad3

autopep8 -ir

Files changed:
M plone/app/caching/browser/controlpanel.py
M plone/app/caching/browser/edit.py
M plone/app/caching/interfaces.py
M plone/app/caching/lastmodified.py
M plone/app/caching/lookup.py
M plone/app/caching/operations/default.py
M plone/app/caching/operations/etags.py
M plone/app/caching/operations/ramcache.py
M plone/app/caching/operations/utils.py
M plone/app/caching/purge.py
M plone/app/caching/setuphandlers.py
M plone/app/caching/testing.py
M plone/app/caching/tests/test_etags.py
M plone/app/caching/tests/test_integration.py
M plone/app/caching/tests/test_lastmodified.py
M plone/app/caching/tests/test_lookup.py
M plone/app/caching/tests/test_operation_default.py
M plone/app/caching/tests/test_operation_parameters.py
M plone/app/caching/tests/test_operation_utils.py
M plone/app/caching/tests/test_profile_with_caching_proxy.py
M plone/app/caching/tests/test_profile_without_caching_proxy.py
M plone/app/caching/tests/test_purge.py
M plone/app/caching/tests/test_utils.py
M plone/app/caching/utils.py

diff --git a/plone/app/caching/browser/controlpanel.py b/plone/app/caching/browser/controlpanel.py
index 5e4583d..0977731 100644
--- a/plone/app/caching/browser/controlpanel.py
+++ b/plone/app/caching/browser/controlpanel.py
@@ -56,7 +56,8 @@ def update(self):
         self.registry = getUtility(IRegistry)
         self.settings = self.registry.forInterface(ICacheSettings)
         self.ploneSettings = self.registry.forInterface(IPloneCacheSettings)
-        self.purgingSettings = self.registry.forInterface(ICachePurgingSettings)
+        self.purgingSettings = self.registry.forInterface(
+            ICachePurgingSettings)
         self.ramCache = queryUtility(IRAMCache)
 
         if self.request.method == 'POST':
@@ -113,7 +114,8 @@ def publishTraverse(self, request, name):
 
             if self.editGlobal:
 
-                operation = queryUtility(ICachingOperationType, name=self.editOperationName)
+                operation = queryUtility(
+                    ICachingOperationType, name=self.editOperationName)
                 if operation is None:
                     raise NotFound(self, operation)
 
@@ -127,7 +129,8 @@ def publishTraverse(self, request, name):
         if self.editRuleset and self.editOperationName and not self.editRulesetName:
             self.editRulesetName = name
 
-            operation = queryUtility(ICachingOperationType, name=self.editOperationName)
+            operation = queryUtility(
+                ICachingOperationType, name=self.editOperationName)
             if operation is None:
                 raise NotFound(self, self.operationName)
 
@@ -255,7 +258,8 @@ def processSave(self):
 
         for domain in domains:
             if not _isuri(domain):
-                self.errors['domain'] = _(u"Invalid URL: ${url}", mapping={'url': domain})
+                self.errors['domain'] = _(
+                    u"Invalid URL: ${url}", mapping={'url': domain})
 
         # RAM cache settings
 
@@ -265,7 +269,8 @@ def processSave(self):
             self.errors['ramCacheMaxEntries'] = _(u"An integer is required.")
         else:
             if ramCacheMaxEntries < 0:
-                self.errors['ramCacheMaxEntries'] = _(u"A positive number is required.")
+                self.errors['ramCacheMaxEntries'] = _(
+                    u"A positive number is required.")
 
         try:
             ramCacheMaxAge = int(ramCacheMaxAge)
@@ -273,19 +278,23 @@ def processSave(self):
             self.errors['ramCacheMaxAge'] = _(u"An integer is required.")
         else:
             if ramCacheMaxAge < 0:
-                self.errors['ramCacheMaxAge'] = _(u"A positive number is required.")
+                self.errors['ramCacheMaxAge'] = _(
+                    u"A positive number is required.")
 
         try:
             ramCacheCleanupInterval = int(ramCacheCleanupInterval)
         except (ValueError, TypeError,):
-            self.errors['ramCacheCleanupInterval'] = _(u"An integer is required.")
+            self.errors['ramCacheCleanupInterval'] = _(
+                u"An integer is required.")
         else:
             if ramCacheMaxAge < 0:
-                self.errors['ramCacheCleanupInterval'] = _(u"A positive number is required.")
+                self.errors['ramCacheCleanupInterval'] = _(
+                    u"A positive number is required.")
 
         # Check for errors
         if self.errors:
-            IStatusMessage(self.request).addStatusMessage(_(u"There were errors."), "error")
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"There were errors."), "error")
             return
 
         # Save settings
@@ -301,9 +310,11 @@ def processSave(self):
         self.purgingSettings.virtualHosting = virtualHosting
         self.purgingSettings.domains = domains
 
-        self.ramCache.update(ramCacheMaxEntries, ramCacheMaxAge, ramCacheCleanupInterval)
+        self.ramCache.update(ramCacheMaxEntries,
+                             ramCacheMaxAge, ramCacheCleanupInterval)
 
-        IStatusMessage(self.request).addStatusMessage(_(u"Changes saved."), "info")
+        IStatusMessage(self.request).addStatusMessage(
+            _(u"Changes saved."), "info")
 
     # Rule types - used as the index column
     @property
@@ -368,7 +379,8 @@ def contentTypesLookup(self):
         types = {}
         portal_types = getToolByName(self.context, 'portal_types')
         for fti in portal_types.objectValues():
-            types[fti.id] = dict(title=fti.title or fti.id, description=fti.description)
+            types[fti.id] = dict(title=fti.title or fti.id,
+                                 description=fti.description)
         return types
 
     # Sorted lists (e.g. for drop-downs)
@@ -377,7 +389,8 @@ def contentTypesLookup(self):
     @memoize
     def operationTypes(self):
         operations = [v for k, v in self.operationTypesLookup.items()]
-        operations.sort(lambda x, y: (cmp(x['sort'], y['sort']) or cmp(x['title'], y['title'])))
+        operations.sort(lambda x, y: (
+            cmp(x['sort'], y['sort']) or cmp(x['title'], y['title'])))
         return operations
 
     @property
@@ -463,7 +476,8 @@ def processImport(self):
             self.errors['profile'] = _(u"You must select a profile to import.")
 
         if self.errors:
-            IStatusMessage(self.request).addStatusMessage(_(u"There were errors."), "error")
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"There were errors."), "error")
             return
 
         portal_setup = getToolByName(self.context, 'portal_setup')
@@ -477,7 +491,8 @@ def processImport(self):
         # Import the new profile
         portal_setup.runAllImportStepsFromProfile("profile-%s" % profile)
 
-        IStatusMessage(self.request).addStatusMessage(_(u"Import complete."), "info")
+        IStatusMessage(self.request).addStatusMessage(
+            _(u"Import complete."), "info")
 
     @property
     @memoize
@@ -490,6 +505,7 @@ def profiles(self):
 class Purge(BaseView):
     """The purge control panel
     """
+
     def update(self):
         self.purgeLog = []
 
@@ -505,7 +521,8 @@ def processPurge(self):
             self.errors['urls'] = _(u"No URLs or paths entered.")
 
         if self.errors:
-            IStatusMessage(self.request).addStatusMessage(_(u"There were errors."), "error")
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"There were errors."), "error")
             return
 
         purger = getUtility(IPurger)
@@ -581,11 +598,14 @@ def update(self):
     def processPurge(self):
 
         if self.ramCache is None:
-            IStatusMessage(self.request).addStatusMessage(_(u"RAM cache not installed."), "error")
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"RAM cache not installed."), "error")
 
         if self.errors:
-            IStatusMessage(self.request).addStatusMessage(_(u"There were errors."), "error")
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"There were errors."), "error")
             return
 
         self.ramCache.invalidateAll()
-        IStatusMessage(self.request).addStatusMessage(_(u"Cache purged."), "info")
+        IStatusMessage(self.request).addStatusMessage(
+            _(u"Cache purged."), "info")
diff --git a/plone/app/caching/browser/edit.py b/plone/app/caching/browser/edit.py
index 7c472b3..bf4ec1a 100644
--- a/plone/app/caching/browser/edit.py
+++ b/plone/app/caching/browser/edit.py
@@ -55,7 +55,8 @@ class EditForm(form.Form):
 
     template = ViewPageTemplateFile('edit.pt')
 
-    # Keep the ZPublisher happy - would normally be done by the ZCML registration
+    # Keep the ZPublisher happy - would normally be done by the ZCML
+    # registration
     __name__ = 'cache-operation-edit'
 
     def __init__(self, context, request, operationName, operation, rulesetName=None, ruleset=None):
@@ -70,7 +71,8 @@ def update(self):
 
         self.registry = getUtility(IRegistry)
 
-        # If we were using plone.z3cform, this would be done with z2.switch_on()
+        # If we were using plone.z3cform, this would be done with
+        # z2.switch_on()
         if not IFormLayer.providedBy(self.request):
             alsoProvides(self.request, IFormLayer)
 
@@ -88,18 +90,22 @@ def update(self):
             fieldName = "%s.%s" % (prefix, option)
 
             if self.rulesetName:
-                rulesetFieldName = "%s.%s.%s" % (prefix, self.rulesetName, option)
+                rulesetFieldName = "%s.%s.%s" % (
+                    prefix, self.rulesetName, option)
 
                 if rulesetFieldName in self.registry.records:
-                    newField = self.cloneField(self.registry.records[rulesetFieldName].field)
+                    newField = self.cloneField(self.registry.records[
+                                               rulesetFieldName].field)
                     newField.__name__ = rulesetFieldName
                 elif fieldName in self.registry.records:
-                    newField = self.cloneField(self.registry.records[fieldName].field)
+                    newField = self.cloneField(
+                        self.registry.records[fieldName].field)
                     newField.__name__ = rulesetFieldName
 
             else:
                 if fieldName in self.registry.records:
-                    newField = self.cloneField(self.registry.records[fieldName].field)
+                    newField = self.cloneField(
+                        self.registry.records[fieldName].field)
                     newField.__name__ = fieldName
 
             if newField is not None:
@@ -142,10 +148,12 @@ def getContent(self):
             # as necessary in applyChanges()
 
             if self.rulesetName:
-                rulesetRecordName = "%s.%s.%s" % (prefix, self.rulesetName, option,)
+                rulesetRecordName = "%s.%s.%s" % (
+                    prefix, self.rulesetName, option,)
 
                 if rulesetRecordName in self.registry.records:
-                    context[rulesetRecordName] = self.registry[rulesetRecordName]
+                    context[rulesetRecordName] = self.registry[
+                        rulesetRecordName]
                 elif recordName in self.registry.records:
                     context[rulesetRecordName] = self.registry[recordName]
 
@@ -171,12 +179,15 @@ def applyChanges(self, data):
                 # Strip the ruleset name out, leaving the original key - this
                 # must exist, otherwise getContent() would not have put it in
                 # the data dictionary
-                globalKey = self.operation.prefix + key[len(self.operation.prefix) + len(self.rulesetName) + 1:]
+                globalKey = self.operation.prefix + \
+                    key[len(self.operation.prefix) +
+                        len(self.rulesetName) + 1:]
                 assert globalKey in self.registry.records
 
                 # Create a new record with a FieldRef
                 field = self.registry.records[globalKey].field
-                self.registry.records[key] = Record(FieldRef(globalKey, field), value)
+                self.registry.records[key] = Record(
+                    FieldRef(globalKey, field), value)
 
             else:
                 self.registry[key] = value
@@ -205,11 +216,11 @@ def cloneField(self, field):
     def title(self):
         if self.rulesetName:
             return _(u"Edit ${operation} options for Ruleset: ${ruleset}",
-                        mapping={'operation': self.operation.title,
-                                 'ruleset': self.ruleset.title})
+                     mapping={'operation': self.operation.title,
+                              'ruleset': self.ruleset.title})
         else:
             return _(u"Edit ${operation} options",
-                        mapping={'operation': self.operation.title})
+                     mapping={'operation': self.operation.title})
 
     @property
     def description(self):
@@ -224,23 +235,30 @@ def save(self, action):
             self.status = self.formErrorsMessage
             return
         self.applyChanges(data)
-        IStatusMessage(self.request).addStatusMessage(_(u"Changes saved."), "info")
-        self.request.response.redirect("%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
+        IStatusMessage(self.request).addStatusMessage(
+            _(u"Changes saved."), "info")
+        self.request.response.redirect(
+            "%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
 
     @button.buttonAndHandler(_(u"Cancel"), name="cancel")
     def cancel(self, action):
-        IStatusMessage(self.request).addStatusMessage(_(u"Edit cancelled."), type="info")
-        self.request.response.redirect("%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
+        IStatusMessage(self.request).addStatusMessage(
+            _(u"Edit cancelled."), type="info")
+        self.request.response.redirect(
+            "%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
         return ''
 
     @button.buttonAndHandler(_(u"Delete settings (use defaults)"), name="clear")
     def clear(self, action):
         for key in self.getContent().keys():
-            assert key.startswith("%s.%s." % (self.operation.prefix, self.rulesetName,))
+            assert key.startswith("%s.%s." % (
+                self.operation.prefix, self.rulesetName,))
 
             if key in self.registry.records:
                 del self.registry.records[key]
 
-        IStatusMessage(self.request).addStatusMessage(_(u"Ruleset-specific settings removed."), type="info")
-        self.request.response.redirect("%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
+        IStatusMessage(self.request).addStatusMessage(
+            _(u"Ruleset-specific settings removed."), type="info")
+        self.request.response.redirect(
+            "%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
         return ''
diff --git a/plone/app/caching/interfaces.py b/plone/app/caching/interfaces.py
index ea762b4..e6eac09 100644
--- a/plone/app/caching/interfaces.py
+++ b/plone/app/caching/interfaces.py
@@ -7,6 +7,7 @@
 
 _ = zope.i18nmessageid.MessageFactory('plone.app.caching')
 
+
 class ICacheProfiles(Interface):
     """Marker interface for extension profiles that contain cache settings.
     These will primarily include a ``registry.xml`` file to configure cache
@@ -27,6 +28,7 @@ class ICacheProfiles(Interface):
     available for installation in the cache settings control panel.
     """
 
+
 class IPloneCacheSettings(Interface):
     """Settings stored in the registry.
 
@@ -36,32 +38,35 @@ class IPloneCacheSettings(Interface):
     """
 
     templateRulesetMapping = schema.Dict(
-            title=_(u"Page template/ruleset mapping"),
-            description=_(u"Maps skin layer page template names to ruleset names"),
-            key_type=schema.ASCIILine(title=_(u"Page template name")),
-            value_type=schema.DottedName(title=_(u"Ruleset name")),
-        )
+        title=_(u"Page template/ruleset mapping"),
+        description=_(u"Maps skin layer page template names to ruleset names"),
+        key_type=schema.ASCIILine(title=_(u"Page template name")),
+        value_type=schema.DottedName(title=_(u"Ruleset name")),
+    )
 
     contentTypeRulesetMapping = schema.Dict(
-            title=_(u"Content type/ruleset mapping"),
-            description=_(u"Maps content type names to ruleset names"),
-            key_type=schema.ASCIILine(title=_(u"Content type name")),
-            value_type=schema.DottedName(title=_(u"Ruleset name")),
-        )
+        title=_(u"Content type/ruleset mapping"),
+        description=_(u"Maps content type names to ruleset names"),
+        key_type=schema.ASCIILine(title=_(u"Content type name")),
+        value_type=schema.DottedName(title=_(u"Ruleset name")),
+    )
 
     purgedContentTypes = schema.Tuple(
-            title=_(u"Content types to purge"),
-            description=_(u"List content types which should be purged when modified"),
-            value_type=schema.ASCIILine(title=_(u"Content type name")),
-            default=('File', 'Image', 'News Item', ),
-        )
+        title=_(u"Content types to purge"),
+        description=_(
+            u"List content types which should be purged when modified"),
+        value_type=schema.ASCIILine(title=_(u"Content type name")),
+        default=('File', 'Image', 'News Item', ),
+    )
 
     cacheStopRequestVariables = schema.Tuple(
-            title=_(u"Request variables that prevent caching"),
-            description=_(u"Variables in the request that prevent caching if present"),
-            value_type=schema.ASCIILine(title=_(u"Request variables")),
-            default=('statusmessages', 'SearchableText',),
-        )
+        title=_(u"Request variables that prevent caching"),
+        description=_(
+            u"Variables in the request that prevent caching if present"),
+        value_type=schema.ASCIILine(title=_(u"Request variables")),
+        default=('statusmessages', 'SearchableText',),
+    )
+
 
 class IETagValue(Interface):
     """ETag component builder
@@ -76,6 +81,7 @@ def __call__():
         """Return the ETag component, as a string.
         """
 
+
 class IRAMCached(Interface):
     """Marker interface applied to the request if it should be RAM cached.
 
diff --git a/plone/app/caching/lastmodified.py b/plone/app/caching/lastmodified.py
index 2ecf1dd..5570e1b 100644
--- a/plone/app/caching/lastmodified.py
+++ b/plone/app/caching/lastmodified.py
@@ -28,9 +28,6 @@ class IDCTimes(Interface):
         pass
 
 
-
-
-
 @implementer(ILastModified)
 @adapter(IPageTemplate)
 def PageTemplateDelegateLastModified(template):
@@ -40,6 +37,7 @@ def PageTemplateDelegateLastModified(template):
     """
     return ILastModified(template.__parent__, None)
 
+
 @implementer(ILastModified)
 @adapter(FSPageTemplate)
 def FSPageTemplateDelegateLastModified(template):
@@ -49,6 +47,7 @@ def FSPageTemplateDelegateLastModified(template):
     """
     return PageTemplateDelegateLastModified(template)
 
+
 @implementer(ILastModified)
 class PersistentLastModified(object):
     """General ILastModified adapter for persistent objects that have a
@@ -68,11 +67,13 @@ def __call__(self):
             return datetime.fromtimestamp(mtime, tzlocal())
         return None
 
+
 class OFSFileLastModified(PersistentLastModified):
     """ILastModified adapter for OFS.Image.File
     """
     adapts(File)
 
+
 @implementer(ILastModified)
 class ImageScaleLastModified(object):
     """ILastModified adapter for Products.Archetypes.Field.Image
@@ -88,6 +89,7 @@ def __call__(self):
             return ILastModified(parent)()
         return None
 
+
 @implementer(ILastModified)
 class FSObjectLastModified(object):
     """ILastModified adapter for FSFile and FSImage
@@ -105,6 +107,7 @@ def __call__(self):
         mtime = self.context._file_mod_time
         return datetime.fromtimestamp(mtime, tzlocal())
 
+
 @implementer(ILastModified)
 class CatalogableDublinCoreLastModified(object):
     """ILastModified adapter for ICatalogableDublinCore, which includes
@@ -121,6 +124,7 @@ def __call__(self):
             return None
         return modified.asdatetime()
 
+
 @implementer(ILastModified)
 class DCTimesLastModified(object):
     """ILastModified adapter for zope.dublincore IDCTimes
@@ -133,6 +137,7 @@ def __init__(self, context):
     def __call__(self):
         return self.context.modified
 
+
 @implementer(ILastModified)
 class ResourceLastModified(object):
     """ILastModified for Zope 3 style browser resources
@@ -148,6 +153,7 @@ def __call__(self):
             return datetime.fromtimestamp(lmt, tzlocal())
         return None
 
+
 @implementer(ILastModified)
 class CookedFileLastModified(object):
     """ILastModified for Resource Registry `cooked` files
diff --git a/plone/app/caching/lookup.py b/plone/app/caching/lookup.py
index 4232249..a3a5f5d 100644
--- a/plone/app/caching/lookup.py
+++ b/plone/app/caching/lookup.py
@@ -65,7 +65,8 @@ def __call__(self):
         if registry is None:
             return None
 
-        ploneCacheSettings = registry.forInterface(IPloneCacheSettings, check=False)
+        ploneCacheSettings = registry.forInterface(
+            IPloneCacheSettings, check=False)
 
         # 2. Get the name of the published object
         name = getattr(self.published, '__name__', None)
@@ -89,16 +90,20 @@ def __call__(self):
                 # 4.1.1. Get the default view of the parent content object
                 defaultView = getObjectDefaultView(parent)
 
-                # 4.1.2. If the name of the published object is the same as the default view of the parent:
+                # 4.1.2. If the name of the published object is the same as the
+                # default view of the parent:
                 if defaultView == name:
 
-                    # 4.1.2.1. Look up the parent type in the content type mapping
+                    # 4.1.2.1. Look up the parent type in the content type
+                    # mapping
                     if ploneCacheSettings.contentTypeRulesetMapping is not None:
-                        ruleset = ploneCacheSettings.contentTypeRulesetMapping.get(parentPortalType, None)
+                        ruleset = ploneCacheSettings.contentTypeRulesetMapping.get(
+                            parentPortalType, None)
                         if ruleset is not None:
                             return ruleset
 
-                    # 4.1.2.2. Look up a ruleset on the parent object and return
+                    # 4.1.2.2. Look up a ruleset on the parent object and
+                    # return
                     ruleset = lookup(parent)
                     if ruleset is not None:
                         return ruleset
diff --git a/plone/app/caching/operations/default.py b/plone/app/caching/operations/default.py
index 3337f5d..2e97c51 100644
--- a/plone/app/caching/operations/default.py
+++ b/plone/app/caching/operations/default.py
@@ -33,6 +33,7 @@
 except ImportError:
     HAVE_RESOURCE_REGISTRIES = False
 
+
 @implementer(ICachingOperation)
 @provider(ICachingOperationType)
 class BaseCaching(object):
@@ -67,7 +68,8 @@ class BaseCaching(object):
                     u"to use one of the other simpler operations (Strong caching, "
                     u"Moderate caching, Weak caching, or No caching).")
     prefix = 'plone.app.caching.baseCaching'
-    options = ('maxage','smaxage','etags','lastModified','ramCache', 'vary', 'anonOnly')
+    options = ('maxage', 'smaxage', 'etags', 'lastModified',
+               'ramCache', 'vary', 'anonOnly')
 
     # Default option values
     maxage = smaxage = etags = vary = None
@@ -80,9 +82,9 @@ def __init__(self, published, request):
     def interceptResponse(self, rulename, response, class_=None):
         options = lookupOptions(class_ or self.__class__, rulename)
 
-        etags        = options.get('etags') or self.etags
-        anonOnly     = options.get('anonOnly', self.anonOnly)
-        ramCache     = options.get('ramCache', self.ramCache)
+        etags = options.get('etags') or self.etags
+        anonOnly = options.get('anonOnly', self.anonOnly)
+        ramCache = options.get('ramCache', self.ramCache)
         lastModified = options.get('lastModified', self.lastModified)
 
         # Add the ``anonymousOrRandom`` etag if we are anonymous only
@@ -93,7 +95,8 @@ def interceptResponse(self, rulename, response, class_=None):
                 etags = tuple(etags) + ('anonymousOrRandom',)
 
         etag = getETagAnnotation(self.published, self.request, keys=etags)
-        lastModified = getLastModifiedAnnotation(self.published, self.request, lastModified=lastModified)
+        lastModified = getLastModifiedAnnotation(
+            self.published, self.request, lastModified=lastModified)
 
         # Check for cache stop request variables
         if cacheStop(self.request, rulename):
@@ -106,10 +109,12 @@ def interceptResponse(self, rulename, response, class_=None):
         # Check if this is in the ram cache
         if ramCache:
             context = getContext(self.published)
-            portal_state = getMultiAdapter((context, self.request), name=u'plone_portal_state')
+            portal_state = getMultiAdapter(
+                (context, self.request), name=u'plone_portal_state')
 
             if portal_state.anonymous():
-                cached = fetchFromRAMCache(self.request, etag=etag, lastModified=lastModified)
+                cached = fetchFromRAMCache(
+                    self.request, etag=etag, lastModified=lastModified)
                 if cached is not None:
                     return cachedResponse(self.published, self.request, response, *cached)
 
@@ -118,13 +123,13 @@ def interceptResponse(self, rulename, response, class_=None):
     def modifyResponse(self, rulename, response, class_=None):
         options = lookupOptions(class_ or self.__class__, rulename)
 
-        maxage   = options.get('maxage', self.maxage)
-        smaxage  = options.get('smaxage', self.smaxage)
-        etags    = options.get('etags') or self.etags
+        maxage = options.get('maxage', self.maxage)
+        smaxage = options.get('smaxage', self.smaxage)
+        etags = options.get('etags') or self.etags
 
         anonOnly = options.get('anonOnly', self.anonOnly)
         ramCache = options.get('ramCache', self.ramCache)
-        vary     = options.get('vary', self.vary)
+        vary = options.get('vary', self.vary)
 
         # Add the ``anonymousOrRandom`` etag if we are anonymous only
         if anonOnly:
@@ -134,7 +139,8 @@ def modifyResponse(self, rulename, response, class_=None):
                 etags = tuple(etags) + ('anonymousOrRandom',)
 
         etag = getETagAnnotation(self.published, self.request, etags)
-        lastModified = getLastModifiedAnnotation(self.published, self.request, options['lastModified'])
+        lastModified = getLastModifiedAnnotation(
+            self.published, self.request, options['lastModified'])
 
         # Check for cache stop request variables
         if cacheStop(self.request, rulename):
@@ -154,7 +160,8 @@ def modifyResponse(self, rulename, response, class_=None):
             if etags is not None:
                 if 'userid' in etags or 'anonymousOrRandom' in etags or 'roles' in etags:
                     context = getContext(self.published)
-                    portal_state = getMultiAdapter((context, self.request), name=u'plone_portal_state')
+                    portal_state = getMultiAdapter(
+                        (context, self.request), name=u'plone_portal_state')
                     public = portal_state.anonymous()
             public = public and visibleToRole(self.published, role='Anonymous')
 
@@ -163,10 +170,11 @@ def modifyResponse(self, rulename, response, class_=None):
             maxage = smaxage = 0
 
         setCacheHeaders(self.published, self.request, response, maxage=maxage, smaxage=smaxage,
-            etag=etag, lastModified=lastModified, vary=vary)
+                        etag=etag, lastModified=lastModified, vary=vary)
 
         if ramCache and public:
-            cacheInRAM(self.published, self.request, response, etag=etag, lastModified=lastModified)
+            cacheInRAM(self.published, self.request, response,
+                       etag=etag, lastModified=lastModified)
 
 
 @provider(ICachingOperationType)
@@ -187,13 +195,14 @@ class WeakCaching(BaseCaching):
     sort = 3
 
     # Configurable options
-    options = ('etags','lastModified','ramCache','vary', 'anonOnly')
+    options = ('etags', 'lastModified', 'ramCache', 'vary', 'anonOnly')
 
     # Default option values
     maxage = 0
     smaxage = etags = vary = None
     lastModified = ramCache = anonOnly = False
 
+
 @provider(ICachingOperationType)
 class ModerateCaching(BaseCaching):
     """Moderate caching operation. A subclass of the generic BaseCaching
@@ -211,7 +220,8 @@ class ModerateCaching(BaseCaching):
     sort = 2
 
     # Configurable options
-    options = ('smaxage','etags','lastModified','ramCache','vary', 'anonOnly')
+    options = ('smaxage', 'etags', 'lastModified',
+               'ramCache', 'vary', 'anonOnly')
 
     # Default option values
     maxage = 0
@@ -219,6 +229,7 @@ class ModerateCaching(BaseCaching):
     etags = vary = None
     lastModified = ramCache = anonOnly = False
 
+
 @provider(ICachingOperationType)
 class StrongCaching(BaseCaching):
     """Strong caching operation. A subclass of the generic BaseCaching
@@ -234,7 +245,8 @@ class StrongCaching(BaseCaching):
     sort = 1
 
     # Configurable options
-    options = ('maxage','smaxage','etags','lastModified','ramCache','vary', 'anonOnly')
+    options = ('maxage', 'smaxage', 'etags', 'lastModified',
+               'ramCache', 'vary', 'anonOnly')
 
     # Default option values
     maxage = 86400
@@ -261,7 +273,9 @@ def modifyResponse(self, rulename, response):
                     doNotCache(self.published, self.request, response)
                     return
 
-            super(ResourceRegistriesCaching, self).modifyResponse(rulename, response, class_=StrongCaching)
+            super(ResourceRegistriesCaching, self).modifyResponse(
+                rulename, response, class_=StrongCaching)
+
 
 @implementer(ICachingOperation)
 @provider(ICachingOperationType)
diff --git a/plone/app/caching/operations/etags.py b/plone/app/caching/operations/etags.py
index a82b987..cff76e6 100644
--- a/plone/app/caching/operations/etags.py
+++ b/plone/app/caching/operations/etags.py
@@ -27,7 +27,8 @@ def __init__(self, published, request):
 
     def __call__(self):
         context = getContext(self.published)
-        portal_state = queryMultiAdapter((context, self.request), name=u'plone_portal_state')
+        portal_state = queryMultiAdapter(
+            (context, self.request), name=u'plone_portal_state')
         if portal_state is None:
             return None
 
@@ -37,6 +38,7 @@ def __call__(self):
 
         return member.getId()
 
+
 @implementer(IETagValue)
 class Roles(object):
     """The ``roles`` etag component, returning the current user's roles,
@@ -50,7 +52,8 @@ def __init__(self, published, request):
 
     def __call__(self):
         context = getContext(self.published)
-        portal_state = queryMultiAdapter((context, self.request), name=u'plone_portal_state')
+        portal_state = queryMultiAdapter(
+            (context, self.request), name=u'plone_portal_state')
         if portal_state is None:
             return None
 
@@ -63,6 +66,7 @@ def __call__(self):
 
         return ';'.join(sorted(member.getRolesInContext(context)))
 
+
 @implementer(IETagValue)
 class Language(object):
     """The ``language`` etag component, returning the value of the
@@ -77,6 +81,7 @@ def __init__(self, published, request):
     def __call__(self):
         return self.request.get('HTTP_ACCEPT_LANGUAGE', '')
 
+
 @implementer(IETagValue)
 class UserLanguage(object):
     """The ``userLanguage`` etag component, returning the user's preferred
@@ -90,12 +95,14 @@ def __init__(self, published, request):
 
     def __call__(self):
         context = getContext(self.published)
-        portal_state = queryMultiAdapter((context, self.request), name=u'plone_portal_state')
+        portal_state = queryMultiAdapter(
+            (context, self.request), name=u'plone_portal_state')
         if portal_state is None:
             return None
 
         return portal_state.language()
 
+
 @implementer(IETagValue)
 class LastModified(object):
     """The ``lastModified`` etag component, returning the last modification
@@ -113,6 +120,7 @@ def __call__(self):
             return None
         return str(time.mktime(lastModified.utctimetuple()))
 
+
 @implementer(IETagValue)
 class CatalogCounter(object):
     """The ``catalogCounter`` etag component, returning a counter which is
@@ -132,6 +140,7 @@ def __call__(self):
 
         return str(tools.catalog().getCounter())
 
+
 @implementer(IETagValue)
 class ObjectLocked(object):
     """The ``locked`` etag component, returning 1 or 0 depending on whether
@@ -145,11 +154,13 @@ def __init__(self, published, request):
 
     def __call__(self):
         context = getContext(self.published)
-        context_state = queryMultiAdapter((context, self.request), name=u'plone_context_state')
+        context_state = queryMultiAdapter(
+            (context, self.request), name=u'plone_context_state')
         if context_state is None:
             return None
         return str(int(context_state.is_locked()))
 
+
 @implementer(IETagValue)
 class Skin(object):
     """The ``skin`` etag component, returning the current skin name.
@@ -173,6 +184,7 @@ def __call__(self):
 
         return portal_skins.getDefaultSkin()
 
+
 @implementer(IETagValue)
 class ResourceRegistries(object):
     """The ``resourceRegistries`` etag component, returning the most recent
@@ -204,6 +216,7 @@ def __call__(self):
         mtimes.sort()
         return str(mtimes[-1])
 
+
 @implementer(IETagValue)
 class AnonymousOrRandom(object):
     """The ``anonymousOrRandom`` etag component. This is normally added
@@ -219,13 +232,15 @@ def __init__(self, published, request):
 
     def __call__(self):
         context = getContext(self.published)
-        portal_state = queryMultiAdapter((context, self.request), name=u'plone_portal_state')
+        portal_state = queryMultiAdapter(
+            (context, self.request), name=u'plone_portal_state')
         if portal_state is None:
             return None
         if portal_state.anonymous():
             return None
         return "%s%d" % (time.time(), random.randint(0, 1000))
 
+
 @implementer(IETagValue)
 class CopyCookie(object):
     """The ``copy`` etag component, returning 1 or 0 depending on whether
diff --git a/plone/app/caching/operations/ramcache.py b/plone/app/caching/operations/ramcache.py
index 2d7671f..0a82287 100644
--- a/plone/app/caching/operations/ramcache.py
+++ b/plone/app/caching/operations/ramcache.py
@@ -29,20 +29,20 @@ def __init__(self, published, request):
     def transformUnicode(self, result, encoding):
         if self.responseIsSuccess() and IRAMCached.providedBy(self.request):
             storeResponseInRAMCache(self.request, self.request.response,
-                    result.encode(encoding))
+                                    result.encode(encoding))
         return None
 
     def transformBytes(self, result, encoding):
         if self.responseIsSuccess() and IRAMCached.providedBy(self.request):
             storeResponseInRAMCache(self.request, self.request.response,
-                    result)
+                                    result)
         return None
 
     def transformIterable(self, result, encoding):
         if self.responseIsSuccess() and IRAMCached.providedBy(self.request):
             result = ''.join(result)
             storeResponseInRAMCache(self.request, self.request.response,
-                result)
+                                    result)
             # as we have iterated the iterable, we must return a new one
             return iter(result)
         return None
diff --git a/plone/app/caching/operations/utils.py b/plone/app/caching/operations/utils.py
index 2e51c88..f9ab7b0 100644
--- a/plone/app/caching/operations/utils.py
+++ b/plone/app/caching/operations/utils.py
@@ -47,6 +47,7 @@
 # as any additional keyword parameters required.
 #
 
+
 def setCacheHeaders(published, request, response, maxage=None, smaxage=None, etag=None, lastModified=None, vary=None):
     """General purpose dispatcher to set various cache headers
 
@@ -59,19 +60,20 @@ def setCacheHeaders(published, request, response, maxage=None, smaxage=None, eta
 
     if maxage:
         cacheInBrowserAndProxy(published, request, response, maxage, smaxage=smaxage,
-            etag=etag, lastModified=lastModified, vary=vary)
+                               etag=etag, lastModified=lastModified, vary=vary)
 
     elif smaxage:
         cacheInProxy(published, request, response, smaxage,
-            etag=etag, lastModified=lastModified, vary=vary)
+                     etag=etag, lastModified=lastModified, vary=vary)
 
     elif etag or lastModified:
         cacheInBrowser(published, request, response,
-            etag=etag, lastModified=lastModified)
+                       etag=etag, lastModified=lastModified)
 
     else:
         doNotCache(published, request, response)
 
+
 def doNotCache(published, request, response):
     """Set response headers to ensure that the response is not cached by
     web browsers or caching proxies.
@@ -87,6 +89,7 @@ def doNotCache(published, request, response):
     response.setHeader('Expires', formatDateTime(getExpiration(0)))
     response.setHeader('Cache-Control', 'max-age=0, must-revalidate, private')
 
+
 def cacheInBrowser(published, request, response, etag=None, lastModified=None):
     """Set response headers to indicate that browsers should cache the
     response but expire immediately and revalidate the cache on every
@@ -100,7 +103,7 @@ def cacheInBrowser(published, request, response, etag=None, lastModified=None):
     """
 
     if etag is not None:
-        response.setHeader('ETag', '"%s"' %etag, literal=1)
+        response.setHeader('ETag', '"%s"' % etag, literal=1)
 
     if lastModified is not None:
         response.setHeader('Last-Modified', formatDateTime(lastModified))
@@ -110,6 +113,7 @@ def cacheInBrowser(published, request, response, etag=None, lastModified=None):
     response.setHeader('Expires', formatDateTime(getExpiration(0)))
     response.setHeader('Cache-Control', 'max-age=0, must-revalidate, private')
 
+
 def cacheInProxy(published, request, response, smaxage, etag=None, lastModified=None, vary=None):
     """Set headers to cache the response in a caching proxy.
 
@@ -125,13 +129,15 @@ def cacheInProxy(published, request, response, smaxage, etag=None, lastModified=
         del response.headers['last-modified']
 
     if etag is not None:
-        response.setHeader('ETag', '"%s"' %etag, literal=1)
+        response.setHeader('ETag', '"%s"' % etag, literal=1)
 
     if vary is not None:
         response.setHeader('Vary', vary)
 
     response.setHeader('Expires', formatDateTime(getExpiration(0)))
-    response.setHeader('Cache-Control', 'max-age=0, s-maxage=%d, must-revalidate' % smaxage)
+    response.setHeader(
+        'Cache-Control', 'max-age=0, s-maxage=%d, must-revalidate' % smaxage)
+
 
 def cacheInBrowserAndProxy(published, request, response, maxage, smaxage=None, etag=None, lastModified=None, vary=None):
     """Set headers to cache the response in the browser and caching proxy if
@@ -150,7 +156,7 @@ def cacheInBrowserAndProxy(published, request, response, maxage, smaxage=None, e
         del response.headers['last-modified']
 
     if etag is not None:
-        response.setHeader('ETag', '"%s"' %etag, literal=1)
+        response.setHeader('ETag', '"%s"' % etag, literal=1)
 
     if vary is not None:
         response.setHeader('Vary', vary)
@@ -158,11 +164,13 @@ def cacheInBrowserAndProxy(published, request, response, maxage, smaxage=None, e
     response.setHeader('Expires', formatDateTime(getExpiration(maxage)))
 
     if smaxage is not None:
-        maxage = '%s, s-maxage=%s' %(maxage, smaxage)
+        maxage = '%s, s-maxage=%s' % (maxage, smaxage)
 
     # Substituting proxy-validate in place of must=revalidate here because of Safari bug
     # https://bugs.webkit.org/show_bug.cgi?id=13128
-    response.setHeader('Cache-Control', 'max-age=%s, proxy-revalidate, public' % maxage)
+    response.setHeader(
+        'Cache-Control', 'max-age=%s, proxy-revalidate, public' % maxage)
+
 
 def cacheInRAM(published, request, response, etag=None, lastModified=None, annotationsKey=PAGE_CACHE_ANNOTATION_KEY):
     """Set a flag indicating that the response for the given request
@@ -192,6 +200,7 @@ def cacheInRAM(published, request, response, etag=None, lastModified=None, annot
     annotations[annotationsKey] = key
     alsoProvides(request, IRAMCached)
 
+
 def cachedResponse(published, request, response, status, headers, body, gzip=False):
     """Returned a cached page. Modifies the response (status and headers)
     and returns the cached body.
@@ -219,6 +228,7 @@ def cachedResponse(published, request, response, status, headers, body, gzip=Fal
 
     return body
 
+
 def notModified(published, request, response, etag=None, lastModified=None):
     """Return a ``304 NOT MODIFIED`` response. Modifies the response (status)
     and returns an empty body to indicate the request should be interrupted.
@@ -283,6 +293,7 @@ def cacheStop(request, rulename):
             return True
     return False
 
+
 def isModified(request, etag=None, lastModified=None):
     """Return True or False depending on whether the published resource has
     been modified.
@@ -327,7 +338,7 @@ def isModified(request, etag=None, lastModified=None):
     latest headers. I interpret this as the spec rule that the
     etags do NOT match, and therefor we must not return a 304.
     """
-    if ifNoneMatch and etag==None:
+    if ifNoneMatch and etag == None:
         return True
 
     # Check the modification date
@@ -372,6 +383,7 @@ def visibleToRole(published, role, permission='View'):
 # Basic helper functions
 #
 
+
 def getContext(published, marker=(IContentish, ISiteRoot,)):
     """Given a published object, attempt to look up a context
 
@@ -402,6 +414,7 @@ def checkType(context):
 
     return published
 
+
 def formatDateTime(dt):
     """Format a Python datetime object as an RFC1123 date.
 
@@ -415,6 +428,7 @@ def formatDateTime(dt):
 
     return wsgiref.handlers.format_date_time(time.mktime(dt.timetuple()))
 
+
 def parseDateTime(str):
     """Return a Python datetime object from an an RFC1123 date.
 
@@ -437,6 +451,7 @@ def parseDateTime(str):
 
     return dt
 
+
 def getLastModifiedAnnotation(published, request, lastModified=True):
     """Try to get the last modified date from a request annotation if available,
     otherwise try to get it from published object
@@ -458,6 +473,7 @@ def getLastModifiedAnnotation(published, request, lastModified=True):
 
     return dt
 
+
 def getLastModified(published, lastModified=True):
     """Get a last modified date or None.
 
@@ -483,6 +499,7 @@ def getLastModified(published, lastModified=True):
 
     return dt
 
+
 def getExpiration(maxage):
     """Get an expiration date as a datetime in the local timezone.
 
@@ -496,6 +513,7 @@ def getExpiration(maxage):
     else:
         return now - datetime.timedelta(days=3650)
 
+
 def getETagAnnotation(published, request, keys=(), extraTokens=()):
     """Try to get the ETag from a request annotation if available,
     otherwise try to get it from published object
@@ -517,6 +535,7 @@ def getETagAnnotation(published, request, keys=(), extraTokens=()):
 
     return etag
 
+
 def getETag(published, request, keys=(), extraTokens=()):
     """Calculate an ETag.
 
@@ -536,9 +555,11 @@ def getETag(published, request, keys=(), extraTokens=()):
     tokens = []
     noTokens = True
     for key in keys:
-        component = queryMultiAdapter((published, request), IETagValue, name=key)
+        component = queryMultiAdapter(
+            (published, request), IETagValue, name=key)
         if component is None:
-            logger.warning("Could not find value adapter for ETag component %s", key)
+            logger.warning(
+                "Could not find value adapter for ETag component %s", key)
             tokens.append('')
         else:
             value = component()
@@ -561,6 +582,7 @@ def getETag(published, request, keys=(), extraTokens=()):
 
     return etag
 
+
 def parseETags(text, allowWeak=True, _result=None):
     """Parse a header value into a list of etags. Handles fishy quoting and
     other browser quirks.
@@ -586,13 +608,13 @@ def parseETags(text, allowWeak=True, _result=None):
         m = etagQuote.match(text)
         if m:
             # Match quoted etag (spec-observing client)
-            l     = len(m.group(1))
+            l = len(m.group(1))
             value = (m.group(2) or '') + (m.group(3) or '')
         else:
             # Match non-quoted etag (lazy client)
             m = etagNoQuote.match(text)
             if m:
-                l     = len(m.group(1))
+                l = len(m.group(1))
                 value = (m.group(2) or '') + (m.group(3) or '')
             else:
                 return result
@@ -613,6 +635,7 @@ def parseETags(text, allowWeak=True, _result=None):
 # RAM cache management
 #
 
+
 def getRAMCache(globalKey=PAGE_CACHE_KEY):
     """Get a RAM cache instance for the given key. The return value is ``None``
     if no RAM cache can be found, or a mapping object supporting at least
@@ -629,6 +652,7 @@ def getRAMCache(globalKey=PAGE_CACHE_KEY):
 
     return chooser(globalKey)
 
+
 def getRAMCacheKey(request, etag=None, lastModified=None):
     """Calculate the cache key for pages cached in RAM.
 
@@ -647,13 +671,14 @@ def getRAMCacheKey(request, etag=None, lastModified=None):
         request.get('SERVER_URL', ''),
         request.get('PATH_INFO', ''),
         request.get('QUERY_STRING', ''),
-        )
+    )
     if etag:
         resourceKey = '|' + etag + '||' + resourceKey
     if lastModified:
         resourceKey = '|' + str(lastModified) + '||' + resourceKey
     return resourceKey
 
+
 def storeResponseInRAMCache(request, response, result, globalKey=PAGE_CACHE_KEY, annotationsKey=PAGE_CACHE_ANNOTATION_KEY):
     """Store the given response in the RAM cache.
 
@@ -698,6 +723,7 @@ def storeResponseInRAMCache(request, response, result, globalKey=PAGE_CACHE_KEY,
 
     cache[key] = (status, headers, result, gzipFlag)
 
+
 def fetchFromRAMCache(request, etag=None, lastModified=None, globalKey=PAGE_CACHE_KEY, default=None):
     """Return a page cached in RAM, or None if it cannot be found.
 
diff --git a/plone/app/caching/purge.py b/plone/app/caching/purge.py
index 80a50fc..3221e92 100644
--- a/plone/app/caching/purge.py
+++ b/plone/app/caching/purge.py
@@ -28,6 +28,7 @@
 except ImportError:
     HAVE_AT = False
 
+
 @implementer(IPurgePaths)
 class ContentPurgePaths(object):
     """Paths to purge for content items
@@ -84,6 +85,7 @@ def getRelativePaths(self):
     def getAbsolutePaths(self):
         return []
 
+
 @implementer(IPurgePaths)
 class DiscussionItemPurgePaths(object):
     """Paths to purge for Discussion Item.
@@ -113,7 +115,8 @@ def getRelativePaths(self):
                     if rewriter is None:
                         yield relativePath
                     else:
-                        rewrittenPaths = rewriter(relativePath) or []  # None -> []
+                        rewrittenPaths = rewriter(
+                            relativePath) or []  # None -> []
                         for rewrittenPath in rewrittenPaths:
                             yield rewrittenPath
 
@@ -163,8 +166,8 @@ def getRelativePaths(self):
 
             def fieldFilter(field):
                 return ((IBlobField.providedBy(field) or
-                        IFileField.providedBy(field) or
-                        IImageField.providedBy(field))
+                         IFileField.providedBy(field) or
+                         IImageField.providedBy(field))
                         and not ITextField.providedBy(field))
 
             seenDownloads = False
@@ -191,11 +194,13 @@ def getAbsolutePaths(self):
 # Event redispatch for content items - we check the list of content items
 # instead of the marker interface
 
+
 @adapter(IContentish, IObjectModifiedEvent)
 def purgeOnModified(object, event):
     if isPurged(object):
         notify(Purge(object))
 
+
 @adapter(IContentish, IObjectMovedEvent)
 def purgeOnMovedOrRemoved(object, event):
     # Don't purge when added
diff --git a/plone/app/caching/setuphandlers.py b/plone/app/caching/setuphandlers.py
index 9d2f5c1..5dd25d7 100644
--- a/plone/app/caching/setuphandlers.py
+++ b/plone/app/caching/setuphandlers.py
@@ -11,6 +11,7 @@ def enableExplicitMode():
     if registry is not None:
         registry.explicit = True
 
+
 def importVarious(context):
 
     if not context.readDataFile('plone.app.caching.txt'):
diff --git a/plone/app/caching/testing.py b/plone/app/caching/testing.py
index 623631e..765a58d 100644
--- a/plone/app/caching/testing.py
+++ b/plone/app/caching/testing.py
@@ -19,12 +19,12 @@
 except ImportError:
     # so we can run tests on plone 4.3
     from plone.keyring.interfaces import IKeyManager
+
     def _getKeyring(username):
         manager = getUtility(IKeyManager)
         return manager['_system']
 
 
-
 @implementer(IPurger)
 class FauxPurger(object):
 
@@ -56,7 +56,8 @@ def setUpZope(self, app, configurationContext):
 
         # Load ZCML
         import plone.app.caching
-        xmlconfig.file('configure.zcml', plone.app.caching, context=configurationContext)
+        xmlconfig.file('configure.zcml', plone.app.caching,
+                       context=configurationContext)
 
         # Install fake purger
         self.oldPurger = getUtility(IPurger)
@@ -65,7 +66,8 @@ def setUpZope(self, app, configurationContext):
     def setUpPloneSite(self, portal):
         applyProfile(portal, 'plone.app.caching:default')
 
-        portal['portal_workflow'].setDefaultChain('simple_publication_workflow')
+        portal['portal_workflow'].setDefaultChain(
+            'simple_publication_workflow')
 
     def tearDownZope(self, app):
         # Store old purger
diff --git a/plone/app/caching/tests/test_etags.py b/plone/app/caching/tests/test_etags.py
index 504d24d..66b75f7 100644
--- a/plone/app/caching/tests/test_etags.py
+++ b/plone/app/caching/tests/test_etags.py
@@ -27,11 +27,13 @@
 class DummyContext(Explicit):
     pass
 
+
 class DummyPublished(object):
 
     def __init__(self, parent=None):
         self.__parent__ = parent
 
+
 class TestETags(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -94,7 +96,6 @@ def member(self):
 
         self.assertEqual('bob', etag())
 
-
     # Roles
 
     def test_Roles_anonymous(self):
@@ -156,7 +157,6 @@ def member(self):
 
         self.assertEqual('Manager;Member', etag())
 
-
     # Language
 
     def test_Language_no_header(self):
@@ -306,7 +306,6 @@ def catalog(self):
 
         self.assertEqual('10', etag())
 
-
     # ObjectLocked
 
     def test_ObjectLocked_true(self):
@@ -357,7 +356,6 @@ def is_locked(self):
 
         self.assertEqual('0', etag())
 
-
     # Skin
 
     def test_Skin_request_variable(self):
diff --git a/plone/app/caching/tests/test_integration.py b/plone/app/caching/tests/test_integration.py
index ab852e9..77cc985 100644
--- a/plone/app/caching/tests/test_integration.py
+++ b/plone/app/caching/tests/test_integration.py
@@ -197,7 +197,8 @@ def test_auto_purge_content_types(self):
 
         browser.open(editURL)
 
-        browser.getControl(name='form.widgets.IDublinCore.title').value = u"Title 1"
+        browser.getControl(
+            name='form.widgets.IDublinCore.title').value = u"Title 1"
         browser.getControl('Save').click()
 
         self.assertEqual([], self.purger._sync)
@@ -212,7 +213,8 @@ def test_auto_purge_content_types(self):
         transaction.commit()
 
         browser.open(editURL)
-        browser.getControl(name='form.widgets.IDublinCore.title').value = u"Title 2"
+        browser.getControl(
+            name='form.widgets.IDublinCore.title').value = u"Title 2"
         browser.getControl('Save').click()
 
         self.assertEqual([], self.purger._sync)
@@ -227,7 +229,8 @@ def test_auto_purge_content_types(self):
         transaction.commit()
 
         browser.open(editURL)
-        browser.getControl(name='form.widgets.IDublinCore.title').value = u"Title 3"
+        browser.getControl(
+            name='form.widgets.IDublinCore.title').value = u"Title 3"
         browser.getControl('Save').click()
 
         self.assertEqual([], self.purger._sync)
@@ -242,7 +245,8 @@ def test_auto_purge_content_types(self):
         transaction.commit()
 
         browser.open(editURL)
-        browser.getControl(name='form.widgets.IDublinCore.title').value = u"Title 4"
+        browser.getControl(
+            name='form.widgets.IDublinCore.title').value = u"Title 4"
         browser.getControl('Save').click()
 
         self.assertEqual([], self.purger._sync)
diff --git a/plone/app/caching/tests/test_lastmodified.py b/plone/app/caching/tests/test_lastmodified.py
index 028ab5f..975566a 100644
--- a/plone/app/caching/tests/test_lastmodified.py
+++ b/plone/app/caching/tests/test_lastmodified.py
@@ -24,6 +24,7 @@ def oldstate(self, obj, tid):
     def register(self, object):
         pass
 
+
 class TestLastModified(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -52,8 +53,7 @@ class Dummy(Persistent, Explicit):
         zpt = ZopePageTemplate('zpt').__of__(d)
         self.assertEqual(None, ILastModified(zpt)())
 
-
-        timestamp = 987654321.0 # time stamp (in UTC)
+        timestamp = 987654321.0  # time stamp (in UTC)
         # equivalent in local time, which is what the last-modified adapter
         # should return
         mod = datetime.datetime.fromtimestamp(timestamp, tzlocal())
@@ -76,8 +76,7 @@ class Dummy(Persistent, Explicit):
         zpt = FSPageTemplate('zpt', __file__).__of__(d)
         self.assertEqual(None, ILastModified(zpt)())
 
-
-        timestamp = 987654321.0 # time stamp (in UTC)
+        timestamp = 987654321.0  # time stamp (in UTC)
         # equivalent in local time, which is what the last-modified adapter
         # should return
         mod = datetime.datetime.fromtimestamp(timestamp, tzlocal())
@@ -91,8 +90,8 @@ def test_OFSFileLastModified_File(self):
         dummy = File('dummy', 'Dummy', 'data')
         self.assertEqual(None, ILastModified(dummy)())
 
-        timestamp = 987654321.0 # time stamp (in UTC)
-        ts = TimeStamp(*time.gmtime(timestamp)[:6]) # corresponding TimeStamp
+        timestamp = 987654321.0  # time stamp (in UTC)
+        ts = TimeStamp(*time.gmtime(timestamp)[:6])  # corresponding TimeStamp
 
         # equivalent in local time, which is what the last-modified adapter
         # should return
@@ -108,8 +107,8 @@ def test_OFSFileLastModified_Image(self):
         dummy = Image('dummy', 'Dummy', 'data')
         self.assertEqual(None, ILastModified(dummy)())
 
-        timestamp = 987654321.0 # time stamp (in UTC)
-        ts = TimeStamp(*time.gmtime(timestamp)[:6]) # corresponding TimeStamp
+        timestamp = 987654321.0  # time stamp (in UTC)
+        ts = TimeStamp(*time.gmtime(timestamp)[:6])  # corresponding TimeStamp
 
         # equivalent in local time, which is what the last-modified adapter
         # should return
@@ -127,19 +126,22 @@ def test_FSObjectLastModified_FSFile(self):
         modtime = float(os.path.getmtime(__file__))
         mod = datetime.datetime.fromtimestamp(modtime, tzlocal())
 
-        format = "%y%m%d%H%M%s" # see note in test_FSObjectLastModified_FSImage
-        self.assertEqual(mod.strftime(format), ILastModified(dummy)().strftime(format))
+        format = "%y%m%d%H%M%s"  # see note in test_FSObjectLastModified_FSImage
+        self.assertEqual(mod.strftime(format),
+                         ILastModified(dummy)().strftime(format))
 
     def test_FSObjectLastModified_FSImage(self):
         from Products.CMFCore.FSImage import FSImage
 
-        dummy = FSImage('dummy', __file__) # not really an image, but anyway
+        dummy = FSImage('dummy', __file__)  # not really an image, but anyway
         modtime = float(os.path.getmtime(__file__))
         mod = datetime.datetime.fromtimestamp(modtime, tzlocal())
         # different filesystems seem to handle datetime differently. some use microseconds
-        # and others don't so to make jenkins happy lets omit the microseconds factor
+        # and others don't so to make jenkins happy lets omit the microseconds
+        # factor
         format = "%y%m%d%H%M%s"
-        self.assertEqual(mod.strftime(format), ILastModified(dummy)().strftime(format))
+        self.assertEqual(mod.strftime(format),
+                         ILastModified(dummy)().strftime(format))
 
     def test_CatalogableDublinCoreLastModified(self):
         from Products.CMFCore.interfaces import ICatalogableDublinCore
@@ -151,7 +153,8 @@ class Dummy(object):
             _mod = None
 
             def modified(self):
-                if self._mod is not None: return DateTime.DateTime(self._mod)
+                if self._mod is not None:
+                    return DateTime.DateTime(self._mod)
                 return None
 
         d = Dummy()
diff --git a/plone/app/caching/tests/test_lookup.py b/plone/app/caching/tests/test_lookup.py
index d57f954..13bd411 100644
--- a/plone/app/caching/tests/test_lookup.py
+++ b/plone/app/caching/tests/test_lookup.py
@@ -30,16 +30,18 @@ def __init__(self, portal_type='testtype', defaultView='defaultView'):
     def defaultView(self):
         return self._defaultView
 
+
 class DummyNotContent(Explicit):
     pass
 
+
 class DummyFTI(object):
 
     def __init__(self, portal_type, viewAction=''):
         self.id = portal_type
         self._actions = {
-                'object/view': {'url': viewAction},
-            }
+            'object/view': {'url': viewAction},
+        }
 
     def getActionInfo(self, name):
         return self._actions[name]
@@ -51,6 +53,7 @@ def queryMethodID(self, id, default=None, context=None):
             return '@@defaultView'
         return default
 
+
 @implementer(IDynamicType)
 class DummyNotBrowserDefault(Explicit):
 
@@ -61,19 +64,24 @@ def __init__(self, portal_type='testtype', viewAction=''):
     def getTypeInfo(self):
         return DummyFTI(self.portal_type, self._viewAction)
 
+
 class DummyResponse(dict):
 
     def addHeader(self, name, value):
         self.setdefault(name, []).append(value)
 
+
 class DummyRequest(dict):
+
     def __init__(self, published, response):
         self['PUBLISHED'] = published
         self.response = response
 
+
 class DummyView(BrowserView):
     __name__ = 'defaultView'
 
+
 class TestContentItemLookup(unittest.TestCase):
 
     layer = IMPLICIT_RULESET_REGISTRY_UNIT_TESTING
@@ -218,7 +226,8 @@ def test_parent_not_IBrowserDefault_methodid(self):
         ploneSettings.templateRulesetMapping = {}
         ploneSettings.contentTypeRulesetMapping = {'testtype': 'rule1'}
 
-        published = ZopePageTemplate('defaultView').__of__(DummyNotBrowserDefault('testtype', 'string:${object_url}/view'))
+        published = ZopePageTemplate('defaultView').__of__(
+            DummyNotBrowserDefault('testtype', 'string:${object_url}/view'))
         request = DummyRequest(published, DummyResponse())
         self.assertEqual('rule1', ContentItemLookup(published, request)())
 
@@ -231,7 +240,8 @@ def test_parent_not_IBrowserDefault_default_method(self):
         ploneSettings.templateRulesetMapping = {}
         ploneSettings.contentTypeRulesetMapping = {'testtype': 'rule1'}
 
-        published = ZopePageTemplate('defaultView').__of__(DummyNotBrowserDefault('testtype', 'string:${object_url}/'))
+        published = ZopePageTemplate('defaultView').__of__(
+            DummyNotBrowserDefault('testtype', 'string:${object_url}/'))
         request = DummyRequest(published, DummyResponse())
         self.assertEqual('rule1', ContentItemLookup(published, request)())
 
@@ -244,7 +254,8 @@ def test_parent_not_IBrowserDefault_actiononly(self):
         ploneSettings.templateRulesetMapping = {}
         ploneSettings.contentTypeRulesetMapping = {'testtype': 'rule1'}
 
-        published = ZopePageTemplate('defaultView').__of__(DummyNotBrowserDefault('testtype', 'string:${object_url}/defaultView'))
+        published = ZopePageTemplate('defaultView').__of__(
+            DummyNotBrowserDefault('testtype', 'string:${object_url}/defaultView'))
         request = DummyRequest(published, DummyResponse())
 
         self.assertEqual('rule1', ContentItemLookup(published, request)())
diff --git a/plone/app/caching/tests/test_operation_default.py b/plone/app/caching/tests/test_operation_default.py
index 8c79997..f2fe0ca 100644
--- a/plone/app/caching/tests/test_operation_default.py
+++ b/plone/app/caching/tests/test_operation_default.py
@@ -66,7 +66,8 @@ def test_last_modified_no_etags(self):
         self.assertFalse('Etag' in browser.headers)
 
         # now set up etags and make sure that a header is added
-        self.registry['plone.app.caching.weakCaching.etags'] = ('lastModified',)
+        self.registry['plone.app.caching.weakCaching.etags'] = (
+            'lastModified',)
         import transaction
         transaction.commit()
         browser.open("%s/dummy-content/edit?_authenticator=%s" % (
diff --git a/plone/app/caching/tests/test_operation_parameters.py b/plone/app/caching/tests/test_operation_parameters.py
index 2bf0b2c..c49f2e2 100644
--- a/plone/app/caching/tests/test_operation_parameters.py
+++ b/plone/app/caching/tests/test_operation_parameters.py
@@ -58,25 +58,31 @@ def test_anon_only(self):
 
         # Publish the folder and page
         self.portal.portal_workflow.doActionFor(self.portal['f1'], 'publish')
-        self.portal.portal_workflow.doActionFor(self.portal['f1']['d1'], 'publish')
+        self.portal.portal_workflow.doActionFor(
+            self.portal['f1']['d1'], 'publish')
 
         # Set pages to have weak caching and test anonymous
 
-        self.cacheSettings.operationMapping = {'plone.content.itemView': 'plone.app.caching.weakCaching'}
+        self.cacheSettings.operationMapping = {
+            'plone.content.itemView': 'plone.app.caching.weakCaching'}
         transaction.commit()
 
         # View the page as anonymous
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
 
         # Set pages to have moderate caching so that we can see the difference
         # between logged in and anonymous
 
-        self.cacheSettings.operationMapping = {'plone.content.itemView': 'plone.app.caching.moderateCaching'}
+        self.cacheSettings.operationMapping = {
+            'plone.content.itemView': 'plone.app.caching.moderateCaching'}
         self.registry['plone.app.caching.moderateCaching.smaxage'] = 60
         self.registry['plone.app.caching.moderateCaching.vary'] = 'X-Anonymous'
         self.registry['plone.app.caching.moderateCaching.anonOnly'] = True
@@ -86,27 +92,35 @@ def test_anon_only(self):
         # View the page as anonymous
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, s-maxage=60, must-revalidate', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=0, s-maxage=60, must-revalidate',
+                         browser.headers['Cache-Control'])
         self.assertEqual('X-Anonymous', browser.headers['Vary'])
         self.assertFalse('Etag' in browser.headers)
 
         # View the page as logged-in
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
         self.assertTrue('Etag' in browser.headers)
 
         # Set pages to have strong caching so that we can see the difference
         # between logged in and anonymous
 
-        self.cacheSettings.operationMapping = {'plone.content.itemView': 'plone.app.caching.strongCaching'}
+        self.cacheSettings.operationMapping = {
+            'plone.content.itemView': 'plone.app.caching.strongCaching'}
         self.registry['plone.app.caching.strongCaching.vary'] = 'X-Anonymous'
         self.registry['plone.app.caching.strongCaching.anonOnly'] = True
         transaction.commit()
@@ -114,21 +128,28 @@ def test_anon_only(self):
         # View the page as anonymous
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=86400, proxy-revalidate, public', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=86400, proxy-revalidate, public',
+                         browser.headers['Cache-Control'])
         self.assertEqual('X-Anonymous', browser.headers['Vary'])
         self.assertFalse('Etag' in browser.headers)
 
         # View the page as logged-in
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
         self.assertTrue('Etag' in browser.headers)
 
         # Check an edge case that has had a problem in the past:
@@ -141,4 +162,5 @@ def test_anon_only(self):
         # View the page as anonymous
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('max-age=0, s-maxage=60, must-revalidate', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=0, s-maxage=60, must-revalidate',
+                         browser.headers['Cache-Control'])
diff --git a/plone/app/caching/tests/test_operation_utils.py b/plone/app/caching/tests/test_operation_utils.py
index a5d90d6..8fba6c3 100644
--- a/plone/app/caching/tests/test_operation_utils.py
+++ b/plone/app/caching/tests/test_operation_utils.py
@@ -31,6 +31,7 @@ class DummyPublished(object):
     def __init__(self, parent=None):
         self.__parent__ = parent
 
+
 def normalize_response_cache(value):
     # Zope < 2.13 incorrectly includes the HTTP status as a header;
     # Zope 2.13 does not
@@ -62,7 +63,8 @@ def test_doNotCache(self):
         doNotCache(published, request, response)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
 
         expires = dateutil.parser.parse(response.getHeader('Expires'))
@@ -77,18 +79,19 @@ def test_doNotCache_deletes_last_modified(self):
         published = DummyPublished()
 
         now = datetime.datetime.now(dateutil.tz.tzlocal())
-        response.setHeader('Last-Modified', wsgiref.handlers.format_date_time(time.mktime(now.timetuple())))
+        response.setHeader(
+            'Last-Modified', wsgiref.handlers.format_date_time(time.mktime(now.timetuple())))
 
         doNotCache(published, request, response)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
 
         expires = dateutil.parser.parse(response.getHeader('Expires'))
         self.assertTrue(now > expires)
 
-
     # cacheInBrowser()
 
     def test_cacheInBrowser_no_etag_no_last_modified(self):
@@ -104,7 +107,8 @@ def test_cacheInBrowser_no_etag_no_last_modified(self):
         cacheInBrowser(published, request, response)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
         self.assertEqual(None, response.getHeader('ETag', literal=1))
 
@@ -125,7 +129,8 @@ def test_cacheInBrowser_etag(self):
         cacheInBrowser(published, request, response, etag=etag)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
         self.assertEqual('"|foo|bar|"', response.getHeader('ETag', literal=1))
 
@@ -141,12 +146,14 @@ def test_cacheInBrowser_lastModified(self):
         published = DummyPublished()
 
         now = datetime.datetime.now(dateutil.tz.tzlocal())
-        nowFormatted = wsgiref.handlers.format_date_time(time.mktime(now.timetuple()))
+        nowFormatted = wsgiref.handlers.format_date_time(
+            time.mktime(now.timetuple()))
 
         cacheInBrowser(published, request, response, lastModified=now)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(nowFormatted, response.getHeader('Last-Modified'))
         self.assertEqual(None, response.getHeader('ETag', literal=1))
 
@@ -164,19 +171,21 @@ def test_cacheInBrowser_lastModified_and_etag(self):
         now = datetime.datetime.now(dateutil.tz.tzlocal())
         etag = "|foo|bar|"
 
-        nowFormatted = wsgiref.handlers.format_date_time(time.mktime(now.timetuple()))
+        nowFormatted = wsgiref.handlers.format_date_time(
+            time.mktime(now.timetuple()))
 
-        cacheInBrowser(published, request, response, etag=etag, lastModified=now)
+        cacheInBrowser(published, request, response,
+                       etag=etag, lastModified=now)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(nowFormatted, response.getHeader('Last-Modified'))
         self.assertEqual('"|foo|bar|"', response.getHeader('ETag', literal=1))
 
         expires = dateutil.parser.parse(response.getHeader('Expires'))
         self.assertTrue(now > expires)
 
-
     # cacheInProxy()
 
     def test_cacheInProxy_minimal(self):
@@ -192,7 +201,8 @@ def test_cacheInProxy_minimal(self):
         cacheInProxy(published, request, response, smaxage=60)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, s-maxage=60, must-revalidate', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, s-maxage=60, must-revalidate',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
         self.assertEqual(None, response.getHeader('ETag', literal=1))
         self.assertEqual(None, response.getHeader('Vary'))
@@ -212,12 +222,15 @@ def test_cacheInProxy_full(self):
         etag = '|foo|bar|'
         vary = 'Accept-Language'
 
-        nowFormatted = wsgiref.handlers.format_date_time(time.mktime(now.timetuple()))
+        nowFormatted = wsgiref.handlers.format_date_time(
+            time.mktime(now.timetuple()))
 
-        cacheInProxy(published, request, response, smaxage=60, etag=etag, lastModified=now, vary=vary)
+        cacheInProxy(published, request, response, smaxage=60,
+                     etag=etag, lastModified=now, vary=vary)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, s-maxage=60, must-revalidate', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, s-maxage=60, must-revalidate',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(nowFormatted, response.getHeader('Last-Modified'))
         self.assertEqual('"|foo|bar|"', response.getHeader('ETag', literal=1))
         self.assertEqual('Accept-Language', response.getHeader('Vary'))
@@ -225,7 +238,6 @@ def test_cacheInProxy_full(self):
         expires = dateutil.parser.parse(response.getHeader('Expires'))
         self.assertTrue(now > expires)
 
-
     # cacheInBrowserAndProxy()
 
     def test_cacheInBrowserAndProxy_minimal(self):
@@ -241,7 +253,8 @@ def test_cacheInBrowserAndProxy_minimal(self):
         cacheInBrowserAndProxy(published, request, response, maxage=60)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=60, proxy-revalidate, public', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=60, proxy-revalidate, public',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
         self.assertEqual(None, response.getHeader('ETag', literal=1))
         self.assertEqual(None, response.getHeader('Vary'))
@@ -262,12 +275,15 @@ def test_cacheInBrowserAndProxy_full(self):
         etag = '|foo|bar|'
         vary = 'Accept-Language'
 
-        nowFormatted = wsgiref.handlers.format_date_time(time.mktime(now.timetuple()))
+        nowFormatted = wsgiref.handlers.format_date_time(
+            time.mktime(now.timetuple()))
 
-        cacheInBrowserAndProxy(published, request, response, maxage=60, etag=etag, lastModified=now, vary=vary)
+        cacheInBrowserAndProxy(published, request, response,
+                               maxage=60, etag=etag, lastModified=now, vary=vary)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=60, proxy-revalidate, public', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=60, proxy-revalidate, public',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(nowFormatted, response.getHeader('Last-Modified'))
         self.assertEqual('"|foo|bar|"', response.getHeader('ETag', literal=1))
         self.assertEqual('Accept-Language', response.getHeader('Vary'))
@@ -282,7 +298,6 @@ def test_cacheInBrowserAndProxy_full(self):
             "%s is not > %s" % (timedelta, datetime.timedelta(seconds=61))
         )
 
-
     # cacheInRAM()
 
     def test_cacheInRAM_no_etag(self):
@@ -303,7 +318,8 @@ def test_cacheInRAM_no_etag(self):
         cacheInRAM(published, request, response)
 
         annotations = IAnnotations(request)
-        self.assertEqual("http://example.com/foo?", annotations[PAGE_CACHE_ANNOTATION_KEY])
+        self.assertEqual("http://example.com/foo?",
+                         annotations[PAGE_CACHE_ANNOTATION_KEY])
         self.assertTrue(IRAMCached.providedBy(request))
 
     def test_cacheInRAM_etag(self):
@@ -325,7 +341,8 @@ def test_cacheInRAM_etag(self):
         cacheInRAM(published, request, response, etag=etag)
 
         annotations = IAnnotations(request)
-        self.assertEqual("||foo|bar|||http://example.com/foo?", annotations[PAGE_CACHE_ANNOTATION_KEY])
+        self.assertEqual("||foo|bar|||http://example.com/foo?",
+                         annotations[PAGE_CACHE_ANNOTATION_KEY])
         self.assertTrue(IRAMCached.providedBy(request))
 
     def test_cacheInRAM_etag_alternate_key(self):
@@ -343,10 +360,12 @@ def test_cacheInRAM_etag_alternate_key(self):
 
         assert not IRAMCached.providedBy(response)
 
-        cacheInRAM(published, request, response, etag=etag, annotationsKey="alt.key")
+        cacheInRAM(published, request, response,
+                   etag=etag, annotationsKey="alt.key")
 
         annotations = IAnnotations(request)
-        self.assertEqual("||foo|bar|||http://example.com/foo?", annotations["alt.key"])
+        self.assertEqual("||foo|bar|||http://example.com/foo?",
+                         annotations["alt.key"])
         self.assertTrue(IRAMCached.providedBy(request))
 
 
@@ -378,7 +397,8 @@ def test_cachedResponse(self):
         response.setHeader('X-Bar', 'qux')
         response.setStatus(200)
 
-        body = cachedResponse(published, request, response, 404, headers, u"body")
+        body = cachedResponse(published, request,
+                              response, 404, headers, u"body")
 
         self.assertEqual(u"body", body)
         self.assertEqual(404, response.getStatus())
@@ -410,7 +430,8 @@ def test_cachedResponse_gzip_off(self):
 
         assert response.enableHTTPCompression(query=True)
 
-        body = cachedResponse(published, request, response, 404, headers, u"body", 0)
+        body = cachedResponse(published, request, response,
+                              404, headers, u"body", 0)
 
         self.assertEqual(u"body", body)
         self.assertEqual(404, response.getStatus())
@@ -444,7 +465,8 @@ def test_cachedResponse_gzip_on(self):
 
         assert not response.enableHTTPCompression(query=True)
 
-        body = cachedResponse(published, request, response, 404, headers, u"body", 1)
+        body = cachedResponse(published, request, response,
+                              404, headers, u"body", 1)
 
         self.assertEqual(u"body", body)
         self.assertEqual(404, response.getStatus())
@@ -485,7 +507,8 @@ def test_notModified_full(self):
         now = datetime.datetime.now(dateutil.tz.tzlocal())
         etag = "|foo|bar|"
 
-        body = notModified(published, request, response, etag=etag, lastModified=now)
+        body = notModified(published, request, response,
+                           etag=etag, lastModified=now)
 
         self.assertEqual(u"", body)
         self.assertEqual(etag, response.getHeader('ETag', literal=1))
@@ -494,6 +517,7 @@ def test_notModified_full(self):
         self.assertEqual(None, response.getHeader('Cache-Control'))
         self.assertEqual(304, response.getStatus())
 
+
 class CacheCheckHelpersTest(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -521,9 +545,11 @@ def test_isModified_no_headers_with_keys(self):
         request = HTTPRequest(StringIO(), environ, response)
 
         etag = '|foo'
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
-        self.assertEqual(True, isModified(request, etag=etag, lastModified=lastModified))
+        self.assertEqual(True, isModified(
+            request, etag=etag, lastModified=lastModified))
 
     def test_isModified_ims_invalid_date(self):
         from plone.app.caching.operations.utils import isModified
@@ -534,7 +560,8 @@ def test_isModified_ims_invalid_date(self):
 
         request.environ['HTTP_IF_MODIFIED_SINCE'] = 'blah'
 
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
         self.assertEqual(True, isModified(request, lastModified=lastModified))
 
@@ -545,9 +572,11 @@ def test_isModified_ims_modified(self):
         response = HTTPResponse()
         request = HTTPRequest(StringIO(), environ, response)
 
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
 
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
         self.assertEqual(True, isModified(request, lastModified=lastModified))
 
@@ -558,9 +587,11 @@ def test_isModified_ims_not_modified(self):
         response = HTTPResponse()
         request = HTTPRequest(StringIO(), environ, response)
 
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
 
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
         self.assertEqual(False, isModified(request, lastModified=lastModified))
 
@@ -571,9 +602,11 @@ def test_isModified_ims_not_modified_two_dates(self):
         response = HTTPResponse()
         request = HTTPRequest(StringIO(), environ, response)
 
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT; Thu, 24 Nov 2011 03:04:05'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT; Thu, 24 Nov 2011 03:04:05'
 
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
         self.assertEqual(False, isModified(request, lastModified=lastModified))
 
@@ -584,12 +617,15 @@ def test_isModified_ims_not_modified_etag_no_inm_header(self):
         response = HTTPResponse()
         request = HTTPRequest(StringIO(), environ, response)
 
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
 
         etag = '|foo'
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
-        self.assertEqual(True, isModified(request, etag=etag, lastModified=lastModified))
+        self.assertEqual(True, isModified(
+            request, etag=etag, lastModified=lastModified))
 
     def test_isModified_inm_no_tags(self):
         from plone.app.caching.operations.utils import isModified
@@ -690,8 +726,7 @@ def test_isModified_inm_match_update(self):
         etag = None
 
         self.assertEqual(True, isModified(request, etag=etag,
-                                           lastModified='doesnt_really_matter'))
-
+                                          lastModified='doesnt_really_matter'))
 
     def test_isModified_inm_match_multiple(self):
         from plone.app.caching.operations.utils import isModified
@@ -727,7 +762,8 @@ def test_isModified_inm_match_ignores_ims_if_no_last_modified_date(self):
         request = HTTPRequest(StringIO(), environ, response)
 
         request.environ['HTTP_IF_NONE_MATCH'] = '"|foo"'
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
 
         etag = '|foo'
 
@@ -741,12 +777,15 @@ def test_isModified_inm_match_modified(self):
         request = HTTPRequest(StringIO(), environ, response)
 
         request.environ['HTTP_IF_NONE_MATCH'] = '"|foo"'
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
 
         etag = '|foo'
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
-        self.assertEqual(True, isModified(request, etag=etag, lastModified=lastModified))
+        self.assertEqual(True, isModified(
+            request, etag=etag, lastModified=lastModified))
 
     def test_isModified_inm_match_not_modified(self):
         from plone.app.caching.operations.utils import isModified
@@ -756,12 +795,15 @@ def test_isModified_inm_match_not_modified(self):
         request = HTTPRequest(StringIO(), environ, response)
 
         request.environ['HTTP_IF_NONE_MATCH'] = '"|foo"'
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
 
         etag = '|foo'
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
-        self.assertEqual(False, isModified(request, etag=etag, lastModified=lastModified))
+        self.assertEqual(False, isModified(
+            request, etag=etag, lastModified=lastModified))
 
     # visibleToRole()
 
@@ -849,7 +891,8 @@ def test_formatDateTime_local(self):
 
         # We lose microseconds. Big whoop.
         p = dateutil.parser.parse(inGMT).astimezone(dateutil.tz.tzlocal())
-        lofi = datetime.datetime(2010, 11, 24, 3, 4, 5, 0, dateutil.tz.tzlocal())
+        lofi = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 0, dateutil.tz.tzlocal())
         self.assertEqual(p, lofi)
 
     def test_formatDateTime_naive(self):
@@ -864,7 +907,8 @@ def test_formatDateTime_naive(self):
 
         # Can't compare offset aware and naive
         p = dateutil.parser.parse(inGMT).astimezone(dateutil.tz.tzlocal())
-        self.assertEqual((2010, 11, 24, 3, 4, 5), (p.year, p.month, p.day, p.hour, p.minute, p.second))
+        self.assertEqual((2010, 11, 24, 3, 4, 5),
+                         (p.year, p.month, p.day, p.hour, p.minute, p.second))
 
     # parseDateTime()
 
@@ -883,7 +927,8 @@ def test_formatDateTime_no_timezone(self):
         from plone.app.caching.operations.utils import parseDateTime
 
         # parser will assume input was local time
-        dt = datetime.datetime(2010, 11, 23, 19, 4, 5, 0, dateutil.tz.tzlocal())
+        dt = datetime.datetime(2010, 11, 23, 19, 4, 5,
+                               0, dateutil.tz.tzlocal())
         self.assertEqual(dt, parseDateTime("'Tue, 23 Nov 2010 19:04:05'"))
 
     # getLastModified()
@@ -929,7 +974,7 @@ def __call__(self):
 
         published = DummyPublished()
         self.assertEqual(datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzlocal()),
-                          getLastModified(published))
+                         getLastModified(published))
 
     def test_getLastModified_timezone(self):
         from plone.app.caching.operations.utils import getLastModified
@@ -948,8 +993,7 @@ def __call__(self):
 
         published = DummyPublished()
         self.assertEqual(datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc()),
-                          getLastModified(published))
-
+                         getLastModified(published))
 
     # getExpiration()
 
@@ -988,7 +1032,6 @@ def test_getExpiration_future(self):
         # give the test two seconds' leeway
         self.assertTrue(difference >= datetime.timedelta(seconds=58))
 
-
     # getETag()
 
     def test_getETag_extra_only(self):
@@ -999,7 +1042,8 @@ def test_getETag_extra_only(self):
         request = HTTPRequest(StringIO(), environ, response)
         published = DummyPublished()
 
-        self.assertEqual('|foo|bar;baz', getETag(published, request, extraTokens=('foo', 'bar,baz')))
+        self.assertEqual('|foo|bar;baz', getETag(
+            published, request, extraTokens=('foo', 'bar,baz')))
 
     def test_getETag_key_not_found(self):
         from plone.app.caching.operations.utils import getETag
@@ -1009,7 +1053,8 @@ def test_getETag_key_not_found(self):
         request = HTTPRequest(StringIO(), environ, response)
         published = DummyPublished()
 
-        self.assertEqual(None, getETag(published, request, keys=('foo', 'bar',)))
+        self.assertEqual(None, getETag(
+            published, request, keys=('foo', 'bar',)))
 
     def test_getETag_adapter_returns_none(self):
         from plone.app.caching.operations.utils import getETag
@@ -1046,7 +1091,8 @@ def __call__(self):
         request = HTTPRequest(StringIO(), environ, response)
         published = DummyPublished()
 
-        self.assertEqual('|foo|', getETag(published, request, keys=('foo', 'bar',)))
+        self.assertEqual('|foo|', getETag(
+            published, request, keys=('foo', 'bar',)))
 
     def test_getETag_full(self):
         from plone.app.caching.operations.utils import getETag
@@ -1084,8 +1130,7 @@ def __call__(self):
         published = DummyPublished()
 
         self.assertEqual('|foo|bar|baz;qux', getETag(published, request,
-                keys=('foo', 'bar',), extraTokens=('baz,qux',)))
-
+                                                     keys=('foo', 'bar',), extraTokens=('baz,qux',)))
 
     # parseETags()
 
@@ -1115,35 +1160,44 @@ def test_parseETags_single_quoted(self):
 
     def test_parseETags_multiple(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('|foo|bar;baz, 1234'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('|foo|bar;baz, 1234'))
 
     def test_parseETags_multiple_quoted(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('"|foo|bar;baz", "1234"'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('"|foo|bar;baz", "1234"'))
 
     def test_parseETags_multiple_nospace(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('|foo|bar;baz,1234'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('|foo|bar;baz,1234'))
 
     def test_parseETags_multiple_quoted_nospace(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('"|foo|bar;baz","1234"'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('"|foo|bar;baz","1234"'))
 
     def test_parseETags_multiple_weak(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('|foo|bar;baz, W/1234'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('|foo|bar;baz, W/1234'))
 
     def test_parseETags_multiple_quoted_weak(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('"|foo|bar;baz", W/"1234"'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('"|foo|bar;baz", W/"1234"'))
 
     def test_parseETags_multiple_weak_disallowed(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz'], parseETags('|foo|bar;baz, W/1234', allowWeak=False))
+        self.assertEqual(['|foo|bar;baz'], parseETags(
+            '|foo|bar;baz, W/1234', allowWeak=False))
 
     def test_parseETags_multiple_quoted_weak_disallowed(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz'], parseETags('"|foo|bar;baz", W/"1234"', allowWeak=False))
+        self.assertEqual(['|foo|bar;baz'], parseETags(
+            '"|foo|bar;baz", W/"1234"', allowWeak=False))
+
 
 class RAMCacheTest(unittest.TestCase):
 
@@ -1195,7 +1249,6 @@ def __call__(self, key):
         provideUtility(Chooser())
         self.assertEqual(cache, getRAMCache())
 
-
     # getRAMCacheKey()
 
     def test_getRAMCacheKey_empty(self):
@@ -1217,7 +1270,8 @@ def test_getRAMCacheKey_normal(self):
         request.environ['PATH_INFO'] = '/foo/bar'
         request.environ['QUERY_STRING'] = 'x=1&y=2'
 
-        self.assertEqual('http://example.com/foo/bar?x=1&y=2', getRAMCacheKey(request))
+        self.assertEqual('http://example.com/foo/bar?x=1&y=2',
+                         getRAMCacheKey(request))
 
     def test_getRAMCacheKey_etag(self):
         from plone.app.caching.operations.utils import getRAMCacheKey
@@ -1229,8 +1283,8 @@ def test_getRAMCacheKey_etag(self):
         request.environ['PATH_INFO'] = '/foo/bar'
         request.environ['QUERY_STRING'] = 'x=1&y=2'
 
-        self.assertEqual('||foo|bar||http://example.com/foo/bar?x=1&y=2', getRAMCacheKey(request, etag="|foo|bar"))
-
+        self.assertEqual('||foo|bar||http://example.com/foo/bar?x=1&y=2',
+                         getRAMCacheKey(request, etag="|foo|bar"))
 
     # storeResponseInRAMCache()
 
@@ -1272,7 +1326,8 @@ def test_storeResponseInRAMCache_no_cache(self):
         result = u"Body"
         response.setHeader('X-Foo', 'bar')
 
-        IAnnotations(request)['plone.app.caching.operations.ramcache.key'] = 'foo'
+        IAnnotations(request)[
+            'plone.app.caching.operations.ramcache.key'] = 'foo'
 
         storeResponseInRAMCache(request, response, result)
 
@@ -1300,7 +1355,8 @@ def __call__(self, key):
         result = u"Body"
         response.setHeader('X-Foo', 'bar')
 
-        IAnnotations(request)['plone.app.caching.operations.ramcache.key'] = 'foo'
+        IAnnotations(request)[
+            'plone.app.caching.operations.ramcache.key'] = 'foo'
 
         storeResponseInRAMCache(request, response, result)
 
@@ -1335,7 +1391,8 @@ def __call__(self, key):
         result = u"Body"
         response.setHeader('X-Foo', 'bar')
 
-        IAnnotations(request)['plone.app.caching.operations.ramcache.key'] = 'foo'
+        IAnnotations(request)[
+            'plone.app.caching.operations.ramcache.key'] = 'foo'
 
         storeResponseInRAMCache(request, response, result)
 
@@ -1369,7 +1426,8 @@ def __call__(self, key):
 
         IAnnotations(request)['annkey'] = 'foo'
 
-        storeResponseInRAMCache(request, response, result, globalKey='cachekey', annotationsKey='annkey')
+        storeResponseInRAMCache(request, response, result,
+                                globalKey='cachekey', annotationsKey='annkey')
 
         self.assertEqual(1, len(cache))
         cached = normalize_response_cache(cache['foo'])
@@ -1442,9 +1500,11 @@ def __call__(self, key):
         request.environ['PATH_INFO'] = '/foo/bar'
         request.environ['QUERY_STRING'] = ''
 
-        cache['||a|b||http://example.com/foo/bar?'] = (200, {'x-foo': 'bar'}, u'Body')
+        cache[
+            '||a|b||http://example.com/foo/bar?'] = (200, {'x-foo': 'bar'}, u'Body')
 
-        cached = normalize_response_cache(fetchFromRAMCache(request, etag="|a|b"))
+        cached = normalize_response_cache(
+            fetchFromRAMCache(request, etag="|a|b"))
         self.assertEqual((200, {'x-foo': 'bar'}, u'Body'), cached)
 
     def test_fetchFromRAMCache_custom_key(self):
@@ -1473,7 +1533,8 @@ def __call__(self, key):
 
         cache['http://example.com/foo/bar?'] = (200, {'x-foo': 'bar'}, u'Body')
 
-        cached = normalize_response_cache(fetchFromRAMCache(request, globalKey='cachekey'))
+        cached = normalize_response_cache(
+            fetchFromRAMCache(request, globalKey='cachekey'))
         self.assertEqual((200, {'x-foo': 'bar'}, u'Body'), cached)
 
     def test_fetchFromRAMCache_miss(self):
@@ -1502,7 +1563,8 @@ def __call__(self, key):
 
         cache['http://example.com/foo/bar?'] = (200, {'x-foo': 'bar'}, u'Body')
 
-        cached = normalize_response_cache(fetchFromRAMCache(request, etag='|foo'))
+        cached = normalize_response_cache(
+            fetchFromRAMCache(request, etag='|foo'))
         self.assertEqual(None, cached)
 
     def test_fetchFromRAMCache_miss_custom_default(self):
@@ -1532,5 +1594,6 @@ def __call__(self, key):
         cache['http://example.com/foo/bar?'] = (200, {'x-foo': 'bar'}, u'Body')
 
         marker = object()
-        cached = normalize_response_cache(fetchFromRAMCache(request, etag='|foo', default=marker))
+        cached = normalize_response_cache(
+            fetchFromRAMCache(request, etag='|foo', default=marker))
         self.assertTrue(cached is marker)
diff --git a/plone/app/caching/tests/test_profile_with_caching_proxy.py b/plone/app/caching/tests/test_profile_with_caching_proxy.py
index 9143980..e027712 100644
--- a/plone/app/caching/tests/test_profile_with_caching_proxy.py
+++ b/plone/app/caching/tests/test_profile_with_caching_proxy.py
@@ -31,12 +31,14 @@
 import urllib
 
 
-TEST_FILE = pkg_resources.resource_filename('plone.app.caching.tests', 'test.gif')
+TEST_FILE = pkg_resources.resource_filename(
+    'plone.app.caching.tests', 'test.gif')
 
 
 def test_image():
     from plone.namedfile.file import NamedBlobImage
-    filename = pkg_resources.resource_filename('plone.app.caching.tests', 'test.gif')
+    filename = pkg_resources.resource_filename(
+        'plone.app.caching.tests', 'test.gif')
     filename = os.path.join(os.path.dirname(__file__), u'test.gif')
     return NamedBlobImage(
         data=open(filename, 'r').read(),
@@ -65,7 +67,8 @@ def setUp(self):
         self.app = self.layer['app']
         self.portal = self.layer['portal']
 
-        test_css = FSFile('test.css', os.path.join(os.path.dirname(__file__), 'test.css'))
+        test_css = FSFile('test.css', os.path.join(
+            os.path.dirname(__file__), 'test.css'))
         self.portal.portal_skins.custom._setOb('test.css', test_css)
 
         setRequest(self.portal.REQUEST)
@@ -75,8 +78,10 @@ def setUp(self):
         self.registry = getUtility(IRegistry)
 
         self.cacheSettings = self.registry.forInterface(ICacheSettings)
-        self.cachePurgingSettings = self.registry.forInterface(ICachePurgingSettings)
-        self.ploneCacheSettings = self.registry.forInterface(IPloneCacheSettings)
+        self.cachePurgingSettings = self.registry.forInterface(
+            ICachePurgingSettings)
+        self.ploneCacheSettings = self.registry.forInterface(
+            IPloneCacheSettings)
 
         self.cacheSettings.enabled = True
 
@@ -114,7 +119,8 @@ def test_composite_views(self):
 
         # Publish the folder and page
         self.portal.portal_workflow.doActionFor(self.portal['f1'], 'publish')
-        self.portal.portal_workflow.doActionFor(self.portal['f1']['d1'], 'publish')
+        self.portal.portal_workflow.doActionFor(
+            self.portal['f1']['d1'], 'publish')
 
         # Should we set up the etag components?
         # - set member?  No
@@ -125,56 +131,78 @@ def test_composite_views(self):
         # - leave status unlocked
         #
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the authenticated folder
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1'].absolute_url())
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0|0' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0|0' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Set the copy/cut cookie and then request the folder view again
         browser.cookies.create('__cp', 'xxx')
         browser.open(self.portal['f1'].absolute_url())
         # The response should be the same as before except for the etag
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0|1' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0|1' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
 
         # Request the authenticated page
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the authenticated page again -- to test RAM cache.
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # Authenticated should NOT be RAM cached
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
 
-        # Request the authenticated page again -- with an INM header to test 304
+        # Request the authenticated page again -- with an INM header to test
+        # 304
         etag = browser.headers['ETag']
         browser = Browser(self.app)
         browser.raiseHttpErrors = False  # we really do want to see the 304
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
         # This should be a 304 response
@@ -185,38 +213,54 @@ def test_composite_views(self):
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1'].absolute_url())
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0|0' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0|0' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page again -- to test RAM cache.
         # Anonymous should be RAM cached
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should come from RAM cache
-        self.assertEqual('plone.app.caching.operations.ramcache', browser.headers['X-RAMCache'])
+        self.assertEqual('plone.app.caching.operations.ramcache',
+                         browser.headers['X-RAMCache'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page again -- with an INM header to test 304.
         etag = browser.headers['ETag']
@@ -224,8 +268,10 @@ def test_composite_views(self):
         browser.raiseHttpErrors = False
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -239,15 +285,19 @@ def test_composite_views(self):
         )
         self.portal['f1']['d1'].reindexObject()
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
-        # Request the anonymous page again -- to test expiration of 304 and RAM.
+        # Request the anonymous page again -- to test expiration of 304 and
+        # RAM.
         etag = browser.headers['ETag']
         browser = Browser(self.app)
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # The etag has changed so we should get a fresh page.
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
         self.assertEqual('200 Ok', browser.headers['Status'])
@@ -263,18 +313,23 @@ def test_content_feeds(self):
         self.syndication.editProperties(isAllowed=True)
         self.syndication.enableSyndication(self.portal)
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the rss feed
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInProxy
-        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(), skins_tool.default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(),
+                                           skins_tool.default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the rss feed again -- to test RAM cache
         now = stable_now()
@@ -282,13 +337,18 @@ def test_content_feeds(self):
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should come from the RAM cache
-        self.assertEqual('plone.app.caching.operations.ramcache', browser.headers['X-RAMCache'])
+        self.assertEqual('plone.app.caching.operations.ramcache',
+                         browser.headers['X-RAMCache'])
         self.assertEqual(rssText, browser.contents)
-        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(), skins_tool.default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(),
+                                           skins_tool.default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the rss feed again -- with an INM header to test 304.
         etag = browser.headers['ETag']
@@ -297,7 +357,8 @@ def test_content_feeds(self):
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -305,21 +366,28 @@ def test_content_feeds(self):
         # Request the authenticated rss feed
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s"' % (catalog.getCounter(), skins_tool.default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s"' % (
+            catalog.getCounter(), skins_tool.default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the authenticated rss feed again -- to test RAM cache
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # Authenticated should NOT be RAM cached
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
 
@@ -339,52 +407,69 @@ def test_content_files(self):
         self.portal['f1']['i1'].image = test_image()
         self.portal['f1']['i1'].reindexObject()
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the image with Manager role
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,))
         browser.open(self.portal['f1']['i1'].absolute_url())
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # Folder not published yet so image should not be cached in proxy
         # so this should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request an image scale with Manager role
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,))
-        browser.open(self.portal['f1']['i1'].absolute_url() + '/@@images/image/preview')
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,))
+        browser.open(self.portal['f1'][
+                     'i1'].absolute_url() + '/@@images/image/preview')
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # Folder not published yet so image scale should not be cached in proxy
         # so this should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Publish the folder
         self.portal.portal_workflow.doActionFor(self.portal['f1'], 'publish')
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the image
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['i1'].absolute_url())
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # Now visible to anonymous so this should use cacheInProxy
-        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the image again -- with an IMS header to test 304
         lastmodified = browser.headers['Last-Modified']
@@ -393,7 +478,8 @@ def test_content_files(self):
         browser.addHeader('If-Modified-Since', lastmodified)
         browser.open(self.portal['f1']['i1'].absolute_url())
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -401,30 +487,39 @@ def test_content_files(self):
         # Request an image scale
         now = stable_now()
         browser = Browser(self.app)
-        browser.open(self.portal['f1']['i1'].absolute_url() + '/@@images/image/preview')
+        browser.open(self.portal['f1'][
+                     'i1'].absolute_url() + '/@@images/image/preview')
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # Now visible to anonymous so this should use cacheInProxy
-        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
     def test_resources(self):
         # This is a clone of the same test for 'without-caching-proxy'
         # Can we just call that test from this context?
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request a skin image
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/rss.png')
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowserAndProxy
-        self.assertEqual('max-age=86400, proxy-revalidate, public', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=86400, proxy-revalidate, public',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
         timedelta = dateutil.parser.parse(browser.headers['Expires']) - now
         self.assertTrue(timedelta > datetime.timedelta(seconds=86390))
@@ -436,7 +531,8 @@ def test_resources(self):
         browser.addHeader('If-Modified-Since', lastmodified)
         browser.open(self.portal.absolute_url() + '/rss.png')
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -448,17 +544,22 @@ def test_resources(self):
         # large Resource Registry cooked files, which all use the same
         # method to initiate a streamed response.
         s = "a" * (1 << 16) * 3
-        self.portal.manage_addFile('bigfile', file=StringIO(s), content_type='application/octet-stream')
+        self.portal.manage_addFile('bigfile', file=StringIO(
+            s), content_type='application/octet-stream')
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         browser = Browser(self.app)
         browser.open(self.portal['bigfile'].absolute_url())
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowserAndProxy
-        self.assertEqual('max-age=86400, proxy-revalidate, public', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=86400, proxy-revalidate, public',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
         timedelta = dateutil.parser.parse(browser.headers['Expires']) - now
         self.assertTrue(timedelta > datetime.timedelta(seconds=86390))
diff --git a/plone/app/caching/tests/test_profile_without_caching_proxy.py b/plone/app/caching/tests/test_profile_without_caching_proxy.py
index f8848a1..fedb42a 100644
--- a/plone/app/caching/tests/test_profile_without_caching_proxy.py
+++ b/plone/app/caching/tests/test_profile_without_caching_proxy.py
@@ -28,12 +28,14 @@
 import urllib
 
 
-TEST_FILE = pkg_resources.resource_filename('plone.app.caching.tests', 'test.gif')
+TEST_FILE = pkg_resources.resource_filename(
+    'plone.app.caching.tests', 'test.gif')
 
 
 def test_image():
     from plone.namedfile.file import NamedBlobImage
-    filename = pkg_resources.resource_filename('plone.app.caching.tests', 'test.gif')
+    filename = pkg_resources.resource_filename(
+        'plone.app.caching.tests', 'test.gif')
     filename = os.path.join(os.path.dirname(__file__), u'test.gif')
     return NamedBlobImage(
         data=open(filename, 'r').read(),
@@ -62,7 +64,8 @@ def setUp(self):
         self.app = self.layer['app']
         self.portal = self.layer['portal']
 
-        test_css = FSFile('test.css', os.path.join(os.path.dirname(__file__), 'test.css'))
+        test_css = FSFile('test.css', os.path.join(
+            os.path.dirname(__file__), 'test.css'))
         self.portal.portal_skins.custom._setOb('test.css', test_css)
 
         setRequest(self.portal.REQUEST)
@@ -72,8 +75,10 @@ def setUp(self):
         self.registry = getUtility(IRegistry)
 
         self.cacheSettings = self.registry.forInterface(ICacheSettings)
-        self.cachePurgingSettings = self.registry.forInterface(ICachePurgingSettings)
-        self.ploneCacheSettings = self.registry.forInterface(IPloneCacheSettings)
+        self.cachePurgingSettings = self.registry.forInterface(
+            ICachePurgingSettings)
+        self.ploneCacheSettings = self.registry.forInterface(
+            IPloneCacheSettings)
 
         self.cacheSettings.enabled = True
 
@@ -106,7 +111,8 @@ def test_composite_views(self):
 
         # Publish the folder and page
         self.portal.portal_workflow.doActionFor(self.portal['f1'], 'publish')
-        self.portal.portal_workflow.doActionFor(self.portal['f1']['d1'], 'publish')
+        self.portal.portal_workflow.doActionFor(
+            self.portal['f1']['d1'], 'publish')
 
         # Should we set up the etag components?
         # - set member?  No
@@ -117,56 +123,78 @@ def test_composite_views(self):
         # - leave status unlocked
         # - set the mod date on the resource registries?  Probably.
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the quthenticated folder
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1'].absolute_url())
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0|0' % (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0|0' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Set the copy/cut cookie and then request the folder view again
         browser.cookies.create('__cp', 'xxx')
         browser.open(self.portal['f1'].absolute_url())
         # The response should be the same as before except for the etag
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0|1' % (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0|1' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
 
         # Request the authenticated page
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0' % (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the authenticated page again -- to test RAM cache.
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # Authenticated should NOT be RAM cached
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
 
-        # Request the authenticated page again -- with an INM header to test 304
+        # Request the authenticated page again -- with an INM header to test
+        # 304
         etag = browser.headers['ETag']
         browser = Browser(self.app)
         browser.raiseHttpErrors = False  # we really do want to see the 304
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
         # This should be a 304 response
@@ -177,38 +205,54 @@ def test_composite_views(self):
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1'].absolute_url())
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0|0'  % (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0|0' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0' % (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page again -- to test RAM cache.
         # Anonymous should be RAM cached
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should come from RAM cache
-        self.assertEqual('plone.app.caching.operations.ramcache', browser.headers['X-RAMCache'])
+        self.assertEqual('plone.app.caching.operations.ramcache',
+                         browser.headers['X-RAMCache'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0'% (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page again -- with an INM header to test 304.
         etag = browser.headers['ETag']
@@ -216,8 +260,10 @@ def test_composite_views(self):
         browser.raiseHttpErrors = False
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -233,13 +279,16 @@ def test_composite_views(self):
 
         transaction.commit()
 
-        # Request the anonymous page again -- to test expiration of 304 and RAM.
+        # Request the anonymous page again -- to test expiration of 304 and
+        # RAM.
         etag = browser.headers['ETag']
         browser = Browser(self.app)
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # The etag has changed so we should get a fresh page.
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
         self.assertEqual('200 Ok', browser.headers['Status'])
@@ -255,18 +304,23 @@ def test_content_feeds(self):
         self.syndication.editProperties(isAllowed=True)
         self.syndication.enableSyndication(self.portal)
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the rss feed
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(), default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(),
+                                           default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the rss feed again -- to test RAM cache
         now = stable_now()
@@ -274,13 +328,18 @@ def test_content_feeds(self):
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should come from RAM cache
-        self.assertEqual('plone.app.caching.operations.ramcache', browser.headers['X-RAMCache'])
+        self.assertEqual('plone.app.caching.operations.ramcache',
+                         browser.headers['X-RAMCache'])
         self.assertEqual(rssText, browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(), default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(),
+                                           default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the rss feed again -- with an INM header to test 304.
         etag = browser.headers['ETag']
@@ -289,7 +348,8 @@ def test_content_feeds(self):
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -297,21 +357,28 @@ def test_content_feeds(self):
         # Request the authenticated rss feed
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s"' % (catalog.getCounter(), default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s"' % (
+            catalog.getCounter(), default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the authenticated rss feed again -- to test RAM cache
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # Authenticated should NOT be RAM cached
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
 
@@ -334,19 +401,24 @@ def test_content_files(self):
         # Publish the folder
         self.portal.portal_workflow.doActionFor(self.portal['f1'], 'publish')
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the image
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['i1'].absolute_url())
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the image again -- with an IMS header to test 304
         lastmodified = browser.headers['Last-Modified']
@@ -355,7 +427,8 @@ def test_content_files(self):
         browser.addHeader('If-Modified-Since', lastmodified)
         browser.open(self.portal['f1']['i1'].absolute_url())
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -363,28 +436,37 @@ def test_content_files(self):
         # Request an image scale
         now = stable_now()
         browser = Browser(self.app)
-        browser.open(self.portal['f1']['i1'].absolute_url() + '/@@images/image/preview')
+        browser.open(self.portal['f1'][
+                     'i1'].absolute_url() + '/@@images/image/preview')
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
     def test_resources(self):
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request a skin image
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/rss.png')
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowserAndProxy
-        self.assertEqual('max-age=86400, proxy-revalidate, public', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=86400, proxy-revalidate, public',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
         timedelta = dateutil.parser.parse(browser.headers['Expires']) - now
         self.assertTrue(timedelta > datetime.timedelta(seconds=86390))
@@ -396,7 +478,8 @@ def test_resources(self):
         browser.addHeader('If-Modified-Since', lastmodified)
         browser.open(self.portal.absolute_url() + '/rss.png')
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -408,17 +491,22 @@ def test_resources(self):
         # large Resource Registry cooked files, which all use the same
         # method to initiate a streamed response.
         s = "a" * (1 << 16) * 3
-        self.portal.manage_addFile('bigfile', file=StringIO(s), content_type='application/octet-stream')
+        self.portal.manage_addFile('bigfile', file=StringIO(
+            s), content_type='application/octet-stream')
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         browser = Browser(self.app)
         browser.open(self.portal['bigfile'].absolute_url())
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowserAndProxy
-        self.assertEqual('max-age=86400, proxy-revalidate, public', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=86400, proxy-revalidate, public',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
         timedelta = dateutil.parser.parse(browser.headers['Expires']) - now
         self.assertTrue(timedelta > datetime.timedelta(seconds=86390))
diff --git a/plone/app/caching/tests/test_purge.py b/plone/app/caching/tests/test_purge.py
index 3d046bf..bac4b7a 100644
--- a/plone/app/caching/tests/test_purge.py
+++ b/plone/app/caching/tests/test_purge.py
@@ -45,9 +45,11 @@ def __init__(self):
     def handler(self, event):
         self.invocations.append(event)
 
+
 class FauxRequest(dict):
     pass
 
+
 @implementer(IContentish)
 class FauxNonContent(Explicit):
 
@@ -68,6 +70,7 @@ def virtual_url_path(self):
     def getPhysicalPath(self):
         return ('', )
 
+
 @implementer(IBrowserDefault)
 class FauxContent(FauxNonContent):
 
@@ -76,10 +79,12 @@ class FauxContent(FauxNonContent):
     def defaultView(self):
         return 'default-view'
 
+
 @implementer(IDiscussionResponse)
 class FauxDiscussable(Explicit):
     pass
 
+
 class TestPurgeRedispatch(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -151,6 +156,7 @@ def test_removed(self):
         self.assertEqual(1, len(self.handler.invocations))
         self.assertEqual(context, self.handler.invocations[0].object)
 
+
 class TestContentPurgePaths(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -188,6 +194,7 @@ def test_parent_default_view(self):
                          list(purger.getRelativePaths()))
         self.assertEqual([], list(purger.getAbsolutePaths()))
 
+
 class TestDiscussionItemPurgePaths(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -281,6 +288,7 @@ def getDiscussionThread(self, item):
         self.assertEqual(['/app/foo'], list(purge.getRelativePaths()))
         self.assertEqual(['/purgeme'], list(purge.getAbsolutePaths()))
 
+
 class TestObjectFieldPurgePaths(unittest.TestCase):
 
     maxDiff = None
@@ -308,7 +316,8 @@ class ATMultipleFields(atapi.BaseContent):
                 atapi.StringField('foo'),
                 atapi.FileField('file1'),
                 atapi.ImageField('image1'),
-                atapi.ImageField('image2', sizes={'mini': (50, 50), 'normal': (100, 100)}),
+                atapi.ImageField('image2', sizes={
+                                 'mini': (50, 50), 'normal': (100, 100)}),
                 BlobField('blob1'),
             ))
 
@@ -331,7 +340,8 @@ class ATMultipleFields(atapi.BaseContent):
                 atapi.StringField('foo'),
                 atapi.FileField('file1'),
                 atapi.ImageField('image1'),
-                atapi.ImageField('image2', sizes={'mini': (50, 50), 'normal': (100, 100)}),
+                atapi.ImageField('image2', sizes={
+                                 'mini': (50, 50), 'normal': (100, 100)}),
                 atapi.TextField('text'),
             ))
 
diff --git a/plone/app/caching/tests/test_utils.py b/plone/app/caching/tests/test_utils.py
index 925baec..6d0c3ec 100644
--- a/plone/app/caching/tests/test_utils.py
+++ b/plone/app/caching/tests/test_utils.py
@@ -41,16 +41,18 @@ def __init__(self, portal_type='testtype', defaultView='defaultView'):
     def defaultView(self):
         return self._defaultView
 
+
 class DummyNotContent(Explicit):
     pass
 
+
 class DummyFTI(object):
 
     def __init__(self, portal_type, viewAction=''):
         self.id = portal_type
         self._actions = {
-                'object/view': {'url': viewAction},
-            }
+            'object/view': {'url': viewAction},
+        }
 
     def getActionInfo(self, name):
         return self._actions[name]
@@ -62,6 +64,7 @@ def queryMethodID(self, id, default=None, context=None):
             return '@@defaultView'
         return default
 
+
 @implementer(IDynamicType)
 class DummyNotBrowserDefault(Explicit):
 
@@ -72,6 +75,7 @@ def __init__(self, portal_type='testtype', viewAction=''):
     def getTypeInfo(self):
         return DummyFTI(self.portal_type, self._viewAction)
 
+
 class TestIsPurged(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -121,6 +125,7 @@ def test_listed(self):
         content = DummyContent()
         self.assertEqual(True, isPurged(content))
 
+
 class TestGetObjectDefaultPath(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -138,7 +143,8 @@ def test_browserviewdefault(self):
         self.assertEqual('defaultView', getObjectDefaultView(context))
 
     def test_not_IBrowserDefault_methodid(self):
-        context = DummyNotBrowserDefault('testtype', 'string:${object_url}/view')
+        context = DummyNotBrowserDefault(
+            'testtype', 'string:${object_url}/view')
         self.assertEqual('defaultView', getObjectDefaultView(context))
 
     def test_not_IBrowserDefault_default_method(self):
@@ -146,5 +152,6 @@ def test_not_IBrowserDefault_default_method(self):
         self.assertEqual('defaultView', getObjectDefaultView(context))
 
     def test_not_IBrowserDefault_actiononly(self):
-        context = DummyNotBrowserDefault('testtype', 'string:${object_url}/defaultView')
+        context = DummyNotBrowserDefault(
+            'testtype', 'string:${object_url}/defaultView')
         self.assertEqual('defaultView', getObjectDefaultView(context))
diff --git a/plone/app/caching/utils.py b/plone/app/caching/utils.py
index 9317c05..83a5a64 100644
--- a/plone/app/caching/utils.py
+++ b/plone/app/caching/utils.py
@@ -27,6 +27,7 @@ def isPurged(object):
 
     return (portal_type in settings.purgedContentTypes)
 
+
 def stripLeadingCharacters(name):
     """Strip off leading / and/or @@
     """
@@ -38,6 +39,7 @@ def stripLeadingCharacters(name):
 
     return name
 
+
 def getObjectDefaultView(context):
     """Get the id of an object's default view
     """
@@ -59,7 +61,7 @@ def getObjectDefaultView(context):
     fti = context.getTypeInfo()
     try:
         # XXX: This isn't quite right since it assumes the action starts
-        #with ${object_url}
+        # with ${object_url}
         action = fti.getActionInfo('object/view')['url'].split('/')[-1]
     except ValueError:
         # If the action doesn't exist, stop
@@ -67,9 +69,9 @@ def getObjectDefaultView(context):
 
     # Try resolving method aliases because we need a real template_id here
     if action:
-        action = fti.queryMethodID(action, default = action, context = context)
+        action = fti.queryMethodID(action, default=action, context=context)
     else:
-        action = fti.queryMethodID('(Default)', default = action,
-                                   context = context)
+        action = fti.queryMethodID('(Default)', default=action,
+                                   context=context)
 
     return stripLeadingCharacters(action)


Repository: plone.app.caching


Branch: refs/heads/master
Date: 2016-09-27T16:24:47+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.caching/commit/7255035c7fcde95a515f277cc487910d902a566f

manual cleanup

Files changed:
M CHANGES.rst
M plone/app/caching/browser/controlpanel.py
M plone/app/caching/browser/edit.py
M plone/app/caching/lastmodified.py
M plone/app/caching/lookup.py
M plone/app/caching/operations/default.py
M plone/app/caching/operations/etags.py
M plone/app/caching/operations/ramcache.py
M plone/app/caching/operations/utils.py
M plone/app/caching/purge.py
M plone/app/caching/testing.py
M plone/app/caching/tests/test_etags.py
M plone/app/caching/tests/test_lookup.py
M plone/app/caching/tests/test_operation_utils.py
M plone/app/caching/tests/test_profile_with_caching_proxy.py
M plone/app/caching/tests/test_profile_without_caching_proxy.py
M plone/app/caching/tests/test_purge.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 9d629c0..efb5291 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -14,7 +14,8 @@ New features:
 
 Bug fixes:
 
-- *add item here*
+- Code-Style: isort, utf8-headers, zca-decorators, manual cleanup.
+  [jensens]
 
 
 1.2.12 (2016-09-16)
diff --git a/plone/app/caching/browser/controlpanel.py b/plone/app/caching/browser/controlpanel.py
index 0977731..b53d70d 100644
--- a/plone/app/caching/browser/controlpanel.py
+++ b/plone/app/caching/browser/controlpanel.py
@@ -109,7 +109,10 @@ def publishTraverse(self, request, name):
             return self  # traverse again to get operation name
 
         # Step 2 - get operation name
-        if (self.editGlobal or self.editRuleset) and not self.editOperationName:
+        if (
+            (self.editGlobal or self.editRuleset) and
+            not self.editOperationName
+        ):
             self.editOperationName = name
 
             if self.editGlobal:
@@ -119,14 +122,23 @@ def publishTraverse(self, request, name):
                 if operation is None:
                     raise NotFound(self, operation)
 
-                return EditForm(self.context, self.request, self.editOperationName, operation)
+                return EditForm(
+                    self.context,
+                    self.request,
+                    self.editOperationName,
+                    operation
+                )
             elif self.editRuleset:
                 return self  # traverse again to get ruleset name
             else:
                 raise NotFound(self, name)
 
         # Step 3 - if this is ruleset traversal, get the ruleset name
-        if self.editRuleset and self.editOperationName and not self.editRulesetName:
+        if (
+            self.editRuleset and
+            self.editOperationName and
+            not self.editRulesetName
+        ):
             self.editRulesetName = name
 
             operation = queryUtility(
@@ -195,7 +207,6 @@ def processSave(self):
             operationMapping[ruleset] = operation
 
         for ruleset, contentTypes in contentTypesMap.items():
-
             if not ruleset:
                 continue
 
@@ -203,9 +214,7 @@ def processSave(self):
                 ruleset = ruleset.encode('utf-8')
 
             ruleset = ruleset.replace('-', '.')
-
             for contentType in contentTypes:
-
                 if not contentType:
                     continue
 
@@ -213,16 +222,25 @@ def processSave(self):
                     contentType = contentType.encode('utf-8')
 
                 if contentType in contentTypeRulesetMapping:
-                    self.errors.setdefault('contenttypes', {})[ruleset] = \
-                        _(u"Content type ${contentType} is already mapped to the rule ${ruleset}.",
-                            mapping={
-                                'contentType': self.contentTypesLookup.get(contentType, {}).get('title', contentType),  # noqa
-                                'ruleset': contentTypeRulesetMapping[contentType]})
+                    self.errors.setdefault(
+                        'contenttypes', {}
+                    )[ruleset] = _(
+                        u'Content type ${contentType} is already mapped to '
+                        u'the rule ${ruleset}.',
+                        mapping={
+                            'contentType': self.contentTypesLookup.get(
+                                contentType, {}
+                            ).get(
+                                'title',
+                                contentType
+                            ),
+                            'ruleset': contentTypeRulesetMapping[contentType]
+                        }
+                    )
                 else:
                     contentTypeRulesetMapping[contentType] = ruleset
 
         for ruleset, templates in templatesMap.items():
-
             if not ruleset:
                 continue
 
@@ -230,11 +248,8 @@ def processSave(self):
                 ruleset = ruleset.encode('utf-8')
 
             ruleset = ruleset.replace('-', '.')
-
             for template in templates:
-
                 template = template.strip()
-
                 if not template:
                     continue
 
@@ -242,16 +257,20 @@ def processSave(self):
                     template = template.encode('utf-8')
 
                 if template in templateRulesetMapping:
-                    self.errors.setdefault('templates', {})[ruleset] = \
-                        _(u"Template ${template} is already mapped to the rule ${ruleset}.",
-                            mapping={
-                                'template': template,
-                                'ruleset': templateRulesetMapping[template]})
+                    self.errors.setdefault(
+                        'templates', {}
+                    )[ruleset] = _(
+                        u'Template ${template} is already mapped to the rule '
+                        u'${ruleset}.',
+                        mapping={
+                            'template': template,
+                            'ruleset': templateRulesetMapping[template]
+                        }
+                    )
                 else:
                     templateRulesetMapping[template] = ruleset
 
         # Validate purging settings
-
         for cachingProxy in cachingProxies:
             if not _isuri(cachingProxy):
                 self.errors['cachingProxies'] = _(u"Invalid URL: ${url}", mapping={'url': cachingProxy})  # noqa
@@ -259,10 +278,11 @@ def processSave(self):
         for domain in domains:
             if not _isuri(domain):
                 self.errors['domain'] = _(
-                    u"Invalid URL: ${url}", mapping={'url': domain})
+                    u'Invalid URL: ${url}',
+                    mapping={'url': domain}
+                )
 
         # RAM cache settings
-
         try:
             ramCacheMaxEntries = int(ramCacheMaxEntries)
         except (ValueError, TypeError,):
@@ -270,8 +290,8 @@ def processSave(self):
         else:
             if ramCacheMaxEntries < 0:
                 self.errors['ramCacheMaxEntries'] = _(
-                    u"A positive number is required.")
-
+                    u"A positive number is required."
+                )
         try:
             ramCacheMaxAge = int(ramCacheMaxAge)
         except (ValueError, TypeError,):
@@ -279,17 +299,20 @@ def processSave(self):
         else:
             if ramCacheMaxAge < 0:
                 self.errors['ramCacheMaxAge'] = _(
-                    u"A positive number is required.")
+                    u'A positive number is required.'
+                )
 
         try:
             ramCacheCleanupInterval = int(ramCacheCleanupInterval)
         except (ValueError, TypeError,):
             self.errors['ramCacheCleanupInterval'] = _(
-                u"An integer is required.")
+                u'An integer is required.'
+            )
         else:
             if ramCacheMaxAge < 0:
                 self.errors['ramCacheCleanupInterval'] = _(
-                    u"A positive number is required.")
+                    u'A positive number is required.'
+                )
 
         # Check for errors
         if self.errors:
@@ -302,7 +325,7 @@ def processSave(self):
         self.settings.operationMapping = operationMapping
 
         self.ploneSettings.templateRulesetMapping = templateRulesetMapping
-        self.ploneSettings.contentTypeRulesetMapping = contentTypeRulesetMapping
+        self.ploneSettings.contentTypeRulesetMapping = contentTypeRulesetMapping  # noqa
         self.ploneSettings.purgedContentTypes = purgedContentTypes
 
         self.purgingSettings.enabled = purgingEnabled
@@ -310,11 +333,16 @@ def processSave(self):
         self.purgingSettings.virtualHosting = virtualHosting
         self.purgingSettings.domains = domains
 
-        self.ramCache.update(ramCacheMaxEntries,
-                             ramCacheMaxAge, ramCacheCleanupInterval)
+        self.ramCache.update(
+            ramCacheMaxEntries,
+            ramCacheMaxAge,
+            ramCacheCleanupInterval
+        )
 
         IStatusMessage(self.request).addStatusMessage(
-            _(u"Changes saved."), "info")
+            _(u'Changes saved.'),
+            'info'
+        )
 
     # Rule types - used as the index column
     @property
@@ -343,15 +371,23 @@ def operationMapping(self):
     @property
     def templateMapping(self):
         return dict(
-            [(k, v.replace('.', '-'),)
-             for k, v in (self.ploneSettings.templateRulesetMapping or {}).items()]
+            [
+                (k, v.replace('.', '-'),)
+                for k, v in (
+                    self.ploneSettings.templateRulesetMapping or {}
+                ).items()
+            ]
         )
 
     @property
     def contentTypeMapping(self):
         return dict(
-            [(k, v.replace('.', '-'),)
-             for k, v in (self.ploneSettings.contentTypeRulesetMapping or {}).items()]
+            [
+                (k, v.replace('.', '-'),)
+                for k, v in (
+                    self.ploneSettings.contentTypeRulesetMapping or {}
+                ).items()
+            ]
         )
 
     # Type lookups (for accessing settings)
@@ -498,8 +534,13 @@ def processImport(self):
     @memoize
     def profiles(self):
         portal_setup = getToolByName(self.context, 'portal_setup')
-        return [profile for profile in portal_setup.listProfileInfo(ICacheProfiles)
-                if profile.get('type', BASE) == EXTENSION and profile.get('for') is not None]
+        return [
+            profile for profile in portal_setup.listProfileInfo(ICacheProfiles)
+            if (
+                profile.get('type', BASE) == EXTENSION and
+                profile.get('for') is not None
+            )
+        ]
 
 
 class Purge(BaseView):
@@ -508,7 +549,6 @@ class Purge(BaseView):
 
     def update(self):
         self.purgeLog = []
-
         if super(Purge, self).update():
             if 'form.button.Purge' in self.request.form:
                 self.processPurge()
@@ -526,7 +566,6 @@ def processPurge(self):
             return
 
         purger = getUtility(IPurger)
-
         serverURL = self.request['SERVER_URL']
 
         def purge(url):
diff --git a/plone/app/caching/browser/edit.py b/plone/app/caching/browser/edit.py
index bf4ec1a..3522a86 100644
--- a/plone/app/caching/browser/edit.py
+++ b/plone/app/caching/browser/edit.py
@@ -59,7 +59,15 @@ class EditForm(form.Form):
     # registration
     __name__ = 'cache-operation-edit'
 
-    def __init__(self, context, request, operationName, operation, rulesetName=None, ruleset=None):
+    def __init__(
+        self,
+        context,
+        request,
+        operationName,
+        operation,
+        rulesetName=None,
+        ruleset=None
+    ):
         self.context = context
         self.request = request
         self.operationName = operationName
@@ -228,7 +236,7 @@ def description(self):
 
     # Buttons/actions
 
-    @button.buttonAndHandler(_(u"Save"), name="save")
+    @button.buttonAndHandler(_(u'Save'), name='save')
     def save(self, action):
         data, errors = self.extractData()
         if errors:
@@ -236,19 +244,29 @@ def save(self, action):
             return
         self.applyChanges(data)
         IStatusMessage(self.request).addStatusMessage(
-            _(u"Changes saved."), "info")
+            _(u'Changes saved.'), 'info')
         self.request.response.redirect(
-            "%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
+            '{0}/@@caching-controlpanel#detailed-settings'.format(
+                self.context.absolute_url()
+            )
+        )
+        return ''
 
-    @button.buttonAndHandler(_(u"Cancel"), name="cancel")
+    @button.buttonAndHandler(_(u'Cancel'), name='cancel')
     def cancel(self, action):
         IStatusMessage(self.request).addStatusMessage(
             _(u"Edit cancelled."), type="info")
         self.request.response.redirect(
-            "%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
+            '{0}/@@caching-controlpanel#detailed-settings'.format(
+                self.context.absolute_url()
+            )
+        )
         return ''
 
-    @button.buttonAndHandler(_(u"Delete settings (use defaults)"), name="clear")
+    @button.buttonAndHandler(
+        _(u'Delete settings (use defaults)'),
+        name='clear'
+    )
     def clear(self, action):
         for key in self.getContent().keys():
             assert key.startswith("%s.%s." % (
@@ -260,5 +278,8 @@ def clear(self, action):
         IStatusMessage(self.request).addStatusMessage(
             _(u"Ruleset-specific settings removed."), type="info")
         self.request.response.redirect(
-            "%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
+            '{0}/@@caching-controlpanel#detailed-settings'.format(
+                self.context.absolute_url()
+            )
+        )
         return ''
diff --git a/plone/app/caching/lastmodified.py b/plone/app/caching/lastmodified.py
index 5570e1b..9cef1ac 100644
--- a/plone/app/caching/lastmodified.py
+++ b/plone/app/caching/lastmodified.py
@@ -1,7 +1,5 @@
 # -*- coding: utf-8 -*-
 from Acquisition import aq_base
-from Acquisition import aq_inner
-from Acquisition import aq_parent
 from datetime import datetime
 from dateutil.tz import tzlocal
 from OFS.Image import File
@@ -15,7 +13,6 @@
 from z3c.caching.interfaces import ILastModified
 from zope.browserresource.interfaces import IResource
 from zope.component import adapter
-from zope.component import adapts
 from zope.interface import implementer
 from zope.interface import Interface
 from zope.pagetemplate.interfaces import IPageTemplate
@@ -68,17 +65,17 @@ def __call__(self):
         return None
 
 
+@adapter(File)
 class OFSFileLastModified(PersistentLastModified):
     """ILastModified adapter for OFS.Image.File
     """
-    adapts(File)
 
 
 @implementer(ILastModified)
+@adapter(ImageScale)
 class ImageScaleLastModified(object):
     """ILastModified adapter for Products.Archetypes.Field.Image
     """
-    adapts(ImageScale)
 
     def __init__(self, context):
         self.context = context
@@ -91,10 +88,10 @@ def __call__(self):
 
 
 @implementer(ILastModified)
+@adapter(FSObject)
 class FSObjectLastModified(object):
     """ILastModified adapter for FSFile and FSImage
     """
-    adapts(FSObject)
 
     def __init__(self, context):
         self.context = context
@@ -109,11 +106,11 @@ def __call__(self):
 
 
 @implementer(ILastModified)
+@adapter(ICatalogableDublinCore)
 class CatalogableDublinCoreLastModified(object):
     """ILastModified adapter for ICatalogableDublinCore, which includes
     most CMF, Archetypes and Dexterity content
     """
-    adapts(ICatalogableDublinCore)
 
     def __init__(self, context):
         self.context = context
@@ -126,10 +123,10 @@ def __call__(self):
 
 
 @implementer(ILastModified)
+@adapter(IDCTimes)
 class DCTimesLastModified(object):
     """ILastModified adapter for zope.dublincore IDCTimes
     """
-    adapts(IDCTimes)
 
     def __init__(self, context):
         self.context = context
@@ -139,10 +136,10 @@ def __call__(self):
 
 
 @implementer(ILastModified)
+@adapter(IResource)
 class ResourceLastModified(object):
     """ILastModified for Zope 3 style browser resources
     """
-    adapts(IResource)
 
     def __init__(self, context):
         self.context = context
@@ -151,24 +148,25 @@ def __call__(self):
         lmt = getattr(self.context.context, 'lmt', None)
         if lmt is not None:
             return datetime.fromtimestamp(lmt, tzlocal())
-        return None
 
 
 @implementer(ILastModified)
+@adapter(ICookedFile)
 class CookedFileLastModified(object):
     """ILastModified for Resource Registry `cooked` files
     """
-    adapts(ICookedFile)
 
     def __init__(self, context):
         self.context = context
 
     def __call__(self):
         registry = getContext(self.context, IResourceRegistry)
-        if registry is not None:
-            if registry.getDebugMode() or not registry.isCacheable(self.context.__name__):
-                return None
-            mtime = getattr(registry.aq_base, '_p_mtime', None)
-            if mtime is not None and mtime > 0:
-                return datetime.fromtimestamp(mtime, tzlocal())
-        return None
+        if (
+            registry is None or
+            registry.getDebugMode() or
+            not registry.isCacheable(self.context.__name__)
+        ):
+            return None
+        mtime = getattr(registry.aq_base, '_p_mtime', None)
+        if mtime is not None and mtime > 0:
+            return datetime.fromtimestamp(mtime, tzlocal())
diff --git a/plone/app/caching/lookup.py b/plone/app/caching/lookup.py
index a3a5f5d..c044141 100644
--- a/plone/app/caching/lookup.py
+++ b/plone/app/caching/lookup.py
@@ -47,8 +47,8 @@ class ContentItemLookup(object):
     """
 
     # This adapter is registered twice in configure.zcml, ala:
-    # adapts(IPageTemplate, Interface)
-    # adapts(IBrowserView, Interface)
+    # @adapter(IPageTemplate, Interface)
+    # @adapter(IBrowserView, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -81,31 +81,34 @@ def __call__(self):
 
         # 4. Find the parent of the published object
         parent = getattr(self.published, '__parent__', None)
-        if parent is not None:
-
-            # 4.1. If the parent is a content object:
-            parentPortalType = getattr(aq_base(parent), 'portal_type', None)
-            if parentPortalType is not None:
-
-                # 4.1.1. Get the default view of the parent content object
-                defaultView = getObjectDefaultView(parent)
-
-                # 4.1.2. If the name of the published object is the same as the
-                # default view of the parent:
-                if defaultView == name:
-
-                    # 4.1.2.1. Look up the parent type in the content type
-                    # mapping
-                    if ploneCacheSettings.contentTypeRulesetMapping is not None:
-                        ruleset = ploneCacheSettings.contentTypeRulesetMapping.get(
-                            parentPortalType, None)
-                        if ruleset is not None:
-                            return ruleset
-
-                    # 4.1.2.2. Look up a ruleset on the parent object and
-                    # return
-                    ruleset = lookup(parent)
-                    if ruleset is not None:
-                        return ruleset
-
-        return None
+        if parent is None:
+            return None
+
+        # 4.1. If the parent is a content object:
+        parentPortalType = getattr(aq_base(parent), 'portal_type', None)
+        if parentPortalType is None:
+            return None
+
+        # 4.1.1. Get the default view of the parent content object
+        defaultView = getObjectDefaultView(parent)
+
+        # 4.1.2. If the name of the published object is the same as the
+        # default view of the parent:
+        if defaultView != name:
+            return None
+
+        # 4.1.2.1. Look up the parent type in the content type
+        # mapping
+        if ploneCacheSettings.contentTypeRulesetMapping is not None:
+            ruleset = ploneCacheSettings.contentTypeRulesetMapping.get(
+                parentPortalType,
+                None
+            )
+            if ruleset is not None:
+                return ruleset
+
+        # 4.1.2.2. Look up a ruleset on the parent object and
+        # return
+        ruleset = lookup(parent)
+        if ruleset is not None:
+            return ruleset
diff --git a/plone/app/caching/operations/default.py b/plone/app/caching/operations/default.py
index 2e97c51..a265f1c 100644
--- a/plone/app/caching/operations/default.py
+++ b/plone/app/caching/operations/default.py
@@ -15,7 +15,7 @@
 from plone.caching.interfaces import ICachingOperation
 from plone.caching.interfaces import ICachingOperationType
 from plone.caching.utils import lookupOptions
-from zope.component import adapts
+from zope.component import adapter
 from zope.component import getMultiAdapter
 from zope.interface import implementer
 from zope.interface import Interface
@@ -36,6 +36,7 @@
 
 @implementer(ICachingOperation)
 @provider(ICachingOperationType)
+@adapter(Interface, Interface)
 class BaseCaching(object):
     """A generic caching operation class that can do pretty much all the usual
     caching operations based on options settings. For UI simplicity, it might
@@ -44,29 +45,36 @@ class BaseCaching(object):
 
     Generic options (Default value for each is None):
 
-    ``maxage`` is the maximum age of the cached item, in seconds..
+    ``maxage``
+        is the maximum age of the cached item, in seconds..
 
-    ``smaxage`` is the maximum age of the cached item in proxies, in seconds.
+    ``smaxage``
+        is the maximum age of the cached item in proxies, in seconds.
 
-    ``etags'' is a list of etag components to use when constructing an etag.
+    ``etags''
+        is a list of etag components to use when constructing an etag.
 
-    ``lastModified`` is a boolean indicating whether to set a Last-Modified header
-    and turn on 304 responses.
+    ``lastModified``
+        is a boolean indicating whether to set a Last-Modified header
+        and turn on 304 responses.
 
-    ``ramCache`` is a boolean indicating whether to turn on RAM caching for this
-    item. Etags are only required if the URL is not specific enough to ensure
-    uniqueness.
+    ``ramCache``
+        is a boolean indicating whether to turn on RAM caching for this item.
+        Etags are only required if the URL is not specific enough to ensure
+        uniqueness.
 
-    ``vary`` is a string to add as a Vary header value in the response.
+    ``vary``
+        is a string to add as a Vary header value in the response.
     """
-    adapts(Interface, IHTTPRequest)
-
-    title = _(u"Generic caching")
-    description = _(u"Through this operation, all standard caching functions "
-                    u"can be performed via various combinations of the optional "
-                    u"parameter settings. For most cases, it's probably easier "
-                    u"to use one of the other simpler operations (Strong caching, "
-                    u"Moderate caching, Weak caching, or No caching).")
+
+    title = _(u'Generic caching')
+    description = _(
+        u'Through this operation, all standard caching functions '
+        u'can be performed via various combinations of the optional '
+        u'parameter settings. For most cases, it\'s probably easier '
+        u'to use one of the other simpler operations (Strong caching, '
+        u'Moderate caching, Weak caching, or No caching).'
+    )
     prefix = 'plone.app.caching.baseCaching'
     options = ('maxage', 'smaxage', 'etags', 'lastModified',
                'ramCache', 'vary', 'anonOnly')
@@ -104,7 +112,13 @@ def interceptResponse(self, rulename, response, class_=None):
 
         # Check if this should be a 304 response
         if not isModified(self.request, etag=etag, lastModified=lastModified):
-            return notModified(self.published, self.request, response, etag=etag, lastModified=lastModified)
+            return notModified(
+                self.published,
+                self.request,
+                response,
+                etag=etag,
+                lastModified=lastModified
+            )
 
         # Check if this is in the ram cache
         if ramCache:
@@ -116,7 +130,12 @@ def interceptResponse(self, rulename, response, class_=None):
                 cached = fetchFromRAMCache(
                     self.request, etag=etag, lastModified=lastModified)
                 if cached is not None:
-                    return cachedResponse(self.published, self.request, response, *cached)
+                    return cachedResponse(
+                        self.published,
+                        self.request,
+                        response,
+                        *cached
+                    )
 
         return None
 
@@ -147,8 +166,14 @@ def modifyResponse(self, rulename, response, class_=None):
             # only stop with etags if configured
             if etags:
                 etag = "%s%d" % (time.time(), random.randint(0, 1000))
-                return setCacheHeaders(self.published, self.request, response, etag=etag)
-            # XXX: should there be an else here? Last modified works without extra headers.
+                return setCacheHeaders(
+                    self.published,
+                    self.request,
+                    response,
+                    etag=etag
+                )
+            # XXX: should there be an else here? Last modified works without
+            #      extra headers.
             #      Are there other config options?
 
         # Do the maxage/smaxage settings allow for proxy caching?
@@ -158,10 +183,17 @@ def modifyResponse(self, rulename, response, class_=None):
         public = True
         if ramCache or proxyCache:
             if etags is not None:
-                if 'userid' in etags or 'anonymousOrRandom' in etags or 'roles' in etags:
+                if (
+                    'userid' in etags or
+                    'anonymousOrRandom' in etags or
+                    'roles' in etags
+
+                ):
                     context = getContext(self.published)
                     portal_state = getMultiAdapter(
-                        (context, self.request), name=u'plone_portal_state')
+                        (context, self.request),
+                        name=u'plone_portal_state'
+                    )
                     public = portal_state.anonymous()
             public = public and visibleToRole(self.published, role='Anonymous')
 
@@ -169,8 +201,16 @@ def modifyResponse(self, rulename, response, class_=None):
             # This is private so keep it out of both shared and browser caches
             maxage = smaxage = 0
 
-        setCacheHeaders(self.published, self.request, response, maxage=maxage, smaxage=smaxage,
-                        etag=etag, lastModified=lastModified, vary=vary)
+        setCacheHeaders(
+            self.published,
+            self.request,
+            response,
+            maxage=maxage,
+            smaxage=smaxage,
+            etag=etag,
+            lastModified=lastModified,
+            vary=vary
+        )
 
         if ramCache and public:
             cacheInRAM(self.published, self.request, response,
@@ -183,14 +223,16 @@ class WeakCaching(BaseCaching):
     operation to help make the UI approachable by mortals
     """
 
-    title = _(u"Weak caching")
-    description = _(u"Cache in browser but expire immediately and enable 304 "
-                    u"responses on subsequent requests. 304's require configuration "
-                    u"of the 'Last-modified' and/or 'ETags' settings. If Last-Modified "
-                    u"header is insufficient to ensure freshness, turn on ETag "
-                    u"checking by listing each ETag components that should be used to "
-                    u"to construct the ETag header. "
-                    u"To also cache public responses in Zope memory, set 'RAM cache' to True. ")
+    title = _(u'Weak caching')
+    description = _(
+        u'Cache in browser but expire immediately and enable 304 '
+        u'responses on subsequent requests. 304\'s require configuration '
+        u'of the \'Last-modified\' and/or \'ETags\' settings. If '
+        u'Last-Modified  header is insufficient to ensure freshness, turn on '
+        u'ETag checking by listing each ETag components that should be used '
+        u'to construct the ETag header. To also cache public responses in '
+        u'Zope memory, set \'RAM cache\' to True.'
+    )
     prefix = 'plone.app.caching.weakCaching'
     sort = 3
 
@@ -209,13 +251,14 @@ class ModerateCaching(BaseCaching):
     operation to help make the UI approachable by mortals
     """
 
-    title = _(u"Moderate caching")
-    description = _(u"Cache in browser but expire immediately (same as 'weak caching'), "
-                    u"and cache in proxy (default: 24 hrs). "
-                    u"Use a purgable caching reverse proxy for best results. "
-                    u"Caution: If proxy cannot be purged, or cannot be configured "
-                    u"to remove the 's-maxage' token from the response, then stale "
-                    u"responses might be seen until the cached entry expires. ")
+    title = _(u'Moderate caching')
+    description = _(
+        u'Cache in browser but expire immediately (same as \'weak caching\'), '
+        u'and cache in proxy (default: 24 hrs). '
+        u'Use a purgable caching reverse proxy for best results. '
+        u'Caution: If proxy cannot be purged, or cannot be configured '
+        u'to remove the \s-maxage\ token from the response, then stale '
+        u'responses might be seen until the cached entry expires. ')
     prefix = 'plone.app.caching.moderateCaching'
     sort = 2
 
@@ -236,11 +279,13 @@ class StrongCaching(BaseCaching):
     operation to help make the UI approachable by mortals
     """
 
-    title = _(u"Strong caching")
-    description = _(u"Cache in browser and proxy (default: 24 hrs). "
-                    u"Caution: Only use for stable resources "
-                    u"that never change without changing their URL, or resources "
-                    u"for which temporary staleness is not critical.")
+    title = _(u'Strong caching')
+    description = _(
+        u'Cache in browser and proxy (default: 24 hrs). '
+        u'Caution: Only use for stable resources '
+        u'that never change without changing their URL, or resources '
+        u'for which temporary staleness is not critical.'
+    )
     prefix = 'plone.app.caching.strongCaching'
     sort = 1
 
@@ -253,23 +298,29 @@ class StrongCaching(BaseCaching):
     smaxage = etags = vary = None
     lastModified = ramCache = anonOnly = False
 
+
 if HAVE_RESOURCE_REGISTRIES:
 
+    @adapter(ICookedFile, IHTTPRequest)
     class ResourceRegistriesCaching(StrongCaching):
         """Override for StrongCaching which checks ResourceRegistries
         cacheability
         """
 
-        adapts(ICookedFile, IHTTPRequest)
-
         def interceptResponse(self, rulename, response):
-            return super(ResourceRegistriesCaching, self).interceptResponse(rulename, response, class_=StrongCaching)
+            return super(
+                ResourceRegistriesCaching,
+                self
+            ).interceptResponse(rulename, response, class_=StrongCaching)
 
         def modifyResponse(self, rulename, response):
             registry = getContext(self.published, IResourceRegistry)
 
             if registry is not None:
-                if registry.getDebugMode() or not registry.isCacheable(self.published.__name__):
+                if (
+                    registry.getDebugMode() or
+                    not registry.isCacheable(self.published.__name__)
+                ):
                     doNotCache(self.published, self.request, response)
                     return
 
@@ -279,11 +330,11 @@ def modifyResponse(self, rulename, response):
 
 @implementer(ICachingOperation)
 @provider(ICachingOperationType)
+@adapter(Interface, IHTTPRequest)
 class NoCaching(object):
     """A caching operation that tries to keep the response
     out of all caches.
     """
-    adapts(Interface, IHTTPRequest)
 
     title = _(u"No caching")
     description = _(u"Use this operation to keep the response "
diff --git a/plone/app/caching/operations/etags.py b/plone/app/caching/operations/etags.py
index cff76e6..1e285d4 100644
--- a/plone/app/caching/operations/etags.py
+++ b/plone/app/caching/operations/etags.py
@@ -1,13 +1,10 @@
 # -*- coding: utf-8 -*-
 from plone.app.caching.interfaces import IETagValue
-from plone.app.caching.interfaces import IPloneCacheSettings
 from plone.app.caching.operations.utils import getContext
 from plone.app.caching.operations.utils import getLastModifiedAnnotation
-from plone.registry.interfaces import IRegistry
 from Products.CMFCore.utils import getToolByName
-from zope.component import adapts
+from zope.component import adapter
 from zope.component import queryMultiAdapter
-from zope.component import queryUtility
 from zope.interface import implementer
 from zope.interface import Interface
 
@@ -16,10 +13,10 @@
 
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class UserID(object):
     """The ``userid`` etag component, returning the current user's id
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -40,11 +37,11 @@ def __call__(self):
 
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class Roles(object):
     """The ``roles`` etag component, returning the current user's roles,
     separated by semicolons
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -68,11 +65,11 @@ def __call__(self):
 
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class Language(object):
     """The ``language`` etag component, returning the value of the
     HTTP_ACCEPT_LANGUAGE request key.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -83,11 +80,11 @@ def __call__(self):
 
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class UserLanguage(object):
     """The ``userLanguage`` etag component, returning the user's preferred
     language
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -104,11 +101,11 @@ def __call__(self):
 
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class LastModified(object):
     """The ``lastModified`` etag component, returning the last modification
     timestamp
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -122,11 +119,11 @@ def __call__(self):
 
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class CatalogCounter(object):
     """The ``catalogCounter`` etag component, returning a counter which is
     incremented each time the catalog is updated.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -142,11 +139,11 @@ def __call__(self):
 
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class ObjectLocked(object):
     """The ``locked`` etag component, returning 1 or 0 depending on whether
     the object is locked.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -162,10 +159,10 @@ def __call__(self):
 
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class Skin(object):
     """The ``skin`` etag component, returning the current skin name.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -186,12 +183,12 @@ def __call__(self):
 
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class ResourceRegistries(object):
     """The ``resourceRegistries`` etag component, returning the most recent
     last modified timestamp from all three Resource Registries.  This is
     useful for avoiding requests for expired resources from cached pages.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -218,13 +215,13 @@ def __call__(self):
 
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class AnonymousOrRandom(object):
     """The ``anonymousOrRandom`` etag component. This is normally added
     implicitly by the ``anonOnly`` setting. It will return None for anonymous
     users, but a random number for logged-in ones. The idea is to force a
     re-fetch of a page every time for logged-in users.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -242,11 +239,11 @@ def __call__(self):
 
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class CopyCookie(object):
     """The ``copy`` etag component, returning 1 or 0 depending on whether
     the '__cp' cookie is set.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
diff --git a/plone/app/caching/operations/ramcache.py b/plone/app/caching/operations/ramcache.py
index 0a82287..9947af0 100644
--- a/plone/app/caching/operations/ramcache.py
+++ b/plone/app/caching/operations/ramcache.py
@@ -2,7 +2,7 @@
 from plone.app.caching.interfaces import IRAMCached
 from plone.app.caching.operations.utils import storeResponseInRAMCache
 from plone.transformchain.interfaces import ITransform
-from zope.component import adapts
+from zope.component import adapter
 from zope.interface import implementer
 from zope.interface import Interface
 
@@ -11,6 +11,7 @@
 
 
 @implementer(ITransform)
+@adapter(Interface, Interface)
 class Store(object):
     """Transform chain element which actually saves the page in RAM.
 
@@ -18,7 +19,6 @@ class Store(object):
     the ``cacheInRAM()`` helper method. Thus, the transform is only used if
     the caching operation requested it.
     """
-    adapts(Interface, Interface)
 
     order = 90000
 
diff --git a/plone/app/caching/operations/utils.py b/plone/app/caching/operations/utils.py
index f9ab7b0..e7bc0b1 100644
--- a/plone/app/caching/operations/utils.py
+++ b/plone/app/caching/operations/utils.py
@@ -48,7 +48,16 @@
 #
 
 
-def setCacheHeaders(published, request, response, maxage=None, smaxage=None, etag=None, lastModified=None, vary=None):
+def setCacheHeaders(
+    published,
+    request,
+    response,
+    maxage=None,
+    smaxage=None,
+    etag=None,
+    lastModified=None,
+    vary=None
+):
     """General purpose dispatcher to set various cache headers
 
     ``maxage`` is the cache timeout value in seconds
@@ -59,16 +68,36 @@ def setCacheHeaders(published, request, response, maxage=None, smaxage=None, eta
     """
 
     if maxage:
-        cacheInBrowserAndProxy(published, request, response, maxage, smaxage=smaxage,
-                               etag=etag, lastModified=lastModified, vary=vary)
+        cacheInBrowserAndProxy(
+            published,
+            request,
+            response,
+            maxage,
+            smaxage=smaxage,
+            etag=etag,
+            lastModified=lastModified,
+            vary=vary
+        )
 
     elif smaxage:
-        cacheInProxy(published, request, response, smaxage,
-                     etag=etag, lastModified=lastModified, vary=vary)
+        cacheInProxy(
+            published,
+            request,
+            response,
+            smaxage,
+            etag=etag,
+            lastModified=lastModified,
+            vary=vary
+        )
 
     elif etag or lastModified:
-        cacheInBrowser(published, request, response,
-                       etag=etag, lastModified=lastModified)
+        cacheInBrowser(
+            published,
+            request,
+            response,
+            etag=etag,
+            lastModified=lastModified
+        )
 
     else:
         doNotCache(published, request, response)
@@ -114,7 +143,15 @@ def cacheInBrowser(published, request, response, etag=None, lastModified=None):
     response.setHeader('Cache-Control', 'max-age=0, must-revalidate, private')
 
 
-def cacheInProxy(published, request, response, smaxage, etag=None, lastModified=None, vary=None):
+def cacheInProxy(
+    published,
+    request,
+    response,
+    smaxage,
+    etag=None,
+    lastModified=None,
+    vary=None
+):
     """Set headers to cache the response in a caching proxy.
 
     ``smaxage`` is the timeout value in seconds.
@@ -124,7 +161,10 @@ def cacheInProxy(published, request, response, smaxage, etag=None, lastModified=
     """
 
     if lastModified is not None:
-        response.setHeader('Last-Modified', formatDateTime(lastModified))
+        response.setHeader(
+            'Last-Modified',
+            formatDateTime(lastModified)
+        )
     elif response.getHeader('Last-Modified'):
         del response.headers['last-modified']
 
@@ -139,7 +179,16 @@ def cacheInProxy(published, request, response, smaxage, etag=None, lastModified=
         'Cache-Control', 'max-age=0, s-maxage=%d, must-revalidate' % smaxage)
 
 
-def cacheInBrowserAndProxy(published, request, response, maxage, smaxage=None, etag=None, lastModified=None, vary=None):
+def cacheInBrowserAndProxy(
+    published,
+    request,
+    response,
+    maxage,
+    smaxage=None,
+    etag=None,
+    lastModified=None,
+    vary=None
+):
     """Set headers to cache the response in the browser and caching proxy if
     applicable.
 
@@ -166,13 +215,23 @@ def cacheInBrowserAndProxy(published, request, response, maxage, smaxage=None, e
     if smaxage is not None:
         maxage = '%s, s-maxage=%s' % (maxage, smaxage)
 
-    # Substituting proxy-validate in place of must=revalidate here because of Safari bug
+    # Substituting proxy-validate in place of must=revalidate here because of
+    # Safari bug
     # https://bugs.webkit.org/show_bug.cgi?id=13128
     response.setHeader(
-        'Cache-Control', 'max-age=%s, proxy-revalidate, public' % maxage)
+        'Cache-Control',
+        'max-age=%s, proxy-revalidate, public' % maxage
+    )
 
 
-def cacheInRAM(published, request, response, etag=None, lastModified=None, annotationsKey=PAGE_CACHE_ANNOTATION_KEY):
+def cacheInRAM(
+    published,
+    request,
+    response,
+    etag=None,
+    lastModified=None,
+    annotationsKey=PAGE_CACHE_ANNOTATION_KEY
+):
     """Set a flag indicating that the response for the given request
     should be cached in RAM.
 
@@ -201,7 +260,15 @@ def cacheInRAM(published, request, response, etag=None, lastModified=None, annot
     alsoProvides(request, IRAMCached)
 
 
-def cachedResponse(published, request, response, status, headers, body, gzip=False):
+def cachedResponse(
+    published,
+    request,
+    response,
+    status,
+    headers,
+    body,
+    gzip=False
+):
     """Returned a cached page. Modifies the response (status and headers)
     and returns the cached body.
 
@@ -287,11 +354,7 @@ def cacheStop(request, rulename):
 
     ploneSettings = registry.forInterface(IPloneCacheSettings)
     variables = ploneSettings.cacheStopRequestVariables
-
-    for variable in variables:
-        if request.has_key(variable):
-            return True
-    return False
+    return set(variables) & set(request.keys())
 
 
 def isModified(request, etag=None, lastModified=None):
@@ -338,7 +401,7 @@ def isModified(request, etag=None, lastModified=None):
     latest headers. I interpret this as the spec rule that the
     etags do NOT match, and therefor we must not return a 304.
     """
-    if ifNoneMatch and etag == None:
+    if ifNoneMatch and etag is None:
         return True
 
     # Check the modification date
@@ -355,16 +418,16 @@ def isModified(request, etag=None, lastModified=None):
         # has content been modified since the if-modified-since time?
         try:
             # browser only knows the date to one second resolution
-            if (lastModified - ifModifiedSince) > datetime.timedelta(seconds=1):
+            delta_sec = datetime.timedelta(seconds=1)
+            if (lastModified - ifModifiedSince) > delta_sec:
                 return True
         except TypeError:
             logger.exception("Could not compare dates")
 
         # If we expected an ETag and the client didn't give us one, consider
         # that an error. This may be more conservative than the spec requires.
-        if etag is not None:
-            if not etagMatched:
-                return True
+        if etag is not None and not etagMatched:
+            return True
 
     # XXX Do we really want the default here to be false?
     return False
@@ -403,9 +466,9 @@ def checkType(context):
         return False
 
     while (
-        published is not None
-        and not checkType(published)
-        and hasattr(published, '__parent__',)
+        published is not None and
+        not checkType(published) and
+        hasattr(published, '__parent__',)
     ):
         published = published.__parent__
 
@@ -608,13 +671,13 @@ def parseETags(text, allowWeak=True, _result=None):
         m = etagQuote.match(text)
         if m:
             # Match quoted etag (spec-observing client)
-            l = len(m.group(1))
+            length = len(m.group(1))
             value = (m.group(2) or '') + (m.group(3) or '')
         else:
             # Match non-quoted etag (lazy client)
             m = etagNoQuote.match(text)
             if m:
-                l = len(m.group(1))
+                length = len(m.group(1))
                 value = (m.group(2) or '') + (m.group(3) or '')
             else:
                 return result
@@ -622,14 +685,13 @@ def parseETags(text, allowWeak=True, _result=None):
         parseETagLock.release()
 
     if value:
-
         if value.startswith('W/'):
             if allowWeak:
                 result.append(value[2:])
         else:
             result.append(value)
 
-    return parseETags(text[l:], allowWeak=allowWeak, _result=result)
+    return parseETags(text[length:], allowWeak=allowWeak, _result=result)
 
 #
 # RAM cache management
@@ -679,7 +741,13 @@ def getRAMCacheKey(request, etag=None, lastModified=None):
     return resourceKey
 
 
-def storeResponseInRAMCache(request, response, result, globalKey=PAGE_CACHE_KEY, annotationsKey=PAGE_CACHE_ANNOTATION_KEY):
+def storeResponseInRAMCache(
+    request,
+    response,
+    result,
+    globalKey=PAGE_CACHE_KEY,
+    annotationsKey=PAGE_CACHE_ANNOTATION_KEY
+):
     """Store the given response in the RAM cache.
 
     ``result`` should be the response body as a string.
@@ -706,9 +774,9 @@ def storeResponseInRAMCache(request, response, result, globalKey=PAGE_CACHE_KEY,
 
     """
     Resource registries have no body. If we put them in the cache the content
-    type headers will indicate length and the body will be '', causing the browser
-    to just spin. Furthermore, I doubt we ever want to cache an empty result:
-    it's an indication that something went wrong somewhere.
+    type headers will indicate length and the body will be '', causing the
+    browser to just spin. Furthermore, I doubt we ever want to cache an empty
+    result: it's an indication that something went wrong somewhere.
 
     This does mean that any resources will not be cached in ram. There is
     potentially another fix but I doubt long term it's ever the right thing to
@@ -724,7 +792,13 @@ def storeResponseInRAMCache(request, response, result, globalKey=PAGE_CACHE_KEY,
     cache[key] = (status, headers, result, gzipFlag)
 
 
-def fetchFromRAMCache(request, etag=None, lastModified=None, globalKey=PAGE_CACHE_KEY, default=None):
+def fetchFromRAMCache(
+    request,
+    etag=None,
+    lastModified=None,
+    globalKey=PAGE_CACHE_KEY,
+    default=None
+):
     """Return a page cached in RAM, or None if it cannot be found.
 
     The return value is a tuple as stored by ``storeResponseInRAMCache()``.
diff --git a/plone/app/caching/purge.py b/plone/app/caching/purge.py
index 3221e92..3b87cec 100644
--- a/plone/app/caching/purge.py
+++ b/plone/app/caching/purge.py
@@ -11,7 +11,6 @@
 from z3c.caching.interfaces import IPurgePaths
 from z3c.caching.purge import Purge
 from zope.component import adapter
-from zope.component import adapts
 from zope.component import getAdapters
 from zope.event import notify
 from zope.globalrequest import getRequest
@@ -23,13 +22,16 @@
 try:
     from plone.app.blob.interfaces import IBlobField
     from Products.Archetypes.interfaces import IBaseObject
-    from Products.Archetypes.interfaces import IFileField, IImageField, ITextField
+    from Products.Archetypes.interfaces import IFileField
+    from Products.Archetypes.interfaces import IImageField
+    from Products.Archetypes.interfaces import ITextField
     HAVE_AT = True
 except ImportError:
     HAVE_AT = False
 
 
 @implementer(IPurgePaths)
+@adapter(IDynamicType)
 class ContentPurgePaths(object):
     """Paths to purge for content items
 
@@ -44,7 +46,6 @@ class ContentPurgePaths(object):
     * ${parent_path}
     * ${parent_path}/
     """
-    adapts(IDynamicType)
 
     def __init__(self, context):
         self.context = context
@@ -60,25 +61,28 @@ def getRelativePaths(self):
                 paths.append(path)
 
         parent = aq_parent(self.context)
-        if parent is not None:
-            parentDefaultView = getObjectDefaultView(parent)
-            if parentDefaultView == self.context.getId():
-                parentPrefix = '/' + parent.virtual_url_path()
-                paths.append(parentPrefix)
-                if parentPrefix == '/':
-                    # special handling for site root since parentPrefix
-                    # does not make sense in that case.
-                    # Additionally, empty site roots were not getting
-                    # purge paths /VirtualHostBase/http/site.com:80/site1/VirtualHostRoot/_vh_site1/
-                    # was getting generated but not
-                    # /VirtualHostBase/http/site.com:80/site1/VirtualHostRoot/_vh_site1
-                    # which would translate to http://site.come/ getting invalidated
-                    # but not http://site.come
-                    paths.append('')
-                    paths.append('/view')
-                else:
-                    paths.append(parentPrefix + '/')
-                    paths.append(parentPrefix + '/view')
+        if parent is None:
+            return paths
+
+        parentDefaultView = getObjectDefaultView(parent)
+        if parentDefaultView == self.context.getId():
+            parentPrefix = '/' + parent.virtual_url_path()
+            paths.append(parentPrefix)
+            if parentPrefix == '/':
+                # special handling for site root since parentPrefix
+                # does not make sense in that case.
+                # Additionally, empty site roots were not getting
+                # purge paths
+                # /VirtualHostBase/http/site.com:80/site1/VirtualHostRoot/_vh_site1/
+                # was getting generated but not
+                # /VirtualHostBase/http/site.com:80/site1/VirtualHostRoot/_vh_site1
+                # which would translate to http://site.come/ getting
+                # invalidated but not http://site.come
+                paths.append('')
+                paths.append('/view')
+            else:
+                paths.append(parentPrefix + '/')
+                paths.append(parentPrefix + '/view')
 
         return paths
 
@@ -87,12 +91,12 @@ def getAbsolutePaths(self):
 
 
 @implementer(IPurgePaths)
+@adapter(IDiscussionResponse)
 class DiscussionItemPurgePaths(object):
     """Paths to purge for Discussion Item.
 
     Looks up paths for the ultimate parent.
     """
-    adapts(IDiscussionResponse)
 
     def __init__(self, context):
         self.context = context
@@ -149,13 +153,14 @@ def _getRoot(self):
 
         return thread[0]
 
+
 if HAVE_AT:
 
     @implementer(IPurgePaths)
+    @adapter(IBaseObject)
     class ObjectFieldPurgePaths(object):
         """Paths to purge for Archetypes object fields
         """
-        adapts(IBaseObject)
 
         def __init__(self, context):
             self.context = context
@@ -165,15 +170,16 @@ def getRelativePaths(self):
             schema = self.context.Schema()
 
             def fieldFilter(field):
-                return ((IBlobField.providedBy(field) or
-                         IFileField.providedBy(field) or
-                         IImageField.providedBy(field))
-                        and not ITextField.providedBy(field))
-
+                return (
+                    (
+                        IBlobField.providedBy(field) or
+                        IFileField.providedBy(field) or
+                        IImageField.providedBy(field)
+                    ) and
+                    not ITextField.providedBy(field)
+                )
             seenDownloads = False
-
             for field in schema.filterFields(fieldFilter):
-
                 if not seenDownloads:
                     yield prefix + '/download'
                     yield prefix + '/at_download'
diff --git a/plone/app/caching/testing.py b/plone/app/caching/testing.py
index 765a58d..1c76fa6 100644
--- a/plone/app/caching/testing.py
+++ b/plone/app/caching/testing.py
@@ -6,6 +6,7 @@
 from plone.app.testing import IntegrationTesting
 from plone.app.testing import PloneSandboxLayer
 from plone.cachepurging.interfaces import IPurger
+from plone.protect.authenticator import _getKeyring
 from zope.component import getUtility
 from zope.component import provideUtility
 from zope.configuration import xmlconfig
@@ -14,17 +15,6 @@
 import hmac
 
 
-try:
-    from plone.protect.authenticator import _getKeyring
-except ImportError:
-    # so we can run tests on plone 4.3
-    from plone.keyring.interfaces import IKeyManager
-
-    def _getKeyring(username):
-        manager = getUtility(IKeyManager)
-        return manager['_system']
-
-
 @implementer(IPurger)
 class FauxPurger(object):
 
@@ -76,9 +66,13 @@ def tearDownZope(self, app):
 
 PLONE_APP_CACHING_FIXTURE = PloneAppCaching()
 PLONE_APP_CACHING_INTEGRATION_TESTING = IntegrationTesting(
-    bases=(PLONE_APP_CACHING_FIXTURE,), name="PloneAppCaching:Integration")
+    bases=(PLONE_APP_CACHING_FIXTURE,),
+    name='PloneAppCaching:Integration'
+)
 PLONE_APP_CACHING_FUNCTIONAL_TESTING = FunctionalTesting(
-    bases=(PLONE_APP_CACHING_FIXTURE,), name="PloneAppCaching:Functional")
+    bases=(PLONE_APP_CACHING_FIXTURE,),
+    name='PloneAppCaching:Functional'
+)
 
 
 def getToken(username):
diff --git a/plone/app/caching/tests/test_etags.py b/plone/app/caching/tests/test_etags.py
index 66b75f7..7de8085 100644
--- a/plone/app/caching/tests/test_etags.py
+++ b/plone/app/caching/tests/test_etags.py
@@ -2,18 +2,13 @@
 from Acquisition import Explicit
 from datetime import datetime
 from dateutil.tz import tzlocal
-from plone.app.caching.interfaces import IPloneCacheSettings
-from plone.registry import Registry
 from plone.registry.fieldfactory import persistentFieldAdapter
-from plone.registry.interfaces import IRegistry
 from plone.testing.zca import UNIT_TESTING
 from Products.CMFCore.interfaces import IContentish
 from StringIO import StringIO
 from z3c.caching.interfaces import ILastModified
-from zope.component import adapts
-from zope.component import getUtility
+from zope.component import adapter
 from zope.component import provideAdapter
-from zope.component import provideUtility
 from zope.interface import implementer
 from zope.interface import Interface
 from ZPublisher.HTTPRequest import HTTPRequest
@@ -47,8 +42,8 @@ def test_UserID_anonymous(self):
         from plone.app.caching.operations.etags import UserID
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyPortalState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -76,8 +71,8 @@ def getId(self):
                 return 'bob'
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyPortalState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -102,8 +97,8 @@ def test_Roles_anonymous(self):
         from plone.app.caching.operations.etags import Roles
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyPortalState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -134,8 +129,8 @@ def getRolesInContext(self, context):
                 return ['Member', 'Manager']
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyPortalState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -191,8 +186,8 @@ def test_UserLanguage(self):
         from plone.app.caching.operations.etags import UserLanguage
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyPortalState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -229,8 +224,8 @@ def test_LastModified_None(self):
         from plone.app.caching.operations.etags import LastModified
 
         @implementer(ILastModified)
+        @adapter(DummyPublished)
         class DummyLastModified(object):
-            adapts(DummyPublished)
 
             def __init__(self, context):
                 self.context = context
@@ -256,8 +251,8 @@ def test_LastModified(self):
         utcStamp = time.mktime(mod.utctimetuple())
 
         @implementer(ILastModified)
+        @adapter(DummyPublished)
         class DummyLastModified(object):
-            adapts(DummyPublished)
 
             def __init__(self, context):
                 self.context = context
@@ -286,8 +281,8 @@ def getCounter(self):
                 return 10
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyTools(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -312,8 +307,8 @@ def test_ObjectLocked_true(self):
         from plone.app.caching.operations.etags import ObjectLocked
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyContextState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -336,8 +331,8 @@ def test_ObjectLocked_false(self):
         from plone.app.caching.operations.etags import ObjectLocked
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyContextState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
diff --git a/plone/app/caching/tests/test_lookup.py b/plone/app/caching/tests/test_lookup.py
index 13bd411..de0d1f6 100644
--- a/plone/app/caching/tests/test_lookup.py
+++ b/plone/app/caching/tests/test_lookup.py
@@ -10,7 +10,6 @@
 from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
 from Products.Five.browser import BrowserView
 from Products.PageTemplates.ZopePageTemplate import ZopePageTemplate
-from z3c.caching.registry import RulesetRegistry
 from zope.component import getUtility
 from zope.component import provideAdapter
 from zope.component import provideUtility
diff --git a/plone/app/caching/tests/test_operation_utils.py b/plone/app/caching/tests/test_operation_utils.py
index 8fba6c3..4a61d12 100644
--- a/plone/app/caching/tests/test_operation_utils.py
+++ b/plone/app/caching/tests/test_operation_utils.py
@@ -8,7 +8,7 @@
 from zope.annotation.attribute import AttributeAnnotations
 from zope.annotation.interfaces import IAnnotations
 from zope.annotation.interfaces import IAttributeAnnotatable
-from zope.component import adapts
+from zope.component import adapter
 from zope.component import provideAdapter
 from zope.component import provideUtility
 from zope.interface import alsoProvides
@@ -80,7 +80,9 @@ def test_doNotCache_deletes_last_modified(self):
 
         now = datetime.datetime.now(dateutil.tz.tzlocal())
         response.setHeader(
-            'Last-Modified', wsgiref.handlers.format_date_time(time.mktime(now.timetuple())))
+            'Last-Modified',
+            wsgiref.handlers.format_date_time(time.mktime(now.timetuple()))
+        )
 
         doNotCache(published, request, response)
 
@@ -278,8 +280,15 @@ def test_cacheInBrowserAndProxy_full(self):
         nowFormatted = wsgiref.handlers.format_date_time(
             time.mktime(now.timetuple()))
 
-        cacheInBrowserAndProxy(published, request, response,
-                               maxage=60, etag=etag, lastModified=now, vary=vary)
+        cacheInBrowserAndProxy(
+            published,
+            request,
+            response,
+            maxage=60,
+            etag=etag,
+            lastModified=now,
+            vary=vary
+        )
 
         self.assertEqual(200, response.getStatus())
         self.assertEqual('max-age=60, proxy-revalidate, public',
@@ -302,7 +311,7 @@ def test_cacheInBrowserAndProxy_full(self):
 
     def test_cacheInRAM_no_etag(self):
         from plone.app.caching.operations.utils import cacheInRAM
-        from plone.app.caching.operations.utils import PAGE_CACHE_ANNOTATION_KEY
+        from plone.app.caching.operations.utils import PAGE_CACHE_ANNOTATION_KEY  # noqa
 
         from plone.app.caching.interfaces import IRAMCached
 
@@ -324,7 +333,7 @@ def test_cacheInRAM_no_etag(self):
 
     def test_cacheInRAM_etag(self):
         from plone.app.caching.operations.utils import cacheInRAM
-        from plone.app.caching.operations.utils import PAGE_CACHE_ANNOTATION_KEY
+        from plone.app.caching.operations.utils import PAGE_CACHE_ANNOTATION_KEY  # noqa
 
         from plone.app.caching.interfaces import IRAMCached
 
@@ -602,8 +611,8 @@ def test_isModified_ims_not_modified_two_dates(self):
         response = HTTPResponse()
         request = HTTPRequest(StringIO(), environ, response)
 
-        request.environ[
-            'HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT; Thu, 24 Nov 2011 03:04:05'
+        request.environ['HTTP_IF_MODIFIED_SINCE'] = \
+            'Thu, 24 Nov 2011 03:04:05 GMT; Thu, 24 Nov 2011 03:04:05'
 
         lastModified = datetime.datetime(
             2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
@@ -943,8 +952,8 @@ def test_getLastModified_none(self):
         from plone.app.caching.operations.utils import getLastModified
 
         @implementer(ILastModified)
+        @adapter(DummyPublished)
         class DummyLastModified(object):
-            adapts(DummyPublished)
 
             def __init__(self, context):
                 self.context = context
@@ -961,8 +970,8 @@ def test_getLastModified_missing_timezone(self):
         from plone.app.caching.operations.utils import getLastModified
 
         @implementer(ILastModified)
+        @adapter(DummyPublished)
         class DummyLastModified(object):
-            adapts(DummyPublished)
 
             def __init__(self, context):
                 self.context = context
@@ -973,27 +982,33 @@ def __call__(self):
         provideAdapter(DummyLastModified)
 
         published = DummyPublished()
-        self.assertEqual(datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzlocal()),
-                         getLastModified(published))
+        self.assertEqual(
+            datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzlocal()),
+            getLastModified(published)
+        )
 
     def test_getLastModified_timezone(self):
         from plone.app.caching.operations.utils import getLastModified
 
         @implementer(ILastModified)
+        @adapter(DummyPublished)
         class DummyLastModified(object):
-            adapts(DummyPublished)
 
             def __init__(self, context):
                 self.context = context
 
             def __call__(self):
-                return datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+                return datetime.datetime(
+                    2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc()
+                )
 
         provideAdapter(DummyLastModified)
 
         published = DummyPublished()
-        self.assertEqual(datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc()),
-                         getLastModified(published))
+        self.assertEqual(
+            datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc()),
+            getLastModified(published)
+        )
 
     # getExpiration()
 
@@ -1061,8 +1076,8 @@ def test_getETag_adapter_returns_none(self):
         from plone.app.caching.interfaces import IETagValue
 
         @implementer(IETagValue)
+        @adapter(DummyPublished, HTTPRequest)
         class FooETag(object):
-            adapts(DummyPublished, HTTPRequest)
 
             def __init__(self, published, request):
                 self.published = published
@@ -1074,8 +1089,8 @@ def __call__(self):
         provideAdapter(FooETag, name=u"foo")
 
         @implementer(IETagValue)
+        @adapter(DummyPublished, HTTPRequest)
         class BarETag(object):
-            adapts(DummyPublished, HTTPRequest)
 
             def __init__(self, published, request):
                 self.published = published
@@ -1099,8 +1114,8 @@ def test_getETag_full(self):
         from plone.app.caching.interfaces import IETagValue
 
         @implementer(IETagValue)
+        @adapter(DummyPublished, HTTPRequest)
         class FooETag(object):
-            adapts(DummyPublished, HTTPRequest)
 
             def __init__(self, published, request):
                 self.published = published
@@ -1112,8 +1127,8 @@ def __call__(self):
         provideAdapter(FooETag, name=u"foo")
 
         @implementer(IETagValue)
+        @adapter(DummyPublished, HTTPRequest)
         class BarETag(object):
-            adapts(DummyPublished, HTTPRequest)
 
             def __init__(self, published, request):
                 self.published = published
@@ -1129,8 +1144,15 @@ def __call__(self):
         request = HTTPRequest(StringIO(), environ, response)
         published = DummyPublished()
 
-        self.assertEqual('|foo|bar|baz;qux', getETag(published, request,
-                                                     keys=('foo', 'bar',), extraTokens=('baz,qux',)))
+        self.assertEqual(
+            '|foo|bar|baz;qux',
+            getETag(
+                published,
+                request,
+                keys=('foo', 'bar',),
+                extraTokens=('baz,qux',)
+            )
+        )
 
     # parseETags()
 
@@ -1500,8 +1522,9 @@ def __call__(self, key):
         request.environ['PATH_INFO'] = '/foo/bar'
         request.environ['QUERY_STRING'] = ''
 
-        cache[
-            '||a|b||http://example.com/foo/bar?'] = (200, {'x-foo': 'bar'}, u'Body')
+        cache['||a|b||http://example.com/foo/bar?'] = (
+            200, {'x-foo': 'bar'}, u'Body'
+        )
 
         cached = normalize_response_cache(
             fetchFromRAMCache(request, etag="|a|b"))
diff --git a/plone/app/caching/tests/test_profile_with_caching_proxy.py b/plone/app/caching/tests/test_profile_with_caching_proxy.py
index e027712..04f5bbf 100644
--- a/plone/app/caching/tests/test_profile_with_caching_proxy.py
+++ b/plone/app/caching/tests/test_profile_with_caching_proxy.py
@@ -24,11 +24,9 @@
 import datetime
 import dateutil.parser
 import dateutil.tz
-import OFS.Image
 import os
 import pkg_resources
 import unittest2 as unittest
-import urllib
 
 
 TEST_FILE = pkg_resources.resource_filename(
diff --git a/plone/app/caching/tests/test_profile_without_caching_proxy.py b/plone/app/caching/tests/test_profile_without_caching_proxy.py
index fedb42a..8c2d764 100644
--- a/plone/app/caching/tests/test_profile_without_caching_proxy.py
+++ b/plone/app/caching/tests/test_profile_without_caching_proxy.py
@@ -21,11 +21,9 @@
 import datetime
 import dateutil.parser
 import dateutil.tz
-import OFS.Image
 import os
 import pkg_resources
 import unittest2 as unittest
-import urllib
 
 
 TEST_FILE = pkg_resources.resource_filename(
diff --git a/plone/app/caching/tests/test_purge.py b/plone/app/caching/tests/test_purge.py
index bac4b7a..3435d5b 100644
--- a/plone/app/caching/tests/test_purge.py
+++ b/plone/app/caching/tests/test_purge.py
@@ -19,7 +19,6 @@
 from z3c.caching.interfaces import IPurgeEvent
 from z3c.caching.interfaces import IPurgePaths
 from zope.component import adapter
-from zope.component import adapts
 from zope.component import getUtility
 from zope.component import provideAdapter
 from zope.component import provideHandler
@@ -181,17 +180,26 @@ def test_parent_not_default_view(self):
         context = FauxContent('foo').__of__(FauxContent('bar'))
         purger = ContentPurgePaths(context)
 
-        self.assertEqual(['/bar/foo/', '/bar/foo/view', '/bar/foo/default-view'],
-                         list(purger.getRelativePaths()))
+        self.assertEqual(
+            ['/bar/foo/', '/bar/foo/view', '/bar/foo/default-view'],
+            list(purger.getRelativePaths())
+        )
         self.assertEqual([], list(purger.getAbsolutePaths()))
 
     def test_parent_default_view(self):
         context = FauxContent('default-view').__of__(FauxContent('bar'))
         purger = ContentPurgePaths(context)
-
-        self.assertEqual(['/bar/default-view/', '/bar/default-view/view',
-                          '/bar/default-view/default-view', '/bar', '/bar/', '/bar/view'],
-                         list(purger.getRelativePaths()))
+        self.assertEqual(
+            [
+                '/bar/default-view/',
+                '/bar/default-view/view',
+                '/bar/default-view/default-view',
+                '/bar',
+                '/bar/',
+                '/bar/view'
+            ],
+            list(purger.getRelativePaths())
+        )
         self.assertEqual([], list(purger.getAbsolutePaths()))
 
 
@@ -202,8 +210,8 @@ class TestDiscussionItemPurgePaths(unittest.TestCase):
     def setUp(self):
 
         @implementer(IPurgePaths)
+        @adapter(FauxContent)
         class FauxContentPurgePaths(object):
-            adapts(FauxContent)
 
             def __init__(self, context):
                 self.context = context
@@ -325,12 +333,24 @@ class ATMultipleFields(atapi.BaseContent):
         context = ATMultipleFields('foo').__of__(root)
         purger = ObjectFieldPurgePaths(context)
 
-        self.assertEqual(['/foo/download', '/foo/at_download',
-                          '/foo/at_download/file1', '/foo/file1',
-                          '/foo/at_download/image1', '/foo/image1', '/foo/image1_thumb',
-                          '/foo/at_download/image2', '/foo/image2', '/foo/image2_mini',
-                          '/foo/image2_normal', '/foo/at_download/blob1', '/foo/blob1'],
-                         list(purger.getRelativePaths()))
+        self.assertEqual(
+            [
+                '/foo/download',
+                '/foo/at_download',
+                '/foo/at_download/file1',
+                '/foo/file1',
+                '/foo/at_download/image1',
+                '/foo/image1',
+                '/foo/image1_thumb',
+                '/foo/at_download/image2',
+                '/foo/image2',
+                '/foo/image2_mini',
+                '/foo/image2_normal',
+                '/foo/at_download/blob1',
+                '/foo/blob1'
+            ],
+            list(purger.getRelativePaths())
+        )
         self.assertEqual([], list(purger.getAbsolutePaths()))
 
     def test_file_image_text_fields(self):
@@ -349,10 +369,20 @@ class ATMultipleFields(atapi.BaseContent):
         context = ATMultipleFields('foo').__of__(root)
         purger = ObjectFieldPurgePaths(context)
 
-        self.assertEqual(['/foo/download', '/foo/at_download',
-                          '/foo/at_download/file1', '/foo/file1',
-                          '/foo/at_download/image1', '/foo/image1', '/foo/image1_thumb',
-                          '/foo/at_download/image2', '/foo/image2', '/foo/image2_mini',
-                          '/foo/image2_normal'],
-                         list(purger.getRelativePaths()))
+        self.assertEqual(
+            [
+                '/foo/download',
+                '/foo/at_download',
+                '/foo/at_download/file1',
+                '/foo/file1',
+                '/foo/at_download/image1',
+                '/foo/image1',
+                '/foo/image1_thumb',
+                '/foo/at_download/image2',
+                '/foo/image2',
+                '/foo/image2_mini',
+                '/foo/image2_normal'
+            ],
+            list(purger.getRelativePaths())
+        )
         self.assertEqual([], list(purger.getAbsolutePaths()))
diff --git a/setup.py b/setup.py
index 606c02c..3931ee1 100644
--- a/setup.py
+++ b/setup.py
@@ -2,63 +2,64 @@
 
 version = '1.2.13.dev0'
 
-setup(name='plone.app.caching',
-      version=version,
-      description="Plone UI and default rules for plone.caching/z3c.caching",
-      long_description=(open("README.rst").read() + "\n" +
-                        open("CHANGES.rst").read()),
-      classifiers=[
-          "Environment :: Web Environment",
-          "Framework :: Plone",
-          "Framework :: Plone :: 5.0",
-          "Framework :: Plone :: 5.1",
-          "Framework :: Zope2",
-          "License :: OSI Approved :: GNU General Public License (GPL)",
-          "Operating System :: OS Independent",
-          "Programming Language :: Python",
-          "Programming Language :: Python :: 2.7",
-      ],
-      keywords='plone caching',
-      author='Plone Foundation',
-      author_email='plone-developers@lists.sourceforge.net',
-      url='https://pypi.python.org/pypi/plone.app.caching',
-      license='GPL version 2',
-      packages=find_packages(exclude=['ez_setup']),
-      namespace_packages=['plone', 'plone.app'],
-      include_package_data=True,
-      zip_safe=False,
-      install_requires=[
-          'setuptools',
-          'python-dateutil',
-          'plone.caching',
-          'plone.cachepurging',
-          'plone.app.registry >= 1.0b5',
-          'zope.browserresource',
-          'zope.interface',
-          'zope.component',
-          'zope.publisher',
-          'zope.pagetemplate',
-          'plone.memoize',
-          'plone.protect',
-          'plone.registry >= 1.0b4',
-          'Products.CMFDynamicViewFTI',
-          'Products.GenericSetup',
-          'Products.CMFCore',
-          'Products.statusmessages',
-          'Zope2',
-          'Acquisition',
-          'plone.app.z3cform',
-          'z3c.form',
-          'z3c.zcmlhook',
-      ],
-      extras_require={
-          'test': [
-              'plone.app.contenttypes[test]',
-              'plone.app.testing',
-          ]
-      },
-      entry_points="""
-      [z3c.autoinclude.plugin]
-      target = plone
-      """,
-      )
+setup(
+    name='plone.app.caching',
+    version=version,
+    description='Plone UI and default rules for plone.caching/z3c.caching',
+    long_description=(open('README.rst').read() + '\n' +
+                      open('CHANGES.rst').read()),
+    classifiers=[
+        'Environment :: Web Environment',
+        'Framework :: Plone',
+        'Framework :: Plone :: 5.0',
+        'Framework :: Plone :: 5.1',
+        'Framework :: Zope2',
+        'License :: OSI Approved :: GNU General Public License (GPL)',
+        'Operating System :: OS Independent',
+        'Programming Language :: Python',
+        'Programming Language :: Python :: 2.7',
+    ],
+    keywords='plone caching',
+    author='Plone Foundation',
+    author_email='plone-developers@lists.sourceforge.net',
+    url='https://pypi.python.org/pypi/plone.app.caching',
+    license='GPL version 2',
+    packages=find_packages(exclude=['ez_setup']),
+    namespace_packages=['plone', 'plone.app'],
+    include_package_data=True,
+    zip_safe=False,
+    install_requires=[
+        'setuptools',
+        'python-dateutil',
+        'plone.caching',
+        'plone.cachepurging',
+        'plone.app.registry >= 1.0b5',
+        'zope.browserresource',
+        'zope.interface',
+        'zope.component',
+        'zope.publisher',
+        'zope.pagetemplate',
+        'plone.memoize',
+        'plone.protect',
+        'plone.registry >= 1.0b4',
+        'Products.CMFDynamicViewFTI',
+        'Products.GenericSetup',
+        'Products.CMFCore',
+        'Products.statusmessages',
+        'Zope2',
+        'Acquisition',
+        'plone.app.z3cform',
+        'z3c.form',
+        'z3c.zcmlhook',
+    ],
+    extras_require={
+        'test': [
+            'plone.app.contenttypes[test]',
+            'plone.app.testing',
+        ]
+    },
+    entry_points="""
+    [z3c.autoinclude.plugin]
+    target = plone
+    """,
+)


Repository: plone.app.caching


Branch: refs/heads/master
Date: 2016-09-28T08:17:19+02:00
Author: agitator (agitator) <hpeter@agitator.com>
Commit: https://github.com/plone/plone.app.caching/commit/866bcf6f3dd9054f4565aa5c16292dee7414f963

Merge pull request #29 from plone/cleanup

Cleanup

Files changed:
M CHANGES.rst
M plone/__init__.py
M plone/app/__init__.py
M plone/app/caching/browser/controlpanel.py
M plone/app/caching/browser/edit.py
M plone/app/caching/interfaces.py
M plone/app/caching/lastmodified.py
M plone/app/caching/lookup.py
M plone/app/caching/operations/default.py
M plone/app/caching/operations/etags.py
M plone/app/caching/operations/ramcache.py
M plone/app/caching/operations/utils.py
M plone/app/caching/purge.py
M plone/app/caching/setuphandlers.py
M plone/app/caching/testing.py
M plone/app/caching/tests/test_etags.py
M plone/app/caching/tests/test_integration.py
M plone/app/caching/tests/test_lastmodified.py
M plone/app/caching/tests/test_lookup.py
M plone/app/caching/tests/test_operation_default.py
M plone/app/caching/tests/test_operation_parameters.py
M plone/app/caching/tests/test_operation_utils.py
M plone/app/caching/tests/test_profile_with_caching_proxy.py
M plone/app/caching/tests/test_profile_without_caching_proxy.py
M plone/app/caching/tests/test_purge.py
M plone/app/caching/tests/test_utils.py
M plone/app/caching/utils.py
M setup.cfg
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 9d629c0..efb5291 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -14,7 +14,8 @@ New features:
 
 Bug fixes:
 
-- *add item here*
+- Code-Style: isort, utf8-headers, zca-decorators, manual cleanup.
+  [jensens]
 
 
 1.2.12 (2016-09-16)
diff --git a/plone/__init__.py b/plone/__init__.py
index de40ea7..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1 +1,2 @@
+# -*- coding: utf-8 -*-
 __import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/app/__init__.py b/plone/app/__init__.py
index de40ea7..68c04af 100644
--- a/plone/app/__init__.py
+++ b/plone/app/__init__.py
@@ -1 +1,2 @@
+# -*- coding: utf-8 -*-
 __import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/app/caching/browser/controlpanel.py b/plone/app/caching/browser/controlpanel.py
index 6ad76dc..b53d70d 100644
--- a/plone/app/caching/browser/controlpanel.py
+++ b/plone/app/caching/browser/controlpanel.py
@@ -1,43 +1,35 @@
-import re
-import datetime
-
-from zope.interface import implementer
-from zope.component import getUtility
+# -*- coding: utf-8 -*-
+from plone.app.caching.browser.edit import EditForm
+from plone.app.caching.interfaces import _
+from plone.app.caching.interfaces import ICacheProfiles
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.cachepurging.interfaces import ICachePurgingSettings
+from plone.cachepurging.interfaces import IPurger
+from plone.cachepurging.utils import getPathsToPurge
+from plone.cachepurging.utils import getURLsToPurge
+from plone.cachepurging.utils import isCachePurgingEnabled
+from plone.caching.interfaces import ICacheSettings
+from plone.caching.interfaces import ICachingOperationType
+from plone.memoize.instance import memoize
+from plone.protect import CheckAuthenticator
+from plone.registry.interfaces import IRegistry
+from Products.CMFCore.utils import getToolByName
+from Products.GenericSetup.interfaces import BASE
+from Products.GenericSetup.interfaces import EXTENSION
+from Products.statusmessages.interfaces import IStatusMessage
+from z3c.caching.interfaces import IRulesetType
+from z3c.caching.registry import enumerateTypes
 from zope.component import getUtilitiesFor
+from zope.component import getUtility
 from zope.component import queryUtility
-
+from zope.interface import implementer
 from zope.publisher.interfaces import IPublishTraverse
 from zope.publisher.interfaces import NotFound
-
 from zope.ramcache.interfaces.ram import IRAMCache
 
-from plone.memoize.instance import memoize
-
-from plone.registry.interfaces import IRegistry
-
-from z3c.caching.interfaces import IRulesetType
-from z3c.caching.registry import enumerateTypes
-
-from plone.protect import CheckAuthenticator
-
-from plone.caching.interfaces import ICacheSettings
-from plone.caching.interfaces import ICachingOperationType
-
-from plone.cachepurging.interfaces import IPurger
-from plone.cachepurging.interfaces import ICachePurgingSettings
-
-from plone.cachepurging.utils import isCachePurgingEnabled
-from plone.cachepurging.utils import getPathsToPurge
-from plone.cachepurging.utils import getURLsToPurge
-
-from plone.app.caching.interfaces import IPloneCacheSettings
-from plone.app.caching.interfaces import ICacheProfiles
-from plone.app.caching.interfaces import _
-from plone.app.caching.browser.edit import EditForm
+import datetime
+import re
 
-from Products.GenericSetup.interfaces import BASE, EXTENSION
-from Products.CMFCore.utils import getToolByName
-from Products.statusmessages.interfaces import IStatusMessage
 
 # Borrowed from zope.schema to avoid an import of a private name
 _isuri = re.compile(
@@ -64,7 +56,8 @@ def update(self):
         self.registry = getUtility(IRegistry)
         self.settings = self.registry.forInterface(ICacheSettings)
         self.ploneSettings = self.registry.forInterface(IPloneCacheSettings)
-        self.purgingSettings = self.registry.forInterface(ICachePurgingSettings)
+        self.purgingSettings = self.registry.forInterface(
+            ICachePurgingSettings)
         self.ramCache = queryUtility(IRAMCache)
 
         if self.request.method == 'POST':
@@ -116,26 +109,40 @@ def publishTraverse(self, request, name):
             return self  # traverse again to get operation name
 
         # Step 2 - get operation name
-        if (self.editGlobal or self.editRuleset) and not self.editOperationName:
+        if (
+            (self.editGlobal or self.editRuleset) and
+            not self.editOperationName
+        ):
             self.editOperationName = name
 
             if self.editGlobal:
 
-                operation = queryUtility(ICachingOperationType, name=self.editOperationName)
+                operation = queryUtility(
+                    ICachingOperationType, name=self.editOperationName)
                 if operation is None:
                     raise NotFound(self, operation)
 
-                return EditForm(self.context, self.request, self.editOperationName, operation)
+                return EditForm(
+                    self.context,
+                    self.request,
+                    self.editOperationName,
+                    operation
+                )
             elif self.editRuleset:
                 return self  # traverse again to get ruleset name
             else:
                 raise NotFound(self, name)
 
         # Step 3 - if this is ruleset traversal, get the ruleset name
-        if self.editRuleset and self.editOperationName and not self.editRulesetName:
+        if (
+            self.editRuleset and
+            self.editOperationName and
+            not self.editRulesetName
+        ):
             self.editRulesetName = name
 
-            operation = queryUtility(ICachingOperationType, name=self.editOperationName)
+            operation = queryUtility(
+                ICachingOperationType, name=self.editOperationName)
             if operation is None:
                 raise NotFound(self, self.operationName)
 
@@ -200,7 +207,6 @@ def processSave(self):
             operationMapping[ruleset] = operation
 
         for ruleset, contentTypes in contentTypesMap.items():
-
             if not ruleset:
                 continue
 
@@ -208,9 +214,7 @@ def processSave(self):
                 ruleset = ruleset.encode('utf-8')
 
             ruleset = ruleset.replace('-', '.')
-
             for contentType in contentTypes:
-
                 if not contentType:
                     continue
 
@@ -218,16 +222,25 @@ def processSave(self):
                     contentType = contentType.encode('utf-8')
 
                 if contentType in contentTypeRulesetMapping:
-                    self.errors.setdefault('contenttypes', {})[ruleset] = \
-                        _(u"Content type ${contentType} is already mapped to the rule ${ruleset}.",
-                            mapping={
-                                'contentType': self.contentTypesLookup.get(contentType, {}).get('title', contentType),  # noqa
-                                'ruleset': contentTypeRulesetMapping[contentType]})
+                    self.errors.setdefault(
+                        'contenttypes', {}
+                    )[ruleset] = _(
+                        u'Content type ${contentType} is already mapped to '
+                        u'the rule ${ruleset}.',
+                        mapping={
+                            'contentType': self.contentTypesLookup.get(
+                                contentType, {}
+                            ).get(
+                                'title',
+                                contentType
+                            ),
+                            'ruleset': contentTypeRulesetMapping[contentType]
+                        }
+                    )
                 else:
                     contentTypeRulesetMapping[contentType] = ruleset
 
         for ruleset, templates in templatesMap.items():
-
             if not ruleset:
                 continue
 
@@ -235,11 +248,8 @@ def processSave(self):
                 ruleset = ruleset.encode('utf-8')
 
             ruleset = ruleset.replace('-', '.')
-
             for template in templates:
-
                 template = template.strip()
-
                 if not template:
                     continue
 
@@ -247,53 +257,67 @@ def processSave(self):
                     template = template.encode('utf-8')
 
                 if template in templateRulesetMapping:
-                    self.errors.setdefault('templates', {})[ruleset] = \
-                        _(u"Template ${template} is already mapped to the rule ${ruleset}.",
-                            mapping={
-                                'template': template,
-                                'ruleset': templateRulesetMapping[template]})
+                    self.errors.setdefault(
+                        'templates', {}
+                    )[ruleset] = _(
+                        u'Template ${template} is already mapped to the rule '
+                        u'${ruleset}.',
+                        mapping={
+                            'template': template,
+                            'ruleset': templateRulesetMapping[template]
+                        }
+                    )
                 else:
                     templateRulesetMapping[template] = ruleset
 
         # Validate purging settings
-
         for cachingProxy in cachingProxies:
             if not _isuri(cachingProxy):
                 self.errors['cachingProxies'] = _(u"Invalid URL: ${url}", mapping={'url': cachingProxy})  # noqa
 
         for domain in domains:
             if not _isuri(domain):
-                self.errors['domain'] = _(u"Invalid URL: ${url}", mapping={'url': domain})
+                self.errors['domain'] = _(
+                    u'Invalid URL: ${url}',
+                    mapping={'url': domain}
+                )
 
         # RAM cache settings
-
         try:
             ramCacheMaxEntries = int(ramCacheMaxEntries)
         except (ValueError, TypeError,):
             self.errors['ramCacheMaxEntries'] = _(u"An integer is required.")
         else:
             if ramCacheMaxEntries < 0:
-                self.errors['ramCacheMaxEntries'] = _(u"A positive number is required.")
-
+                self.errors['ramCacheMaxEntries'] = _(
+                    u"A positive number is required."
+                )
         try:
             ramCacheMaxAge = int(ramCacheMaxAge)
         except (ValueError, TypeError,):
             self.errors['ramCacheMaxAge'] = _(u"An integer is required.")
         else:
             if ramCacheMaxAge < 0:
-                self.errors['ramCacheMaxAge'] = _(u"A positive number is required.")
+                self.errors['ramCacheMaxAge'] = _(
+                    u'A positive number is required.'
+                )
 
         try:
             ramCacheCleanupInterval = int(ramCacheCleanupInterval)
         except (ValueError, TypeError,):
-            self.errors['ramCacheCleanupInterval'] = _(u"An integer is required.")
+            self.errors['ramCacheCleanupInterval'] = _(
+                u'An integer is required.'
+            )
         else:
             if ramCacheMaxAge < 0:
-                self.errors['ramCacheCleanupInterval'] = _(u"A positive number is required.")
+                self.errors['ramCacheCleanupInterval'] = _(
+                    u'A positive number is required.'
+                )
 
         # Check for errors
         if self.errors:
-            IStatusMessage(self.request).addStatusMessage(_(u"There were errors."), "error")
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"There were errors."), "error")
             return
 
         # Save settings
@@ -301,7 +325,7 @@ def processSave(self):
         self.settings.operationMapping = operationMapping
 
         self.ploneSettings.templateRulesetMapping = templateRulesetMapping
-        self.ploneSettings.contentTypeRulesetMapping = contentTypeRulesetMapping
+        self.ploneSettings.contentTypeRulesetMapping = contentTypeRulesetMapping  # noqa
         self.ploneSettings.purgedContentTypes = purgedContentTypes
 
         self.purgingSettings.enabled = purgingEnabled
@@ -309,9 +333,16 @@ def processSave(self):
         self.purgingSettings.virtualHosting = virtualHosting
         self.purgingSettings.domains = domains
 
-        self.ramCache.update(ramCacheMaxEntries, ramCacheMaxAge, ramCacheCleanupInterval)
+        self.ramCache.update(
+            ramCacheMaxEntries,
+            ramCacheMaxAge,
+            ramCacheCleanupInterval
+        )
 
-        IStatusMessage(self.request).addStatusMessage(_(u"Changes saved."), "info")
+        IStatusMessage(self.request).addStatusMessage(
+            _(u'Changes saved.'),
+            'info'
+        )
 
     # Rule types - used as the index column
     @property
@@ -340,15 +371,23 @@ def operationMapping(self):
     @property
     def templateMapping(self):
         return dict(
-            [(k, v.replace('.', '-'),)
-             for k, v in (self.ploneSettings.templateRulesetMapping or {}).items()]
+            [
+                (k, v.replace('.', '-'),)
+                for k, v in (
+                    self.ploneSettings.templateRulesetMapping or {}
+                ).items()
+            ]
         )
 
     @property
     def contentTypeMapping(self):
         return dict(
-            [(k, v.replace('.', '-'),)
-             for k, v in (self.ploneSettings.contentTypeRulesetMapping or {}).items()]
+            [
+                (k, v.replace('.', '-'),)
+                for k, v in (
+                    self.ploneSettings.contentTypeRulesetMapping or {}
+                ).items()
+            ]
         )
 
     # Type lookups (for accessing settings)
@@ -376,7 +415,8 @@ def contentTypesLookup(self):
         types = {}
         portal_types = getToolByName(self.context, 'portal_types')
         for fti in portal_types.objectValues():
-            types[fti.id] = dict(title=fti.title or fti.id, description=fti.description)
+            types[fti.id] = dict(title=fti.title or fti.id,
+                                 description=fti.description)
         return types
 
     # Sorted lists (e.g. for drop-downs)
@@ -385,7 +425,8 @@ def contentTypesLookup(self):
     @memoize
     def operationTypes(self):
         operations = [v for k, v in self.operationTypesLookup.items()]
-        operations.sort(lambda x, y: (cmp(x['sort'], y['sort']) or cmp(x['title'], y['title'])))
+        operations.sort(lambda x, y: (
+            cmp(x['sort'], y['sort']) or cmp(x['title'], y['title'])))
         return operations
 
     @property
@@ -471,7 +512,8 @@ def processImport(self):
             self.errors['profile'] = _(u"You must select a profile to import.")
 
         if self.errors:
-            IStatusMessage(self.request).addStatusMessage(_(u"There were errors."), "error")
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"There were errors."), "error")
             return
 
         portal_setup = getToolByName(self.context, 'portal_setup')
@@ -485,22 +527,28 @@ def processImport(self):
         # Import the new profile
         portal_setup.runAllImportStepsFromProfile("profile-%s" % profile)
 
-        IStatusMessage(self.request).addStatusMessage(_(u"Import complete."), "info")
+        IStatusMessage(self.request).addStatusMessage(
+            _(u"Import complete."), "info")
 
     @property
     @memoize
     def profiles(self):
         portal_setup = getToolByName(self.context, 'portal_setup')
-        return [profile for profile in portal_setup.listProfileInfo(ICacheProfiles)
-                if profile.get('type', BASE) == EXTENSION and profile.get('for') is not None]
+        return [
+            profile for profile in portal_setup.listProfileInfo(ICacheProfiles)
+            if (
+                profile.get('type', BASE) == EXTENSION and
+                profile.get('for') is not None
+            )
+        ]
 
 
 class Purge(BaseView):
     """The purge control panel
     """
+
     def update(self):
         self.purgeLog = []
-
         if super(Purge, self).update():
             if 'form.button.Purge' in self.request.form:
                 self.processPurge()
@@ -513,11 +561,11 @@ def processPurge(self):
             self.errors['urls'] = _(u"No URLs or paths entered.")
 
         if self.errors:
-            IStatusMessage(self.request).addStatusMessage(_(u"There were errors."), "error")
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"There were errors."), "error")
             return
 
         purger = getUtility(IPurger)
-
         serverURL = self.request['SERVER_URL']
 
         def purge(url):
@@ -589,11 +637,14 @@ def update(self):
     def processPurge(self):
 
         if self.ramCache is None:
-            IStatusMessage(self.request).addStatusMessage(_(u"RAM cache not installed."), "error")
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"RAM cache not installed."), "error")
 
         if self.errors:
-            IStatusMessage(self.request).addStatusMessage(_(u"There were errors."), "error")
+            IStatusMessage(self.request).addStatusMessage(
+                _(u"There were errors."), "error")
             return
 
         self.ramCache.invalidateAll()
-        IStatusMessage(self.request).addStatusMessage(_(u"Cache purged."), "info")
+        IStatusMessage(self.request).addStatusMessage(
+            _(u"Cache purged."), "info")
diff --git a/plone/app/caching/browser/edit.py b/plone/app/caching/browser/edit.py
index 7af321c..3522a86 100644
--- a/plone/app/caching/browser/edit.py
+++ b/plone/app/caching/browser/edit.py
@@ -1,21 +1,19 @@
-from zope.component import getUtility
-from zope.interface import alsoProvides
-
-from zope.schema.interfaces import IField
-
-from z3c.form.interfaces import IFormLayer
-from z3c.form import form, button, field
-
+# -*- coding: utf-8 -*-
+from plone.app.caching.interfaces import _
 from plone.memoize.instance import memoize
-
-from plone.registry.interfaces import IRegistry
-from plone.registry import Record
 from plone.registry import FieldRef
-
-from plone.app.caching.interfaces import _
-
+from plone.registry import Record
+from plone.registry.interfaces import IRegistry
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
 from Products.statusmessages.interfaces import IStatusMessage
+from z3c.form import button
+from z3c.form import field
+from z3c.form import form
+from z3c.form.interfaces import IFormLayer
+from zope.component import getUtility
+from zope.interface import alsoProvides
+from zope.schema.interfaces import IField
+
 
 class EditForm(form.Form):
     """General edit form for operations.
@@ -57,10 +55,19 @@ class EditForm(form.Form):
 
     template = ViewPageTemplateFile('edit.pt')
 
-    # Keep the ZPublisher happy - would normally be done by the ZCML registration
+    # Keep the ZPublisher happy - would normally be done by the ZCML
+    # registration
     __name__ = 'cache-operation-edit'
 
-    def __init__(self, context, request, operationName, operation, rulesetName=None, ruleset=None):
+    def __init__(
+        self,
+        context,
+        request,
+        operationName,
+        operation,
+        rulesetName=None,
+        ruleset=None
+    ):
         self.context = context
         self.request = request
         self.operationName = operationName
@@ -72,7 +79,8 @@ def update(self):
 
         self.registry = getUtility(IRegistry)
 
-        # If we were using plone.z3cform, this would be done with z2.switch_on()
+        # If we were using plone.z3cform, this would be done with
+        # z2.switch_on()
         if not IFormLayer.providedBy(self.request):
             alsoProvides(self.request, IFormLayer)
 
@@ -90,18 +98,22 @@ def update(self):
             fieldName = "%s.%s" % (prefix, option)
 
             if self.rulesetName:
-                rulesetFieldName = "%s.%s.%s" % (prefix, self.rulesetName, option)
+                rulesetFieldName = "%s.%s.%s" % (
+                    prefix, self.rulesetName, option)
 
                 if rulesetFieldName in self.registry.records:
-                    newField = self.cloneField(self.registry.records[rulesetFieldName].field)
+                    newField = self.cloneField(self.registry.records[
+                                               rulesetFieldName].field)
                     newField.__name__ = rulesetFieldName
                 elif fieldName in self.registry.records:
-                    newField = self.cloneField(self.registry.records[fieldName].field)
+                    newField = self.cloneField(
+                        self.registry.records[fieldName].field)
                     newField.__name__ = rulesetFieldName
 
             else:
                 if fieldName in self.registry.records:
-                    newField = self.cloneField(self.registry.records[fieldName].field)
+                    newField = self.cloneField(
+                        self.registry.records[fieldName].field)
                     newField.__name__ = fieldName
 
             if newField is not None:
@@ -144,10 +156,12 @@ def getContent(self):
             # as necessary in applyChanges()
 
             if self.rulesetName:
-                rulesetRecordName = "%s.%s.%s" % (prefix, self.rulesetName, option,)
+                rulesetRecordName = "%s.%s.%s" % (
+                    prefix, self.rulesetName, option,)
 
                 if rulesetRecordName in self.registry.records:
-                    context[rulesetRecordName] = self.registry[rulesetRecordName]
+                    context[rulesetRecordName] = self.registry[
+                        rulesetRecordName]
                 elif recordName in self.registry.records:
                     context[rulesetRecordName] = self.registry[recordName]
 
@@ -173,12 +187,15 @@ def applyChanges(self, data):
                 # Strip the ruleset name out, leaving the original key - this
                 # must exist, otherwise getContent() would not have put it in
                 # the data dictionary
-                globalKey = self.operation.prefix + key[len(self.operation.prefix) + len(self.rulesetName) + 1:]
+                globalKey = self.operation.prefix + \
+                    key[len(self.operation.prefix) +
+                        len(self.rulesetName) + 1:]
                 assert globalKey in self.registry.records
 
                 # Create a new record with a FieldRef
                 field = self.registry.records[globalKey].field
-                self.registry.records[key] = Record(FieldRef(globalKey, field), value)
+                self.registry.records[key] = Record(
+                    FieldRef(globalKey, field), value)
 
             else:
                 self.registry[key] = value
@@ -207,11 +224,11 @@ def cloneField(self, field):
     def title(self):
         if self.rulesetName:
             return _(u"Edit ${operation} options for Ruleset: ${ruleset}",
-                        mapping={'operation': self.operation.title,
-                                 'ruleset': self.ruleset.title})
+                     mapping={'operation': self.operation.title,
+                              'ruleset': self.ruleset.title})
         else:
             return _(u"Edit ${operation} options",
-                        mapping={'operation': self.operation.title})
+                     mapping={'operation': self.operation.title})
 
     @property
     def description(self):
@@ -219,30 +236,50 @@ def description(self):
 
     # Buttons/actions
 
-    @button.buttonAndHandler(_(u"Save"), name="save")
+    @button.buttonAndHandler(_(u'Save'), name='save')
     def save(self, action):
         data, errors = self.extractData()
         if errors:
             self.status = self.formErrorsMessage
             return
         self.applyChanges(data)
-        IStatusMessage(self.request).addStatusMessage(_(u"Changes saved."), "info")
-        self.request.response.redirect("%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
+        IStatusMessage(self.request).addStatusMessage(
+            _(u'Changes saved.'), 'info')
+        self.request.response.redirect(
+            '{0}/@@caching-controlpanel#detailed-settings'.format(
+                self.context.absolute_url()
+            )
+        )
+        return ''
 
-    @button.buttonAndHandler(_(u"Cancel"), name="cancel")
+    @button.buttonAndHandler(_(u'Cancel'), name='cancel')
     def cancel(self, action):
-        IStatusMessage(self.request).addStatusMessage(_(u"Edit cancelled."), type="info")
-        self.request.response.redirect("%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
+        IStatusMessage(self.request).addStatusMessage(
+            _(u"Edit cancelled."), type="info")
+        self.request.response.redirect(
+            '{0}/@@caching-controlpanel#detailed-settings'.format(
+                self.context.absolute_url()
+            )
+        )
         return ''
 
-    @button.buttonAndHandler(_(u"Delete settings (use defaults)"), name="clear")
+    @button.buttonAndHandler(
+        _(u'Delete settings (use defaults)'),
+        name='clear'
+    )
     def clear(self, action):
         for key in self.getContent().keys():
-            assert key.startswith("%s.%s." % (self.operation.prefix, self.rulesetName,))
+            assert key.startswith("%s.%s." % (
+                self.operation.prefix, self.rulesetName,))
 
             if key in self.registry.records:
                 del self.registry.records[key]
 
-        IStatusMessage(self.request).addStatusMessage(_(u"Ruleset-specific settings removed."), type="info")
-        self.request.response.redirect("%s/@@caching-controlpanel#detailed-settings" % self.context.absolute_url())
+        IStatusMessage(self.request).addStatusMessage(
+            _(u"Ruleset-specific settings removed."), type="info")
+        self.request.response.redirect(
+            '{0}/@@caching-controlpanel#detailed-settings'.format(
+                self.context.absolute_url()
+            )
+        )
         return ''
diff --git a/plone/app/caching/interfaces.py b/plone/app/caching/interfaces.py
index 71552a9..e6eac09 100644
--- a/plone/app/caching/interfaces.py
+++ b/plone/app/caching/interfaces.py
@@ -1,10 +1,13 @@
+# -*- coding: utf-8 -*-
+from zope import schema
+from zope.interface import Interface
+
 import zope.i18nmessageid
 
-from zope.interface import Interface
-from zope import schema
 
 _ = zope.i18nmessageid.MessageFactory('plone.app.caching')
 
+
 class ICacheProfiles(Interface):
     """Marker interface for extension profiles that contain cache settings.
     These will primarily include a ``registry.xml`` file to configure cache
@@ -25,6 +28,7 @@ class ICacheProfiles(Interface):
     available for installation in the cache settings control panel.
     """
 
+
 class IPloneCacheSettings(Interface):
     """Settings stored in the registry.
 
@@ -34,32 +38,35 @@ class IPloneCacheSettings(Interface):
     """
 
     templateRulesetMapping = schema.Dict(
-            title=_(u"Page template/ruleset mapping"),
-            description=_(u"Maps skin layer page template names to ruleset names"),
-            key_type=schema.ASCIILine(title=_(u"Page template name")),
-            value_type=schema.DottedName(title=_(u"Ruleset name")),
-        )
+        title=_(u"Page template/ruleset mapping"),
+        description=_(u"Maps skin layer page template names to ruleset names"),
+        key_type=schema.ASCIILine(title=_(u"Page template name")),
+        value_type=schema.DottedName(title=_(u"Ruleset name")),
+    )
 
     contentTypeRulesetMapping = schema.Dict(
-            title=_(u"Content type/ruleset mapping"),
-            description=_(u"Maps content type names to ruleset names"),
-            key_type=schema.ASCIILine(title=_(u"Content type name")),
-            value_type=schema.DottedName(title=_(u"Ruleset name")),
-        )
+        title=_(u"Content type/ruleset mapping"),
+        description=_(u"Maps content type names to ruleset names"),
+        key_type=schema.ASCIILine(title=_(u"Content type name")),
+        value_type=schema.DottedName(title=_(u"Ruleset name")),
+    )
 
     purgedContentTypes = schema.Tuple(
-            title=_(u"Content types to purge"),
-            description=_(u"List content types which should be purged when modified"),
-            value_type=schema.ASCIILine(title=_(u"Content type name")),
-            default=('File', 'Image', 'News Item', ),
-        )
+        title=_(u"Content types to purge"),
+        description=_(
+            u"List content types which should be purged when modified"),
+        value_type=schema.ASCIILine(title=_(u"Content type name")),
+        default=('File', 'Image', 'News Item', ),
+    )
 
     cacheStopRequestVariables = schema.Tuple(
-            title=_(u"Request variables that prevent caching"),
-            description=_(u"Variables in the request that prevent caching if present"),
-            value_type=schema.ASCIILine(title=_(u"Request variables")),
-            default=('statusmessages', 'SearchableText',),
-        )
+        title=_(u"Request variables that prevent caching"),
+        description=_(
+            u"Variables in the request that prevent caching if present"),
+        value_type=schema.ASCIILine(title=_(u"Request variables")),
+        default=('statusmessages', 'SearchableText',),
+    )
+
 
 class IETagValue(Interface):
     """ETag component builder
@@ -74,6 +81,7 @@ def __call__():
         """Return the ETag component, as a string.
         """
 
+
 class IRAMCached(Interface):
     """Marker interface applied to the request if it should be RAM cached.
 
diff --git a/plone/app/caching/lastmodified.py b/plone/app/caching/lastmodified.py
index 252dcf2..9cef1ac 100644
--- a/plone/app/caching/lastmodified.py
+++ b/plone/app/caching/lastmodified.py
@@ -1,12 +1,22 @@
+# -*- coding: utf-8 -*-
+from Acquisition import aq_base
 from datetime import datetime
 from dateutil.tz import tzlocal
-
-from zope.interface import implementer, implementer, Interface
-from zope.component import adapter, adapts
-
+from OFS.Image import File
+from plone.app.caching.operations.utils import getContext
+from Products.Archetypes.Field import Image as ImageScale
+from Products.CMFCore.FSObject import FSObject
+from Products.CMFCore.FSPageTemplate import FSPageTemplate
+from Products.CMFCore.interfaces import ICatalogableDublinCore
+from Products.ResourceRegistries.interfaces import ICookedFile
+from Products.ResourceRegistries.interfaces import IResourceRegistry
+from z3c.caching.interfaces import ILastModified
 from zope.browserresource.interfaces import IResource
+from zope.component import adapter
+from zope.interface import implementer
+from zope.interface import Interface
 from zope.pagetemplate.interfaces import IPageTemplate
-from z3c.caching.interfaces import ILastModified
+
 
 try:
     from zope.dublincore.interfaces import IDCTimes
@@ -14,20 +24,6 @@
     class IDCTimes(Interface):
         pass
 
-from Acquisition import aq_base
-from Acquisition import aq_parent
-from Acquisition import aq_inner
-
-from OFS.Image import File
-from Products.Archetypes.Field import Image as ImageScale
-from Products.CMFCore.interfaces import ICatalogableDublinCore
-from Products.CMFCore.FSObject import FSObject
-from Products.CMFCore.FSPageTemplate import FSPageTemplate
-
-from plone.app.caching.operations.utils import getContext
-from Products.ResourceRegistries.interfaces import ICookedFile
-from Products.ResourceRegistries.interfaces import IResourceRegistry
-
 
 @implementer(ILastModified)
 @adapter(IPageTemplate)
@@ -38,6 +34,7 @@ def PageTemplateDelegateLastModified(template):
     """
     return ILastModified(template.__parent__, None)
 
+
 @implementer(ILastModified)
 @adapter(FSPageTemplate)
 def FSPageTemplateDelegateLastModified(template):
@@ -47,6 +44,7 @@ def FSPageTemplateDelegateLastModified(template):
     """
     return PageTemplateDelegateLastModified(template)
 
+
 @implementer(ILastModified)
 class PersistentLastModified(object):
     """General ILastModified adapter for persistent objects that have a
@@ -66,16 +64,18 @@ def __call__(self):
             return datetime.fromtimestamp(mtime, tzlocal())
         return None
 
+
+@adapter(File)
 class OFSFileLastModified(PersistentLastModified):
     """ILastModified adapter for OFS.Image.File
     """
-    adapts(File)
+
 
 @implementer(ILastModified)
+@adapter(ImageScale)
 class ImageScaleLastModified(object):
     """ILastModified adapter for Products.Archetypes.Field.Image
     """
-    adapts(ImageScale)
 
     def __init__(self, context):
         self.context = context
@@ -86,11 +86,12 @@ def __call__(self):
             return ILastModified(parent)()
         return None
 
+
 @implementer(ILastModified)
+@adapter(FSObject)
 class FSObjectLastModified(object):
     """ILastModified adapter for FSFile and FSImage
     """
-    adapts(FSObject)
 
     def __init__(self, context):
         self.context = context
@@ -103,12 +104,13 @@ def __call__(self):
         mtime = self.context._file_mod_time
         return datetime.fromtimestamp(mtime, tzlocal())
 
+
 @implementer(ILastModified)
+@adapter(ICatalogableDublinCore)
 class CatalogableDublinCoreLastModified(object):
     """ILastModified adapter for ICatalogableDublinCore, which includes
     most CMF, Archetypes and Dexterity content
     """
-    adapts(ICatalogableDublinCore)
 
     def __init__(self, context):
         self.context = context
@@ -119,11 +121,12 @@ def __call__(self):
             return None
         return modified.asdatetime()
 
+
 @implementer(ILastModified)
+@adapter(IDCTimes)
 class DCTimesLastModified(object):
     """ILastModified adapter for zope.dublincore IDCTimes
     """
-    adapts(IDCTimes)
 
     def __init__(self, context):
         self.context = context
@@ -131,11 +134,12 @@ def __init__(self, context):
     def __call__(self):
         return self.context.modified
 
+
 @implementer(ILastModified)
+@adapter(IResource)
 class ResourceLastModified(object):
     """ILastModified for Zope 3 style browser resources
     """
-    adapts(IResource)
 
     def __init__(self, context):
         self.context = context
@@ -144,23 +148,25 @@ def __call__(self):
         lmt = getattr(self.context.context, 'lmt', None)
         if lmt is not None:
             return datetime.fromtimestamp(lmt, tzlocal())
-        return None
+
 
 @implementer(ILastModified)
+@adapter(ICookedFile)
 class CookedFileLastModified(object):
     """ILastModified for Resource Registry `cooked` files
     """
-    adapts(ICookedFile)
 
     def __init__(self, context):
         self.context = context
 
     def __call__(self):
         registry = getContext(self.context, IResourceRegistry)
-        if registry is not None:
-            if registry.getDebugMode() or not registry.isCacheable(self.context.__name__):
-                return None
-            mtime = getattr(registry.aq_base, '_p_mtime', None)
-            if mtime is not None and mtime > 0:
-                return datetime.fromtimestamp(mtime, tzlocal())
-        return None
+        if (
+            registry is None or
+            registry.getDebugMode() or
+            not registry.isCacheable(self.context.__name__)
+        ):
+            return None
+        mtime = getattr(registry.aq_base, '_p_mtime', None)
+        if mtime is not None and mtime > 0:
+            return datetime.fromtimestamp(mtime, tzlocal())
diff --git a/plone/app/caching/lookup.py b/plone/app/caching/lookup.py
index ddbbc44..c044141 100644
--- a/plone/app/caching/lookup.py
+++ b/plone/app/caching/lookup.py
@@ -1,15 +1,13 @@
-from zope.interface import implementer
-from zope.component import queryUtility
-
+# -*- coding: utf-8 -*-
+from Acquisition import aq_base
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.utils import getObjectDefaultView
+from plone.caching.interfaces import IRulesetLookup
 from plone.registry.interfaces import IRegistry
-
 from z3c.caching.registry import lookup
-from plone.caching.interfaces import IRulesetLookup
-from plone.app.caching.interfaces import IPloneCacheSettings
-
-from Acquisition import aq_base
+from zope.component import queryUtility
+from zope.interface import implementer
 
-from plone.app.caching.utils import getObjectDefaultView
 
 @implementer(IRulesetLookup)
 class ContentItemLookup(object):
@@ -49,8 +47,8 @@ class ContentItemLookup(object):
     """
 
     # This adapter is registered twice in configure.zcml, ala:
-    # adapts(IPageTemplate, Interface)
-    # adapts(IBrowserView, Interface)
+    # @adapter(IPageTemplate, Interface)
+    # @adapter(IBrowserView, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -67,7 +65,8 @@ def __call__(self):
         if registry is None:
             return None
 
-        ploneCacheSettings = registry.forInterface(IPloneCacheSettings, check=False)
+        ploneCacheSettings = registry.forInterface(
+            IPloneCacheSettings, check=False)
 
         # 2. Get the name of the published object
         name = getattr(self.published, '__name__', None)
@@ -82,27 +81,34 @@ def __call__(self):
 
         # 4. Find the parent of the published object
         parent = getattr(self.published, '__parent__', None)
-        if parent is not None:
-
-            # 4.1. If the parent is a content object:
-            parentPortalType = getattr(aq_base(parent), 'portal_type', None)
-            if parentPortalType is not None:
+        if parent is None:
+            return None
 
-                # 4.1.1. Get the default view of the parent content object
-                defaultView = getObjectDefaultView(parent)
+        # 4.1. If the parent is a content object:
+        parentPortalType = getattr(aq_base(parent), 'portal_type', None)
+        if parentPortalType is None:
+            return None
 
-                # 4.1.2. If the name of the published object is the same as the default view of the parent:
-                if defaultView == name:
+        # 4.1.1. Get the default view of the parent content object
+        defaultView = getObjectDefaultView(parent)
 
-                    # 4.1.2.1. Look up the parent type in the content type mapping
-                    if ploneCacheSettings.contentTypeRulesetMapping is not None:
-                        ruleset = ploneCacheSettings.contentTypeRulesetMapping.get(parentPortalType, None)
-                        if ruleset is not None:
-                            return ruleset
+        # 4.1.2. If the name of the published object is the same as the
+        # default view of the parent:
+        if defaultView != name:
+            return None
 
-                    # 4.1.2.2. Look up a ruleset on the parent object and return
-                    ruleset = lookup(parent)
-                    if ruleset is not None:
-                        return ruleset
+        # 4.1.2.1. Look up the parent type in the content type
+        # mapping
+        if ploneCacheSettings.contentTypeRulesetMapping is not None:
+            ruleset = ploneCacheSettings.contentTypeRulesetMapping.get(
+                parentPortalType,
+                None
+            )
+            if ruleset is not None:
+                return ruleset
 
-        return None
+        # 4.1.2.2. Look up a ruleset on the parent object and
+        # return
+        ruleset = lookup(parent)
+        if ruleset is not None:
+            return ruleset
diff --git a/plone/app/caching/operations/default.py b/plone/app/caching/operations/default.py
index 2b4b06a..a265f1c 100644
--- a/plone/app/caching/operations/default.py
+++ b/plone/app/caching/operations/default.py
@@ -1,35 +1,30 @@
-import time
-import random
-
-from zope.interface import implementer
-from zope.interface import provider
-from zope.interface import Interface
-from zope.component import adapts
-from zope.component import getMultiAdapter
-
-from zope.publisher.interfaces.http import IHTTPRequest
-
-from plone.caching.interfaces import ICachingOperation
-from plone.caching.interfaces import ICachingOperationType
-from plone.caching.utils import lookupOptions
-
-from plone.app.caching.operations.utils import setCacheHeaders
-from plone.app.caching.operations.utils import doNotCache
+# -*- coding: utf-8 -*-
+from plone.app.caching.interfaces import _
+from plone.app.caching.operations.utils import cachedResponse
 from plone.app.caching.operations.utils import cacheInRAM
 from plone.app.caching.operations.utils import cacheStop
-
-from plone.app.caching.operations.utils import cachedResponse
-from plone.app.caching.operations.utils import notModified
-
-from plone.app.caching.operations.utils import getETagAnnotation
+from plone.app.caching.operations.utils import doNotCache
+from plone.app.caching.operations.utils import fetchFromRAMCache
 from plone.app.caching.operations.utils import getContext
+from plone.app.caching.operations.utils import getETagAnnotation
 from plone.app.caching.operations.utils import getLastModifiedAnnotation
-
-from plone.app.caching.operations.utils import fetchFromRAMCache
 from plone.app.caching.operations.utils import isModified
+from plone.app.caching.operations.utils import notModified
+from plone.app.caching.operations.utils import setCacheHeaders
 from plone.app.caching.operations.utils import visibleToRole
+from plone.caching.interfaces import ICachingOperation
+from plone.caching.interfaces import ICachingOperationType
+from plone.caching.utils import lookupOptions
+from zope.component import adapter
+from zope.component import getMultiAdapter
+from zope.interface import implementer
+from zope.interface import Interface
+from zope.interface import provider
+from zope.publisher.interfaces.http import IHTTPRequest
+
+import random
+import time
 
-from plone.app.caching.interfaces import _
 
 try:
     from Products.ResourceRegistries.interfaces import ICookedFile
@@ -38,8 +33,10 @@
 except ImportError:
     HAVE_RESOURCE_REGISTRIES = False
 
+
 @implementer(ICachingOperation)
 @provider(ICachingOperationType)
+@adapter(Interface, Interface)
 class BaseCaching(object):
     """A generic caching operation class that can do pretty much all the usual
     caching operations based on options settings. For UI simplicity, it might
@@ -48,31 +45,39 @@ class BaseCaching(object):
 
     Generic options (Default value for each is None):
 
-    ``maxage`` is the maximum age of the cached item, in seconds..
+    ``maxage``
+        is the maximum age of the cached item, in seconds..
 
-    ``smaxage`` is the maximum age of the cached item in proxies, in seconds.
+    ``smaxage``
+        is the maximum age of the cached item in proxies, in seconds.
 
-    ``etags'' is a list of etag components to use when constructing an etag.
+    ``etags''
+        is a list of etag components to use when constructing an etag.
 
-    ``lastModified`` is a boolean indicating whether to set a Last-Modified header
-    and turn on 304 responses.
+    ``lastModified``
+        is a boolean indicating whether to set a Last-Modified header
+        and turn on 304 responses.
 
-    ``ramCache`` is a boolean indicating whether to turn on RAM caching for this
-    item. Etags are only required if the URL is not specific enough to ensure
-    uniqueness.
+    ``ramCache``
+        is a boolean indicating whether to turn on RAM caching for this item.
+        Etags are only required if the URL is not specific enough to ensure
+        uniqueness.
 
-    ``vary`` is a string to add as a Vary header value in the response.
+    ``vary``
+        is a string to add as a Vary header value in the response.
     """
-    adapts(Interface, IHTTPRequest)
-
-    title = _(u"Generic caching")
-    description = _(u"Through this operation, all standard caching functions "
-                    u"can be performed via various combinations of the optional "
-                    u"parameter settings. For most cases, it's probably easier "
-                    u"to use one of the other simpler operations (Strong caching, "
-                    u"Moderate caching, Weak caching, or No caching).")
+
+    title = _(u'Generic caching')
+    description = _(
+        u'Through this operation, all standard caching functions '
+        u'can be performed via various combinations of the optional '
+        u'parameter settings. For most cases, it\'s probably easier '
+        u'to use one of the other simpler operations (Strong caching, '
+        u'Moderate caching, Weak caching, or No caching).'
+    )
     prefix = 'plone.app.caching.baseCaching'
-    options = ('maxage','smaxage','etags','lastModified','ramCache', 'vary', 'anonOnly')
+    options = ('maxage', 'smaxage', 'etags', 'lastModified',
+               'ramCache', 'vary', 'anonOnly')
 
     # Default option values
     maxage = smaxage = etags = vary = None
@@ -85,9 +90,9 @@ def __init__(self, published, request):
     def interceptResponse(self, rulename, response, class_=None):
         options = lookupOptions(class_ or self.__class__, rulename)
 
-        etags        = options.get('etags') or self.etags
-        anonOnly     = options.get('anonOnly', self.anonOnly)
-        ramCache     = options.get('ramCache', self.ramCache)
+        etags = options.get('etags') or self.etags
+        anonOnly = options.get('anonOnly', self.anonOnly)
+        ramCache = options.get('ramCache', self.ramCache)
         lastModified = options.get('lastModified', self.lastModified)
 
         # Add the ``anonymousOrRandom`` etag if we are anonymous only
@@ -98,7 +103,8 @@ def interceptResponse(self, rulename, response, class_=None):
                 etags = tuple(etags) + ('anonymousOrRandom',)
 
         etag = getETagAnnotation(self.published, self.request, keys=etags)
-        lastModified = getLastModifiedAnnotation(self.published, self.request, lastModified=lastModified)
+        lastModified = getLastModifiedAnnotation(
+            self.published, self.request, lastModified=lastModified)
 
         # Check for cache stop request variables
         if cacheStop(self.request, rulename):
@@ -106,30 +112,43 @@ def interceptResponse(self, rulename, response, class_=None):
 
         # Check if this should be a 304 response
         if not isModified(self.request, etag=etag, lastModified=lastModified):
-            return notModified(self.published, self.request, response, etag=etag, lastModified=lastModified)
+            return notModified(
+                self.published,
+                self.request,
+                response,
+                etag=etag,
+                lastModified=lastModified
+            )
 
         # Check if this is in the ram cache
         if ramCache:
             context = getContext(self.published)
-            portal_state = getMultiAdapter((context, self.request), name=u'plone_portal_state')
+            portal_state = getMultiAdapter(
+                (context, self.request), name=u'plone_portal_state')
 
             if portal_state.anonymous():
-                cached = fetchFromRAMCache(self.request, etag=etag, lastModified=lastModified)
+                cached = fetchFromRAMCache(
+                    self.request, etag=etag, lastModified=lastModified)
                 if cached is not None:
-                    return cachedResponse(self.published, self.request, response, *cached)
+                    return cachedResponse(
+                        self.published,
+                        self.request,
+                        response,
+                        *cached
+                    )
 
         return None
 
     def modifyResponse(self, rulename, response, class_=None):
         options = lookupOptions(class_ or self.__class__, rulename)
 
-        maxage   = options.get('maxage', self.maxage)
-        smaxage  = options.get('smaxage', self.smaxage)
-        etags    = options.get('etags') or self.etags
+        maxage = options.get('maxage', self.maxage)
+        smaxage = options.get('smaxage', self.smaxage)
+        etags = options.get('etags') or self.etags
 
         anonOnly = options.get('anonOnly', self.anonOnly)
         ramCache = options.get('ramCache', self.ramCache)
-        vary     = options.get('vary', self.vary)
+        vary = options.get('vary', self.vary)
 
         # Add the ``anonymousOrRandom`` etag if we are anonymous only
         if anonOnly:
@@ -139,15 +158,22 @@ def modifyResponse(self, rulename, response, class_=None):
                 etags = tuple(etags) + ('anonymousOrRandom',)
 
         etag = getETagAnnotation(self.published, self.request, etags)
-        lastModified = getLastModifiedAnnotation(self.published, self.request, options['lastModified'])
+        lastModified = getLastModifiedAnnotation(
+            self.published, self.request, options['lastModified'])
 
         # Check for cache stop request variables
         if cacheStop(self.request, rulename):
             # only stop with etags if configured
             if etags:
                 etag = "%s%d" % (time.time(), random.randint(0, 1000))
-                return setCacheHeaders(self.published, self.request, response, etag=etag)
-            # XXX: should there be an else here? Last modified works without extra headers.
+                return setCacheHeaders(
+                    self.published,
+                    self.request,
+                    response,
+                    etag=etag
+                )
+            # XXX: should there be an else here? Last modified works without
+            #      extra headers.
             #      Are there other config options?
 
         # Do the maxage/smaxage settings allow for proxy caching?
@@ -157,9 +183,17 @@ def modifyResponse(self, rulename, response, class_=None):
         public = True
         if ramCache or proxyCache:
             if etags is not None:
-                if 'userid' in etags or 'anonymousOrRandom' in etags or 'roles' in etags:
+                if (
+                    'userid' in etags or
+                    'anonymousOrRandom' in etags or
+                    'roles' in etags
+
+                ):
                     context = getContext(self.published)
-                    portal_state = getMultiAdapter((context, self.request), name=u'plone_portal_state')
+                    portal_state = getMultiAdapter(
+                        (context, self.request),
+                        name=u'plone_portal_state'
+                    )
                     public = portal_state.anonymous()
             public = public and visibleToRole(self.published, role='Anonymous')
 
@@ -167,11 +201,20 @@ def modifyResponse(self, rulename, response, class_=None):
             # This is private so keep it out of both shared and browser caches
             maxage = smaxage = 0
 
-        setCacheHeaders(self.published, self.request, response, maxage=maxage, smaxage=smaxage,
-            etag=etag, lastModified=lastModified, vary=vary)
+        setCacheHeaders(
+            self.published,
+            self.request,
+            response,
+            maxage=maxage,
+            smaxage=smaxage,
+            etag=etag,
+            lastModified=lastModified,
+            vary=vary
+        )
 
         if ramCache and public:
-            cacheInRAM(self.published, self.request, response, etag=etag, lastModified=lastModified)
+            cacheInRAM(self.published, self.request, response,
+                       etag=etag, lastModified=lastModified)
 
 
 @provider(ICachingOperationType)
@@ -180,43 +223,48 @@ class WeakCaching(BaseCaching):
     operation to help make the UI approachable by mortals
     """
 
-    title = _(u"Weak caching")
-    description = _(u"Cache in browser but expire immediately and enable 304 "
-                    u"responses on subsequent requests. 304's require configuration "
-                    u"of the 'Last-modified' and/or 'ETags' settings. If Last-Modified "
-                    u"header is insufficient to ensure freshness, turn on ETag "
-                    u"checking by listing each ETag components that should be used to "
-                    u"to construct the ETag header. "
-                    u"To also cache public responses in Zope memory, set 'RAM cache' to True. ")
+    title = _(u'Weak caching')
+    description = _(
+        u'Cache in browser but expire immediately and enable 304 '
+        u'responses on subsequent requests. 304\'s require configuration '
+        u'of the \'Last-modified\' and/or \'ETags\' settings. If '
+        u'Last-Modified  header is insufficient to ensure freshness, turn on '
+        u'ETag checking by listing each ETag components that should be used '
+        u'to construct the ETag header. To also cache public responses in '
+        u'Zope memory, set \'RAM cache\' to True.'
+    )
     prefix = 'plone.app.caching.weakCaching'
     sort = 3
 
     # Configurable options
-    options = ('etags','lastModified','ramCache','vary', 'anonOnly')
+    options = ('etags', 'lastModified', 'ramCache', 'vary', 'anonOnly')
 
     # Default option values
     maxage = 0
     smaxage = etags = vary = None
     lastModified = ramCache = anonOnly = False
 
+
 @provider(ICachingOperationType)
 class ModerateCaching(BaseCaching):
     """Moderate caching operation. A subclass of the generic BaseCaching
     operation to help make the UI approachable by mortals
     """
 
-    title = _(u"Moderate caching")
-    description = _(u"Cache in browser but expire immediately (same as 'weak caching'), "
-                    u"and cache in proxy (default: 24 hrs). "
-                    u"Use a purgable caching reverse proxy for best results. "
-                    u"Caution: If proxy cannot be purged, or cannot be configured "
-                    u"to remove the 's-maxage' token from the response, then stale "
-                    u"responses might be seen until the cached entry expires. ")
+    title = _(u'Moderate caching')
+    description = _(
+        u'Cache in browser but expire immediately (same as \'weak caching\'), '
+        u'and cache in proxy (default: 24 hrs). '
+        u'Use a purgable caching reverse proxy for best results. '
+        u'Caution: If proxy cannot be purged, or cannot be configured '
+        u'to remove the \s-maxage\ token from the response, then stale '
+        u'responses might be seen until the cached entry expires. ')
     prefix = 'plone.app.caching.moderateCaching'
     sort = 2
 
     # Configurable options
-    options = ('smaxage','etags','lastModified','ramCache','vary', 'anonOnly')
+    options = ('smaxage', 'etags', 'lastModified',
+               'ramCache', 'vary', 'anonOnly')
 
     # Default option values
     maxage = 0
@@ -224,57 +272,69 @@ class ModerateCaching(BaseCaching):
     etags = vary = None
     lastModified = ramCache = anonOnly = False
 
+
 @provider(ICachingOperationType)
 class StrongCaching(BaseCaching):
     """Strong caching operation. A subclass of the generic BaseCaching
     operation to help make the UI approachable by mortals
     """
 
-    title = _(u"Strong caching")
-    description = _(u"Cache in browser and proxy (default: 24 hrs). "
-                    u"Caution: Only use for stable resources "
-                    u"that never change without changing their URL, or resources "
-                    u"for which temporary staleness is not critical.")
+    title = _(u'Strong caching')
+    description = _(
+        u'Cache in browser and proxy (default: 24 hrs). '
+        u'Caution: Only use for stable resources '
+        u'that never change without changing their URL, or resources '
+        u'for which temporary staleness is not critical.'
+    )
     prefix = 'plone.app.caching.strongCaching'
     sort = 1
 
     # Configurable options
-    options = ('maxage','smaxage','etags','lastModified','ramCache','vary', 'anonOnly')
+    options = ('maxage', 'smaxage', 'etags', 'lastModified',
+               'ramCache', 'vary', 'anonOnly')
 
     # Default option values
     maxage = 86400
     smaxage = etags = vary = None
     lastModified = ramCache = anonOnly = False
 
+
 if HAVE_RESOURCE_REGISTRIES:
 
+    @adapter(ICookedFile, IHTTPRequest)
     class ResourceRegistriesCaching(StrongCaching):
         """Override for StrongCaching which checks ResourceRegistries
         cacheability
         """
 
-        adapts(ICookedFile, IHTTPRequest)
-
         def interceptResponse(self, rulename, response):
-            return super(ResourceRegistriesCaching, self).interceptResponse(rulename, response, class_=StrongCaching)
+            return super(
+                ResourceRegistriesCaching,
+                self
+            ).interceptResponse(rulename, response, class_=StrongCaching)
 
         def modifyResponse(self, rulename, response):
             registry = getContext(self.published, IResourceRegistry)
 
             if registry is not None:
-                if registry.getDebugMode() or not registry.isCacheable(self.published.__name__):
+                if (
+                    registry.getDebugMode() or
+                    not registry.isCacheable(self.published.__name__)
+                ):
                     doNotCache(self.published, self.request, response)
                     return
 
-            super(ResourceRegistriesCaching, self).modifyResponse(rulename, response, class_=StrongCaching)
+            super(ResourceRegistriesCaching, self).modifyResponse(
+                rulename, response, class_=StrongCaching)
+
 
 @implementer(ICachingOperation)
 @provider(ICachingOperationType)
+@adapter(Interface, IHTTPRequest)
 class NoCaching(object):
     """A caching operation that tries to keep the response
     out of all caches.
     """
-    adapts(Interface, IHTTPRequest)
 
     title = _(u"No caching")
     description = _(u"Use this operation to keep the response "
diff --git a/plone/app/caching/operations/etags.py b/plone/app/caching/operations/etags.py
index 1a346da..1e285d4 100644
--- a/plone/app/caching/operations/etags.py
+++ b/plone/app/caching/operations/etags.py
@@ -1,28 +1,22 @@
-import random
-import time
-
-from zope.interface import implementer
-from zope.interface import Interface
-
-from zope.component import adapts
-from zope.component import queryMultiAdapter
-from zope.component import queryUtility
-
-from plone.registry.interfaces import IRegistry
-
+# -*- coding: utf-8 -*-
 from plone.app.caching.interfaces import IETagValue
-from plone.app.caching.interfaces import IPloneCacheSettings
-
 from plone.app.caching.operations.utils import getContext
 from plone.app.caching.operations.utils import getLastModifiedAnnotation
-
 from Products.CMFCore.utils import getToolByName
+from zope.component import adapter
+from zope.component import queryMultiAdapter
+from zope.interface import implementer
+from zope.interface import Interface
+
+import random
+import time
+
 
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class UserID(object):
     """The ``userid`` etag component, returning the current user's id
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -30,7 +24,8 @@ def __init__(self, published, request):
 
     def __call__(self):
         context = getContext(self.published)
-        portal_state = queryMultiAdapter((context, self.request), name=u'plone_portal_state')
+        portal_state = queryMultiAdapter(
+            (context, self.request), name=u'plone_portal_state')
         if portal_state is None:
             return None
 
@@ -40,12 +35,13 @@ def __call__(self):
 
         return member.getId()
 
+
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class Roles(object):
     """The ``roles`` etag component, returning the current user's roles,
     separated by semicolons
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -53,7 +49,8 @@ def __init__(self, published, request):
 
     def __call__(self):
         context = getContext(self.published)
-        portal_state = queryMultiAdapter((context, self.request), name=u'plone_portal_state')
+        portal_state = queryMultiAdapter(
+            (context, self.request), name=u'plone_portal_state')
         if portal_state is None:
             return None
 
@@ -66,12 +63,13 @@ def __call__(self):
 
         return ';'.join(sorted(member.getRolesInContext(context)))
 
+
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class Language(object):
     """The ``language`` etag component, returning the value of the
     HTTP_ACCEPT_LANGUAGE request key.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -80,12 +78,13 @@ def __init__(self, published, request):
     def __call__(self):
         return self.request.get('HTTP_ACCEPT_LANGUAGE', '')
 
+
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class UserLanguage(object):
     """The ``userLanguage`` etag component, returning the user's preferred
     language
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -93,18 +92,20 @@ def __init__(self, published, request):
 
     def __call__(self):
         context = getContext(self.published)
-        portal_state = queryMultiAdapter((context, self.request), name=u'plone_portal_state')
+        portal_state = queryMultiAdapter(
+            (context, self.request), name=u'plone_portal_state')
         if portal_state is None:
             return None
 
         return portal_state.language()
 
+
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class LastModified(object):
     """The ``lastModified`` etag component, returning the last modification
     timestamp
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -116,12 +117,13 @@ def __call__(self):
             return None
         return str(time.mktime(lastModified.utctimetuple()))
 
+
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class CatalogCounter(object):
     """The ``catalogCounter`` etag component, returning a counter which is
     incremented each time the catalog is updated.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -135,12 +137,13 @@ def __call__(self):
 
         return str(tools.catalog().getCounter())
 
+
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class ObjectLocked(object):
     """The ``locked`` etag component, returning 1 or 0 depending on whether
     the object is locked.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -148,16 +151,18 @@ def __init__(self, published, request):
 
     def __call__(self):
         context = getContext(self.published)
-        context_state = queryMultiAdapter((context, self.request), name=u'plone_context_state')
+        context_state = queryMultiAdapter(
+            (context, self.request), name=u'plone_context_state')
         if context_state is None:
             return None
         return str(int(context_state.is_locked()))
 
+
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class Skin(object):
     """The ``skin`` etag component, returning the current skin name.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -176,13 +181,14 @@ def __call__(self):
 
         return portal_skins.getDefaultSkin()
 
+
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class ResourceRegistries(object):
     """The ``resourceRegistries`` etag component, returning the most recent
     last modified timestamp from all three Resource Registries.  This is
     useful for avoiding requests for expired resources from cached pages.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -207,14 +213,15 @@ def __call__(self):
         mtimes.sort()
         return str(mtimes[-1])
 
+
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class AnonymousOrRandom(object):
     """The ``anonymousOrRandom`` etag component. This is normally added
     implicitly by the ``anonOnly`` setting. It will return None for anonymous
     users, but a random number for logged-in ones. The idea is to force a
     re-fetch of a page every time for logged-in users.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
@@ -222,19 +229,21 @@ def __init__(self, published, request):
 
     def __call__(self):
         context = getContext(self.published)
-        portal_state = queryMultiAdapter((context, self.request), name=u'plone_portal_state')
+        portal_state = queryMultiAdapter(
+            (context, self.request), name=u'plone_portal_state')
         if portal_state is None:
             return None
         if portal_state.anonymous():
             return None
         return "%s%d" % (time.time(), random.randint(0, 1000))
 
+
 @implementer(IETagValue)
+@adapter(Interface, Interface)
 class CopyCookie(object):
     """The ``copy`` etag component, returning 1 or 0 depending on whether
     the '__cp' cookie is set.
     """
-    adapts(Interface, Interface)
 
     def __init__(self, published, request):
         self.published = published
diff --git a/plone/app/caching/operations/ramcache.py b/plone/app/caching/operations/ramcache.py
index 80beb87..9947af0 100644
--- a/plone/app/caching/operations/ramcache.py
+++ b/plone/app/caching/operations/ramcache.py
@@ -1,17 +1,17 @@
+# -*- coding: utf-8 -*-
+from plone.app.caching.interfaces import IRAMCached
+from plone.app.caching.operations.utils import storeResponseInRAMCache
+from plone.transformchain.interfaces import ITransform
+from zope.component import adapter
 from zope.interface import implementer
 from zope.interface import Interface
 
-from zope.component import adapts
-from plone.transformchain.interfaces import ITransform
-
-from plone.app.caching.interfaces import IRAMCached
-
-from plone.app.caching.operations.utils import storeResponseInRAMCache
 
 GLOBAL_KEY = 'plone.app.caching.operations.ramcache'
 
 
 @implementer(ITransform)
+@adapter(Interface, Interface)
 class Store(object):
     """Transform chain element which actually saves the page in RAM.
 
@@ -19,7 +19,6 @@ class Store(object):
     the ``cacheInRAM()`` helper method. Thus, the transform is only used if
     the caching operation requested it.
     """
-    adapts(Interface, Interface)
 
     order = 90000
 
@@ -30,20 +29,20 @@ def __init__(self, published, request):
     def transformUnicode(self, result, encoding):
         if self.responseIsSuccess() and IRAMCached.providedBy(self.request):
             storeResponseInRAMCache(self.request, self.request.response,
-                    result.encode(encoding))
+                                    result.encode(encoding))
         return None
 
     def transformBytes(self, result, encoding):
         if self.responseIsSuccess() and IRAMCached.providedBy(self.request):
             storeResponseInRAMCache(self.request, self.request.response,
-                    result)
+                                    result)
         return None
 
     def transformIterable(self, result, encoding):
         if self.responseIsSuccess() and IRAMCached.providedBy(self.request):
             result = ''.join(result)
             storeResponseInRAMCache(self.request, self.request.response,
-                result)
+                                    result)
             # as we have iterated the iterable, we must return a new one
             return iter(result)
         return None
diff --git a/plone/app/caching/operations/utils.py b/plone/app/caching/operations/utils.py
index 686000f..e7bc0b1 100644
--- a/plone/app/caching/operations/utils.py
+++ b/plone/app/caching/operations/utils.py
@@ -1,30 +1,28 @@
-import re
-import time
-import datetime
-import logging
-import dateutil.parser
-import dateutil.tz
-import wsgiref.handlers
-
+# -*- coding: utf-8 -*-
+from AccessControl.PermissionRole import rolesForPermissionOn
+from plone.app.caching.interfaces import IETagValue
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.interfaces import IRAMCached
+from plone.memoize.interfaces import ICacheChooser
+from plone.registry.interfaces import IRegistry
+from Products.CMFCore.interfaces import IContentish
+from Products.CMFCore.interfaces import ISiteRoot
 from thread import allocate_lock
-
-from zope.interface import alsoProvides
+from z3c.caching.interfaces import ILastModified
+from zope.annotation.interfaces import IAnnotations
+from zope.component import getUtility
 from zope.component import queryMultiAdapter
 from zope.component import queryUtility
-from zope.component import getUtility
-
-from zope.annotation.interfaces import IAnnotations
-from z3c.caching.interfaces import ILastModified
-from plone.registry.interfaces import IRegistry
-from plone.memoize.interfaces import ICacheChooser
+from zope.interface import alsoProvides
 
-from plone.app.caching.interfaces import IRAMCached
-from plone.app.caching.interfaces import IETagValue
-from plone.app.caching.interfaces import IPloneCacheSettings
+import datetime
+import dateutil.parser
+import dateutil.tz
+import logging
+import re
+import time
+import wsgiref.handlers
 
-from AccessControl.PermissionRole import rolesForPermissionOn
-from Products.CMFCore.interfaces import IContentish
-from Products.CMFCore.interfaces import ISiteRoot
 
 PAGE_CACHE_KEY = 'plone.app.caching.operations.ramcache'
 PAGE_CACHE_ANNOTATION_KEY = 'plone.app.caching.operations.ramcache.key'
@@ -49,7 +47,17 @@
 # as any additional keyword parameters required.
 #
 
-def setCacheHeaders(published, request, response, maxage=None, smaxage=None, etag=None, lastModified=None, vary=None):
+
+def setCacheHeaders(
+    published,
+    request,
+    response,
+    maxage=None,
+    smaxage=None,
+    etag=None,
+    lastModified=None,
+    vary=None
+):
     """General purpose dispatcher to set various cache headers
 
     ``maxage`` is the cache timeout value in seconds
@@ -60,20 +68,41 @@ def setCacheHeaders(published, request, response, maxage=None, smaxage=None, eta
     """
 
     if maxage:
-        cacheInBrowserAndProxy(published, request, response, maxage, smaxage=smaxage,
-            etag=etag, lastModified=lastModified, vary=vary)
+        cacheInBrowserAndProxy(
+            published,
+            request,
+            response,
+            maxage,
+            smaxage=smaxage,
+            etag=etag,
+            lastModified=lastModified,
+            vary=vary
+        )
 
     elif smaxage:
-        cacheInProxy(published, request, response, smaxage,
-            etag=etag, lastModified=lastModified, vary=vary)
+        cacheInProxy(
+            published,
+            request,
+            response,
+            smaxage,
+            etag=etag,
+            lastModified=lastModified,
+            vary=vary
+        )
 
     elif etag or lastModified:
-        cacheInBrowser(published, request, response,
-            etag=etag, lastModified=lastModified)
+        cacheInBrowser(
+            published,
+            request,
+            response,
+            etag=etag,
+            lastModified=lastModified
+        )
 
     else:
         doNotCache(published, request, response)
 
+
 def doNotCache(published, request, response):
     """Set response headers to ensure that the response is not cached by
     web browsers or caching proxies.
@@ -89,6 +118,7 @@ def doNotCache(published, request, response):
     response.setHeader('Expires', formatDateTime(getExpiration(0)))
     response.setHeader('Cache-Control', 'max-age=0, must-revalidate, private')
 
+
 def cacheInBrowser(published, request, response, etag=None, lastModified=None):
     """Set response headers to indicate that browsers should cache the
     response but expire immediately and revalidate the cache on every
@@ -102,7 +132,7 @@ def cacheInBrowser(published, request, response, etag=None, lastModified=None):
     """
 
     if etag is not None:
-        response.setHeader('ETag', '"%s"' %etag, literal=1)
+        response.setHeader('ETag', '"%s"' % etag, literal=1)
 
     if lastModified is not None:
         response.setHeader('Last-Modified', formatDateTime(lastModified))
@@ -112,7 +142,16 @@ def cacheInBrowser(published, request, response, etag=None, lastModified=None):
     response.setHeader('Expires', formatDateTime(getExpiration(0)))
     response.setHeader('Cache-Control', 'max-age=0, must-revalidate, private')
 
-def cacheInProxy(published, request, response, smaxage, etag=None, lastModified=None, vary=None):
+
+def cacheInProxy(
+    published,
+    request,
+    response,
+    smaxage,
+    etag=None,
+    lastModified=None,
+    vary=None
+):
     """Set headers to cache the response in a caching proxy.
 
     ``smaxage`` is the timeout value in seconds.
@@ -122,20 +161,34 @@ def cacheInProxy(published, request, response, smaxage, etag=None, lastModified=
     """
 
     if lastModified is not None:
-        response.setHeader('Last-Modified', formatDateTime(lastModified))
+        response.setHeader(
+            'Last-Modified',
+            formatDateTime(lastModified)
+        )
     elif response.getHeader('Last-Modified'):
         del response.headers['last-modified']
 
     if etag is not None:
-        response.setHeader('ETag', '"%s"' %etag, literal=1)
+        response.setHeader('ETag', '"%s"' % etag, literal=1)
 
     if vary is not None:
         response.setHeader('Vary', vary)
 
     response.setHeader('Expires', formatDateTime(getExpiration(0)))
-    response.setHeader('Cache-Control', 'max-age=0, s-maxage=%d, must-revalidate' % smaxage)
-
-def cacheInBrowserAndProxy(published, request, response, maxage, smaxage=None, etag=None, lastModified=None, vary=None):
+    response.setHeader(
+        'Cache-Control', 'max-age=0, s-maxage=%d, must-revalidate' % smaxage)
+
+
+def cacheInBrowserAndProxy(
+    published,
+    request,
+    response,
+    maxage,
+    smaxage=None,
+    etag=None,
+    lastModified=None,
+    vary=None
+):
     """Set headers to cache the response in the browser and caching proxy if
     applicable.
 
@@ -152,7 +205,7 @@ def cacheInBrowserAndProxy(published, request, response, maxage, smaxage=None, e
         del response.headers['last-modified']
 
     if etag is not None:
-        response.setHeader('ETag', '"%s"' %etag, literal=1)
+        response.setHeader('ETag', '"%s"' % etag, literal=1)
 
     if vary is not None:
         response.setHeader('Vary', vary)
@@ -160,13 +213,25 @@ def cacheInBrowserAndProxy(published, request, response, maxage, smaxage=None, e
     response.setHeader('Expires', formatDateTime(getExpiration(maxage)))
 
     if smaxage is not None:
-        maxage = '%s, s-maxage=%s' %(maxage, smaxage)
+        maxage = '%s, s-maxage=%s' % (maxage, smaxage)
 
-    # Substituting proxy-validate in place of must=revalidate here because of Safari bug
+    # Substituting proxy-validate in place of must=revalidate here because of
+    # Safari bug
     # https://bugs.webkit.org/show_bug.cgi?id=13128
-    response.setHeader('Cache-Control', 'max-age=%s, proxy-revalidate, public' % maxage)
-
-def cacheInRAM(published, request, response, etag=None, lastModified=None, annotationsKey=PAGE_CACHE_ANNOTATION_KEY):
+    response.setHeader(
+        'Cache-Control',
+        'max-age=%s, proxy-revalidate, public' % maxage
+    )
+
+
+def cacheInRAM(
+    published,
+    request,
+    response,
+    etag=None,
+    lastModified=None,
+    annotationsKey=PAGE_CACHE_ANNOTATION_KEY
+):
     """Set a flag indicating that the response for the given request
     should be cached in RAM.
 
@@ -194,7 +259,16 @@ def cacheInRAM(published, request, response, etag=None, lastModified=None, annot
     annotations[annotationsKey] = key
     alsoProvides(request, IRAMCached)
 
-def cachedResponse(published, request, response, status, headers, body, gzip=False):
+
+def cachedResponse(
+    published,
+    request,
+    response,
+    status,
+    headers,
+    body,
+    gzip=False
+):
     """Returned a cached page. Modifies the response (status and headers)
     and returns the cached body.
 
@@ -221,6 +295,7 @@ def cachedResponse(published, request, response, status, headers, body, gzip=Fal
 
     return body
 
+
 def notModified(published, request, response, etag=None, lastModified=None):
     """Return a ``304 NOT MODIFIED`` response. Modifies the response (status)
     and returns an empty body to indicate the request should be interrupted.
@@ -279,11 +354,8 @@ def cacheStop(request, rulename):
 
     ploneSettings = registry.forInterface(IPloneCacheSettings)
     variables = ploneSettings.cacheStopRequestVariables
+    return set(variables) & set(request.keys())
 
-    for variable in variables:
-        if request.has_key(variable):
-            return True
-    return False
 
 def isModified(request, etag=None, lastModified=None):
     """Return True or False depending on whether the published resource has
@@ -329,7 +401,7 @@ def isModified(request, etag=None, lastModified=None):
     latest headers. I interpret this as the spec rule that the
     etags do NOT match, and therefor we must not return a 304.
     """
-    if ifNoneMatch and etag==None:
+    if ifNoneMatch and etag is None:
         return True
 
     # Check the modification date
@@ -346,16 +418,16 @@ def isModified(request, etag=None, lastModified=None):
         # has content been modified since the if-modified-since time?
         try:
             # browser only knows the date to one second resolution
-            if (lastModified - ifModifiedSince) > datetime.timedelta(seconds=1):
+            delta_sec = datetime.timedelta(seconds=1)
+            if (lastModified - ifModifiedSince) > delta_sec:
                 return True
         except TypeError:
             logger.exception("Could not compare dates")
 
         # If we expected an ETag and the client didn't give us one, consider
         # that an error. This may be more conservative than the spec requires.
-        if etag is not None:
-            if not etagMatched:
-                return True
+        if etag is not None and not etagMatched:
+            return True
 
     # XXX Do we really want the default here to be false?
     return False
@@ -374,6 +446,7 @@ def visibleToRole(published, role, permission='View'):
 # Basic helper functions
 #
 
+
 def getContext(published, marker=(IContentish, ISiteRoot,)):
     """Given a published object, attempt to look up a context
 
@@ -393,9 +466,9 @@ def checkType(context):
         return False
 
     while (
-        published is not None
-        and not checkType(published)
-        and hasattr(published, '__parent__',)
+        published is not None and
+        not checkType(published) and
+        hasattr(published, '__parent__',)
     ):
         published = published.__parent__
 
@@ -404,6 +477,7 @@ def checkType(context):
 
     return published
 
+
 def formatDateTime(dt):
     """Format a Python datetime object as an RFC1123 date.
 
@@ -417,6 +491,7 @@ def formatDateTime(dt):
 
     return wsgiref.handlers.format_date_time(time.mktime(dt.timetuple()))
 
+
 def parseDateTime(str):
     """Return a Python datetime object from an an RFC1123 date.
 
@@ -439,6 +514,7 @@ def parseDateTime(str):
 
     return dt
 
+
 def getLastModifiedAnnotation(published, request, lastModified=True):
     """Try to get the last modified date from a request annotation if available,
     otherwise try to get it from published object
@@ -460,6 +536,7 @@ def getLastModifiedAnnotation(published, request, lastModified=True):
 
     return dt
 
+
 def getLastModified(published, lastModified=True):
     """Get a last modified date or None.
 
@@ -485,6 +562,7 @@ def getLastModified(published, lastModified=True):
 
     return dt
 
+
 def getExpiration(maxage):
     """Get an expiration date as a datetime in the local timezone.
 
@@ -498,6 +576,7 @@ def getExpiration(maxage):
     else:
         return now - datetime.timedelta(days=3650)
 
+
 def getETagAnnotation(published, request, keys=(), extraTokens=()):
     """Try to get the ETag from a request annotation if available,
     otherwise try to get it from published object
@@ -519,6 +598,7 @@ def getETagAnnotation(published, request, keys=(), extraTokens=()):
 
     return etag
 
+
 def getETag(published, request, keys=(), extraTokens=()):
     """Calculate an ETag.
 
@@ -538,9 +618,11 @@ def getETag(published, request, keys=(), extraTokens=()):
     tokens = []
     noTokens = True
     for key in keys:
-        component = queryMultiAdapter((published, request), IETagValue, name=key)
+        component = queryMultiAdapter(
+            (published, request), IETagValue, name=key)
         if component is None:
-            logger.warning("Could not find value adapter for ETag component %s", key)
+            logger.warning(
+                "Could not find value adapter for ETag component %s", key)
             tokens.append('')
         else:
             value = component()
@@ -563,6 +645,7 @@ def getETag(published, request, keys=(), extraTokens=()):
 
     return etag
 
+
 def parseETags(text, allowWeak=True, _result=None):
     """Parse a header value into a list of etags. Handles fishy quoting and
     other browser quirks.
@@ -588,13 +671,13 @@ def parseETags(text, allowWeak=True, _result=None):
         m = etagQuote.match(text)
         if m:
             # Match quoted etag (spec-observing client)
-            l     = len(m.group(1))
+            length = len(m.group(1))
             value = (m.group(2) or '') + (m.group(3) or '')
         else:
             # Match non-quoted etag (lazy client)
             m = etagNoQuote.match(text)
             if m:
-                l     = len(m.group(1))
+                length = len(m.group(1))
                 value = (m.group(2) or '') + (m.group(3) or '')
             else:
                 return result
@@ -602,19 +685,19 @@ def parseETags(text, allowWeak=True, _result=None):
         parseETagLock.release()
 
     if value:
-
         if value.startswith('W/'):
             if allowWeak:
                 result.append(value[2:])
         else:
             result.append(value)
 
-    return parseETags(text[l:], allowWeak=allowWeak, _result=result)
+    return parseETags(text[length:], allowWeak=allowWeak, _result=result)
 
 #
 # RAM cache management
 #
 
+
 def getRAMCache(globalKey=PAGE_CACHE_KEY):
     """Get a RAM cache instance for the given key. The return value is ``None``
     if no RAM cache can be found, or a mapping object supporting at least
@@ -631,6 +714,7 @@ def getRAMCache(globalKey=PAGE_CACHE_KEY):
 
     return chooser(globalKey)
 
+
 def getRAMCacheKey(request, etag=None, lastModified=None):
     """Calculate the cache key for pages cached in RAM.
 
@@ -649,14 +733,21 @@ def getRAMCacheKey(request, etag=None, lastModified=None):
         request.get('SERVER_URL', ''),
         request.get('PATH_INFO', ''),
         request.get('QUERY_STRING', ''),
-        )
+    )
     if etag:
         resourceKey = '|' + etag + '||' + resourceKey
     if lastModified:
         resourceKey = '|' + str(lastModified) + '||' + resourceKey
     return resourceKey
 
-def storeResponseInRAMCache(request, response, result, globalKey=PAGE_CACHE_KEY, annotationsKey=PAGE_CACHE_ANNOTATION_KEY):
+
+def storeResponseInRAMCache(
+    request,
+    response,
+    result,
+    globalKey=PAGE_CACHE_KEY,
+    annotationsKey=PAGE_CACHE_ANNOTATION_KEY
+):
     """Store the given response in the RAM cache.
 
     ``result`` should be the response body as a string.
@@ -683,9 +774,9 @@ def storeResponseInRAMCache(request, response, result, globalKey=PAGE_CACHE_KEY,
 
     """
     Resource registries have no body. If we put them in the cache the content
-    type headers will indicate length and the body will be '', causing the browser
-    to just spin. Furthermore, I doubt we ever want to cache an empty result:
-    it's an indication that something went wrong somewhere.
+    type headers will indicate length and the body will be '', causing the
+    browser to just spin. Furthermore, I doubt we ever want to cache an empty
+    result: it's an indication that something went wrong somewhere.
 
     This does mean that any resources will not be cached in ram. There is
     potentially another fix but I doubt long term it's ever the right thing to
@@ -700,7 +791,14 @@ def storeResponseInRAMCache(request, response, result, globalKey=PAGE_CACHE_KEY,
 
     cache[key] = (status, headers, result, gzipFlag)
 
-def fetchFromRAMCache(request, etag=None, lastModified=None, globalKey=PAGE_CACHE_KEY, default=None):
+
+def fetchFromRAMCache(
+    request,
+    etag=None,
+    lastModified=None,
+    globalKey=PAGE_CACHE_KEY,
+    default=None
+):
     """Return a page cached in RAM, or None if it cannot be found.
 
     The return value is a tuple as stored by ``storeResponseInRAMCache()``.
diff --git a/plone/app/caching/purge.py b/plone/app/caching/purge.py
index 37e7542..3b87cec 100644
--- a/plone/app/caching/purge.py
+++ b/plone/app/caching/purge.py
@@ -1,37 +1,37 @@
-from zope.interface import implementer
-from zope.component import adapts, adapter, getAdapters
-from zope.event import notify
-from zope.globalrequest import getRequest
-
-from zope.lifecycleevent.interfaces import IObjectModifiedEvent
-from zope.lifecycleevent.interfaces import IObjectMovedEvent
-
-from z3c.caching.purge import Purge
-from z3c.caching.interfaces import IPurgePaths
-
+# -*- coding: utf-8 -*-
+from Acquisition import aq_parent
+from plone.app.caching.utils import getObjectDefaultView
+from plone.app.caching.utils import isPurged
 from plone.cachepurging.interfaces import IPurgePathRewriter
-
-from Products.CMFCore.interfaces import IDiscussionResponse
+from plone.memoize.instance import memoize
 from Products.CMFCore.interfaces import IContentish
+from Products.CMFCore.interfaces import IDiscussionResponse
 from Products.CMFCore.interfaces import IDynamicType
 from Products.CMFCore.utils import getToolByName
+from z3c.caching.interfaces import IPurgePaths
+from z3c.caching.purge import Purge
+from zope.component import adapter
+from zope.component import getAdapters
+from zope.event import notify
+from zope.globalrequest import getRequest
+from zope.interface import implementer
+from zope.lifecycleevent.interfaces import IObjectModifiedEvent
+from zope.lifecycleevent.interfaces import IObjectMovedEvent
 
-from plone.app.caching.utils import isPurged
-from plone.app.caching.utils import getObjectDefaultView
-
-from plone.memoize.instance import memoize
-
-from Acquisition import aq_parent
 
 try:
     from plone.app.blob.interfaces import IBlobField
     from Products.Archetypes.interfaces import IBaseObject
-    from Products.Archetypes.interfaces import IFileField, IImageField, ITextField
+    from Products.Archetypes.interfaces import IFileField
+    from Products.Archetypes.interfaces import IImageField
+    from Products.Archetypes.interfaces import ITextField
     HAVE_AT = True
 except ImportError:
     HAVE_AT = False
 
+
 @implementer(IPurgePaths)
+@adapter(IDynamicType)
 class ContentPurgePaths(object):
     """Paths to purge for content items
 
@@ -46,7 +46,6 @@ class ContentPurgePaths(object):
     * ${parent_path}
     * ${parent_path}/
     """
-    adapts(IDynamicType)
 
     def __init__(self, context):
         self.context = context
@@ -62,38 +61,42 @@ def getRelativePaths(self):
                 paths.append(path)
 
         parent = aq_parent(self.context)
-        if parent is not None:
-            parentDefaultView = getObjectDefaultView(parent)
-            if parentDefaultView == self.context.getId():
-                parentPrefix = '/' + parent.virtual_url_path()
-                paths.append(parentPrefix)
-                if parentPrefix == '/':
-                    # special handling for site root since parentPrefix
-                    # does not make sense in that case.
-                    # Additionally, empty site roots were not getting
-                    # purge paths /VirtualHostBase/http/site.com:80/site1/VirtualHostRoot/_vh_site1/
-                    # was getting generated but not
-                    # /VirtualHostBase/http/site.com:80/site1/VirtualHostRoot/_vh_site1
-                    # which would translate to http://site.come/ getting invalidated
-                    # but not http://site.come
-                    paths.append('')
-                    paths.append('/view')
-                else:
-                    paths.append(parentPrefix + '/')
-                    paths.append(parentPrefix + '/view')
+        if parent is None:
+            return paths
+
+        parentDefaultView = getObjectDefaultView(parent)
+        if parentDefaultView == self.context.getId():
+            parentPrefix = '/' + parent.virtual_url_path()
+            paths.append(parentPrefix)
+            if parentPrefix == '/':
+                # special handling for site root since parentPrefix
+                # does not make sense in that case.
+                # Additionally, empty site roots were not getting
+                # purge paths
+                # /VirtualHostBase/http/site.com:80/site1/VirtualHostRoot/_vh_site1/
+                # was getting generated but not
+                # /VirtualHostBase/http/site.com:80/site1/VirtualHostRoot/_vh_site1
+                # which would translate to http://site.come/ getting
+                # invalidated but not http://site.come
+                paths.append('')
+                paths.append('/view')
+            else:
+                paths.append(parentPrefix + '/')
+                paths.append(parentPrefix + '/view')
 
         return paths
 
     def getAbsolutePaths(self):
         return []
 
+
 @implementer(IPurgePaths)
+@adapter(IDiscussionResponse)
 class DiscussionItemPurgePaths(object):
     """Paths to purge for Discussion Item.
 
     Looks up paths for the ultimate parent.
     """
-    adapts(IDiscussionResponse)
 
     def __init__(self, context):
         self.context = context
@@ -116,7 +119,8 @@ def getRelativePaths(self):
                     if rewriter is None:
                         yield relativePath
                     else:
-                        rewrittenPaths = rewriter(relativePath) or []  # None -> []
+                        rewrittenPaths = rewriter(
+                            relativePath) or []  # None -> []
                         for rewrittenPath in rewrittenPaths:
                             yield rewrittenPath
 
@@ -149,13 +153,14 @@ def _getRoot(self):
 
         return thread[0]
 
+
 if HAVE_AT:
 
     @implementer(IPurgePaths)
+    @adapter(IBaseObject)
     class ObjectFieldPurgePaths(object):
         """Paths to purge for Archetypes object fields
         """
-        adapts(IBaseObject)
 
         def __init__(self, context):
             self.context = context
@@ -165,15 +170,16 @@ def getRelativePaths(self):
             schema = self.context.Schema()
 
             def fieldFilter(field):
-                return ((IBlobField.providedBy(field) or
+                return (
+                    (
+                        IBlobField.providedBy(field) or
                         IFileField.providedBy(field) or
-                        IImageField.providedBy(field))
-                        and not ITextField.providedBy(field))
-
+                        IImageField.providedBy(field)
+                    ) and
+                    not ITextField.providedBy(field)
+                )
             seenDownloads = False
-
             for field in schema.filterFields(fieldFilter):
-
                 if not seenDownloads:
                     yield prefix + '/download'
                     yield prefix + '/at_download'
@@ -194,11 +200,13 @@ def getAbsolutePaths(self):
 # Event redispatch for content items - we check the list of content items
 # instead of the marker interface
 
+
 @adapter(IContentish, IObjectModifiedEvent)
 def purgeOnModified(object, event):
     if isPurged(object):
         notify(Purge(object))
 
+
 @adapter(IContentish, IObjectMovedEvent)
 def purgeOnMovedOrRemoved(object, event):
     # Don't purge when added
diff --git a/plone/app/caching/setuphandlers.py b/plone/app/caching/setuphandlers.py
index 3ecc843..5dd25d7 100644
--- a/plone/app/caching/setuphandlers.py
+++ b/plone/app/caching/setuphandlers.py
@@ -1,5 +1,7 @@
+# -*- coding: utf-8 -*-
 from Products.CMFCore.utils import getToolByName
 
+
 def enableExplicitMode():
     """ZCML startup hook to put the ruleset registry into explict mode.
     This means we require people to declare ruleset types before using them.
@@ -9,6 +11,7 @@ def enableExplicitMode():
     if registry is not None:
         registry.explicit = True
 
+
 def importVarious(context):
 
     if not context.readDataFile('plone.app.caching.txt'):
diff --git a/plone/app/caching/testing.py b/plone/app/caching/testing.py
index a3968be..1c76fa6 100644
--- a/plone/app/caching/testing.py
+++ b/plone/app/caching/testing.py
@@ -1,29 +1,18 @@
+# -*- coding: utf-8 -*-
+from hashlib import sha1 as sha
 from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE
-from plone.app.testing import PloneSandboxLayer
-from plone.app.testing import IntegrationTesting
-from plone.app.testing import FunctionalTesting
 from plone.app.testing import applyProfile
-
-from zope.interface import implementer
-
+from plone.app.testing import FunctionalTesting
+from plone.app.testing import IntegrationTesting
+from plone.app.testing import PloneSandboxLayer
+from plone.cachepurging.interfaces import IPurger
+from plone.protect.authenticator import _getKeyring
 from zope.component import getUtility
 from zope.component import provideUtility
-
 from zope.configuration import xmlconfig
-
-from plone.cachepurging.interfaces import IPurger
-
-try:
-    from plone.protect.authenticator import _getKeyring
-except ImportError:
-    # so we can run tests on plone 4.3
-    from plone.keyring.interfaces import IKeyManager
-    def _getKeyring(username):
-        manager = getUtility(IKeyManager)
-        return manager['_system']
+from zope.interface import implementer
 
 import hmac
-from hashlib import sha1 as sha
 
 
 @implementer(IPurger)
@@ -57,7 +46,8 @@ def setUpZope(self, app, configurationContext):
 
         # Load ZCML
         import plone.app.caching
-        xmlconfig.file('configure.zcml', plone.app.caching, context=configurationContext)
+        xmlconfig.file('configure.zcml', plone.app.caching,
+                       context=configurationContext)
 
         # Install fake purger
         self.oldPurger = getUtility(IPurger)
@@ -66,7 +56,8 @@ def setUpZope(self, app, configurationContext):
     def setUpPloneSite(self, portal):
         applyProfile(portal, 'plone.app.caching:default')
 
-        portal['portal_workflow'].setDefaultChain('simple_publication_workflow')
+        portal['portal_workflow'].setDefaultChain(
+            'simple_publication_workflow')
 
     def tearDownZope(self, app):
         # Store old purger
@@ -75,9 +66,13 @@ def tearDownZope(self, app):
 
 PLONE_APP_CACHING_FIXTURE = PloneAppCaching()
 PLONE_APP_CACHING_INTEGRATION_TESTING = IntegrationTesting(
-    bases=(PLONE_APP_CACHING_FIXTURE,), name="PloneAppCaching:Integration")
+    bases=(PLONE_APP_CACHING_FIXTURE,),
+    name='PloneAppCaching:Integration'
+)
 PLONE_APP_CACHING_FUNCTIONAL_TESTING = FunctionalTesting(
-    bases=(PLONE_APP_CACHING_FIXTURE,), name="PloneAppCaching:Functional")
+    bases=(PLONE_APP_CACHING_FIXTURE,),
+    name='PloneAppCaching:Functional'
+)
 
 
 def getToken(username):
diff --git a/plone/app/caching/tests/test_etags.py b/plone/app/caching/tests/test_etags.py
index 835e9d8..7de8085 100644
--- a/plone/app/caching/tests/test_etags.py
+++ b/plone/app/caching/tests/test_etags.py
@@ -1,41 +1,34 @@
-import unittest2 as unittest
-from plone.testing.zca import UNIT_TESTING
-
-import time
+# -*- coding: utf-8 -*-
+from Acquisition import Explicit
 from datetime import datetime
 from dateutil.tz import tzlocal
+from plone.registry.fieldfactory import persistentFieldAdapter
+from plone.testing.zca import UNIT_TESTING
+from Products.CMFCore.interfaces import IContentish
 from StringIO import StringIO
-
+from z3c.caching.interfaces import ILastModified
+from zope.component import adapter
+from zope.component import provideAdapter
 from zope.interface import implementer
 from zope.interface import Interface
-
-from zope.component import getUtility
-from zope.component import provideAdapter
-from zope.component import provideUtility
-from zope.component import adapts
-
-from z3c.caching.interfaces import ILastModified
-
-from plone.registry.interfaces import IRegistry
-from plone.registry.fieldfactory import persistentFieldAdapter
-from plone.registry import Registry
-
-from plone.app.caching.interfaces import IPloneCacheSettings
-
-from Acquisition import Explicit
 from ZPublisher.HTTPRequest import HTTPRequest
 from ZPublisher.HTTPResponse import HTTPResponse
-from Products.CMFCore.interfaces import IContentish
+
+import time
+import unittest2 as unittest
+
 
 @implementer(IContentish)
 class DummyContext(Explicit):
     pass
 
+
 class DummyPublished(object):
 
     def __init__(self, parent=None):
         self.__parent__ = parent
 
+
 class TestETags(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -49,8 +42,8 @@ def test_UserID_anonymous(self):
         from plone.app.caching.operations.etags import UserID
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyPortalState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -78,8 +71,8 @@ def getId(self):
                 return 'bob'
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyPortalState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -98,15 +91,14 @@ def member(self):
 
         self.assertEqual('bob', etag())
 
-
     # Roles
 
     def test_Roles_anonymous(self):
         from plone.app.caching.operations.etags import Roles
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyPortalState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -137,8 +129,8 @@ def getRolesInContext(self, context):
                 return ['Member', 'Manager']
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyPortalState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -160,7 +152,6 @@ def member(self):
 
         self.assertEqual('Manager;Member', etag())
 
-
     # Language
 
     def test_Language_no_header(self):
@@ -195,8 +186,8 @@ def test_UserLanguage(self):
         from plone.app.caching.operations.etags import UserLanguage
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyPortalState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -233,8 +224,8 @@ def test_LastModified_None(self):
         from plone.app.caching.operations.etags import LastModified
 
         @implementer(ILastModified)
+        @adapter(DummyPublished)
         class DummyLastModified(object):
-            adapts(DummyPublished)
 
             def __init__(self, context):
                 self.context = context
@@ -260,8 +251,8 @@ def test_LastModified(self):
         utcStamp = time.mktime(mod.utctimetuple())
 
         @implementer(ILastModified)
+        @adapter(DummyPublished)
         class DummyLastModified(object):
-            adapts(DummyPublished)
 
             def __init__(self, context):
                 self.context = context
@@ -290,8 +281,8 @@ def getCounter(self):
                 return 10
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyTools(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -310,15 +301,14 @@ def catalog(self):
 
         self.assertEqual('10', etag())
 
-
     # ObjectLocked
 
     def test_ObjectLocked_true(self):
         from plone.app.caching.operations.etags import ObjectLocked
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyContextState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -341,8 +331,8 @@ def test_ObjectLocked_false(self):
         from plone.app.caching.operations.etags import ObjectLocked
 
         @implementer(Interface)
+        @adapter(DummyContext, Interface)
         class DummyContextState(object):
-            adapts(DummyContext, Interface)
 
             def __init__(self, context, request):
                 pass
@@ -361,7 +351,6 @@ def is_locked(self):
 
         self.assertEqual('0', etag())
 
-
     # Skin
 
     def test_Skin_request_variable(self):
diff --git a/plone/app/caching/tests/test_integration.py b/plone/app/caching/tests/test_integration.py
index 38c8830..77cc985 100644
--- a/plone/app/caching/tests/test_integration.py
+++ b/plone/app/caching/tests/test_integration.py
@@ -1,29 +1,25 @@
-import unittest2 as unittest
-
-from plone.testing.z2 import Browser
-
-from plone.app.testing import TEST_USER_ID, TEST_USER_NAME, TEST_USER_PASSWORD
+# -*- coding: utf-8 -*-
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.testing import getToken
+from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.testing import applyProfile
 from plone.app.testing import setRoles
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
 from plone.app.textfield.value import RichTextValue
-
-import pkg_resources
-
-import OFS.Image
-
-from zope.component import getUtility
-
-from zope.globalrequest import setRequest
-
-from plone.namedfile.file import NamedImage
-from plone.registry.interfaces import IRegistry
-from plone.caching.interfaces import ICacheSettings
 from plone.cachepurging.interfaces import ICachePurgingSettings
 from plone.cachepurging.interfaces import IPurger
-from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.caching.interfaces import ICacheSettings
+from plone.namedfile.file import NamedImage
+from plone.registry.interfaces import IRegistry
+from plone.testing.z2 import Browser
+from zope.component import getUtility
+from zope.globalrequest import setRequest
 
-from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
-from plone.app.caching.testing import getToken
+import OFS.Image
+import pkg_resources
+import unittest2 as unittest
 
 
 TEST_IMAGE = pkg_resources.resource_filename(
@@ -201,7 +197,8 @@ def test_auto_purge_content_types(self):
 
         browser.open(editURL)
 
-        browser.getControl(name='form.widgets.IDublinCore.title').value = u"Title 1"
+        browser.getControl(
+            name='form.widgets.IDublinCore.title').value = u"Title 1"
         browser.getControl('Save').click()
 
         self.assertEqual([], self.purger._sync)
@@ -216,7 +213,8 @@ def test_auto_purge_content_types(self):
         transaction.commit()
 
         browser.open(editURL)
-        browser.getControl(name='form.widgets.IDublinCore.title').value = u"Title 2"
+        browser.getControl(
+            name='form.widgets.IDublinCore.title').value = u"Title 2"
         browser.getControl('Save').click()
 
         self.assertEqual([], self.purger._sync)
@@ -231,7 +229,8 @@ def test_auto_purge_content_types(self):
         transaction.commit()
 
         browser.open(editURL)
-        browser.getControl(name='form.widgets.IDublinCore.title').value = u"Title 3"
+        browser.getControl(
+            name='form.widgets.IDublinCore.title').value = u"Title 3"
         browser.getControl('Save').click()
 
         self.assertEqual([], self.purger._sync)
@@ -246,7 +245,8 @@ def test_auto_purge_content_types(self):
         transaction.commit()
 
         browser.open(editURL)
-        browser.getControl(name='form.widgets.IDublinCore.title').value = u"Title 4"
+        browser.getControl(
+            name='form.widgets.IDublinCore.title').value = u"Title 4"
         browser.getControl('Save').click()
 
         self.assertEqual([], self.purger._sync)
diff --git a/plone/app/caching/tests/test_lastmodified.py b/plone/app/caching/tests/test_lastmodified.py
index 7bc8970..975566a 100644
--- a/plone/app/caching/tests/test_lastmodified.py
+++ b/plone/app/caching/tests/test_lastmodified.py
@@ -1,19 +1,17 @@
-import unittest2 as unittest
+# -*- coding: utf-8 -*-
+from dateutil.tz import tzlocal
+from persistent.TimeStamp import TimeStamp
+from plone.app.caching import lastmodified
 from plone.testing.zca import UNIT_TESTING
+from z3c.caching.interfaces import ILastModified
+from zope.component import provideAdapter
 
-import os
-import time
 import datetime
 import DateTime
+import os
+import time
+import unittest2 as unittest
 
-from dateutil.tz import tzlocal
-
-from persistent.TimeStamp import TimeStamp
-
-from zope.component import provideAdapter
-from z3c.caching.interfaces import ILastModified
-
-from plone.app.caching import lastmodified
 
 class FauxDataManager(object):
 
@@ -26,6 +24,7 @@ def oldstate(self, obj, tid):
     def register(self, object):
         pass
 
+
 class TestLastModified(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -54,8 +53,7 @@ class Dummy(Persistent, Explicit):
         zpt = ZopePageTemplate('zpt').__of__(d)
         self.assertEqual(None, ILastModified(zpt)())
 
-
-        timestamp = 987654321.0 # time stamp (in UTC)
+        timestamp = 987654321.0  # time stamp (in UTC)
         # equivalent in local time, which is what the last-modified adapter
         # should return
         mod = datetime.datetime.fromtimestamp(timestamp, tzlocal())
@@ -78,8 +76,7 @@ class Dummy(Persistent, Explicit):
         zpt = FSPageTemplate('zpt', __file__).__of__(d)
         self.assertEqual(None, ILastModified(zpt)())
 
-
-        timestamp = 987654321.0 # time stamp (in UTC)
+        timestamp = 987654321.0  # time stamp (in UTC)
         # equivalent in local time, which is what the last-modified adapter
         # should return
         mod = datetime.datetime.fromtimestamp(timestamp, tzlocal())
@@ -93,8 +90,8 @@ def test_OFSFileLastModified_File(self):
         dummy = File('dummy', 'Dummy', 'data')
         self.assertEqual(None, ILastModified(dummy)())
 
-        timestamp = 987654321.0 # time stamp (in UTC)
-        ts = TimeStamp(*time.gmtime(timestamp)[:6]) # corresponding TimeStamp
+        timestamp = 987654321.0  # time stamp (in UTC)
+        ts = TimeStamp(*time.gmtime(timestamp)[:6])  # corresponding TimeStamp
 
         # equivalent in local time, which is what the last-modified adapter
         # should return
@@ -110,8 +107,8 @@ def test_OFSFileLastModified_Image(self):
         dummy = Image('dummy', 'Dummy', 'data')
         self.assertEqual(None, ILastModified(dummy)())
 
-        timestamp = 987654321.0 # time stamp (in UTC)
-        ts = TimeStamp(*time.gmtime(timestamp)[:6]) # corresponding TimeStamp
+        timestamp = 987654321.0  # time stamp (in UTC)
+        ts = TimeStamp(*time.gmtime(timestamp)[:6])  # corresponding TimeStamp
 
         # equivalent in local time, which is what the last-modified adapter
         # should return
@@ -129,19 +126,22 @@ def test_FSObjectLastModified_FSFile(self):
         modtime = float(os.path.getmtime(__file__))
         mod = datetime.datetime.fromtimestamp(modtime, tzlocal())
 
-        format = "%y%m%d%H%M%s" # see note in test_FSObjectLastModified_FSImage
-        self.assertEqual(mod.strftime(format), ILastModified(dummy)().strftime(format))
+        format = "%y%m%d%H%M%s"  # see note in test_FSObjectLastModified_FSImage
+        self.assertEqual(mod.strftime(format),
+                         ILastModified(dummy)().strftime(format))
 
     def test_FSObjectLastModified_FSImage(self):
         from Products.CMFCore.FSImage import FSImage
 
-        dummy = FSImage('dummy', __file__) # not really an image, but anyway
+        dummy = FSImage('dummy', __file__)  # not really an image, but anyway
         modtime = float(os.path.getmtime(__file__))
         mod = datetime.datetime.fromtimestamp(modtime, tzlocal())
         # different filesystems seem to handle datetime differently. some use microseconds
-        # and others don't so to make jenkins happy lets omit the microseconds factor
+        # and others don't so to make jenkins happy lets omit the microseconds
+        # factor
         format = "%y%m%d%H%M%s"
-        self.assertEqual(mod.strftime(format), ILastModified(dummy)().strftime(format))
+        self.assertEqual(mod.strftime(format),
+                         ILastModified(dummy)().strftime(format))
 
     def test_CatalogableDublinCoreLastModified(self):
         from Products.CMFCore.interfaces import ICatalogableDublinCore
@@ -153,7 +153,8 @@ class Dummy(object):
             _mod = None
 
             def modified(self):
-                if self._mod is not None: return DateTime.DateTime(self._mod)
+                if self._mod is not None:
+                    return DateTime.DateTime(self._mod)
                 return None
 
         d = Dummy()
diff --git a/plone/app/caching/tests/test_lookup.py b/plone/app/caching/tests/test_lookup.py
index f999f22..de0d1f6 100644
--- a/plone/app/caching/tests/test_lookup.py
+++ b/plone/app/caching/tests/test_lookup.py
@@ -1,26 +1,23 @@
-import unittest2 as unittest
+# -*- coding: utf-8 -*-
+from Acquisition import Explicit
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.lookup import ContentItemLookup
 from plone.caching.testing import IMPLICIT_RULESET_REGISTRY_UNIT_TESTING
-
-from z3c.caching.registry import RulesetRegistry
-import z3c.caching.registry
-
-from zope.component import provideUtility, provideAdapter, getUtility
-from zope.interface import implementer
-
-from plone.registry.interfaces import IRegistry
-
 from plone.registry import Registry
 from plone.registry.fieldfactory import persistentFieldAdapter
-
-from plone.app.caching.interfaces import IPloneCacheSettings
-
-from plone.app.caching.lookup import ContentItemLookup
-
-from Acquisition import Explicit
-from Products.PageTemplates.ZopePageTemplate import ZopePageTemplate
+from plone.registry.interfaces import IRegistry
 from Products.CMFCore.interfaces import IDynamicType
 from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
 from Products.Five.browser import BrowserView
+from Products.PageTemplates.ZopePageTemplate import ZopePageTemplate
+from zope.component import getUtility
+from zope.component import provideAdapter
+from zope.component import provideUtility
+from zope.interface import implementer
+
+import unittest2 as unittest
+import z3c.caching.registry
+
 
 @implementer(IBrowserDefault, IDynamicType)
 class DummyContent(Explicit):
@@ -32,16 +29,18 @@ def __init__(self, portal_type='testtype', defaultView='defaultView'):
     def defaultView(self):
         return self._defaultView
 
+
 class DummyNotContent(Explicit):
     pass
 
+
 class DummyFTI(object):
 
     def __init__(self, portal_type, viewAction=''):
         self.id = portal_type
         self._actions = {
-                'object/view': {'url': viewAction},
-            }
+            'object/view': {'url': viewAction},
+        }
 
     def getActionInfo(self, name):
         return self._actions[name]
@@ -53,6 +52,7 @@ def queryMethodID(self, id, default=None, context=None):
             return '@@defaultView'
         return default
 
+
 @implementer(IDynamicType)
 class DummyNotBrowserDefault(Explicit):
 
@@ -63,19 +63,24 @@ def __init__(self, portal_type='testtype', viewAction=''):
     def getTypeInfo(self):
         return DummyFTI(self.portal_type, self._viewAction)
 
+
 class DummyResponse(dict):
 
     def addHeader(self, name, value):
         self.setdefault(name, []).append(value)
 
+
 class DummyRequest(dict):
+
     def __init__(self, published, response):
         self['PUBLISHED'] = published
         self.response = response
 
+
 class DummyView(BrowserView):
     __name__ = 'defaultView'
 
+
 class TestContentItemLookup(unittest.TestCase):
 
     layer = IMPLICIT_RULESET_REGISTRY_UNIT_TESTING
@@ -220,7 +225,8 @@ def test_parent_not_IBrowserDefault_methodid(self):
         ploneSettings.templateRulesetMapping = {}
         ploneSettings.contentTypeRulesetMapping = {'testtype': 'rule1'}
 
-        published = ZopePageTemplate('defaultView').__of__(DummyNotBrowserDefault('testtype', 'string:${object_url}/view'))
+        published = ZopePageTemplate('defaultView').__of__(
+            DummyNotBrowserDefault('testtype', 'string:${object_url}/view'))
         request = DummyRequest(published, DummyResponse())
         self.assertEqual('rule1', ContentItemLookup(published, request)())
 
@@ -233,7 +239,8 @@ def test_parent_not_IBrowserDefault_default_method(self):
         ploneSettings.templateRulesetMapping = {}
         ploneSettings.contentTypeRulesetMapping = {'testtype': 'rule1'}
 
-        published = ZopePageTemplate('defaultView').__of__(DummyNotBrowserDefault('testtype', 'string:${object_url}/'))
+        published = ZopePageTemplate('defaultView').__of__(
+            DummyNotBrowserDefault('testtype', 'string:${object_url}/'))
         request = DummyRequest(published, DummyResponse())
         self.assertEqual('rule1', ContentItemLookup(published, request)())
 
@@ -246,7 +253,8 @@ def test_parent_not_IBrowserDefault_actiononly(self):
         ploneSettings.templateRulesetMapping = {}
         ploneSettings.contentTypeRulesetMapping = {'testtype': 'rule1'}
 
-        published = ZopePageTemplate('defaultView').__of__(DummyNotBrowserDefault('testtype', 'string:${object_url}/defaultView'))
+        published = ZopePageTemplate('defaultView').__of__(
+            DummyNotBrowserDefault('testtype', 'string:${object_url}/defaultView'))
         request = DummyRequest(published, DummyResponse())
 
         self.assertEqual('rule1', ContentItemLookup(published, request)())
diff --git a/plone/app/caching/tests/test_operation_default.py b/plone/app/caching/tests/test_operation_default.py
index b2fa70b..f2fe0ca 100644
--- a/plone/app/caching/tests/test_operation_default.py
+++ b/plone/app/caching/tests/test_operation_default.py
@@ -1,19 +1,17 @@
-import unittest2 as unittest
-
-from plone.testing.z2 import Browser
-
-from plone.app.testing import TEST_USER_ID, TEST_USER_NAME, TEST_USER_PASSWORD
+# -*- coding: utf-8 -*-
+from plone.app.caching.testing import getToken
+from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.testing import setRoles
-
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
+from plone.caching.interfaces import ICacheSettings
+from plone.registry.interfaces import IRegistry
+from plone.testing.z2 import Browser
 from zope.component import getUtility
-
 from zope.globalrequest import setRequest
 
-from plone.registry.interfaces import IRegistry
-from plone.caching.interfaces import ICacheSettings
-
-from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
-from plone.app.caching.testing import getToken
+import unittest2 as unittest
 
 
 class TestOperationDefault(unittest.TestCase):
@@ -68,7 +66,8 @@ def test_last_modified_no_etags(self):
         self.assertFalse('Etag' in browser.headers)
 
         # now set up etags and make sure that a header is added
-        self.registry['plone.app.caching.weakCaching.etags'] = ('lastModified',)
+        self.registry['plone.app.caching.weakCaching.etags'] = (
+            'lastModified',)
         import transaction
         transaction.commit()
         browser.open("%s/dummy-content/edit?_authenticator=%s" % (
diff --git a/plone/app/caching/tests/test_operation_parameters.py b/plone/app/caching/tests/test_operation_parameters.py
index a1b88ae..c49f2e2 100644
--- a/plone/app/caching/tests/test_operation_parameters.py
+++ b/plone/app/caching/tests/test_operation_parameters.py
@@ -1,21 +1,19 @@
-import unittest2 as unittest
-
-import transaction;
-
-from plone.testing.z2 import Browser
-
-from plone.app.testing import TEST_USER_ID, TEST_USER_NAME, TEST_USER_PASSWORD
+# -*- coding: utf-8 -*-
+from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.testing import setRoles
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
 from plone.app.textfield.value import RichTextValue
-
+from plone.caching.interfaces import ICacheSettings
+from plone.registry.interfaces import IRegistry
+from plone.testing.z2 import Browser
 from zope.component import getUtility
-
 from zope.globalrequest import setRequest
 
-from plone.registry.interfaces import IRegistry
-from plone.caching.interfaces import ICacheSettings
+import transaction
+import unittest2 as unittest
 
-from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 
 class TestOperationParameters(unittest.TestCase):
     """This test aims to test the effect of changing various caching operation
@@ -60,25 +58,31 @@ def test_anon_only(self):
 
         # Publish the folder and page
         self.portal.portal_workflow.doActionFor(self.portal['f1'], 'publish')
-        self.portal.portal_workflow.doActionFor(self.portal['f1']['d1'], 'publish')
+        self.portal.portal_workflow.doActionFor(
+            self.portal['f1']['d1'], 'publish')
 
         # Set pages to have weak caching and test anonymous
 
-        self.cacheSettings.operationMapping = {'plone.content.itemView': 'plone.app.caching.weakCaching'}
+        self.cacheSettings.operationMapping = {
+            'plone.content.itemView': 'plone.app.caching.weakCaching'}
         transaction.commit()
 
         # View the page as anonymous
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
 
         # Set pages to have moderate caching so that we can see the difference
         # between logged in and anonymous
 
-        self.cacheSettings.operationMapping = {'plone.content.itemView': 'plone.app.caching.moderateCaching'}
+        self.cacheSettings.operationMapping = {
+            'plone.content.itemView': 'plone.app.caching.moderateCaching'}
         self.registry['plone.app.caching.moderateCaching.smaxage'] = 60
         self.registry['plone.app.caching.moderateCaching.vary'] = 'X-Anonymous'
         self.registry['plone.app.caching.moderateCaching.anonOnly'] = True
@@ -88,27 +92,35 @@ def test_anon_only(self):
         # View the page as anonymous
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, s-maxage=60, must-revalidate', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=0, s-maxage=60, must-revalidate',
+                         browser.headers['Cache-Control'])
         self.assertEqual('X-Anonymous', browser.headers['Vary'])
         self.assertFalse('Etag' in browser.headers)
 
         # View the page as logged-in
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
         self.assertTrue('Etag' in browser.headers)
 
         # Set pages to have strong caching so that we can see the difference
         # between logged in and anonymous
 
-        self.cacheSettings.operationMapping = {'plone.content.itemView': 'plone.app.caching.strongCaching'}
+        self.cacheSettings.operationMapping = {
+            'plone.content.itemView': 'plone.app.caching.strongCaching'}
         self.registry['plone.app.caching.strongCaching.vary'] = 'X-Anonymous'
         self.registry['plone.app.caching.strongCaching.anonOnly'] = True
         transaction.commit()
@@ -116,21 +128,28 @@ def test_anon_only(self):
         # View the page as anonymous
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=86400, proxy-revalidate, public', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=86400, proxy-revalidate, public',
+                         browser.headers['Cache-Control'])
         self.assertEqual('X-Anonymous', browser.headers['Vary'])
         self.assertFalse('Etag' in browser.headers)
 
         # View the page as logged-in
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
         self.assertTrue('Etag' in browser.headers)
 
         # Check an edge case that has had a problem in the past:
@@ -143,4 +162,5 @@ def test_anon_only(self):
         # View the page as anonymous
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('max-age=0, s-maxage=60, must-revalidate', browser.headers['Cache-Control'])
+        self.assertEqual('max-age=0, s-maxage=60, must-revalidate',
+                         browser.headers['Cache-Control'])
diff --git a/plone/app/caching/tests/test_operation_utils.py b/plone/app/caching/tests/test_operation_utils.py
index 413aaf6..4a61d12 100644
--- a/plone/app/caching/tests/test_operation_utils.py
+++ b/plone/app/caching/tests/test_operation_utils.py
@@ -1,42 +1,37 @@
-import unittest2 as unittest
+# -*- coding: utf-8 -*-
+from OFS.SimpleItem import SimpleItem
+from plone.memoize.interfaces import ICacheChooser
 from plone.testing.zca import UNIT_TESTING
-
-import time
-import datetime
-import dateutil.parser
-import dateutil.tz
-import wsgiref.handlers
+from Products.CMFCore.interfaces import IContentish
 from StringIO import StringIO
-
-from zope.interface import implementer
-from zope.interface import Interface
-from zope.interface import classImplements
-from zope.interface import alsoProvides
-
-from zope.component import provideAdapter
-from zope.component import provideUtility
-from zope.component import adapts
-
-from plone.memoize.interfaces import ICacheChooser
-
 from z3c.caching.interfaces import ILastModified
-
+from zope.annotation.attribute import AttributeAnnotations
 from zope.annotation.interfaces import IAnnotations
 from zope.annotation.interfaces import IAttributeAnnotatable
-from zope.annotation.attribute import AttributeAnnotations
-
+from zope.component import adapter
+from zope.component import provideAdapter
+from zope.component import provideUtility
+from zope.interface import alsoProvides
+from zope.interface import classImplements
+from zope.interface import implementer
+from zope.interface import Interface
 from ZPublisher.HTTPRequest import HTTPRequest
 from ZPublisher.HTTPResponse import HTTPResponse
 
-from OFS.SimpleItem import SimpleItem
+import datetime
+import dateutil.parser
+import dateutil.tz
+import time
+import unittest2 as unittest
+import wsgiref.handlers
 
-from Products.CMFCore.interfaces import IContentish
 
 class DummyPublished(object):
 
     def __init__(self, parent=None):
         self.__parent__ = parent
 
+
 def normalize_response_cache(value):
     # Zope < 2.13 incorrectly includes the HTTP status as a header;
     # Zope 2.13 does not
@@ -68,7 +63,8 @@ def test_doNotCache(self):
         doNotCache(published, request, response)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
 
         expires = dateutil.parser.parse(response.getHeader('Expires'))
@@ -83,18 +79,21 @@ def test_doNotCache_deletes_last_modified(self):
         published = DummyPublished()
 
         now = datetime.datetime.now(dateutil.tz.tzlocal())
-        response.setHeader('Last-Modified', wsgiref.handlers.format_date_time(time.mktime(now.timetuple())))
+        response.setHeader(
+            'Last-Modified',
+            wsgiref.handlers.format_date_time(time.mktime(now.timetuple()))
+        )
 
         doNotCache(published, request, response)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
 
         expires = dateutil.parser.parse(response.getHeader('Expires'))
         self.assertTrue(now > expires)
 
-
     # cacheInBrowser()
 
     def test_cacheInBrowser_no_etag_no_last_modified(self):
@@ -110,7 +109,8 @@ def test_cacheInBrowser_no_etag_no_last_modified(self):
         cacheInBrowser(published, request, response)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
         self.assertEqual(None, response.getHeader('ETag', literal=1))
 
@@ -131,7 +131,8 @@ def test_cacheInBrowser_etag(self):
         cacheInBrowser(published, request, response, etag=etag)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
         self.assertEqual('"|foo|bar|"', response.getHeader('ETag', literal=1))
 
@@ -147,12 +148,14 @@ def test_cacheInBrowser_lastModified(self):
         published = DummyPublished()
 
         now = datetime.datetime.now(dateutil.tz.tzlocal())
-        nowFormatted = wsgiref.handlers.format_date_time(time.mktime(now.timetuple()))
+        nowFormatted = wsgiref.handlers.format_date_time(
+            time.mktime(now.timetuple()))
 
         cacheInBrowser(published, request, response, lastModified=now)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(nowFormatted, response.getHeader('Last-Modified'))
         self.assertEqual(None, response.getHeader('ETag', literal=1))
 
@@ -170,19 +173,21 @@ def test_cacheInBrowser_lastModified_and_etag(self):
         now = datetime.datetime.now(dateutil.tz.tzlocal())
         etag = "|foo|bar|"
 
-        nowFormatted = wsgiref.handlers.format_date_time(time.mktime(now.timetuple()))
+        nowFormatted = wsgiref.handlers.format_date_time(
+            time.mktime(now.timetuple()))
 
-        cacheInBrowser(published, request, response, etag=etag, lastModified=now)
+        cacheInBrowser(published, request, response,
+                       etag=etag, lastModified=now)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, must-revalidate, private', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(nowFormatted, response.getHeader('Last-Modified'))
         self.assertEqual('"|foo|bar|"', response.getHeader('ETag', literal=1))
 
         expires = dateutil.parser.parse(response.getHeader('Expires'))
         self.assertTrue(now > expires)
 
-
     # cacheInProxy()
 
     def test_cacheInProxy_minimal(self):
@@ -198,7 +203,8 @@ def test_cacheInProxy_minimal(self):
         cacheInProxy(published, request, response, smaxage=60)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, s-maxage=60, must-revalidate', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, s-maxage=60, must-revalidate',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
         self.assertEqual(None, response.getHeader('ETag', literal=1))
         self.assertEqual(None, response.getHeader('Vary'))
@@ -218,12 +224,15 @@ def test_cacheInProxy_full(self):
         etag = '|foo|bar|'
         vary = 'Accept-Language'
 
-        nowFormatted = wsgiref.handlers.format_date_time(time.mktime(now.timetuple()))
+        nowFormatted = wsgiref.handlers.format_date_time(
+            time.mktime(now.timetuple()))
 
-        cacheInProxy(published, request, response, smaxage=60, etag=etag, lastModified=now, vary=vary)
+        cacheInProxy(published, request, response, smaxage=60,
+                     etag=etag, lastModified=now, vary=vary)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=0, s-maxage=60, must-revalidate', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=0, s-maxage=60, must-revalidate',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(nowFormatted, response.getHeader('Last-Modified'))
         self.assertEqual('"|foo|bar|"', response.getHeader('ETag', literal=1))
         self.assertEqual('Accept-Language', response.getHeader('Vary'))
@@ -231,7 +240,6 @@ def test_cacheInProxy_full(self):
         expires = dateutil.parser.parse(response.getHeader('Expires'))
         self.assertTrue(now > expires)
 
-
     # cacheInBrowserAndProxy()
 
     def test_cacheInBrowserAndProxy_minimal(self):
@@ -247,7 +255,8 @@ def test_cacheInBrowserAndProxy_minimal(self):
         cacheInBrowserAndProxy(published, request, response, maxage=60)
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=60, proxy-revalidate, public', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=60, proxy-revalidate, public',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(None, response.getHeader('Last-Modified'))
         self.assertEqual(None, response.getHeader('ETag', literal=1))
         self.assertEqual(None, response.getHeader('Vary'))
@@ -268,12 +277,22 @@ def test_cacheInBrowserAndProxy_full(self):
         etag = '|foo|bar|'
         vary = 'Accept-Language'
 
-        nowFormatted = wsgiref.handlers.format_date_time(time.mktime(now.timetuple()))
-
-        cacheInBrowserAndProxy(published, request, response, maxage=60, etag=etag, lastModified=now, vary=vary)
+        nowFormatted = wsgiref.handlers.format_date_time(
+            time.mktime(now.timetuple()))
+
+        cacheInBrowserAndProxy(
+            published,
+            request,
+            response,
+            maxage=60,
+            etag=etag,
+            lastModified=now,
+            vary=vary
+        )
 
         self.assertEqual(200, response.getStatus())
-        self.assertEqual('max-age=60, proxy-revalidate, public', response.getHeader('Cache-Control'))
+        self.assertEqual('max-age=60, proxy-revalidate, public',
+                         response.getHeader('Cache-Control'))
         self.assertEqual(nowFormatted, response.getHeader('Last-Modified'))
         self.assertEqual('"|foo|bar|"', response.getHeader('ETag', literal=1))
         self.assertEqual('Accept-Language', response.getHeader('Vary'))
@@ -288,12 +307,11 @@ def test_cacheInBrowserAndProxy_full(self):
             "%s is not > %s" % (timedelta, datetime.timedelta(seconds=61))
         )
 
-
     # cacheInRAM()
 
     def test_cacheInRAM_no_etag(self):
         from plone.app.caching.operations.utils import cacheInRAM
-        from plone.app.caching.operations.utils import PAGE_CACHE_ANNOTATION_KEY
+        from plone.app.caching.operations.utils import PAGE_CACHE_ANNOTATION_KEY  # noqa
 
         from plone.app.caching.interfaces import IRAMCached
 
@@ -309,12 +327,13 @@ def test_cacheInRAM_no_etag(self):
         cacheInRAM(published, request, response)
 
         annotations = IAnnotations(request)
-        self.assertEqual("http://example.com/foo?", annotations[PAGE_CACHE_ANNOTATION_KEY])
+        self.assertEqual("http://example.com/foo?",
+                         annotations[PAGE_CACHE_ANNOTATION_KEY])
         self.assertTrue(IRAMCached.providedBy(request))
 
     def test_cacheInRAM_etag(self):
         from plone.app.caching.operations.utils import cacheInRAM
-        from plone.app.caching.operations.utils import PAGE_CACHE_ANNOTATION_KEY
+        from plone.app.caching.operations.utils import PAGE_CACHE_ANNOTATION_KEY  # noqa
 
         from plone.app.caching.interfaces import IRAMCached
 
@@ -331,7 +350,8 @@ def test_cacheInRAM_etag(self):
         cacheInRAM(published, request, response, etag=etag)
 
         annotations = IAnnotations(request)
-        self.assertEqual("||foo|bar|||http://example.com/foo?", annotations[PAGE_CACHE_ANNOTATION_KEY])
+        self.assertEqual("||foo|bar|||http://example.com/foo?",
+                         annotations[PAGE_CACHE_ANNOTATION_KEY])
         self.assertTrue(IRAMCached.providedBy(request))
 
     def test_cacheInRAM_etag_alternate_key(self):
@@ -349,10 +369,12 @@ def test_cacheInRAM_etag_alternate_key(self):
 
         assert not IRAMCached.providedBy(response)
 
-        cacheInRAM(published, request, response, etag=etag, annotationsKey="alt.key")
+        cacheInRAM(published, request, response,
+                   etag=etag, annotationsKey="alt.key")
 
         annotations = IAnnotations(request)
-        self.assertEqual("||foo|bar|||http://example.com/foo?", annotations["alt.key"])
+        self.assertEqual("||foo|bar|||http://example.com/foo?",
+                         annotations["alt.key"])
         self.assertTrue(IRAMCached.providedBy(request))
 
 
@@ -384,7 +406,8 @@ def test_cachedResponse(self):
         response.setHeader('X-Bar', 'qux')
         response.setStatus(200)
 
-        body = cachedResponse(published, request, response, 404, headers, u"body")
+        body = cachedResponse(published, request,
+                              response, 404, headers, u"body")
 
         self.assertEqual(u"body", body)
         self.assertEqual(404, response.getStatus())
@@ -416,7 +439,8 @@ def test_cachedResponse_gzip_off(self):
 
         assert response.enableHTTPCompression(query=True)
 
-        body = cachedResponse(published, request, response, 404, headers, u"body", 0)
+        body = cachedResponse(published, request, response,
+                              404, headers, u"body", 0)
 
         self.assertEqual(u"body", body)
         self.assertEqual(404, response.getStatus())
@@ -450,7 +474,8 @@ def test_cachedResponse_gzip_on(self):
 
         assert not response.enableHTTPCompression(query=True)
 
-        body = cachedResponse(published, request, response, 404, headers, u"body", 1)
+        body = cachedResponse(published, request, response,
+                              404, headers, u"body", 1)
 
         self.assertEqual(u"body", body)
         self.assertEqual(404, response.getStatus())
@@ -491,7 +516,8 @@ def test_notModified_full(self):
         now = datetime.datetime.now(dateutil.tz.tzlocal())
         etag = "|foo|bar|"
 
-        body = notModified(published, request, response, etag=etag, lastModified=now)
+        body = notModified(published, request, response,
+                           etag=etag, lastModified=now)
 
         self.assertEqual(u"", body)
         self.assertEqual(etag, response.getHeader('ETag', literal=1))
@@ -500,6 +526,7 @@ def test_notModified_full(self):
         self.assertEqual(None, response.getHeader('Cache-Control'))
         self.assertEqual(304, response.getStatus())
 
+
 class CacheCheckHelpersTest(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -527,9 +554,11 @@ def test_isModified_no_headers_with_keys(self):
         request = HTTPRequest(StringIO(), environ, response)
 
         etag = '|foo'
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
-        self.assertEqual(True, isModified(request, etag=etag, lastModified=lastModified))
+        self.assertEqual(True, isModified(
+            request, etag=etag, lastModified=lastModified))
 
     def test_isModified_ims_invalid_date(self):
         from plone.app.caching.operations.utils import isModified
@@ -540,7 +569,8 @@ def test_isModified_ims_invalid_date(self):
 
         request.environ['HTTP_IF_MODIFIED_SINCE'] = 'blah'
 
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
         self.assertEqual(True, isModified(request, lastModified=lastModified))
 
@@ -551,9 +581,11 @@ def test_isModified_ims_modified(self):
         response = HTTPResponse()
         request = HTTPRequest(StringIO(), environ, response)
 
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
 
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
         self.assertEqual(True, isModified(request, lastModified=lastModified))
 
@@ -564,9 +596,11 @@ def test_isModified_ims_not_modified(self):
         response = HTTPResponse()
         request = HTTPRequest(StringIO(), environ, response)
 
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
 
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
         self.assertEqual(False, isModified(request, lastModified=lastModified))
 
@@ -577,9 +611,11 @@ def test_isModified_ims_not_modified_two_dates(self):
         response = HTTPResponse()
         request = HTTPRequest(StringIO(), environ, response)
 
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT; Thu, 24 Nov 2011 03:04:05'
+        request.environ['HTTP_IF_MODIFIED_SINCE'] = \
+            'Thu, 24 Nov 2011 03:04:05 GMT; Thu, 24 Nov 2011 03:04:05'
 
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
         self.assertEqual(False, isModified(request, lastModified=lastModified))
 
@@ -590,12 +626,15 @@ def test_isModified_ims_not_modified_etag_no_inm_header(self):
         response = HTTPResponse()
         request = HTTPRequest(StringIO(), environ, response)
 
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
 
         etag = '|foo'
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
-        self.assertEqual(True, isModified(request, etag=etag, lastModified=lastModified))
+        self.assertEqual(True, isModified(
+            request, etag=etag, lastModified=lastModified))
 
     def test_isModified_inm_no_tags(self):
         from plone.app.caching.operations.utils import isModified
@@ -696,8 +735,7 @@ def test_isModified_inm_match_update(self):
         etag = None
 
         self.assertEqual(True, isModified(request, etag=etag,
-                                           lastModified='doesnt_really_matter'))
-
+                                          lastModified='doesnt_really_matter'))
 
     def test_isModified_inm_match_multiple(self):
         from plone.app.caching.operations.utils import isModified
@@ -733,7 +771,8 @@ def test_isModified_inm_match_ignores_ims_if_no_last_modified_date(self):
         request = HTTPRequest(StringIO(), environ, response)
 
         request.environ['HTTP_IF_NONE_MATCH'] = '"|foo"'
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
 
         etag = '|foo'
 
@@ -747,12 +786,15 @@ def test_isModified_inm_match_modified(self):
         request = HTTPRequest(StringIO(), environ, response)
 
         request.environ['HTTP_IF_NONE_MATCH'] = '"|foo"'
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Tue, 24 Nov 2009 03:04:05 GMT'
 
         etag = '|foo'
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
-        self.assertEqual(True, isModified(request, etag=etag, lastModified=lastModified))
+        self.assertEqual(True, isModified(
+            request, etag=etag, lastModified=lastModified))
 
     def test_isModified_inm_match_not_modified(self):
         from plone.app.caching.operations.utils import isModified
@@ -762,12 +804,15 @@ def test_isModified_inm_match_not_modified(self):
         request = HTTPRequest(StringIO(), environ, response)
 
         request.environ['HTTP_IF_NONE_MATCH'] = '"|foo"'
-        request.environ['HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
+        request.environ[
+            'HTTP_IF_MODIFIED_SINCE'] = 'Thu, 24 Nov 2011 03:04:05 GMT'
 
         etag = '|foo'
-        lastModified = datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+        lastModified = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
 
-        self.assertEqual(False, isModified(request, etag=etag, lastModified=lastModified))
+        self.assertEqual(False, isModified(
+            request, etag=etag, lastModified=lastModified))
 
     # visibleToRole()
 
@@ -855,7 +900,8 @@ def test_formatDateTime_local(self):
 
         # We lose microseconds. Big whoop.
         p = dateutil.parser.parse(inGMT).astimezone(dateutil.tz.tzlocal())
-        lofi = datetime.datetime(2010, 11, 24, 3, 4, 5, 0, dateutil.tz.tzlocal())
+        lofi = datetime.datetime(
+            2010, 11, 24, 3, 4, 5, 0, dateutil.tz.tzlocal())
         self.assertEqual(p, lofi)
 
     def test_formatDateTime_naive(self):
@@ -870,7 +916,8 @@ def test_formatDateTime_naive(self):
 
         # Can't compare offset aware and naive
         p = dateutil.parser.parse(inGMT).astimezone(dateutil.tz.tzlocal())
-        self.assertEqual((2010, 11, 24, 3, 4, 5), (p.year, p.month, p.day, p.hour, p.minute, p.second))
+        self.assertEqual((2010, 11, 24, 3, 4, 5),
+                         (p.year, p.month, p.day, p.hour, p.minute, p.second))
 
     # parseDateTime()
 
@@ -889,7 +936,8 @@ def test_formatDateTime_no_timezone(self):
         from plone.app.caching.operations.utils import parseDateTime
 
         # parser will assume input was local time
-        dt = datetime.datetime(2010, 11, 23, 19, 4, 5, 0, dateutil.tz.tzlocal())
+        dt = datetime.datetime(2010, 11, 23, 19, 4, 5,
+                               0, dateutil.tz.tzlocal())
         self.assertEqual(dt, parseDateTime("'Tue, 23 Nov 2010 19:04:05'"))
 
     # getLastModified()
@@ -904,8 +952,8 @@ def test_getLastModified_none(self):
         from plone.app.caching.operations.utils import getLastModified
 
         @implementer(ILastModified)
+        @adapter(DummyPublished)
         class DummyLastModified(object):
-            adapts(DummyPublished)
 
             def __init__(self, context):
                 self.context = context
@@ -922,8 +970,8 @@ def test_getLastModified_missing_timezone(self):
         from plone.app.caching.operations.utils import getLastModified
 
         @implementer(ILastModified)
+        @adapter(DummyPublished)
         class DummyLastModified(object):
-            adapts(DummyPublished)
 
             def __init__(self, context):
                 self.context = context
@@ -934,28 +982,33 @@ def __call__(self):
         provideAdapter(DummyLastModified)
 
         published = DummyPublished()
-        self.assertEqual(datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzlocal()),
-                          getLastModified(published))
+        self.assertEqual(
+            datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzlocal()),
+            getLastModified(published)
+        )
 
     def test_getLastModified_timezone(self):
         from plone.app.caching.operations.utils import getLastModified
 
         @implementer(ILastModified)
+        @adapter(DummyPublished)
         class DummyLastModified(object):
-            adapts(DummyPublished)
 
             def __init__(self, context):
                 self.context = context
 
             def __call__(self):
-                return datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc())
+                return datetime.datetime(
+                    2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc()
+                )
 
         provideAdapter(DummyLastModified)
 
         published = DummyPublished()
-        self.assertEqual(datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc()),
-                          getLastModified(published))
-
+        self.assertEqual(
+            datetime.datetime(2010, 11, 24, 3, 4, 5, 6, dateutil.tz.tzutc()),
+            getLastModified(published)
+        )
 
     # getExpiration()
 
@@ -994,7 +1047,6 @@ def test_getExpiration_future(self):
         # give the test two seconds' leeway
         self.assertTrue(difference >= datetime.timedelta(seconds=58))
 
-
     # getETag()
 
     def test_getETag_extra_only(self):
@@ -1005,7 +1057,8 @@ def test_getETag_extra_only(self):
         request = HTTPRequest(StringIO(), environ, response)
         published = DummyPublished()
 
-        self.assertEqual('|foo|bar;baz', getETag(published, request, extraTokens=('foo', 'bar,baz')))
+        self.assertEqual('|foo|bar;baz', getETag(
+            published, request, extraTokens=('foo', 'bar,baz')))
 
     def test_getETag_key_not_found(self):
         from plone.app.caching.operations.utils import getETag
@@ -1015,15 +1068,16 @@ def test_getETag_key_not_found(self):
         request = HTTPRequest(StringIO(), environ, response)
         published = DummyPublished()
 
-        self.assertEqual(None, getETag(published, request, keys=('foo', 'bar',)))
+        self.assertEqual(None, getETag(
+            published, request, keys=('foo', 'bar',)))
 
     def test_getETag_adapter_returns_none(self):
         from plone.app.caching.operations.utils import getETag
         from plone.app.caching.interfaces import IETagValue
 
         @implementer(IETagValue)
+        @adapter(DummyPublished, HTTPRequest)
         class FooETag(object):
-            adapts(DummyPublished, HTTPRequest)
 
             def __init__(self, published, request):
                 self.published = published
@@ -1035,8 +1089,8 @@ def __call__(self):
         provideAdapter(FooETag, name=u"foo")
 
         @implementer(IETagValue)
+        @adapter(DummyPublished, HTTPRequest)
         class BarETag(object):
-            adapts(DummyPublished, HTTPRequest)
 
             def __init__(self, published, request):
                 self.published = published
@@ -1052,15 +1106,16 @@ def __call__(self):
         request = HTTPRequest(StringIO(), environ, response)
         published = DummyPublished()
 
-        self.assertEqual('|foo|', getETag(published, request, keys=('foo', 'bar',)))
+        self.assertEqual('|foo|', getETag(
+            published, request, keys=('foo', 'bar',)))
 
     def test_getETag_full(self):
         from plone.app.caching.operations.utils import getETag
         from plone.app.caching.interfaces import IETagValue
 
         @implementer(IETagValue)
+        @adapter(DummyPublished, HTTPRequest)
         class FooETag(object):
-            adapts(DummyPublished, HTTPRequest)
 
             def __init__(self, published, request):
                 self.published = published
@@ -1072,8 +1127,8 @@ def __call__(self):
         provideAdapter(FooETag, name=u"foo")
 
         @implementer(IETagValue)
+        @adapter(DummyPublished, HTTPRequest)
         class BarETag(object):
-            adapts(DummyPublished, HTTPRequest)
 
             def __init__(self, published, request):
                 self.published = published
@@ -1089,9 +1144,15 @@ def __call__(self):
         request = HTTPRequest(StringIO(), environ, response)
         published = DummyPublished()
 
-        self.assertEqual('|foo|bar|baz;qux', getETag(published, request,
-                keys=('foo', 'bar',), extraTokens=('baz,qux',)))
-
+        self.assertEqual(
+            '|foo|bar|baz;qux',
+            getETag(
+                published,
+                request,
+                keys=('foo', 'bar',),
+                extraTokens=('baz,qux',)
+            )
+        )
 
     # parseETags()
 
@@ -1121,35 +1182,44 @@ def test_parseETags_single_quoted(self):
 
     def test_parseETags_multiple(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('|foo|bar;baz, 1234'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('|foo|bar;baz, 1234'))
 
     def test_parseETags_multiple_quoted(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('"|foo|bar;baz", "1234"'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('"|foo|bar;baz", "1234"'))
 
     def test_parseETags_multiple_nospace(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('|foo|bar;baz,1234'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('|foo|bar;baz,1234'))
 
     def test_parseETags_multiple_quoted_nospace(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('"|foo|bar;baz","1234"'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('"|foo|bar;baz","1234"'))
 
     def test_parseETags_multiple_weak(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('|foo|bar;baz, W/1234'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('|foo|bar;baz, W/1234'))
 
     def test_parseETags_multiple_quoted_weak(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz', '1234'], parseETags('"|foo|bar;baz", W/"1234"'))
+        self.assertEqual(['|foo|bar;baz', '1234'],
+                         parseETags('"|foo|bar;baz", W/"1234"'))
 
     def test_parseETags_multiple_weak_disallowed(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz'], parseETags('|foo|bar;baz, W/1234', allowWeak=False))
+        self.assertEqual(['|foo|bar;baz'], parseETags(
+            '|foo|bar;baz, W/1234', allowWeak=False))
 
     def test_parseETags_multiple_quoted_weak_disallowed(self):
         from plone.app.caching.operations.utils import parseETags
-        self.assertEqual(['|foo|bar;baz'], parseETags('"|foo|bar;baz", W/"1234"', allowWeak=False))
+        self.assertEqual(['|foo|bar;baz'], parseETags(
+            '"|foo|bar;baz", W/"1234"', allowWeak=False))
+
 
 class RAMCacheTest(unittest.TestCase):
 
@@ -1201,7 +1271,6 @@ def __call__(self, key):
         provideUtility(Chooser())
         self.assertEqual(cache, getRAMCache())
 
-
     # getRAMCacheKey()
 
     def test_getRAMCacheKey_empty(self):
@@ -1223,7 +1292,8 @@ def test_getRAMCacheKey_normal(self):
         request.environ['PATH_INFO'] = '/foo/bar'
         request.environ['QUERY_STRING'] = 'x=1&y=2'
 
-        self.assertEqual('http://example.com/foo/bar?x=1&y=2', getRAMCacheKey(request))
+        self.assertEqual('http://example.com/foo/bar?x=1&y=2',
+                         getRAMCacheKey(request))
 
     def test_getRAMCacheKey_etag(self):
         from plone.app.caching.operations.utils import getRAMCacheKey
@@ -1235,8 +1305,8 @@ def test_getRAMCacheKey_etag(self):
         request.environ['PATH_INFO'] = '/foo/bar'
         request.environ['QUERY_STRING'] = 'x=1&y=2'
 
-        self.assertEqual('||foo|bar||http://example.com/foo/bar?x=1&y=2', getRAMCacheKey(request, etag="|foo|bar"))
-
+        self.assertEqual('||foo|bar||http://example.com/foo/bar?x=1&y=2',
+                         getRAMCacheKey(request, etag="|foo|bar"))
 
     # storeResponseInRAMCache()
 
@@ -1278,7 +1348,8 @@ def test_storeResponseInRAMCache_no_cache(self):
         result = u"Body"
         response.setHeader('X-Foo', 'bar')
 
-        IAnnotations(request)['plone.app.caching.operations.ramcache.key'] = 'foo'
+        IAnnotations(request)[
+            'plone.app.caching.operations.ramcache.key'] = 'foo'
 
         storeResponseInRAMCache(request, response, result)
 
@@ -1306,7 +1377,8 @@ def __call__(self, key):
         result = u"Body"
         response.setHeader('X-Foo', 'bar')
 
-        IAnnotations(request)['plone.app.caching.operations.ramcache.key'] = 'foo'
+        IAnnotations(request)[
+            'plone.app.caching.operations.ramcache.key'] = 'foo'
 
         storeResponseInRAMCache(request, response, result)
 
@@ -1341,7 +1413,8 @@ def __call__(self, key):
         result = u"Body"
         response.setHeader('X-Foo', 'bar')
 
-        IAnnotations(request)['plone.app.caching.operations.ramcache.key'] = 'foo'
+        IAnnotations(request)[
+            'plone.app.caching.operations.ramcache.key'] = 'foo'
 
         storeResponseInRAMCache(request, response, result)
 
@@ -1375,7 +1448,8 @@ def __call__(self, key):
 
         IAnnotations(request)['annkey'] = 'foo'
 
-        storeResponseInRAMCache(request, response, result, globalKey='cachekey', annotationsKey='annkey')
+        storeResponseInRAMCache(request, response, result,
+                                globalKey='cachekey', annotationsKey='annkey')
 
         self.assertEqual(1, len(cache))
         cached = normalize_response_cache(cache['foo'])
@@ -1448,9 +1522,12 @@ def __call__(self, key):
         request.environ['PATH_INFO'] = '/foo/bar'
         request.environ['QUERY_STRING'] = ''
 
-        cache['||a|b||http://example.com/foo/bar?'] = (200, {'x-foo': 'bar'}, u'Body')
+        cache['||a|b||http://example.com/foo/bar?'] = (
+            200, {'x-foo': 'bar'}, u'Body'
+        )
 
-        cached = normalize_response_cache(fetchFromRAMCache(request, etag="|a|b"))
+        cached = normalize_response_cache(
+            fetchFromRAMCache(request, etag="|a|b"))
         self.assertEqual((200, {'x-foo': 'bar'}, u'Body'), cached)
 
     def test_fetchFromRAMCache_custom_key(self):
@@ -1479,7 +1556,8 @@ def __call__(self, key):
 
         cache['http://example.com/foo/bar?'] = (200, {'x-foo': 'bar'}, u'Body')
 
-        cached = normalize_response_cache(fetchFromRAMCache(request, globalKey='cachekey'))
+        cached = normalize_response_cache(
+            fetchFromRAMCache(request, globalKey='cachekey'))
         self.assertEqual((200, {'x-foo': 'bar'}, u'Body'), cached)
 
     def test_fetchFromRAMCache_miss(self):
@@ -1508,7 +1586,8 @@ def __call__(self, key):
 
         cache['http://example.com/foo/bar?'] = (200, {'x-foo': 'bar'}, u'Body')
 
-        cached = normalize_response_cache(fetchFromRAMCache(request, etag='|foo'))
+        cached = normalize_response_cache(
+            fetchFromRAMCache(request, etag='|foo'))
         self.assertEqual(None, cached)
 
     def test_fetchFromRAMCache_miss_custom_default(self):
@@ -1538,5 +1617,6 @@ def __call__(self, key):
         cache['http://example.com/foo/bar?'] = (200, {'x-foo': 'bar'}, u'Body')
 
         marker = object()
-        cached = normalize_response_cache(fetchFromRAMCache(request, etag='|foo', default=marker))
+        cached = normalize_response_cache(
+            fetchFromRAMCache(request, etag='|foo', default=marker))
         self.assertTrue(cached is marker)
diff --git a/plone/app/caching/tests/test_profile_with_caching_proxy.py b/plone/app/caching/tests/test_profile_with_caching_proxy.py
index 168cd2b..04f5bbf 100644
--- a/plone/app/caching/tests/test_profile_with_caching_proxy.py
+++ b/plone/app/caching/tests/test_profile_with_caching_proxy.py
@@ -1,47 +1,42 @@
-import pkg_resources
-
-import unittest2 as unittest
-
-from plone.testing.z2 import Browser
-
+# -*- coding: utf-8 -*-
+from cStringIO import StringIO
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.caching.tests.test_utils import stable_now
-from plone.app.testing import TEST_USER_ID, TEST_USER_NAME, TEST_USER_PASSWORD
-from plone.app.testing import SITE_OWNER_NAME, SITE_OWNER_PASSWORD
-from plone.app.testing import setRoles
 from plone.app.testing import applyProfile
-
-from cStringIO import StringIO
+from plone.app.testing import setRoles
+from plone.app.testing import SITE_OWNER_NAME
+from plone.app.testing import SITE_OWNER_PASSWORD
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
+from plone.app.textfield.value import RichTextValue
+from plone.cachepurging.interfaces import ICachePurgingSettings
+from plone.cachepurging.interfaces import IPurger
+from plone.caching.interfaces import ICacheSettings
+from plone.registry.interfaces import IRegistry
+from plone.testing.z2 import Browser
+from Products.CMFCore.FSFile import FSFile
+from Products.CMFCore.utils import getToolByName
+from zope.component import getUtility
+from zope.globalrequest import setRequest
 
 import datetime
 import dateutil.parser
 import dateutil.tz
-
 import os
-import urllib
-
-import OFS.Image
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.FSFile import FSFile
-
-from zope.component import getUtility
-
-from zope.globalrequest import setRequest
-
-from plone.app.textfield.value import RichTextValue
-from plone.registry.interfaces import IRegistry
-from plone.caching.interfaces import ICacheSettings
-from plone.cachepurging.interfaces import ICachePurgingSettings
-from plone.cachepurging.interfaces import IPurger
-from plone.app.caching.interfaces import IPloneCacheSettings
+import pkg_resources
+import unittest2 as unittest
 
-from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 
-TEST_FILE = pkg_resources.resource_filename('plone.app.caching.tests', 'test.gif')
+TEST_FILE = pkg_resources.resource_filename(
+    'plone.app.caching.tests', 'test.gif')
 
 
 def test_image():
     from plone.namedfile.file import NamedBlobImage
-    filename = pkg_resources.resource_filename('plone.app.caching.tests', 'test.gif')
+    filename = pkg_resources.resource_filename(
+        'plone.app.caching.tests', 'test.gif')
     filename = os.path.join(os.path.dirname(__file__), u'test.gif')
     return NamedBlobImage(
         data=open(filename, 'r').read(),
@@ -70,7 +65,8 @@ def setUp(self):
         self.app = self.layer['app']
         self.portal = self.layer['portal']
 
-        test_css = FSFile('test.css', os.path.join(os.path.dirname(__file__), 'test.css'))
+        test_css = FSFile('test.css', os.path.join(
+            os.path.dirname(__file__), 'test.css'))
         self.portal.portal_skins.custom._setOb('test.css', test_css)
 
         setRequest(self.portal.REQUEST)
@@ -80,8 +76,10 @@ def setUp(self):
         self.registry = getUtility(IRegistry)
 
         self.cacheSettings = self.registry.forInterface(ICacheSettings)
-        self.cachePurgingSettings = self.registry.forInterface(ICachePurgingSettings)
-        self.ploneCacheSettings = self.registry.forInterface(IPloneCacheSettings)
+        self.cachePurgingSettings = self.registry.forInterface(
+            ICachePurgingSettings)
+        self.ploneCacheSettings = self.registry.forInterface(
+            IPloneCacheSettings)
 
         self.cacheSettings.enabled = True
 
@@ -119,7 +117,8 @@ def test_composite_views(self):
 
         # Publish the folder and page
         self.portal.portal_workflow.doActionFor(self.portal['f1'], 'publish')
-        self.portal.portal_workflow.doActionFor(self.portal['f1']['d1'], 'publish')
+        self.portal.portal_workflow.doActionFor(
+            self.portal['f1']['d1'], 'publish')
 
         # Should we set up the etag components?
         # - set member?  No
@@ -130,56 +129,78 @@ def test_composite_views(self):
         # - leave status unlocked
         #
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the authenticated folder
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1'].absolute_url())
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0|0' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0|0' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Set the copy/cut cookie and then request the folder view again
         browser.cookies.create('__cp', 'xxx')
         browser.open(self.portal['f1'].absolute_url())
         # The response should be the same as before except for the etag
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0|1' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0|1' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
 
         # Request the authenticated page
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the authenticated page again -- to test RAM cache.
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # Authenticated should NOT be RAM cached
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
 
-        # Request the authenticated page again -- with an INM header to test 304
+        # Request the authenticated page again -- with an INM header to test
+        # 304
         etag = browser.headers['ETag']
         browser = Browser(self.app)
         browser.raiseHttpErrors = False  # we really do want to see the 304
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
         # This should be a 304 response
@@ -190,38 +211,54 @@ def test_composite_views(self):
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1'].absolute_url())
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0|0' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0|0' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page again -- to test RAM cache.
         # Anonymous should be RAM cached
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should come from RAM cache
-        self.assertEqual('plone.app.caching.operations.ramcache', browser.headers['X-RAMCache'])
+        self.assertEqual('plone.app.caching.operations.ramcache',
+                         browser.headers['X-RAMCache'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0' % (catalog.getCounter(), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0' % (catalog.getCounter(
+        ), skins_tool.default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page again -- with an INM header to test 304.
         etag = browser.headers['ETag']
@@ -229,8 +266,10 @@ def test_composite_views(self):
         browser.raiseHttpErrors = False
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -244,15 +283,19 @@ def test_composite_views(self):
         )
         self.portal['f1']['d1'].reindexObject()
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
-        # Request the anonymous page again -- to test expiration of 304 and RAM.
+        # Request the anonymous page again -- to test expiration of 304 and
+        # RAM.
         etag = browser.headers['ETag']
         browser = Browser(self.app)
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # The etag has changed so we should get a fresh page.
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
         self.assertEqual('200 Ok', browser.headers['Status'])
@@ -268,18 +311,23 @@ def test_content_feeds(self):
         self.syndication.editProperties(isAllowed=True)
         self.syndication.enableSyndication(self.portal)
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the rss feed
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInProxy
-        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(), skins_tool.default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(),
+                                           skins_tool.default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the rss feed again -- to test RAM cache
         now = stable_now()
@@ -287,13 +335,18 @@ def test_content_feeds(self):
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should come from the RAM cache
-        self.assertEqual('plone.app.caching.operations.ramcache', browser.headers['X-RAMCache'])
+        self.assertEqual('plone.app.caching.operations.ramcache',
+                         browser.headers['X-RAMCache'])
         self.assertEqual(rssText, browser.contents)
-        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(), skins_tool.default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(),
+                                           skins_tool.default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the rss feed again -- with an INM header to test 304.
         etag = browser.headers['ETag']
@@ -302,7 +355,8 @@ def test_content_feeds(self):
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -310,21 +364,28 @@ def test_content_feeds(self):
         # Request the authenticated rss feed
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s"' % (catalog.getCounter(), skins_tool.default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s"' % (
+            catalog.getCounter(), skins_tool.default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the authenticated rss feed again -- to test RAM cache
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # Authenticated should NOT be RAM cached
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
 
@@ -344,52 +405,69 @@ def test_content_files(self):
         self.portal['f1']['i1'].image = test_image()
         self.portal['f1']['i1'].reindexObject()
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the image with Manager role
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,))
         browser.open(self.portal['f1']['i1'].absolute_url())
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # Folder not published yet so image should not be cached in proxy
         # so this should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request an image scale with Manager role
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,))
-        browser.open(self.portal['f1']['i1'].absolute_url() + '/@@images/image/preview')
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,))
+        browser.open(self.portal['f1'][
+                     'i1'].absolute_url() + '/@@images/image/preview')
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # Folder not published yet so image scale should not be cached in proxy
         # so this should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Publish the folder
         self.portal.portal_workflow.doActionFor(self.portal['f1'], 'publish')
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the image
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['i1'].absolute_url())
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # Now visible to anonymous so this should use cacheInProxy
-        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the image again -- with an IMS header to test 304
         lastmodified = browser.headers['Last-Modified']
@@ -398,7 +476,8 @@ def test_content_files(self):
         browser.addHeader('If-Modified-Since', lastmodified)
         browser.open(self.portal['f1']['i1'].absolute_url())
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -406,30 +485,39 @@ def test_content_files(self):
         # Request an image scale
         now = stable_now()
         browser = Browser(self.app)
-        browser.open(self.portal['f1']['i1'].absolute_url() + '/@@images/image/preview')
+        browser.open(self.portal['f1'][
+                     'i1'].absolute_url() + '/@@images/image/preview')
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.moderateCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.moderateCaching',
+                         browser.headers['X-Cache-Operation'])
         # Now visible to anonymous so this should use cacheInProxy
-        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, s-maxage=86400, must-revalidate',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
     def test_resources(self):
         # This is a clone of the same test for 'without-caching-proxy'
         # Can we just call that test from this context?
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request a skin image
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/rss.png')
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowserAndProxy
-        self.assertEqual('max-age=86400, proxy-revalidate, public', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=86400, proxy-revalidate, public',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
         timedelta = dateutil.parser.parse(browser.headers['Expires']) - now
         self.assertTrue(timedelta > datetime.timedelta(seconds=86390))
@@ -441,7 +529,8 @@ def test_resources(self):
         browser.addHeader('If-Modified-Since', lastmodified)
         browser.open(self.portal.absolute_url() + '/rss.png')
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -453,17 +542,22 @@ def test_resources(self):
         # large Resource Registry cooked files, which all use the same
         # method to initiate a streamed response.
         s = "a" * (1 << 16) * 3
-        self.portal.manage_addFile('bigfile', file=StringIO(s), content_type='application/octet-stream')
+        self.portal.manage_addFile('bigfile', file=StringIO(
+            s), content_type='application/octet-stream')
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         browser = Browser(self.app)
         browser.open(self.portal['bigfile'].absolute_url())
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowserAndProxy
-        self.assertEqual('max-age=86400, proxy-revalidate, public', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=86400, proxy-revalidate, public',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
         timedelta = dateutil.parser.parse(browser.headers['Expires']) - now
         self.assertTrue(timedelta > datetime.timedelta(seconds=86390))
diff --git a/plone/app/caching/tests/test_profile_without_caching_proxy.py b/plone/app/caching/tests/test_profile_without_caching_proxy.py
index f827ff1..8c2d764 100644
--- a/plone/app/caching/tests/test_profile_without_caching_proxy.py
+++ b/plone/app/caching/tests/test_profile_without_caching_proxy.py
@@ -1,45 +1,39 @@
-import pkg_resources
-
-import unittest2 as unittest
-
-from plone.testing.z2 import Browser
-
+# -*- coding: utf-8 -*-
+from cStringIO import StringIO
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 from plone.app.caching.tests.test_utils import stable_now
-from plone.app.textfield.value import RichTextValue
-from plone.app.testing import TEST_USER_ID, TEST_USER_NAME, TEST_USER_PASSWORD
-from plone.app.testing import setRoles
 from plone.app.testing import applyProfile
-
-from cStringIO import StringIO
+from plone.app.testing import setRoles
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
+from plone.app.textfield.value import RichTextValue
+from plone.cachepurging.interfaces import ICachePurgingSettings
+from plone.caching.interfaces import ICacheSettings
+from plone.registry.interfaces import IRegistry
+from plone.testing.z2 import Browser
+from Products.CMFCore.FSFile import FSFile
+from Products.CMFCore.utils import getToolByName
+from zope.component import getUtility
+from zope.globalrequest import setRequest
 
 import datetime
 import dateutil.parser
 import dateutil.tz
-
 import os
-import urllib
-
-import OFS.Image
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.FSFile import FSFile
-
-from zope.component import getUtility
-
-from zope.globalrequest import setRequest
-
-from plone.registry.interfaces import IRegistry
-from plone.caching.interfaces import ICacheSettings
-from plone.cachepurging.interfaces import ICachePurgingSettings
-from plone.app.caching.interfaces import IPloneCacheSettings
+import pkg_resources
+import unittest2 as unittest
 
-from plone.app.caching.testing import PLONE_APP_CACHING_FUNCTIONAL_TESTING
 
-TEST_FILE = pkg_resources.resource_filename('plone.app.caching.tests', 'test.gif')
+TEST_FILE = pkg_resources.resource_filename(
+    'plone.app.caching.tests', 'test.gif')
 
 
 def test_image():
     from plone.namedfile.file import NamedBlobImage
-    filename = pkg_resources.resource_filename('plone.app.caching.tests', 'test.gif')
+    filename = pkg_resources.resource_filename(
+        'plone.app.caching.tests', 'test.gif')
     filename = os.path.join(os.path.dirname(__file__), u'test.gif')
     return NamedBlobImage(
         data=open(filename, 'r').read(),
@@ -68,7 +62,8 @@ def setUp(self):
         self.app = self.layer['app']
         self.portal = self.layer['portal']
 
-        test_css = FSFile('test.css', os.path.join(os.path.dirname(__file__), 'test.css'))
+        test_css = FSFile('test.css', os.path.join(
+            os.path.dirname(__file__), 'test.css'))
         self.portal.portal_skins.custom._setOb('test.css', test_css)
 
         setRequest(self.portal.REQUEST)
@@ -78,8 +73,10 @@ def setUp(self):
         self.registry = getUtility(IRegistry)
 
         self.cacheSettings = self.registry.forInterface(ICacheSettings)
-        self.cachePurgingSettings = self.registry.forInterface(ICachePurgingSettings)
-        self.ploneCacheSettings = self.registry.forInterface(IPloneCacheSettings)
+        self.cachePurgingSettings = self.registry.forInterface(
+            ICachePurgingSettings)
+        self.ploneCacheSettings = self.registry.forInterface(
+            IPloneCacheSettings)
 
         self.cacheSettings.enabled = True
 
@@ -112,7 +109,8 @@ def test_composite_views(self):
 
         # Publish the folder and page
         self.portal.portal_workflow.doActionFor(self.portal['f1'], 'publish')
-        self.portal.portal_workflow.doActionFor(self.portal['f1']['d1'], 'publish')
+        self.portal.portal_workflow.doActionFor(
+            self.portal['f1']['d1'], 'publish')
 
         # Should we set up the etag components?
         # - set member?  No
@@ -123,56 +121,78 @@ def test_composite_views(self):
         # - leave status unlocked
         # - set the mod date on the resource registries?  Probably.
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the quthenticated folder
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1'].absolute_url())
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0|0' % (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0|0' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Set the copy/cut cookie and then request the folder view again
         browser.cookies.create('__cp', 'xxx')
         browser.open(self.portal['f1'].absolute_url())
         # The response should be the same as before except for the etag
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0|1' % (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0|1' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
 
         # Request the authenticated page
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s|0' % (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s|0' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the authenticated page again -- to test RAM cache.
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # Authenticated should NOT be RAM cached
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
 
-        # Request the authenticated page again -- with an INM header to test 304
+        # Request the authenticated page again -- with an INM header to test
+        # 304
         etag = browser.headers['ETag']
         browser = Browser(self.app)
         browser.raiseHttpErrors = False  # we really do want to see the 304
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
         # This should be a 304 response
@@ -183,38 +203,54 @@ def test_composite_views(self):
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1'].absolute_url())
-        self.assertEqual('plone.content.folderView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.folderView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0|0'  % (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0|0' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         self.assertTrue(testText in browser.contents)
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0' % (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page again -- to test RAM cache.
         # Anonymous should be RAM cached
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should come from RAM cache
-        self.assertEqual('plone.app.caching.operations.ramcache', browser.headers['X-RAMCache'])
+        self.assertEqual('plone.app.caching.operations.ramcache',
+                         browser.headers['X-RAMCache'])
         self.assertTrue(testText in browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s|0'% (catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s|0' % (
+            catalog.getCounter(), default_skin), _normalize_etag(browser.headers['ETag']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the anonymous page again -- with an INM header to test 304.
         etag = browser.headers['ETag']
@@ -222,8 +258,10 @@ def test_composite_views(self):
         browser.raiseHttpErrors = False
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -239,13 +277,16 @@ def test_composite_views(self):
 
         transaction.commit()
 
-        # Request the anonymous page again -- to test expiration of 304 and RAM.
+        # Request the anonymous page again -- to test expiration of 304 and
+        # RAM.
         etag = browser.headers['ETag']
         browser = Browser(self.app)
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal['f1']['d1'].absolute_url())
-        self.assertEqual('plone.content.itemView', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.content.itemView',
+                         browser.headers['X-Cache-Rule'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # The etag has changed so we should get a fresh page.
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
         self.assertEqual('200 Ok', browser.headers['Status'])
@@ -261,18 +302,23 @@ def test_content_feeds(self):
         self.syndication.editProperties(isAllowed=True)
         self.syndication.enableSyndication(self.portal)
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the rss feed
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(), default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(),
+                                           default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the rss feed again -- to test RAM cache
         now = stable_now()
@@ -280,13 +326,18 @@ def test_content_feeds(self):
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should come from RAM cache
-        self.assertEqual('plone.app.caching.operations.ramcache', browser.headers['X-RAMCache'])
+        self.assertEqual('plone.app.caching.operations.ramcache',
+                         browser.headers['X-RAMCache'])
         self.assertEqual(rssText, browser.contents)
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(), default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"||%d|en|%s"' % (catalog.getCounter(),
+                                           default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the rss feed again -- with an INM header to test 304.
         etag = browser.headers['ETag']
@@ -295,7 +346,8 @@ def test_content_feeds(self):
         browser.addHeader('If-None-Match', etag)
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -303,21 +355,28 @@ def test_content_feeds(self):
         # Request the authenticated rss feed
         now = stable_now()
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertEqual('"|test_user_1_|%d|en|%s"' % (catalog.getCounter(), default_skin), browser.headers['ETag'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        self.assertEqual('"|test_user_1_|%d|en|%s"' % (
+            catalog.getCounter(), default_skin), browser.headers['ETag'])
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the authenticated rss feed again -- to test RAM cache
         browser = Browser(self.app)
-        browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+        browser.addHeader('Authorization', 'Basic %s:%s' %
+                          (TEST_USER_NAME, TEST_USER_PASSWORD,))
         browser.open(self.portal.absolute_url() + '/RSS')
         self.assertEqual('plone.content.feed', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # Authenticated should NOT be RAM cached
         self.assertEqual(None, browser.headers.get('X-RAMCache'))
 
@@ -340,19 +399,24 @@ def test_content_files(self):
         # Publish the folder
         self.portal.portal_workflow.doActionFor(self.portal['f1'], 'publish')
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request the image
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal['f1']['i1'].absolute_url())
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
         # Request the image again -- with an IMS header to test 304
         lastmodified = browser.headers['Last-Modified']
@@ -361,7 +425,8 @@ def test_content_files(self):
         browser.addHeader('If-Modified-Since', lastmodified)
         browser.open(self.portal['f1']['i1'].absolute_url())
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -369,28 +434,37 @@ def test_content_files(self):
         # Request an image scale
         now = stable_now()
         browser = Browser(self.app)
-        browser.open(self.portal['f1']['i1'].absolute_url() + '/@@images/image/preview')
+        browser.open(self.portal['f1'][
+                     'i1'].absolute_url() + '/@@images/image/preview')
         self.assertEqual('plone.content.file', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.weakCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.weakCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowser
-        self.assertEqual('max-age=0, must-revalidate, private', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=0, must-revalidate, private',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
-        self.assertTrue(now > dateutil.parser.parse(browser.headers['Expires']))
+        self.assertTrue(now > dateutil.parser.parse(
+            browser.headers['Expires']))
 
     def test_resources(self):
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         # Request a skin image
         now = stable_now()
         browser = Browser(self.app)
         browser.open(self.portal.absolute_url() + '/rss.png')
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowserAndProxy
-        self.assertEqual('max-age=86400, proxy-revalidate, public', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=86400, proxy-revalidate, public',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
         timedelta = dateutil.parser.parse(browser.headers['Expires']) - now
         self.assertTrue(timedelta > datetime.timedelta(seconds=86390))
@@ -402,7 +476,8 @@ def test_resources(self):
         browser.addHeader('If-Modified-Since', lastmodified)
         browser.open(self.portal.absolute_url() + '/rss.png')
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should be a 304 response
         self.assertEqual('304 Not Modified', browser.headers['Status'])
         self.assertEqual('', browser.contents)
@@ -414,17 +489,22 @@ def test_resources(self):
         # large Resource Registry cooked files, which all use the same
         # method to initiate a streamed response.
         s = "a" * (1 << 16) * 3
-        self.portal.manage_addFile('bigfile', file=StringIO(s), content_type='application/octet-stream')
+        self.portal.manage_addFile('bigfile', file=StringIO(
+            s), content_type='application/octet-stream')
 
-        import transaction; transaction.commit()
+        import transaction
+        transaction.commit()
 
         browser = Browser(self.app)
         browser.open(self.portal['bigfile'].absolute_url())
         self.assertEqual('plone.resource', browser.headers['X-Cache-Rule'])
-        self.assertEqual('plone.app.caching.strongCaching', browser.headers['X-Cache-Operation'])
+        self.assertEqual('plone.app.caching.strongCaching',
+                         browser.headers['X-Cache-Operation'])
         # This should use cacheInBrowserAndProxy
-        self.assertEqual('max-age=86400, proxy-revalidate, public', browser.headers['Cache-Control'])
-        self.assertFalse(None == browser.headers.get('Last-Modified'))  # remove this when the next line works
+        self.assertEqual('max-age=86400, proxy-revalidate, public',
+                         browser.headers['Cache-Control'])
+        # remove this when the next line works
+        self.assertFalse(None == browser.headers.get('Last-Modified'))
         #self.assertEqual('---lastmodified---', browser.headers['Last-Modified'])
         timedelta = dateutil.parser.parse(browser.headers['Expires']) - now
         self.assertTrue(timedelta > datetime.timedelta(seconds=86390))
diff --git a/plone/app/caching/tests/test_purge.py b/plone/app/caching/tests/test_purge.py
index d35cc2e..3435d5b 100644
--- a/plone/app/caching/tests/test_purge.py
+++ b/plone/app/caching/tests/test_purge.py
@@ -1,48 +1,39 @@
-import unittest2 as unittest
+# -*- coding: utf-8 -*-
+from Acquisition import aq_base
+from Acquisition import Explicit
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.app.caching.purge import ContentPurgePaths
+from plone.app.caching.purge import DiscussionItemPurgePaths
+from plone.app.caching.purge import ObjectFieldPurgePaths
+from plone.app.caching.purge import purgeOnModified
+from plone.app.caching.purge import purgeOnMovedOrRemoved
+from plone.registry import Registry
+from plone.registry.fieldfactory import persistentFieldAdapter
+from plone.registry.interfaces import IRegistry
 from plone.testing.zca import UNIT_TESTING
-
-from zope.interface import implementer
-
-from zope.component import getUtility
+from Products.Archetypes import atapi
+from Products.Archetypes.Schema.factory import instanceSchemaFactory
+from Products.CMFCore.interfaces import IContentish
+from Products.CMFCore.interfaces import IDiscussionResponse
+from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+from z3c.caching.interfaces import IPurgeEvent
+from z3c.caching.interfaces import IPurgePaths
 from zope.component import adapter
-from zope.component import adapts
+from zope.component import getUtility
+from zope.component import provideAdapter
 from zope.component import provideHandler
 from zope.component import provideUtility
-from zope.component import provideAdapter
-
 from zope.component.event import objectEventNotify
-
 from zope.event import notify
-
-from zope.lifecycleevent import ObjectModifiedEvent
+from zope.globalrequest import setRequest
+from zope.interface import implementer
 from zope.lifecycleevent import ObjectAddedEvent
-from zope.lifecycleevent import ObjectRemovedEvent
+from zope.lifecycleevent import ObjectModifiedEvent
 from zope.lifecycleevent import ObjectMovedEvent
+from zope.lifecycleevent import ObjectRemovedEvent
 
-from zope.globalrequest import setRequest
-
-from plone.registry.interfaces import IRegistry
-from plone.registry.fieldfactory import persistentFieldAdapter
-from plone.registry import Registry
-
-from z3c.caching.interfaces import IPurgeEvent
-from z3c.caching.interfaces import IPurgePaths
-
-from plone.app.caching.interfaces import IPloneCacheSettings
-
-from Acquisition import Explicit, aq_base
-from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
-from Products.CMFCore.interfaces import IContentish
-from Products.CMFCore.interfaces import IDiscussionResponse
-from Products.Archetypes import atapi
-from Products.Archetypes.Schema.factory import instanceSchemaFactory
-
-from plone.app.caching.purge import purgeOnModified
-from plone.app.caching.purge import purgeOnMovedOrRemoved
+import unittest2 as unittest
 
-from plone.app.caching.purge import ContentPurgePaths
-from plone.app.caching.purge import DiscussionItemPurgePaths
-from plone.app.caching.purge import ObjectFieldPurgePaths
 
 class Handler(object):
 
@@ -53,9 +44,11 @@ def __init__(self):
     def handler(self, event):
         self.invocations.append(event)
 
+
 class FauxRequest(dict):
     pass
 
+
 @implementer(IContentish)
 class FauxNonContent(Explicit):
 
@@ -76,6 +69,7 @@ def virtual_url_path(self):
     def getPhysicalPath(self):
         return ('', )
 
+
 @implementer(IBrowserDefault)
 class FauxContent(FauxNonContent):
 
@@ -84,10 +78,12 @@ class FauxContent(FauxNonContent):
     def defaultView(self):
         return 'default-view'
 
+
 @implementer(IDiscussionResponse)
 class FauxDiscussable(Explicit):
     pass
 
+
 class TestPurgeRedispatch(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -159,6 +155,7 @@ def test_removed(self):
         self.assertEqual(1, len(self.handler.invocations))
         self.assertEqual(context, self.handler.invocations[0].object)
 
+
 class TestContentPurgePaths(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -183,19 +180,29 @@ def test_parent_not_default_view(self):
         context = FauxContent('foo').__of__(FauxContent('bar'))
         purger = ContentPurgePaths(context)
 
-        self.assertEqual(['/bar/foo/', '/bar/foo/view', '/bar/foo/default-view'],
-                         list(purger.getRelativePaths()))
+        self.assertEqual(
+            ['/bar/foo/', '/bar/foo/view', '/bar/foo/default-view'],
+            list(purger.getRelativePaths())
+        )
         self.assertEqual([], list(purger.getAbsolutePaths()))
 
     def test_parent_default_view(self):
         context = FauxContent('default-view').__of__(FauxContent('bar'))
         purger = ContentPurgePaths(context)
-
-        self.assertEqual(['/bar/default-view/', '/bar/default-view/view',
-                          '/bar/default-view/default-view', '/bar', '/bar/', '/bar/view'],
-                         list(purger.getRelativePaths()))
+        self.assertEqual(
+            [
+                '/bar/default-view/',
+                '/bar/default-view/view',
+                '/bar/default-view/default-view',
+                '/bar',
+                '/bar/',
+                '/bar/view'
+            ],
+            list(purger.getRelativePaths())
+        )
         self.assertEqual([], list(purger.getAbsolutePaths()))
 
+
 class TestDiscussionItemPurgePaths(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -203,8 +210,8 @@ class TestDiscussionItemPurgePaths(unittest.TestCase):
     def setUp(self):
 
         @implementer(IPurgePaths)
+        @adapter(FauxContent)
         class FauxContentPurgePaths(object):
-            adapts(FauxContent)
 
             def __init__(self, context):
                 self.context = context
@@ -289,6 +296,7 @@ def getDiscussionThread(self, item):
         self.assertEqual(['/app/foo'], list(purge.getRelativePaths()))
         self.assertEqual(['/purgeme'], list(purge.getAbsolutePaths()))
 
+
 class TestObjectFieldPurgePaths(unittest.TestCase):
 
     maxDiff = None
@@ -316,7 +324,8 @@ class ATMultipleFields(atapi.BaseContent):
                 atapi.StringField('foo'),
                 atapi.FileField('file1'),
                 atapi.ImageField('image1'),
-                atapi.ImageField('image2', sizes={'mini': (50, 50), 'normal': (100, 100)}),
+                atapi.ImageField('image2', sizes={
+                                 'mini': (50, 50), 'normal': (100, 100)}),
                 BlobField('blob1'),
             ))
 
@@ -324,12 +333,24 @@ class ATMultipleFields(atapi.BaseContent):
         context = ATMultipleFields('foo').__of__(root)
         purger = ObjectFieldPurgePaths(context)
 
-        self.assertEqual(['/foo/download', '/foo/at_download',
-                          '/foo/at_download/file1', '/foo/file1',
-                          '/foo/at_download/image1', '/foo/image1', '/foo/image1_thumb',
-                          '/foo/at_download/image2', '/foo/image2', '/foo/image2_mini',
-                          '/foo/image2_normal', '/foo/at_download/blob1', '/foo/blob1'],
-                         list(purger.getRelativePaths()))
+        self.assertEqual(
+            [
+                '/foo/download',
+                '/foo/at_download',
+                '/foo/at_download/file1',
+                '/foo/file1',
+                '/foo/at_download/image1',
+                '/foo/image1',
+                '/foo/image1_thumb',
+                '/foo/at_download/image2',
+                '/foo/image2',
+                '/foo/image2_mini',
+                '/foo/image2_normal',
+                '/foo/at_download/blob1',
+                '/foo/blob1'
+            ],
+            list(purger.getRelativePaths())
+        )
         self.assertEqual([], list(purger.getAbsolutePaths()))
 
     def test_file_image_text_fields(self):
@@ -339,7 +360,8 @@ class ATMultipleFields(atapi.BaseContent):
                 atapi.StringField('foo'),
                 atapi.FileField('file1'),
                 atapi.ImageField('image1'),
-                atapi.ImageField('image2', sizes={'mini': (50, 50), 'normal': (100, 100)}),
+                atapi.ImageField('image2', sizes={
+                                 'mini': (50, 50), 'normal': (100, 100)}),
                 atapi.TextField('text'),
             ))
 
@@ -347,10 +369,20 @@ class ATMultipleFields(atapi.BaseContent):
         context = ATMultipleFields('foo').__of__(root)
         purger = ObjectFieldPurgePaths(context)
 
-        self.assertEqual(['/foo/download', '/foo/at_download',
-                          '/foo/at_download/file1', '/foo/file1',
-                          '/foo/at_download/image1', '/foo/image1', '/foo/image1_thumb',
-                          '/foo/at_download/image2', '/foo/image2', '/foo/image2_mini',
-                          '/foo/image2_normal'],
-                         list(purger.getRelativePaths()))
+        self.assertEqual(
+            [
+                '/foo/download',
+                '/foo/at_download',
+                '/foo/at_download/file1',
+                '/foo/file1',
+                '/foo/at_download/image1',
+                '/foo/image1',
+                '/foo/image1_thumb',
+                '/foo/at_download/image2',
+                '/foo/image2',
+                '/foo/image2_mini',
+                '/foo/image2_normal'
+            ],
+            list(purger.getRelativePaths())
+        )
         self.assertEqual([], list(purger.getAbsolutePaths()))
diff --git a/plone/app/caching/tests/test_utils.py b/plone/app/caching/tests/test_utils.py
index fd8261a..6d0c3ec 100644
--- a/plone/app/caching/tests/test_utils.py
+++ b/plone/app/caching/tests/test_utils.py
@@ -1,6 +1,6 @@
+# -*- coding: utf-8 -*-
 from Acquisition import Explicit
-from Products.CMFCore.interfaces import IDynamicType
-from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+from datetime import datetime
 from plone.app.caching.interfaces import IPloneCacheSettings
 from plone.app.caching.utils import getObjectDefaultView
 from plone.app.caching.utils import isPurged
@@ -8,8 +8,11 @@
 from plone.registry.fieldfactory import persistentFieldAdapter
 from plone.registry.interfaces import IRegistry
 from plone.testing.zca import UNIT_TESTING
-from datetime import datetime
-from zope.component import provideUtility, provideAdapter, getUtility
+from Products.CMFCore.interfaces import IDynamicType
+from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+from zope.component import getUtility
+from zope.component import provideAdapter
+from zope.component import provideUtility
 from zope.interface import implementer
 
 import pytz
@@ -38,16 +41,18 @@ def __init__(self, portal_type='testtype', defaultView='defaultView'):
     def defaultView(self):
         return self._defaultView
 
+
 class DummyNotContent(Explicit):
     pass
 
+
 class DummyFTI(object):
 
     def __init__(self, portal_type, viewAction=''):
         self.id = portal_type
         self._actions = {
-                'object/view': {'url': viewAction},
-            }
+            'object/view': {'url': viewAction},
+        }
 
     def getActionInfo(self, name):
         return self._actions[name]
@@ -59,6 +64,7 @@ def queryMethodID(self, id, default=None, context=None):
             return '@@defaultView'
         return default
 
+
 @implementer(IDynamicType)
 class DummyNotBrowserDefault(Explicit):
 
@@ -69,6 +75,7 @@ def __init__(self, portal_type='testtype', viewAction=''):
     def getTypeInfo(self):
         return DummyFTI(self.portal_type, self._viewAction)
 
+
 class TestIsPurged(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -118,6 +125,7 @@ def test_listed(self):
         content = DummyContent()
         self.assertEqual(True, isPurged(content))
 
+
 class TestGetObjectDefaultPath(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -135,7 +143,8 @@ def test_browserviewdefault(self):
         self.assertEqual('defaultView', getObjectDefaultView(context))
 
     def test_not_IBrowserDefault_methodid(self):
-        context = DummyNotBrowserDefault('testtype', 'string:${object_url}/view')
+        context = DummyNotBrowserDefault(
+            'testtype', 'string:${object_url}/view')
         self.assertEqual('defaultView', getObjectDefaultView(context))
 
     def test_not_IBrowserDefault_default_method(self):
@@ -143,5 +152,6 @@ def test_not_IBrowserDefault_default_method(self):
         self.assertEqual('defaultView', getObjectDefaultView(context))
 
     def test_not_IBrowserDefault_actiononly(self):
-        context = DummyNotBrowserDefault('testtype', 'string:${object_url}/defaultView')
+        context = DummyNotBrowserDefault(
+            'testtype', 'string:${object_url}/defaultView')
         self.assertEqual('defaultView', getObjectDefaultView(context))
diff --git a/plone/app/caching/utils.py b/plone/app/caching/utils.py
index ad37cc6..83a5a64 100644
--- a/plone/app/caching/utils.py
+++ b/plone/app/caching/utils.py
@@ -1,11 +1,11 @@
-from zope.component import queryUtility
-
-from plone.registry.interfaces import IRegistry
-from plone.app.caching.interfaces import IPloneCacheSettings
-
+# -*- coding: utf-8 -*-
 from Acquisition import aq_base
+from plone.app.caching.interfaces import IPloneCacheSettings
+from plone.registry.interfaces import IRegistry
 from Products.CMFCore.interfaces import IDynamicType
 from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+from zope.component import queryUtility
+
 
 def isPurged(object):
     """Determine if object is of a content type that should be purged.
@@ -27,6 +27,7 @@ def isPurged(object):
 
     return (portal_type in settings.purgedContentTypes)
 
+
 def stripLeadingCharacters(name):
     """Strip off leading / and/or @@
     """
@@ -38,6 +39,7 @@ def stripLeadingCharacters(name):
 
     return name
 
+
 def getObjectDefaultView(context):
     """Get the id of an object's default view
     """
@@ -59,7 +61,7 @@ def getObjectDefaultView(context):
     fti = context.getTypeInfo()
     try:
         # XXX: This isn't quite right since it assumes the action starts
-        #with ${object_url}
+        # with ${object_url}
         action = fti.getActionInfo('object/view')['url'].split('/')[-1]
     except ValueError:
         # If the action doesn't exist, stop
@@ -67,9 +69,9 @@ def getObjectDefaultView(context):
 
     # Try resolving method aliases because we need a real template_id here
     if action:
-        action = fti.queryMethodID(action, default = action, context = context)
+        action = fti.queryMethodID(action, default=action, context=context)
     else:
-        action = fti.queryMethodID('(Default)', default = action,
-                                   context = context)
+        action = fti.queryMethodID('(Default)', default=action,
+                                   context=context)
 
     return stripLeadingCharacters(action)
diff --git a/setup.cfg b/setup.cfg
index 0278fad..ec22f27 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -10,3 +10,11 @@ upload-dir = docs/html
 ignore =
     bootstrap.py
     buildout.cfg
+
+[isort]
+force_alphabetical_sort=True
+force_single_line=True
+lines_after_imports=2
+line_length=200
+not_skip=__init__.py
+
diff --git a/setup.py b/setup.py
index 606c02c..3931ee1 100644
--- a/setup.py
+++ b/setup.py
@@ -2,63 +2,64 @@
 
 version = '1.2.13.dev0'
 
-setup(name='plone.app.caching',
-      version=version,
-      description="Plone UI and default rules for plone.caching/z3c.caching",
-      long_description=(open("README.rst").read() + "\n" +
-                        open("CHANGES.rst").read()),
-      classifiers=[
-          "Environment :: Web Environment",
-          "Framework :: Plone",
-          "Framework :: Plone :: 5.0",
-          "Framework :: Plone :: 5.1",
-          "Framework :: Zope2",
-          "License :: OSI Approved :: GNU General Public License (GPL)",
-          "Operating System :: OS Independent",
-          "Programming Language :: Python",
-          "Programming Language :: Python :: 2.7",
-      ],
-      keywords='plone caching',
-      author='Plone Foundation',
-      author_email='plone-developers@lists.sourceforge.net',
-      url='https://pypi.python.org/pypi/plone.app.caching',
-      license='GPL version 2',
-      packages=find_packages(exclude=['ez_setup']),
-      namespace_packages=['plone', 'plone.app'],
-      include_package_data=True,
-      zip_safe=False,
-      install_requires=[
-          'setuptools',
-          'python-dateutil',
-          'plone.caching',
-          'plone.cachepurging',
-          'plone.app.registry >= 1.0b5',
-          'zope.browserresource',
-          'zope.interface',
-          'zope.component',
-          'zope.publisher',
-          'zope.pagetemplate',
-          'plone.memoize',
-          'plone.protect',
-          'plone.registry >= 1.0b4',
-          'Products.CMFDynamicViewFTI',
-          'Products.GenericSetup',
-          'Products.CMFCore',
-          'Products.statusmessages',
-          'Zope2',
-          'Acquisition',
-          'plone.app.z3cform',
-          'z3c.form',
-          'z3c.zcmlhook',
-      ],
-      extras_require={
-          'test': [
-              'plone.app.contenttypes[test]',
-              'plone.app.testing',
-          ]
-      },
-      entry_points="""
-      [z3c.autoinclude.plugin]
-      target = plone
-      """,
-      )
+setup(
+    name='plone.app.caching',
+    version=version,
+    description='Plone UI and default rules for plone.caching/z3c.caching',
+    long_description=(open('README.rst').read() + '\n' +
+                      open('CHANGES.rst').read()),
+    classifiers=[
+        'Environment :: Web Environment',
+        'Framework :: Plone',
+        'Framework :: Plone :: 5.0',
+        'Framework :: Plone :: 5.1',
+        'Framework :: Zope2',
+        'License :: OSI Approved :: GNU General Public License (GPL)',
+        'Operating System :: OS Independent',
+        'Programming Language :: Python',
+        'Programming Language :: Python :: 2.7',
+    ],
+    keywords='plone caching',
+    author='Plone Foundation',
+    author_email='plone-developers@lists.sourceforge.net',
+    url='https://pypi.python.org/pypi/plone.app.caching',
+    license='GPL version 2',
+    packages=find_packages(exclude=['ez_setup']),
+    namespace_packages=['plone', 'plone.app'],
+    include_package_data=True,
+    zip_safe=False,
+    install_requires=[
+        'setuptools',
+        'python-dateutil',
+        'plone.caching',
+        'plone.cachepurging',
+        'plone.app.registry >= 1.0b5',
+        'zope.browserresource',
+        'zope.interface',
+        'zope.component',
+        'zope.publisher',
+        'zope.pagetemplate',
+        'plone.memoize',
+        'plone.protect',
+        'plone.registry >= 1.0b4',
+        'Products.CMFDynamicViewFTI',
+        'Products.GenericSetup',
+        'Products.CMFCore',
+        'Products.statusmessages',
+        'Zope2',
+        'Acquisition',
+        'plone.app.z3cform',
+        'z3c.form',
+        'z3c.zcmlhook',
+    ],
+    extras_require={
+        'test': [
+            'plone.app.contenttypes[test]',
+            'plone.app.testing',
+        ]
+    },
+    entry_points="""
+    [z3c.autoinclude.plugin]
+    target = plone
+    """,
+)


