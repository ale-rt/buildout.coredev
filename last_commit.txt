Repository: plone.namedfile


Branch: refs/heads/master
Date: 2016-04-18T21:09:38+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.namedfile/commit/f3f3bc39e433e7a41df20cdc5034b41c782288ab

Automatic image rotation based on Exif data

This change introduced straight foreward image rotation based on Exif Information on Jepg and Tiff Images.
It requires an external dependency: piexif, which allows reading and writing of Exif information.
piexif did work very smart together with Pillow.

Files changed:
M CHANGES.rst
M plone/namedfile/file.py
M plone/namedfile/utils.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index b975dd7..f35a798 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -11,6 +11,12 @@ Incompatibilities:
 New:
 
 - *add item here*
+- Add automatic image rotation baed on EXIF data for all images.
+  Based on piexif library and ideas of maartenkling and ezvirtual.
+  Choosen piexif as it allow read and write of exif data for future enhancements.
+  http://piexif.readthedocs.org/en/latest/
+  For Orientation examples and description see http://www.daveperrett.com/articles/2012/07/28/exif-orientation-handling-is-a-ghetto/ test data https://github.com/recurser/exif-orientation-examples
+  [loechel]
 
 Fixes:
 
diff --git a/plone/namedfile/file.py b/plone/namedfile/file.py
index bef3519..44b24d3 100644
--- a/plone/namedfile/file.py
+++ b/plone/namedfile/file.py
@@ -10,12 +10,15 @@
 from plone.namedfile.interfaces import INamedImage
 from plone.namedfile.interfaces import IStorage
 from plone.namedfile.utils import get_contenttype
+from plone.namedfile.utils import get_exif
+from plone.namedfile.utils import getImageInfo
+from plone.namedfile.utils import rotate_image
 from ZODB.blob import Blob
 from zope.component import getUtility
 from zope.interface import implementer
 from zope.schema.fieldproperty import FieldProperty
 
-import struct
+import piexif
 import transaction
 
 
@@ -266,14 +269,21 @@ class NamedImage(NamedFile):
     filename = FieldProperty(INamedFile['filename'])
 
     def __init__(self, data='', contentType='', filename=None):
-        self.contentType, self._width, self._height = getImageInfo(data)
-        self.data = data
         self.filename = filename
+        self._setData(data)
 
         # Allow override of the image sniffer
         if contentType:
             self.contentType = contentType
 
+        if contentType in ['image/jpeg', 'image/tiff']:
+            _exif_data = get_exif(data)
+            if _exif_data is not None:
+                orientation = _exif_data['0th'].get(piexif.ImageIFD.Orientation, 1)
+                if 1 < orientation <= 8:
+                    data = rotate_image(data)
+                self.exif_data = _exif_data
+
     def _setData(self, data):
         super(NamedImage, self)._setData(data)
 
@@ -288,81 +298,6 @@ def getImageSize(self):
     data = property(NamedFile._getData, _setData)
 
 
-def getImageInfo(data):
-    data = str(data)
-    size = len(data)
-    height = -1
-    width = -1
-    content_type = ''
-
-    # handle GIFs
-    if (size >= 10) and data[:6] in ('GIF87a', 'GIF89a'):
-        # Check to see if content_type is correct
-        content_type = 'image/gif'
-        w, h = struct.unpack('<HH', data[6:10])
-        width = int(w)
-        height = int(h)
-
-    # See PNG 2. Edition spec (http://www.w3.org/TR/PNG/)
-    # Bytes 0-7 are below, 4-byte chunk length, then 'IHDR'
-    # and finally the 4-byte width, height
-    elif (
-        (size >= 24) and data.startswith('\211PNG\r\n\032\n') and
-        (data[12:16] == 'IHDR')
-    ):
-        content_type = 'image/png'
-        w, h = struct.unpack('>LL', data[16:24])
-        width = int(w)
-        height = int(h)
-
-    # Maybe this is for an older PNG version.
-    elif (size >= 16) and data.startswith('\211PNG\r\n\032\n'):
-        # Check to see if we have the right content type
-        content_type = 'image/png'
-        w, h = struct.unpack('>LL', data[8:16])
-        width = int(w)
-        height = int(h)
-
-    # handle JPEGs
-    elif (size >= 2) and data.startswith('\377\330'):
-        content_type = 'image/jpeg'
-        jpeg = StringIO(data)
-        jpeg.read(2)
-        b = jpeg.read(1)
-        try:
-            w = -1
-            h = -1
-            while (b and ord(b) != 0xDA):
-                while (ord(b) != 0xFF):
-                    b = jpeg.read(1)
-                while (ord(b) == 0xFF):
-                    b = jpeg.read(1)
-                if (ord(b) >= 0xC0 and ord(b) <= 0xC3):
-                    jpeg.read(3)
-                    h, w = struct.unpack('>HH', jpeg.read(4))
-                    break
-                else:
-                    jpeg.read(int(struct.unpack('>H', jpeg.read(2))[0]) - 2)
-                b = jpeg.read(1)
-            width = int(w)
-            height = int(h)
-        except struct.error:
-            pass
-        except ValueError:
-            pass
-        except TypeError:
-            pass
-
-    # handle BMPs
-    elif (size >= 30) and data.startswith('BM'):
-        kind = struct.unpack('<H', data[14:16])[0]
-        if kind == 40:  # Windows 3.x bitmap
-            content_type = 'image/x-ms-bmp'
-            width, height = struct.unpack('<LL', data[18:26])
-
-    return content_type, width, height
-
-
 @implementer(INamedBlobFile)
 class NamedBlobFile(Persistent):
     """A file stored in a ZODB BLOB, with a filename"""
@@ -430,12 +365,21 @@ class NamedBlobImage(NamedBlobFile):
     """
 
     def __init__(self, data='', contentType='', filename=None):
-        super(NamedBlobImage, self).__init__(data, filename=filename)
+        super(NamedBlobImage, self).__init__(data, contentType=contentType, filename=filename)
 
         # Allow override of the image sniffer
         if contentType:
             self.contentType = contentType
 
+        if contentType in ['image/jpeg', 'image/tiff']:
+            exif_data = get_exif(self.data)
+            if exif_data is not None:
+                orientation = exif_data['0th'].get(piexif.ImageIFD.Orientation, 1)
+                if 1 < orientation <= 8:
+                    self.data, self._width, self._height, self.exif = rotate_image(self.data)
+                else:
+                    self.exif = exif_data
+
     def _setData(self, data):
         super(NamedBlobImage, self)._setData(data)
         firstbytes = self.getFirstBytes()
@@ -468,6 +412,5 @@ def getImageSize(self):
         if (self._width, self._height) != (-1, -1):
             return (self._width, self._height)
 
-        res = getImageInfo(self.data)
-        contentType, self._width, self._height = res
+        contentType, self._width, self._height = getImageInfo(self.data)
         return (self._width, self._height)
diff --git a/plone/namedfile/utils.py b/plone/namedfile/utils.py
index 08317b2..c4b3a08 100644
--- a/plone/namedfile/utils.py
+++ b/plone/namedfile/utils.py
@@ -1,11 +1,20 @@
 # -*- coding: utf-8 -*-
+
+from logging import getLogger
 from plone.namedfile.interfaces import IBlobby
+from StringIO import StringIO
 
 import mimetypes
 import os.path
+import piexif
+import PIL.Image
+import struct
 import urllib
 
 
+log = getLogger(__name__)
+
+
 try:
     # use this to stream data if we can
     from ZPublisher.Iterators import filestream_iterator
@@ -77,3 +86,154 @@ def stream_data(file):
         return filestream_iterator(filename, 'rb')
 
     return file.data
+
+
+def getImageInfo(data):
+    data = str(data)
+    size = len(data)
+    height = -1
+    width = -1
+    content_type = ''
+
+    # handle GIFs
+    if (size >= 10) and data[:6] in ('GIF87a', 'GIF89a'):
+        # Check to see if content_type is correct
+        content_type = 'image/gif'
+        w, h = struct.unpack('<HH', data[6:10])
+        width = int(w)
+        height = int(h)
+
+    # See PNG 2. Edition spec (http://www.w3.org/TR/PNG/)
+    # Bytes 0-7 are below, 4-byte chunk length, then 'IHDR'
+    # and finally the 4-byte width, height
+    elif (
+        (size >= 24) and data.startswith('\211PNG\r\n\032\n') and
+        (data[12:16] == 'IHDR')
+    ):
+        content_type = 'image/png'
+        w, h = struct.unpack('>LL', data[16:24])
+        width = int(w)
+        height = int(h)
+
+    # Maybe this is for an older PNG version.
+    elif (size >= 16) and data.startswith('\211PNG\r\n\032\n'):
+        # Check to see if we have the right content type
+        content_type = 'image/png'
+        w, h = struct.unpack('>LL', data[8:16])
+        width = int(w)
+        height = int(h)
+
+    # handle JPEGs
+    elif (size >= 2) and data.startswith('\377\330'):
+        content_type = 'image/jpeg'
+        jpeg = StringIO(data)
+        jpeg.read(2)
+        b = jpeg.read(1)
+        try:
+            w = -1
+            h = -1
+            while (b and ord(b) != 0xDA):
+                while (ord(b) != 0xFF):
+                    b = jpeg.read(1)
+                while (ord(b) == 0xFF):
+                    b = jpeg.read(1)
+                if (ord(b) >= 0xC0 and ord(b) <= 0xC3):
+                    jpeg.read(3)
+                    h, w = struct.unpack('>HH', jpeg.read(4))
+                    break
+                else:
+                    jpeg.read(int(struct.unpack('>H', jpeg.read(2))[0]) - 2)
+                b = jpeg.read(1)
+            width = int(w)
+            height = int(h)
+        except struct.error:
+            pass
+        except ValueError:
+            pass
+        except TypeError:
+            pass
+
+    # handle BMPs
+    elif (size >= 30) and data.startswith('BM'):
+        kind = struct.unpack('<H', data[14:16])[0]
+        if kind == 40:  # Windows 3.x bitmap
+            content_type = 'image/x-ms-bmp'
+            width, height = struct.unpack('<LL', data[18:26])
+
+    return content_type, width, height
+
+
+def get_exif(image):
+    if getattr(image, 'read', None):
+        exif_data = piexif.load(image.read())
+    else:
+        exif_data = piexif.load(image)
+    return exif_data
+
+
+def rotate_image(image_data, method=None, REQUEST=None):
+    if getattr(image_data, 'read', None):
+        img = PIL.Image.open(image_data)
+    else:
+        img = PIL.Image.open(StringIO(image_data))
+
+    if 'exif' in img.info:
+        exif_data = piexif.load(img.info['exif'])
+
+        if piexif.ImageIFD.Orientation in exif_data['0th']:
+            orientation = exif_data['0th'][piexif.ImageIFD.Orientation]
+    else:
+        width, height = im.size()
+        exif_data = {
+            '0th': {
+                piexif.ImageIFD.XResolution: (width, 1),
+                piexif.ImageIFD.YResolution: (height, 1),
+            }
+        }
+
+    if method is not None:
+        orientation = method
+
+    log.debug('Rotate image with input orientation: %s', orientation)
+
+    fmt = img.format
+    if orientation == 1:  # not transform necessary
+        #img = img
+        pass
+    elif orientation == 2:
+        img = img.transpose(PIL.Image.FLIP_LEFT_RIGHT)
+    elif orientation == 3:
+        #img = img.rotate(180)
+        img = img.transpose(PIL.Image.ROTATE_180)
+    elif orientation == 4:
+        #img = img.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT)
+        img = img.transpose(PIL.Image.ROTATE_180).transpose(PIL.Image.FLIP_LEFT_RIGHT)
+    elif orientation == 5:
+        #img = img.rotate(-90).transpose(PIL.Image.FLIP_LEFT_RIGHT)
+        img = img.transpose(PIL.Image.ROTATE_270).transpose(PIL.Image.FLIP_LEFT_RIGHT)
+        #exif_data['0th'][piexif.ImageIFD.XResolution], exif_data['0th'][piexif.ImageIFD.YResolution] = exif_data['0th'][piexif.ImageIFD.YResolution], exif_data['0th'][piexif.ImageIFD.XResolution]
+    elif orientation == 6:
+        #img = img.rotate(-90)
+        img = img.transpose(PIL.Image.ROTATE_270)
+        #exif_data['0th'][piexif.ImageIFD.XResolution], exif_data['0th'][piexif.ImageIFD.YResolution] = exif_data['0th'][piexif.ImageIFD.YResolution], exif_data['0th'][piexif.ImageIFD.XResolution]
+    elif orientation == 7:
+        #img = img.rotate(90).transpose(PIL.Image.FLIP_LEFT_RIGHT)
+        img = img.transpose(PIL.Image.ROTATE_90).transpose(PIL.Image.FLIP_LEFT_RIGHT)
+        #exif_data['0th'][piexif.ImageIFD.XResolution], exif_data['0th'][piexif.ImageIFD.YResolution] = exif_data['0th'][piexif.ImageIFD.YResolution], exif_data['0th'][piexif.ImageIFD.XResolution]
+    elif orientation == 8:
+        #img = img.rotate(90)
+        img = img.transpose(PIL.Image.ROTATE_90)
+        #exif_data['0th'][piexif.ImageIFD.XResolution], exif_data['0th'][piexif.ImageIFD.YResolution] = exif_data['0th'][piexif.ImageIFD.YResolution], exif_data['0th'][piexif.ImageIFD.XResolution]
+
+    exif_data['0th'][piexif.ImageIFD.Orientation] = 1  # delete orientation
+    #del(exif_data['0th'][piexif.ImageIFD.Orientation])
+
+    try:
+        exif_bytes = piexif.dump(exif_data)
+    except:
+        del(exif_data['Exif'][41729])  # This Elemnt piexif.ExifIFD.SceneType cause error on dump
+        exif_bytes = piexif.dump(exif_data)
+    output_image_data = StringIO()
+    img.save(output_image_data, format=fmt, exif=exif_bytes)
+    width, height = img.size
+    return output_image_data.getvalue(), width, height, exif_data
diff --git a/setup.py b/setup.py
index c1a84f2..a2eb11a 100644
--- a/setup.py
+++ b/setup.py
@@ -44,6 +44,7 @@
         'zope.copy',
         'zope.security',
         'zope.traversing',
+        'piexif',
     ],
     extras_require={
         'editor': ['plone.schemaeditor'],


