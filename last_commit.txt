Repository: plone.testing


Branch: refs/heads/master
Date: 2015-12-10T22:41:14+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/63437f94d3115cb5bfcc3c2741f3ae022440697b

changelog foo

Files changed:
M CHANGES.rst

diff --git a/CHANGES.rst b/CHANGES.rst
index 9ad20c9..58a6af1 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,7 +10,6 @@ New:
 
 Fixes:
 
-- *add item here*
 - Depend on zope.testrunner, which was moved out from
   zope.testing.testrunner.
   [thet]


Repository: plone.testing


Branch: refs/heads/master
Date: 2015-12-10T23:43:02+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/151405a3352b0f7f4b97a1c1ade2dfe4d54a6c0a

autopep8

Files changed:
M CHANGES.rst
M setup.py
M src/plone/__init__.py
M src/plone/testing/__init__.py
M src/plone/testing/_z2_testbrowser.py
M src/plone/testing/layer.py
M src/plone/testing/publisher.py
M src/plone/testing/security.py
M src/plone/testing/testing_zca.zcml
M src/plone/testing/testing_zca_more_specific.zcml
M src/plone/testing/tests.py
M src/plone/testing/z2.py
M src/plone/testing/zca.py
M src/plone/testing/zodb.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 58a6af1..6f107d8 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,6 +10,9 @@ New:
 
 Fixes:
 
+- PEP 8.
+  [thet]
+
 - Depend on zope.testrunner, which was moved out from
   zope.testing.testrunner.
   [thet]
diff --git a/setup.py b/setup.py
index 6fb36ff..90ed341 100644
--- a/setup.py
+++ b/setup.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 import os
 import os.path
 import sys
@@ -5,87 +6,88 @@
 
 version = '4.1.0.dev0'
 
-install_requires = ['setuptools',
-                    'zope.testing',
-                    ]
+install_requires = [
+    'setuptools',
+    'zope.testing',
+]
 
 
 if sys.version_info < (2, 7):
     install_requires.append('unittest2')
 
-tests_require = ['zope.component',
-                 'zope.interface',
-                 'zope.publisher',
-                 'zope.security',
-                 'zope.event',
-                 'zope.configuration',
-                 'zope.testbrowser',
-                 'zope.testrunner',
-                 'zope.app.publisher',  # XXX: Can probably go away in Zope 2.13
-                 'ZODB3',
-                 'Zope2',
-                 ]
+tests_require = [
+    'zope.component',
+    'zope.interface',
+    'zope.publisher',
+    'zope.security',
+    'zope.event',
+    'zope.configuration',
+    'zope.testbrowser',
+    'zope.testrunner',
+    'zope.app.publisher',  # XXX: Can probably go away in Zope 2.13
+    'ZODB3',
+    'Zope2',
+]
 
-setup(name='plone.testing',
-      version=version,
-      description="Testing infrastructure for Zope and Plone projects.",
-      long_description=(open(os.path.join("src", "plone", "testing", "README.rst")).read() + "\n\n" +
-                        open("CHANGES.rst").read() + "\n\n" +
-                        "Detailed documentation\n" +
-                        "======================\n\n" +
-                        open(os.path.join("src", "plone", "testing", "layer.txt")).read() + "\n\n" +
-                        open(os.path.join("src", "plone", "testing", "zca.txt")).read() + "\n\n" +
-                        open(os.path.join("src", "plone", "testing", "security.txt")).read() + "\n\n" +
-                        open(os.path.join("src", "plone", "testing", "publisher.txt")).read() + "\n\n" +
-                        open(os.path.join("src", "plone", "testing", "zodb.txt")).read()),
-      classifiers=[
-          "Environment :: Web Environment",
-          "Framework :: Plone",
-          "Framework :: Plone :: 4.2",
-          "Framework :: Plone :: 4.3",
-          "Framework :: Plone :: 5.0",
-          "Operating System :: OS Independent",
-          "Programming Language :: Python",
-          "Programming Language :: Python :: 2.6",
-          "Programming Language :: Python :: 2.7",
-          "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
-          "License :: OSI Approved :: BSD License",
-      ],
-      keywords='plone zope testing',
-      author='Plone Foundation',
-      author_email='plone-developers@lists.sourceforge.net',
-      url='https://github.com/plone/plone.testing',
-      license='BSD',
-      packages=find_packages('src'),
-      package_dir={'': 'src'},
-      namespace_packages=['plone'],
-      include_package_data=True,
-      zip_safe=False,
-      install_requires=install_requires,
-      tests_require=tests_require,
-      extras_require={
-          'test': tests_require,
-          'zodb': [
-                  'ZODB3',
-                  ],
-          'zca': [
-                  'zope.component',
-                  'zope.event',
-                  'zope.configuration',
-                  ],
-          'security': [
-                  'zope.security',
-                  ],
-          'publisher': [
-                  'zope.configuration',
-                  'zope.security',
-                  'zope.app.publisher',  # XXX: Can probably go away in Zope 2.13
-                  ],
-          'z2': [
-                  'Zope2',
-                  'zope.site',
-                  'zope.testbrowser',
-                  'zope.publisher',
-                  ],
-      },
-      )
+setup(
+    name='plone.testing',
+    version=version,
+    description="Testing infrastructure for Zope and Plone projects.",
+    long_description=(open(os.path.join("src", "plone", "testing", "README.rst")).read() + "\n\n" +
+                      open("CHANGES.rst").read() + "\n\n" +
+                      "Detailed documentation\n" +
+                      "======================\n\n" +
+                      open(os.path.join("src", "plone", "testing", "layer.txt")).read() + "\n\n" +
+                      open(os.path.join("src", "plone", "testing", "zca.txt")).read() + "\n\n" +
+                      open(os.path.join("src", "plone", "testing", "security.txt")).read() + "\n\n" +
+                      open(os.path.join("src", "plone", "testing", "publisher.txt")).read() + "\n\n" +
+                      open(os.path.join("src", "plone", "testing", "zodb.txt")).read()),
+    classifiers=[
+        "Environment :: Web Environment",
+        "Framework :: Plone",
+        "Framework :: Plone :: 4.2",
+        "Framework :: Plone :: 4.3",
+        "Framework :: Plone :: 5.0",
+        "Operating System :: OS Independent",
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 2.6",
+        "Programming Language :: Python :: 2.7",
+        "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
+        "License :: OSI Approved :: BSD License",
+    ],
+    keywords='plone zope testing',
+    author='Plone Foundation',
+    author_email='plone-developers@lists.sourceforge.net',
+    url='https://github.com/plone/plone.testing',
+    license='BSD',
+    packages=find_packages('src'),
+    package_dir={'': 'src'},
+    namespace_packages=['plone'],
+    include_package_data=True,
+    zip_safe=False,
+    install_requires=install_requires,
+    tests_require=tests_require,
+    extras_require={
+        'test': tests_require,
+        'zodb': ['ZODB3'],
+        'zca': [
+            'zope.component',
+            'zope.event',
+            'zope.configuration',
+        ],
+        'security': [
+            'zope.security',
+        ],
+        'publisher': [
+            'zope.configuration',
+            'zope.security',
+            'zope.app.publisher',  # XXX: Can probably go away in Zope 2.13
+        ],
+        'z2': [
+            'Zope2',
+            'zope.site',
+            'zope.testbrowser',
+            'zope.publisher',
+        ],
+    },
+)
diff --git a/src/plone/__init__.py b/src/plone/__init__.py
index de40ea7..68c04af 100644
--- a/src/plone/__init__.py
+++ b/src/plone/__init__.py
@@ -1 +1,2 @@
+# -*- coding: utf-8 -*-
 __import__('pkg_resources').declare_namespace(__name__)
diff --git a/src/plone/testing/__init__.py b/src/plone/testing/__init__.py
index c879a5d..a39d736 100644
--- a/src/plone/testing/__init__.py
+++ b/src/plone/testing/__init__.py
@@ -1,6 +1,4 @@
+# -*- coding: utf-8 -*-
 # Convenience imports
-
-from plone.testing.layer import (
-        Layer,
-        layered
-    )
+from plone.testing.layer import Layer    # noqa
+from plone.testing.layer import layered  # noqa
diff --git a/src/plone/testing/_z2_testbrowser.py b/src/plone/testing/_z2_testbrowser.py
index 14cce2c..8a230ee 100644
--- a/src/plone/testing/_z2_testbrowser.py
+++ b/src/plone/testing/_z2_testbrowser.py
@@ -1,15 +1,14 @@
-import sys
-import re
+# -*- coding: utf-8 -*-
+from cStringIO import StringIO
 import base64
+import mechanize
+import pkg_resources
+import re
 import rfc822
+import sys
 import urllib
 import urllib2
 
-from cStringIO import StringIO
-
-import mechanize
-import pkg_resources
-
 # Using a from-import here to avoid an AttributeError below when using
 # zope.testbrowser 4.x without zope.app.testing:
 from zope.testbrowser.testing import PublisherConnection, PublisherResponse
@@ -18,6 +17,7 @@
 
 try:
     pkg_resources.get_distribution('Zope2>=2.13')
+
     def get_cookies(request):
         return request.response._cookie_list()
 except (pkg_resources.VersionConflict, pkg_resources.DistributionNotFound):
@@ -31,15 +31,30 @@ class Browser(zope.testbrowser.browser.Browser):
     """
 
     def __init__(self, app, url=None):
-        super(Browser, self).__init__(url=url, mech_browser=Zope2MechanizeBrowser(app))
+        super(
+            Browser,
+            self).__init__(
+            url=url,
+            mech_browser=Zope2MechanizeBrowser(app))
+
 
 class Zope2MechanizeBrowser(mechanize.Browser):
     """A mechanize browser class that uses the Zope 2 publisher to talk HTTP
     """
 
-    default_schemes    = ['http']
-    default_others     = ['_http_error', '_http_request_upgrade', '_http_default_error']
-    default_features   = ['_redirect', '_cookies', '_referer', '_refresh','_equiv', '_basicauth', '_digestauth' ]
+    default_schemes = ['http']
+    default_others = [
+        '_http_error',
+        '_http_request_upgrade',
+        '_http_default_error']
+    default_features = [
+        '_redirect',
+        '_cookies',
+        '_referer',
+        '_refresh',
+        '_equiv',
+        '_basicauth',
+        '_digestauth']
 
     def __init__(self, app, *args, **kws):
 
@@ -52,6 +67,7 @@ def httpHandlerFactory():
                                if cls in mechanize.Browser.handler_classes]
         mechanize.Browser.__init__(self, *args, **kws)
 
+
 class Zope2HTTPHandler(urllib2.HTTPHandler):
     """A protocol handler that uses the Zope 2 publisher to talk HTTP
     """
@@ -65,6 +81,7 @@ def connectionFactory(host, timeout=None):
             return Zope2Connection(self.app, host, timeout=timeout)
         return self.do_open(connectionFactory, req)
 
+
 class Zope2Connection(PublisherConnection):
     """A urllib2-compatible connection that can talk to the Zope 2 publisher.
     """
@@ -92,9 +109,11 @@ def getresponse(self):
                 # only change non-literal header names
                 key = "%s%s" % (key[:1].upper(), key[1:])
                 start = 0
-                l = key.find('-',start)
+                l = key.find('-', start)
                 while l >= start:
-                    key = "%s-%s%s" % (key[:l],key[l+1:l+2].upper(),key[l+2:])
+                    key = "%s-%s%s" % (key[:l],
+                                       key[l + 1:l + 2].upper(),
+                                       key[l + 2:])
                     start = l + 1
                     l = key.find('-', start)
             headers.append((key, val))
@@ -109,6 +128,7 @@ def getresponse(self):
 
         return PublisherResponse(content, headers, status, reason)
 
+
 def saveState(func):
     """Save threadlocal state (security manager, local component site) before
     exectuting a decorated function, and restore it after.
@@ -128,10 +148,14 @@ def wrapped_func(*args, **kw):
     return wrapped_func
 
 HEADER_RE = re.compile('(\S+): (.+)$')
+
+
 def splitHeader(header):
     return HEADER_RE.match(header).group(1, 2)
 
 BASIC_RE = re.compile('Basic (.+)?:(.+)?$')
+
+
 def authHeader(header):
     match = BASIC_RE.match(header)
     if match:
@@ -144,6 +168,7 @@ def authHeader(header):
         return 'Basic %s' % auth[:-1]
     return header
 
+
 class Zope2Caller(object):
     """Functional testing caller that can execute HTTP requests via the
     Zope 2 publisher.
@@ -172,7 +197,7 @@ def setBody(self, body, title='', is_error=0, **kw):
         # Split off and parse the command line
         l = requestString.find('\n')
         commandLine = requestString[:l].rstrip()
-        requestString = requestString[l+1:]
+        requestString = requestString[l + 1:]
         method, url, protocol = commandLine.split()
 
         instream = StringIO(requestString)
@@ -189,14 +214,15 @@ def setBody(self, body, title='', is_error=0, **kw):
         elif len(p) == 2:
             [env['PATH_INFO'], env['QUERY_STRING']] = p
         else:
-            raise TypeError, ''
+            raise TypeError('')
 
         # If you followed closely, you notice that one part of the url
         # gets unquoted (PATH_INFO) while the other (QUERY_STRING)
         # doesn't That complies with what the ZSERVER does.
         env['PATH_INFO'] = urllib.unquote(env['PATH_INFO'])
 
-        headers = [splitHeader(header) for header in rfc822.Message(instream).headers]
+        headers = [splitHeader(header)
+                   for header in rfc822.Message(instream).headers]
 
         # Store request body without headers
         instream = StringIO(instream.read())
@@ -207,7 +233,7 @@ def setBody(self, body, title='', is_error=0, **kw):
                 name = 'HTTP_' + name
             env[name] = value.rstrip()
 
-        if env.has_key('HTTP_AUTHORIZATION'):
+        if 'HTTP_AUTHORIZATION' in env:
             env['HTTP_AUTHORIZATION'] = authHeader(env['HTTP_AUTHORIZATION'])
 
         outstream = StringIO()
@@ -218,7 +244,7 @@ def setBody(self, body, title='', is_error=0, **kw):
                        stdin=instream,
                        environ=env,
                        debug=not handle_errors,
-                      )
+                       )
 
         self.app._p_jar.sync()
 
diff --git a/src/plone/testing/layer.py b/src/plone/testing/layer.py
index a14592a..8d8d76d 100644
--- a/src/plone/testing/layer.py
+++ b/src/plone/testing/layer.py
@@ -1,11 +1,13 @@
+# -*- coding: utf-8 -*-
 import sys
 _marker = object()
 
+
 class ResourceManager(object):
     """Mixin class for resource managers.
     """
 
-    __bases__ = () # must be set as an instance variable by subclass
+    __bases__ = ()  # must be set as an instance variable by subclass
 
     def __init__(self):
         self._resources = {}
@@ -38,7 +40,7 @@ def __setitem__(self, key, value):
                 foundStack = True
 
                 foundStackItem = False
-                for idx in range(len(stack)-1, -1, -1):
+                for idx in range(len(stack) - 1, -1, -1):
                     if stack[idx][1] is self:
 
                         # This layer instance has already added an item to
@@ -52,7 +54,7 @@ def __setitem__(self, key, value):
                 # This layer instance does not have a stack item yet. Create
                 # a new one.
                 if not foundStackItem:
-                    stack.append([value, self,])
+                    stack.append([value, self, ])
 
                 # Note: We do not break here on purpose: it's possible
                 # that there is resource stack in another branch of the base
@@ -67,7 +69,7 @@ def __delitem__(self, key):
         for resourceManager in self.baseResolutionOrder:
             if key in getattr(resourceManager, '_resources', {}):
                 stack = resourceManager._resources[key]
-                for idx in range(len(stack)-1, -1, -1):
+                for idx in range(len(stack) - 1, -1, -1):
                     if stack[idx][1] is self:
                         del stack[idx]
 
@@ -101,11 +103,11 @@ def _mergeResourceManagers(self, seqs):
 
             i += 1
 
-            for seq in nonemptyseqs: # find merge candidates among seq heads
+            for seq in nonemptyseqs:  # find merge candidates among seq heads
                 cand = seq[0]
-                nothead=[s for s in nonemptyseqs if cand in s[1:]]
+                nothead = [s for s in nonemptyseqs if cand in s[1:]]
                 if nothead:
-                    cand=None #reject candidate
+                    cand = None  # reject candidate
                 else:
                     break
 
@@ -113,16 +115,17 @@ def _mergeResourceManagers(self, seqs):
                 raise TypeError(u"Inconsistent layer hierarchy!")
 
             res.append(cand)
-            for seq in nonemptyseqs: # remove cand
+            for seq in nonemptyseqs:  # remove cand
                 if seq[0] == cand:
                     del seq[0]
 
     def _resourceResolutionOrder(self, instance):
         return self._mergeResourceManagers(
-                [ [instance] ] +
-                map(self._resourceResolutionOrder, instance.__bases__) +
-                [ list(instance.__bases__) ]
-            )
+            [[instance]] +
+            map(self._resourceResolutionOrder, instance.__bases__) +
+            [list(instance.__bases__)]
+        )
+
 
 class Layer(ResourceManager):
     """A base class for layers.
@@ -151,10 +154,10 @@ def __init__(self, bases=None, name=None, module=None):
         """
 
         if self.__class__ is Layer and name is None:
-            raise ValueError('The `name` argument is required when instantiating `Layer` directly')
+            raise ValueError('The `name` argument is required when instantiating `Layer` directly')  # noqa
 
         if name is None and bases is not None:
-            raise ValueError('The `name`` argument is required when overriding bases with the `bases` argument')
+            raise ValueError('The `name`` argument is required when overriding bases with the `bases` argument')  # noqa
 
         super(Layer, self).__init__()
 
@@ -201,6 +204,7 @@ def testSetUp(self):
     def testTearDown(self):
         pass
 
+
 def layered(suite, layer, addLayerToDoctestGlobs=True):
     """Add the given layer to the given suite and return the suite.
 
@@ -214,7 +218,7 @@ def layered(suite, layer, addLayerToDoctestGlobs=True):
         for test in suite:
             if hasattr(test, '_dt_test'):
                 globs = test._dt_test.globs
-                if not 'layer' in globs:
+                if 'layer' not in globs:
                     globs['layer'] = layer
 
     return suite
diff --git a/src/plone/testing/publisher.py b/src/plone/testing/publisher.py
index 26de1df..555e035 100644
--- a/src/plone/testing/publisher.py
+++ b/src/plone/testing/publisher.py
@@ -1,8 +1,10 @@
+# -*- coding: utf-8 -*-
 """Helpers for working with common Zope publisher operations
 """
-
 from plone.testing import Layer
-from plone.testing import zca, security
+from plone.testing import security
+from plone.testing import zca
+
 
 class PublisherDirectives(Layer):
     """Enables the use of the ZCML directives from ``zope.app.publisher``
@@ -19,7 +21,8 @@ def setUp(self):
         from zope.configuration import xmlconfig
 
         # Stack a new configuration context
-        self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
+        self['configurationContext'] = context = zca.stackConfigurationContext(
+            self.get('configurationContext'))
 
         import zope.security
         xmlconfig.file('meta.zcml', zope.security, context=context)
diff --git a/src/plone/testing/security.py b/src/plone/testing/security.py
index 2cfbb72..28516e7 100644
--- a/src/plone/testing/security.py
+++ b/src/plone/testing/security.py
@@ -1,10 +1,11 @@
+# -*- coding: utf-8 -*-
 """Security helpers and layers
 """
-
 from plone.testing import Layer
 
 _checkersStack = []
 
+
 def pushCheckers():
     """Push the current set of security checkers onto a stack. You should
     normally do this during layer set-up, before loading any ZCML files that
@@ -17,6 +18,7 @@ def pushCheckers():
 
     _checkersStack.append(checker._checkers.copy())
 
+
 def popCheckers():
     """Pop the most recently pushed set of security checkers from the stack.
     You should normally do this during layer tear-down. You *must* keep calls
@@ -29,6 +31,7 @@ def popCheckers():
 
     checker._checkers = _checkersStack.pop()
 
+
 class Checkers(Layer):
     """Ensures correct isolation of security checkers in zope.security.
     """
diff --git a/src/plone/testing/testing_zca.zcml b/src/plone/testing/testing_zca.zcml
index b5c5170..417804c 100644
--- a/src/plone/testing/testing_zca.zcml
+++ b/src/plone/testing/testing_zca.zcml
@@ -1,6 +1,13 @@
-<configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
-    <include package="zope.component" file="meta.zcml" />
-    <utility factory=".tests.DummyUtility"
-             provides="zope.interface.Interface"
-             name="layer" />
+<configure
+    package="plone.testing"
+    xmlns="http://namespaces.zope.org/zope">
+
+  <include package="zope.component" file="meta.zcml" />
+
+  <utility
+      factory=".tests.DummyUtility"
+      provides="zope.interface.Interface"
+      name="layer"
+      />
+
 </configure>
diff --git a/src/plone/testing/testing_zca_more_specific.zcml b/src/plone/testing/testing_zca_more_specific.zcml
index 43ec7d5..a6f0692 100644
--- a/src/plone/testing/testing_zca_more_specific.zcml
+++ b/src/plone/testing/testing_zca_more_specific.zcml
@@ -1,5 +1,11 @@
-<configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
-    <utility factory=".tests.DummyUtility"
-             provides="zope.interface.Interface"
-             name="more_specific_layer" />
+<configure
+    package="plone.testing"
+    xmlns="http://namespaces.zope.org/zope">
+
+  <utility
+      factory=".tests.DummyUtility"
+      provides="zope.interface.Interface"
+      name="more_specific_layer"
+      />
+
 </configure>
diff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py
index 47f1876..a768614 100644
--- a/src/plone/testing/tests.py
+++ b/src/plone/testing/tests.py
@@ -1,6 +1,7 @@
+# -*- coding: utf-8 -*-
 try:
     import unittest2 as unittest
-except ImportError: # Python 2.7
+except ImportError:  # Python 2.7
     import unittest
 import doctest
 
@@ -20,20 +21,29 @@
 #
 # To get around this, we define a fake method and stick it into the globs for
 # the doctest.
+
+
 def _canOutrunKlingons(warpDrive):
     return warpDrive.maxSpeed > 8.0
 
+
 class DummyUtility(object):
+
     def __repr__(self):
         return "<Dummy utility>"
 
+
 class DummyView(object):
+
     def __init__(self, context, request):
         pass
+
     def __call__(self):
         return u""
 
+
 class DummyFile(SimpleItem):
+
     def __call__(self):
         path = get_distribution('plone.testing').location
         path = os.path.join(path, 'plone', 'testing', 'z2.txt')
@@ -44,12 +54,15 @@ def __call__(self):
         response.setHeader('Content-Length', os.path.getsize(path))
         return filestream_iterator(path)
 
+
 def setUp(self):
     zope.component.testing.setUp()
 
+
 def tearDown(self):
     zope.component.testing.tearDown()
 
+
 def test_suite():
     suite = unittest.TestSuite()
     suite.addTests([
@@ -66,7 +79,7 @@ def test_suite():
         ),
         doctest.DocFileSuite(
             'README.rst',
-            globs={'canOutrunKlingons': _canOutrunKlingons,},
+            globs={'canOutrunKlingons': _canOutrunKlingons, },
             setUp=setUp,
             tearDown=tearDown,
             optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,
diff --git a/src/plone/testing/z2.py b/src/plone/testing/z2.py
index 316f236..bb9e11c 100644
--- a/src/plone/testing/z2.py
+++ b/src/plone/testing/z2.py
@@ -1,12 +1,14 @@
+# -*- coding: utf-8 -*-
 """Zope2-specific helpers and layers
 """
-
-import contextlib
-import os
-
 from plone.testing import Layer
-from plone.testing import zodb
 from plone.testing import zca
+from plone.testing import zodb
+from zope.schema.vocabulary import getVocabularyRegistry
+from zope.schema.vocabulary import setVocabularyRegistry
+from Zope2.App.schema import Zope2VocabularyRegistry
+import contextlib
+import os
 
 try:
     from plone.testing._z2_testbrowser import Browser
@@ -14,10 +16,6 @@
     # Just in case zope.testbrowser causes an import error, don't break
     pass
 
-from zope.schema.vocabulary import getVocabularyRegistry
-from zope.schema.vocabulary import setVocabularyRegistry
-from Zope2.App.schema import Zope2VocabularyRegistry
-
 try:
     from OFS.metaconfigure import get_packages_to_initialize
     HAS_ZOPE213 = True
@@ -26,6 +24,7 @@
 
 _INSTALLED_PRODUCTS = {}
 
+
 def installProduct(app, productName, quiet=False, multiinit=False):
     """Install the Zope 2 product with the given name, so that it will show
     up in the Zope 2 control panel and have its ``initialize()`` hook called.
@@ -38,17 +37,14 @@ def installProduct(app, productName, quiet=False, multiinit=False):
     Note that products' ZCML is *not* loaded automatically, even if the
     product is in the Products namespace.
     """
-
-    import sys
-
-
-    from OFS.Folder import Folder
-    from OFS.Application import get_folder_permissions, get_products
-    from OFS.Application import install_product, install_package
-
     from App.class_init import InitializeClass
-
+    from OFS.Application import get_folder_permissions
+    from OFS.Application import get_products
+    from OFS.Application import install_package
+    from OFS.Application import install_product
+    from OFS.Folder import Folder
     import Products
+    import sys
 
     found = False
 
@@ -59,10 +55,21 @@ def installProduct(app, productName, quiet=False, multiinit=False):
         for priority, name, index, productDir in get_products():
             if ('Products.' + name) == productName:
 
-                install_product(app, productDir, name, [], get_folder_permissions(), raise_exc=1)
+                install_product(
+                    app,
+                    productDir,
+                    name,
+                    [],
+                    get_folder_permissions(),
+                    raise_exc=1)
                 InitializeClass(Folder)
 
-                _INSTALLED_PRODUCTS[productName] = (priority, name, index, productDir,)
+                _INSTALLED_PRODUCTS[productName] = (
+                    priority,
+                    name,
+                    index,
+                    productDir,
+                )
 
                 found = True
                 break
@@ -76,7 +83,8 @@ def installProduct(app, productName, quiet=False, multiinit=False):
             if module.__name__ == productName:
                 install_package(app, module, init_func, raise_exc=1)
                 if not HAS_ZOPE213:
-                    Products._packages_to_initialize.remove((module, init_func))
+                    Products._packages_to_initialize.remove(
+                        (module, init_func))
 
                 _INSTALLED_PRODUCTS[productName] = (module, init_func,)
 
@@ -88,6 +96,7 @@ def installProduct(app, productName, quiet=False, multiinit=False):
         sys.stderr.write("Could not install product %s\n" % productName)
         sys.stderr.flush()
 
+
 def uninstallProduct(app, productName, quiet=False):
     """Uninstall the given Zope 2 product. This is the inverse of
     ``installProduct()`` above.
@@ -130,12 +139,13 @@ def uninstallProduct(app, productName, quiet=False):
                         del cp[name]
 
                 # TODO: Also remove permissions from get_folder_permissions?
-                # Difficult to know if this would stomp on any other permissions
+                # Difficult to know if this would stomp on any other
+                # permissions
                 # InitializeClass(Folder)
 
                 found = True
                 break
-    elif productName in _INSTALLED_PRODUCTS: # must be a package
+    elif productName in _INSTALLED_PRODUCTS:  # must be a package
 
         module, init_func = _INSTALLED_PRODUCTS[productName]
         name = module.__name__
@@ -168,6 +178,7 @@ def uninstallProduct(app, productName, quiet=False):
         sys.stderr.write("Could not install product %s\n" % productName)
         sys.stderr.flush()
 
+
 def login(userFolder, userName):
     """Log in as the given user in the given user folder.
     """
@@ -181,6 +192,7 @@ def login(userFolder, userName):
         user = user.__of__(userFolder)
     newSecurityManager(None, user)
 
+
 def logout():
     """Log out, i.e. become anonymous
     """
@@ -188,6 +200,7 @@ def logout():
     from AccessControl.SecurityManagement import noSecurityManager
     noSecurityManager()
 
+
 def setRoles(userFolder, userId, roles):
     """Set the given user's roles to a tuple of roles.
     """
@@ -203,9 +216,9 @@ def setRoles(userFolder, userId, roles):
 def makeTestRequest(environ=None):
     """Return an HTTPRequest object suitable for testing views."""
     from sys import stdin, stdout
+    from zope.publisher.browser import setDefaultSkin
     from ZPublisher.HTTPRequest import HTTPRequest
     from ZPublisher.HTTPResponse import HTTPResponse
-    from zope.publisher.browser import setDefaultSkin
 
     if environ is None:
         environ = {}
@@ -272,18 +285,18 @@ def zopeApp(db=None, connection=None, environ=None):
     inner_exception = None
     try:
         yield app
-    except Exception, e:
+    except Exception as e:
         inner_exception = e
         try:
             transaction.abort()
-        except Exception, e:
+        except Exception as e:
             inner_exception = e
             raise
         raise
     else:
         try:
             transaction.commit()
-        except Exception, e:
+        except Exception as e:
             inner_exception = e
     finally:
         try:
@@ -297,6 +310,7 @@ def zopeApp(db=None, connection=None, environ=None):
             else:
                 raise
 
+
 # Startup layer - you probably don't want to use this one directly
 
 class Startup(Layer):
@@ -414,36 +428,48 @@ def setUpPatches(self):
         import Zope2.App.startup
 
         # Avoid expensive product import
-        def null_import_products(): pass
+        def null_import_products():
+            pass
         self._OFS_Application_import_products = OFS.Application.import_products
         OFS.Application.import_products = null_import_products
 
         # Avoid expensive product installation
-        def null_initialize(app): pass
+        def null_initialize(app):
+            pass
         self._OFS_Application_initialize = OFS.Application.initialize
         OFS.Application.initialize = null_initialize
 
         # Avoid expensive help registration
         try:
-            self._App_ProductContext_ProductContext_registerHelpTopic = App.ProductContext.ProductContext.registerHelpTopic
+            self._App_ProductContext_ProductContext_registerHelpTopic = App.ProductContext.ProductContext.registerHelpTopic  # noqa
         except AttributeError:
             # Zope 4
             pass
         else:
-            def null_register_topic(self,id,topic): pass
-            App.ProductContext.ProductContext.registerHelpTopic = null_register_topic
+            def null_register_topic(self, id, topic):
+                pass
+            App.ProductContext.ProductContext.registerHelpTopic = null_register_topic  # noqa
+
+            self._App_ProductContext_ProductContext_registerHelpTitle = App.ProductContext.ProductContext.registerHelpTitle  # noqa
 
-            self._App_ProductContext_ProductContext_registerHelpTitle = App.ProductContext.ProductContext.registerHelpTitle
-            def null_register_title(self,title): pass
-            App.ProductContext.ProductContext.registerHelpTitle = null_register_title
+            def null_register_title(self, title):
+                pass
+            App.ProductContext.ProductContext.registerHelpTitle = null_register_title  # noqa
 
-            self._App_ProductContext_ProductContext_registerHelp = App.ProductContext.ProductContext.registerHelp
-            def null_register_help(self,directory='',clear=1,title_re=None): pass
+            self._App_ProductContext_ProductContext_registerHelp = App.ProductContext.ProductContext.registerHelp  # noqa
+
+            def null_register_help(
+                    self,
+                    directory='',
+                    clear=1,
+                    title_re=None):
+                pass
             App.ProductContext.ProductContext.registerHelp = null_register_help
 
         # in Zope 2.13, prevent ZCML from loading during App startup
         if hasattr(Zope2.App.startup, 'load_zcml'):
-            def null_load_zcml(): pass
+            def null_load_zcml():
+                pass
             self._Zope2_App_startup_load_zcml = Zope2.App.startup.load_zcml
             Zope2.App.startup.load_zcml = null_load_zcml
 
@@ -461,17 +487,17 @@ def tearDownPatches(self):
         del self._OFS_Application_initialize
 
         try:
-            App.ProductContext.ProductContext.registerHelpTopic = self._App_ProductContext_ProductContext_registerHelpTopic
+            App.ProductContext.ProductContext.registerHelpTopic = self._App_ProductContext_ProductContext_registerHelpTopic  # noqa
         except AttributeError:
             # Zope 4
             pass
         else:
             del self._App_ProductContext_ProductContext_registerHelpTopic
 
-            App.ProductContext.ProductContext.registerHelpTitle = self._App_ProductContext_ProductContext_registerHelpTitle
+            App.ProductContext.ProductContext.registerHelpTitle = self._App_ProductContext_ProductContext_registerHelpTitle  # noqa
             del self._App_ProductContext_ProductContext_registerHelpTitle
 
-            App.ProductContext.ProductContext.registerHelp = self._App_ProductContext_ProductContext_registerHelp
+            App.ProductContext.ProductContext.registerHelp = self._App_ProductContext_ProductContext_registerHelp  # noqa
             del self._App_ProductContext_ProductContext_registerHelp
 
     def setUpThreads(self):
@@ -524,7 +550,9 @@ def setUpDatabase(self):
         # Layer a new storage for Zope 2 on top of the one from the base
         # layer, if there is one.
 
-        self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='Startup')
+        self['zodbDB'] = zodb.stackDemoStorage(
+            self.get('zodbDB'),
+            name='Startup')
 
         # Create a facade for the database object that will delegate to the
         # correct underlying database. This allows resource shadowing to work
@@ -551,7 +579,8 @@ class DBTab(Zope2.Startup.datatypes.DBTab):
             """
 
             def __init__(self, db):
-                self.db_factories = {'testing': None} # value is never used when we have an open db
+                # value is never used when we have an open db
+                self.db_factories = {'testing': None}
                 self.mount_paths = {'/': 'testing'}
                 self.databases = {'testing': db}
 
@@ -658,8 +687,10 @@ def tearDownBasicProducts(self):
         except ImportError:
             # Zope <= 2.12
             from Products.Five import fiveconfigure as metaconfigure
-        metaconfigure._register_monkies = list(set(metaconfigure._register_monkies))
-        metaconfigure._meta_type_regs = list(set(metaconfigure._meta_type_regs))
+        metaconfigure._register_monkies = list(
+            set(metaconfigure._register_monkies))
+        metaconfigure._meta_type_regs = list(
+            set(metaconfigure._meta_type_regs))
 
     def setUpZCML(self):
         """Load the basic ZCML configuration from Five. Exposes a resource
@@ -673,7 +704,8 @@ def setUpZCML(self):
         # Load something akin to the default site.zcml without actually auto-
         # loading products
 
-        self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
+        self['configurationContext'] = context = zca.stackConfigurationContext(
+            self.get('configurationContext'))
 
         from zope.configuration import xmlconfig
         xmlconfig.string("""\
@@ -720,6 +752,7 @@ def tearDownFive(self):
 
 STARTUP = Startup()
 
+
 # Basic integration and functional test and layers. These are the simplest
 # Zope 2 layers that are generally useful
 
@@ -744,7 +777,7 @@ class MyFixture(Layer):
             ...
 
         MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name='MyFixture')
-        MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name='MyFixture:Integration')
+        MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name='MyFixture:Integration')  # noqa
     """
 
     defaultBases = (STARTUP,)
@@ -804,6 +837,7 @@ def testTearDown(self):
 
 INTEGRATION_TESTING = IntegrationTesting()
 
+
 class FunctionalTesting(Layer):
     """An alternative to ``INTEGRATION_TESTING`` suitable for functional testing.
     This one pushes and pops a ``DemoStorage`` layer for each test. The
@@ -825,7 +859,7 @@ class MyFixture(Layer):
             ...
 
         MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name='MyFixture')
-        MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name='MyFixture:Functional')
+        MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name='MyFixture:Functional')  # noqa
     """
 
     defaultBases = (STARTUP,)
@@ -840,7 +874,9 @@ def testSetUp(self):
         # this layer, we can't just assign a new shadow. We therefore keep
         # track of the original so that we can restore it on tear-down.
 
-        self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='FunctionalTest')
+        self['zodbDB'] = zodb.stackDemoStorage(
+            self.get('zodbDB'),
+            name='FunctionalTest')
 
         # Save the app
 
@@ -894,6 +930,7 @@ def testTearDown(self):
 
 FUNCTIONAL_TESTING = FunctionalTesting()
 
+
 # More advanced functional testing - running ZServer and FTP server
 
 class ZServer(Layer):
@@ -931,9 +968,9 @@ def setUp(self):
         self.setUpServer()
 
         self.thread = Thread(
-                name="%s server" % self.__name__,
-                target=self.runner,
-            )
+            name="%s server" % self.__name__,
+            target=self.runner,
+        )
 
         self.thread.start()
         time.sleep(0.5)
@@ -963,7 +1000,11 @@ def setUpServer(self):
 
         zopeLog = logger.file_logger(log)
 
-        server = zhttp_server(ip=self.host, port=self.port, resolver=None, logger_object=zopeLog)
+        server = zhttp_server(
+            ip=self.host,
+            port=self.port,
+            resolver=None,
+            logger_object=zopeLog)
         zhttpHandler = zhttp_handler(module='Zope2', uri_base='')
         server.install_handler(zhttpHandler)
 
@@ -993,7 +1034,12 @@ def runner(self):
 ZSERVER_FIXTURE = ZServer()
 
 # Functional testing layer that uses the ZSERVER_FIXTURE
-ZSERVER = FunctionalTesting(bases=(ZSERVER_FIXTURE,), name="ZServer:Functional")
+ZSERVER = FunctionalTesting(
+    bases=(
+        ZSERVER_FIXTURE,
+    ),
+    name="ZServer:Functional")
+
 
 class FTPServer(ZServer):
     """FTP variant of the ZServer layer.
@@ -1031,7 +1077,11 @@ def setUpServer(self):
 
         zopeLog = logger.file_logger(log)
 
-        self.ftpServer = FTPServer('Zope2', ip=self.host, port=self.port, logger_object=zopeLog)
+        self.ftpServer = FTPServer(
+            'Zope2',
+            ip=self.host,
+            port=self.port,
+            logger_object=zopeLog)
 
     def tearDownServer(self):
         """Close the FTPServer socket
@@ -1043,4 +1093,8 @@ def tearDownServer(self):
 FTP_SERVER_FIXTURE = FTPServer()
 
 # Functional testing layer that uses the FTP_SERVER_FIXTURE
-FTP_SERVER = FunctionalTesting(bases=(FTP_SERVER_FIXTURE,), name="FTPServer:Functional")
+FTP_SERVER = FunctionalTesting(
+    bases=(
+        FTP_SERVER_FIXTURE,
+    ),
+    name="FTPServer:Functional")
diff --git a/src/plone/testing/zca.py b/src/plone/testing/zca.py
index 9ef7731..fb4f598 100644
--- a/src/plone/testing/zca.py
+++ b/src/plone/testing/zca.py
@@ -1,11 +1,12 @@
+# -*- coding: utf-8 -*-
 """Core Zope Component Architecture helpers and layers
 """
+from plone.testing import Layer
+from zope.configuration.config import ConfigurationMachine
 import logging
 
-logger = logging.getLogger('plone.testing.zca')
 
-from zope.configuration.config import ConfigurationMachine
-from plone.testing import Layer
+logger = logging.getLogger('plone.testing.zca')
 
 # Contains a stack of installed global registries (but not the default one)
 _REGISTRIES = []
@@ -48,8 +49,8 @@ def _hookRegistry(reg):
     else:
         localsitemanager.base = reg
 
-# Helper functions
 
+# Helper functions
 
 def pushGlobalRegistry(new=None):
     """Set a new global component registry that uses the current registry as
@@ -83,11 +84,13 @@ def pushGlobalRegistry(new=None):
     if new is None:
         name = 'test-stack-%d' % len(_REGISTRIES)
         new = globalregistry.BaseGlobalComponents(name=name, bases=(current,))
-        logger.debug("New component registry: %s based on %s", name, current.__name__)
+        logger.debug(
+            "New component registry: %s based on %s",
+            name,
+            current.__name__)
     else:
         logger.debug("Push component registry: %s", new.__name__)
 
-
     _REGISTRIES.append(new)
 
     # Monkey patch this into the three (!) places where zope.component
@@ -119,7 +122,7 @@ def popGlobalRegistry():
 
     if not _REGISTRIES or not _REGISTRIES[-1] is globalregistry.base:
         msg = ("popGlobalRegistry() called out of sync with "
-            "pushGlobalRegistry()")
+               "pushGlobalRegistry()")
         raise ValueError(msg)
 
     current = _REGISTRIES.pop()
@@ -159,7 +162,7 @@ def __init__(self, name):
 
     def __str__(self):
         return ('<zope.configuration.config.ConfigurationMachine object %s>'
-            % self.__name__)
+                % self.__name__)
 
     def __repr__(self):
         return self.__str__()
@@ -217,13 +220,13 @@ def stackConfigurationContext(context=None, name="not named"):
                     if Interface in info:
                         factory = info[Interface][u'']
                         newRegistry.register([interface], Interface, '',
-                            factory)
+                                             factory)
 
     logger.debug('Configuration context %s cloned from %s', clone, context)
     return clone
 
-# Layers
 
+# Layers
 
 class UnitTesting(Layer):
     """Zope Component Architecture unit testing sandbox: The ZCA is cleared
@@ -308,7 +311,7 @@ class ZCMLSandbox(Layer):
     defaultBases = (LAYER_CLEANUP,)
 
     def __init__(self, bases=None, name=None, module=None, filename=None,
-        package=None):
+                 package=None):
         super(ZCMLSandbox, self).__init__(bases, name, module)
         self.filename = filename
         self.package = package
@@ -327,7 +330,7 @@ def setUpZCMLFiles(self):
             raise ValueError("ZCML file name has not been provided.")
         if self.package is None:
             raise ValueError("The package that contains the ZCML file "
-                "has not been provided.")
+                             "has not been provided.")
         self.loadZCMLFile(self.filename, self.package)
 
     def loadZCMLFile(self, filename, package):
diff --git a/src/plone/testing/zodb.py b/src/plone/testing/zodb.py
index fd98cf3..6c041ce 100644
--- a/src/plone/testing/zodb.py
+++ b/src/plone/testing/zodb.py
@@ -1,8 +1,9 @@
+# -*- coding: utf-8 -*-
 """ZODB-specific helpers and layers
 """
-
 from plone.testing import Layer
 
+
 def stackDemoStorage(db=None, name=None):
     """Create a new DemoStorage that has the given database as a base.
     ``db`` may be none, in which case a base demo storage will be created.
@@ -11,7 +12,7 @@ def stackDemoStorage(db=None, name=None):
     The usual pattern in a layer is::
 
         def setUp(self):
-            self['zodbDB'] = stackDemoStorage(self.get('zodbDB'), name='mylayer')
+            self['zodbDB'] = stackDemoStorage(self.get('zodbDB'), name='mylayer')  # noqa
 
         def tearDown(self):
             self['zodbDB'].close()
@@ -28,6 +29,7 @@ def tearDown(self):
 
     return DB(storage)
 
+
 class EmptyZODB(Layer):
     """Set up a new ZODB database using ``DemoStorage``. The database object
     is available as the resource ``zodbDB``.
@@ -55,7 +57,7 @@ def tearDown(self):
 
     def testSetUp(self):
         self['zodbConnection'] = connection = self['zodbDB'].open()
-        self['zodbRoot']       = connection.root()
+        self['zodbRoot'] = connection.root()
 
         import transaction
         transaction.begin()


Repository: plone.testing


Branch: refs/heads/master
Date: 2015-12-10T23:44:21+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/b477e4d1b521b315fbbe26a20032221e7f31ec11

Rename all txt doctest files to rst.

Files changed:
A src/plone/testing/layer.rst
A src/plone/testing/publisher.rst
A src/plone/testing/security.rst
A src/plone/testing/z2.rst
A src/plone/testing/zca.rst
A src/plone/testing/zodb.rst
M CHANGES.rst
M MANIFEST.in
M README.rst
M setup.py
M src/plone/testing/README.rst
M src/plone/testing/tests.py
D src/plone/testing/layer.txt
D src/plone/testing/publisher.txt
D src/plone/testing/security.txt
D src/plone/testing/z2.txt
D src/plone/testing/zca.txt
D src/plone/testing/zodb.txt

diff --git a/CHANGES.rst b/CHANGES.rst
index 6f107d8..181f93c 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,6 +10,9 @@ New:
 
 Fixes:
 
+- Rename all txt doctest files to rst.
+  [thet]
+
 - PEP 8.
   [thet]
 
diff --git a/MANIFEST.in b/MANIFEST.in
index 2ab7cc5..c0525da 100644
--- a/MANIFEST.in
+++ b/MANIFEST.in
@@ -1,5 +1,4 @@
 include *.rst
-include *.txt
 
 recursive-include docs *
 recursive-include src *
diff --git a/README.rst b/README.rst
index 9773da5..e41f789 100644
--- a/README.rst
+++ b/README.rst
@@ -1 +1 @@
-# See src/plone/testing/README.txt
\ No newline at end of file
+# See src/plone/testing/README.rst
diff --git a/setup.py b/setup.py
index 90ed341..e062ea2 100644
--- a/setup.py
+++ b/setup.py
@@ -37,11 +37,11 @@
                       open("CHANGES.rst").read() + "\n\n" +
                       "Detailed documentation\n" +
                       "======================\n\n" +
-                      open(os.path.join("src", "plone", "testing", "layer.txt")).read() + "\n\n" +
-                      open(os.path.join("src", "plone", "testing", "zca.txt")).read() + "\n\n" +
-                      open(os.path.join("src", "plone", "testing", "security.txt")).read() + "\n\n" +
-                      open(os.path.join("src", "plone", "testing", "publisher.txt")).read() + "\n\n" +
-                      open(os.path.join("src", "plone", "testing", "zodb.txt")).read()),
+                      open(os.path.join("src", "plone", "testing", "layer.rst")).read() + "\n\n" +
+                      open(os.path.join("src", "plone", "testing", "zca.rst")).read() + "\n\n" +
+                      open(os.path.join("src", "plone", "testing", "security.rst")).read() + "\n\n" +
+                      open(os.path.join("src", "plone", "testing", "publisher.rst")).read() + "\n\n" +
+                      open(os.path.join("src", "plone", "testing", "zodb.rst")).read()),
     classifiers=[
         "Environment :: Web Environment",
         "Framework :: Plone",
diff --git a/src/plone/testing/README.rst b/src/plone/testing/README.rst
index c727322..d782c05 100644
--- a/src/plone/testing/README.rst
+++ b/src/plone/testing/README.rst
@@ -319,7 +319,7 @@ For example, ``plone.testing`` has the following layout::
     plone.testing/setup.py
     plone.testing/bootstrap.py
     plone.testing/buildout.cfg
-    plone.testing/README.txt
+    plone.testing/README.rst
     plone.testing/src/
     plone.testing/src/plone
     plone.testing/src/plone/__init__.py
diff --git a/src/plone/testing/layer.rst b/src/plone/testing/layer.rst
new file mode 100644
index 0000000..5ae6583
--- /dev/null
+++ b/src/plone/testing/layer.rst
@@ -0,0 +1,535 @@
+Layer base class
+----------------
+
+This package provides a layer base class which can be used by the test
+runner. It is available as a convenience import from the package root.
+
+    >>> from plone.testing import Layer
+
+A layer may be instantiated directly, though in this case the ``name``
+argument is required (see below).
+
+    >>> NULL_LAYER = Layer(name="Null layer")
+
+This is not very useful on its own. It has an empty list of bases, and each of
+the layer lifecycle methods does nothing.
+
+    >>> NULL_LAYER.__bases__
+    ()
+    >>> NULL_LAYER.__name__
+    'Null layer'
+    >>> NULL_LAYER.__module__
+    'plone.testing.layer'
+
+    >>> NULL_LAYER.setUp()
+    >>> NULL_LAYER.testSetUp()
+    >>> NULL_LAYER.tearDown()
+    >>> NULL_LAYER.testTearDown()
+
+Just about the only reason to use this directly (i.e. not as a base class) is
+to group together other layers.
+
+    >>> SIMPLE_LAYER = Layer(bases=(NULL_LAYER,), name="Simple layer", module='plone.testing.tests')
+
+Here, we've also set the module name directly. The default for all layers is
+to take the module name from the stack frame where the layer was instantiated.
+In doctests, that doesn't work, though, so we fall back on the module name of
+the layer class. The two are often the same, of course.
+
+This layer now has the bases, name and module we set:
+
+    >>> SIMPLE_LAYER.__bases__
+    (<Layer 'plone.testing.layer.Null layer'>,)
+
+    >>> SIMPLE_LAYER.__name__
+    'Simple layer'
+
+    >>> SIMPLE_LAYER.__module__
+    'plone.testing.tests'
+
+The ``name`` argument is required when using ``Layer`` directly (but not
+when using a subclass):
+
+    >>> Layer((SIMPLE_LAYER,))
+    Traceback (most recent call last):
+    ...
+    ValueError: The `name` argument is required when instantiating `Layer` directly
+
+    >>> class NullLayer(Layer):
+    ...     pass
+    >>> NullLayer()
+    <Layer '__builtin__.NullLayer'>
+
+Using ``Layer`` as a base class
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The usual pattern is to use ``Layer`` as a base class for a custom layer.
+This can then override the lifecycle methods as appropriate, as well as
+set a default list of bases.
+
+    >>> class BaseLayer(Layer):
+    ...
+    ...     def setUp(self):
+    ...         print "Setting up base layer"
+    ...
+    ...     def tearDown(self):
+    ...         print "Tearing down base layer"
+
+    >>> BASE_LAYER = BaseLayer()
+
+The layer name and module are taken from the class.
+
+    >>> BASE_LAYER.__bases__
+    ()
+    >>> BASE_LAYER.__name__
+    'BaseLayer'
+    >>> BASE_LAYER.__module__
+    '__builtin__'
+
+We can now create a new layer that has this one as a base. We can do this in
+the instance constructor, as shown above, but the most common pattern is to
+set the default bases in the class body, using the variable ``defaultBases``.
+
+We'll also set the default name explicitly here by passing a name to the the
+super-constructor. This is mostly cosmetic, but may be desirable if the class
+name would be misleading in the test runner output.
+
+    >>> class ChildLayer(Layer):
+    ...     defaultBases = (BASE_LAYER,)
+    ...
+    ...     def __init__(self, bases=None, name='Child layer', module=None):
+    ...         super(ChildLayer, self).__init__(bases, name, module)
+    ...
+    ...     def setUp(self):
+    ...         print "Setting up child layer"
+    ...
+    ...     def tearDown(self):
+    ...         print "Tearing down child layer"
+
+    >>> CHILD_LAYER = ChildLayer()
+
+Notice how the bases have now been set using the value in ``defaultBases``.
+
+    >>> CHILD_LAYER.__bases__
+    (<Layer '__builtin__.BaseLayer'>,)
+    >>> CHILD_LAYER.__name__
+    'Child layer'
+    >>> CHILD_LAYER.__module__
+    '__builtin__'
+
+Overriding the default list of bases
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+We can override the list of bases on a per-instance basis. This may be
+dangerous, i.e. the layer is likely to expect that its bases are set up.
+Sometimes, it may be useful to inject a new base, however, especially when
+re-using layers from other packages.
+
+The new list of bases is passed to the constructor. When creating a second
+instance of a layer (most layers are global singletons created only once),
+it's useful to give the new instance a unique name, too.
+
+    >>> NEW_CHILD_LAYER = ChildLayer(bases=(SIMPLE_LAYER, BASE_LAYER,), name='New child')
+
+    >>> NEW_CHILD_LAYER.__bases__
+    (<Layer 'plone.testing.tests.Simple layer'>, <Layer '__builtin__.BaseLayer'>)
+    >>> NEW_CHILD_LAYER.__name__
+    'New child'
+    >>> NEW_CHILD_LAYER.__module__
+    '__builtin__'
+
+Inconsistent bases
+~~~~~~~~~~~~~~~~~~
+
+Layer bases are maintained in an order that is semantically equivalent to the
+"method resolution order" Python maintains for base classes. We can get this
+from the ``baseResolutionOrder`` attribute:
+
+    >>> CHILD_LAYER.baseResolutionOrder
+    (<Layer '__builtin__.Child layer'>, <Layer '__builtin__.BaseLayer'>)
+
+    >>> NEW_CHILD_LAYER.baseResolutionOrder
+    (<Layer '__builtin__.New child'>, <Layer 'plone.testing.tests.Simple layer'>,
+     <Layer 'plone.testing.layer.Null layer'>,
+     <Layer '__builtin__.BaseLayer'>)
+
+As with Python classes, it is possible to construct an invalid set of bases.
+In this case, layer instantiation will fail.
+
+    >>> INCONSISTENT_BASE1 = Layer(name="Inconsistent 1")
+    >>> INCONSISTENT_BASE2 = Layer((INCONSISTENT_BASE1,), name="Inconsistent 1")
+    >>> INCONSISTENT_BASE3 = Layer((INCONSISTENT_BASE1, INCONSISTENT_BASE2,), name="Inconsistent 1")
+    Traceback (most recent call last):
+    ...
+    TypeError: Inconsistent layer hierarchy!
+
+Using the resource manager
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Layers are also resource managers. Resources can be set, retrieved and
+deleted using dictionary syntax. Resources in base layers are available in
+child layers. When an item is set on a child layer, it shadows any items with
+the same key in any base layer (until it is deleted), but the original item
+still exists.
+
+Let's create a somewhat complex hierarchy of layers that all set resources
+under a key ``'foo'`` in their ``setUp()`` methods.
+
+    >>> class Layer1(Layer):
+    ...     def setUp(self):
+    ...         self['foo'] = 1
+    ...     def tearDown(self):
+    ...         del self['foo']
+    >>> LAYER1 = Layer1()
+
+    >>> class Layer2(Layer):
+    ...     defaultBases = (LAYER1,)
+    ...     def setUp(self):
+    ...         self['foo'] = 2
+    ...     def tearDown(self):
+    ...         del self['foo']
+    >>> LAYER2 = Layer2()
+
+    >>> class Layer3(Layer):
+    ...     def setUp(self):
+    ...         self['foo'] = 3
+    ...     def tearDown(self):
+    ...         del self['foo']
+    >>> LAYER3 = Layer3()
+
+    >>> class Layer4(Layer):
+    ...     defaultBases = (LAYER2, LAYER3,)
+    ...     def setUp(self):
+    ...         self['foo'] = 4
+    ...     def tearDown(self):
+    ...         del self['foo']
+    >>> LAYER4 = Layer4()
+
+    **Important:** Resources that are created in ``setUp()`` must be deleted
+    in ``tearDown()``. Similarly, resources created in ``testSetUp()`` must
+    be deleted in ``testTearDown()``. This ensures resources are properly
+    stacked and do not leak between layers.
+
+If a test was using ``LAYER4``, the test runner would call each setup step in
+turn, starting with the "deepest" layer. We'll simulate that here, so that
+each of the resources is created.
+
+    >>> LAYER1.setUp()
+    >>> LAYER2.setUp()
+    >>> LAYER3.setUp()
+    >>> LAYER4.setUp()
+
+The layers are ordered in a known "resource resolution order", which is used
+to determine in which order the layers shadow one another. This is based on
+the same algorithm as Python's method resolution order.
+
+    >>> LAYER4.baseResolutionOrder
+    (<Layer '__builtin__.Layer4'>,
+     <Layer '__builtin__.Layer2'>,
+     <Layer '__builtin__.Layer1'>,
+     <Layer '__builtin__.Layer3'>)
+
+When fetching and item from a layer, it will be obtained according to the
+resource resolution order.
+
+    >>> LAYER4['foo']
+    4
+
+This is not terribly interesting, since ``LAYER4`` has the resource ``'foo'``
+set directly. Let's tear down the layer (which deletes the resource) and see
+what happens.
+
+    >>> LAYER4.tearDown()
+    >>> LAYER4['foo']
+    2
+
+We can continue up the chain:
+
+    >>> LAYER2.tearDown()
+    >>> LAYER4['foo']
+    1
+
+    >>> LAYER1.tearDown()
+    >>> LAYER4['foo']
+    3
+
+Once we've deleted the last key, we'll get a ``KeyError``:
+
+    >>> LAYER3.tearDown()
+    >>> LAYER4['foo']
+    Traceback (most recent call last):
+    ...
+    KeyError: 'foo'
+
+To guard against this, we can use the ``get()`` method.
+
+    >>> LAYER4.get('foo', -1)
+    -1
+
+We can also test with 'in':
+
+    >>> 'foo' in LAYER4
+    False
+
+To illustrate that this indeed works, let's set the resource back on one
+of the bases.
+
+    >>> LAYER3['foo'] = 10
+    >>> LAYER4.get('foo', -1)
+    10
+
+Let's now consider a special case: a base layer sets up a resource in layer
+setup, and uses it in test setup. A child layer then shadows this resource in
+its own layer setup method. In this case, we want the base layer's
+``testSetUp()`` to use the shadowed version that the child provided.
+
+(This is similar to how instance variables work: a base class may set an
+attribute on ``self`` and use it in a method. If a subclass then sets the same
+attribute to a different value and the base class method is called on an
+instance of the subclass, the base class attribute is used).
+
+    *Hint:* If you definitely need to access the "original" resource in your
+    ``testSetUp()``/``testTearDown()`` methods, you can store a reference to
+    the resource as a layer instance variable::
+
+        self.someResource = self['someResource'] = SomeResource()
+
+    ``self.someResource`` will now be the exact resource created here, whereas
+    ``self['someResource']`` will retain the layer shadowing semantics. In
+    most cases, you probably *don't* want to do this, allowing child layers to
+    supply overridden versions of resources as appropriate.
+
+First, we'll create some base layers. We want to demonstrate having two
+"branches" of bases that both happen to define the same resource.
+
+    >>> class ResourceBaseLayer1(Layer):
+    ...     def setUp(self):
+    ...         self['resource'] = "Base 1"
+    ...     def testSetUp(self):
+    ...         print self['resource']
+    ...     def tearDown(self):
+    ...         del self['resource']
+
+    >>> RESOURCE_BASE_LAYER1 = ResourceBaseLayer1()
+
+    >>> class ResourceBaseLayer2(Layer):
+    ...     defaultBases = (RESOURCE_BASE_LAYER1,)
+    ...     def testSetUp(self):
+    ...         print self['resource']
+
+    >>> RESOURCE_BASE_LAYER2 = ResourceBaseLayer2()
+
+    >>> class ResourceBaseLayer3(Layer):
+    ...     def setUp(self):
+    ...         self['resource'] = "Base 3"
+    ...     def testSetUp(self):
+    ...         print self['resource']
+    ...     def tearDown(self):
+    ...         del self['resource']
+
+    >>> RESOURCE_BASE_LAYER3 = ResourceBaseLayer3()
+
+We'll then create the child layer that overrides this resource.
+
+    >>> class ResourceChildLayer(Layer):
+    ...     defaultBases = (RESOURCE_BASE_LAYER2, RESOURCE_BASE_LAYER3)
+    ...     def setUp(self):
+    ...         self['resource'] = "Child"
+    ...     def testSetUp(self):
+    ...         print self['resource']
+    ...     def tearDown(self):
+    ...         del self['resource']
+
+    >>> RESOURCE_CHILD_LAYER = ResourceChildLayer()
+
+We'll first set up the base layers on their own and simulate two tests.
+
+A test with RESOURCE_BASE_LAYER1 only would look like this:
+
+    >>> RESOURCE_BASE_LAYER1.setUp()
+
+    >>> RESOURCE_BASE_LAYER1.testSetUp()
+    Base 1
+    >>> RESOURCE_BASE_LAYER1.testTearDown()
+
+    >>> RESOURCE_BASE_LAYER1.tearDown()
+
+A test with RESOURCE_BASE_LAYER2 would look like this:
+
+    >>> RESOURCE_BASE_LAYER1.setUp()
+    >>> RESOURCE_BASE_LAYER2.setUp()
+
+    >>> RESOURCE_BASE_LAYER1.testSetUp()
+    Base 1
+    >>> RESOURCE_BASE_LAYER2.testSetUp()
+    Base 1
+    >>> RESOURCE_BASE_LAYER2.testTearDown()
+    >>> RESOURCE_BASE_LAYER1.testTearDown()
+
+    >>> RESOURCE_BASE_LAYER2.tearDown()
+    >>> RESOURCE_BASE_LAYER1.tearDown()
+
+A test with RESOURCE_BASE_LAYER3 only would look like this:
+
+    >>> RESOURCE_BASE_LAYER3.setUp()
+
+    >>> RESOURCE_BASE_LAYER3.testSetUp()
+    Base 3
+    >>> RESOURCE_BASE_LAYER3.testTearDown()
+
+    >>> RESOURCE_BASE_LAYER3.tearDown()
+
+Now let's set up the child layer and simulate another test. We should now be
+using the shadowed resource.
+
+    >>> RESOURCE_BASE_LAYER1.setUp()
+    >>> RESOURCE_BASE_LAYER2.setUp()
+    >>> RESOURCE_BASE_LAYER3.setUp()
+    >>> RESOURCE_CHILD_LAYER.setUp()
+
+    >>> RESOURCE_BASE_LAYER1.testSetUp()
+    Child
+    >>> RESOURCE_BASE_LAYER2.testSetUp()
+    Child
+    >>> RESOURCE_BASE_LAYER3.testSetUp()
+    Child
+    >>> RESOURCE_CHILD_LAYER.testSetUp()
+    Child
+
+    >>> RESOURCE_CHILD_LAYER.testTearDown()
+    >>> RESOURCE_BASE_LAYER3.testTearDown()
+    >>> RESOURCE_BASE_LAYER2.testTearDown()
+    >>> RESOURCE_BASE_LAYER1.testTearDown()
+
+Finally, we'll tear down the child layer again and simulate another test.
+we should have the original resources back. Note that the first and third
+layers no longer share a resource, since they don't have a common ancestor.
+
+    >>> RESOURCE_CHILD_LAYER.tearDown()
+
+    >>> RESOURCE_BASE_LAYER1.testSetUp()
+    Base 1
+    >>> RESOURCE_BASE_LAYER2.testSetUp()
+    Base 1
+    >>> RESOURCE_BASE_LAYER2.testTearDown()
+    >>> RESOURCE_BASE_LAYER1.testTearDown()
+
+    >>> RESOURCE_BASE_LAYER3.testSetUp()
+    Base 3
+    >>> RESOURCE_BASE_LAYER3.testTearDown()
+
+Finally, we'll tear down the remaining layers..
+
+    >>> RESOURCE_BASE_LAYER3.tearDown()
+    >>> RESOURCE_BASE_LAYER2.tearDown()
+    >>> RESOURCE_BASE_LAYER1.tearDown()
+
+Asymmetric deletion
++++++++++++++++++++
+
+It is an error to create or shadow a resource in a set-up lifecycle method and
+not delete it again in the tear-down. It is also an error to delete a resource
+that was not explicitly created. These two layers break those roles:
+
+    >>> class BadLayer1(Layer):
+    ...     def setUp(self):
+    ...         pass
+    ...     def tearDown(self):
+    ...         del self['foo']
+    >>> BAD_LAYER1 = BadLayer1()
+
+    >>> class BadLayer2(Layer):
+    ...     defaultBases = (BAD_LAYER1,)
+    ...     def setUp(self):
+    ...         self['foo'] = 1
+    ...         self['bar'] = 2
+    >>> BAD_LAYER2 = BadLayer2()
+
+Let's simulate a test that uses ``BAD_LAYER2``:
+
+    >>> BAD_LAYER1.setUp()
+    >>> BAD_LAYER2.setUp()
+
+    >>> BAD_LAYER1.testSetUp()
+    >>> BAD_LAYER2.testSetUp()
+
+    >>> BAD_LAYER2.testTearDown()
+    >>> BAD_LAYER1.testTearDown()
+
+    >>> BAD_LAYER2.tearDown()
+    >>> BAD_LAYER1.tearDown()
+    Traceback (most recent call last):
+    ...
+    KeyError: 'foo'
+
+Here, we've got an error in the base layer. This is because the resource
+is actually associated with the layer that first created it, in this case
+``BASE_LAYER2``. This one remains intact and orphaned:
+
+    >>> 'foo' in BAD_LAYER2._resources
+    True
+    >>> 'bar' in BAD_LAYER2._resources
+    True
+
+Doctest layer helper
+~~~~~~~~~~~~~~~~~~~~
+
+The ``doctest`` module is not aware of ``zope.testing``'s layers concept.
+Therefore, the syntax for creating a doctest with a layer and adding it to
+a test suite is somewhat contrived: the test suite has to be created first,
+and then the layer attribute set on it:
+
+    >>> class DoctestLayer(Layer):
+    ...     pass
+    >>> DOCTEST_LAYER = DoctestLayer()
+
+    >>> try:
+    ...     import unittest2 as unittest
+    ... except ImportError: # Python 2.7
+    ...     import unittest
+    >>> import doctest
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     layerDoctest = doctest.DocFileSuite('layer.rst', package='plone.testing')
+    ...     layerDoctest.layer = DOCTEST_LAYER
+    ...     suite.addTest(layerDoctest)
+    ...     return suite
+
+    >>> suite = test_suite()
+    >>> tests = list(suite)
+    >>> len(tests)
+    1
+    >>> tests[0].layer is DOCTEST_LAYER
+    True
+
+
+To make this a little easier - especially when setting up multiple tests -
+a helper function called ``layered`` is provided:
+
+    >>> from plone.testing import layered
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         layered(doctest.DocFileSuite('layer.rst', package='plone.testing'), layer=DOCTEST_LAYER),
+    ...         # repeat with more suites if necessary
+    ...     ])
+    ...     return suite
+
+This does the same as the sample above.
+
+    >>> suite = test_suite()
+    >>> tests = list(suite)
+    >>> len(tests)
+    1
+    >>> tests[0].layer is DOCTEST_LAYER
+    True
+
+In addition, a 'layer' glob is added to each test in the suite. This allows
+the test to access layer resources.
+
+    >>> len(list(tests[0]))
+    1
+    >>> list(tests[0])[0]._dt_test.globs['layer'] is DOCTEST_LAYER
+    True
diff --git a/src/plone/testing/layer.txt b/src/plone/testing/layer.txt
deleted file mode 100644
index 43aeee2..0000000
--- a/src/plone/testing/layer.txt
+++ /dev/null
@@ -1,535 +0,0 @@
-Layer base class
-----------------
-
-This package provides a layer base class which can be used by the test
-runner. It is available as a convenience import from the package root.
-
-    >>> from plone.testing import Layer
-
-A layer may be instantiated directly, though in this case the ``name``
-argument is required (see below).
-
-    >>> NULL_LAYER = Layer(name="Null layer")
-
-This is not very useful on its own. It has an empty list of bases, and each of
-the layer lifecycle methods does nothing.
-
-    >>> NULL_LAYER.__bases__
-    ()
-    >>> NULL_LAYER.__name__
-    'Null layer'
-    >>> NULL_LAYER.__module__
-    'plone.testing.layer'
-
-    >>> NULL_LAYER.setUp()
-    >>> NULL_LAYER.testSetUp()
-    >>> NULL_LAYER.tearDown()
-    >>> NULL_LAYER.testTearDown()
-
-Just about the only reason to use this directly (i.e. not as a base class) is
-to group together other layers.
-
-    >>> SIMPLE_LAYER = Layer(bases=(NULL_LAYER,), name="Simple layer", module='plone.testing.tests')
-
-Here, we've also set the module name directly. The default for all layers is
-to take the module name from the stack frame where the layer was instantiated.
-In doctests, that doesn't work, though, so we fall back on the module name of
-the layer class. The two are often the same, of course.
-
-This layer now has the bases, name and module we set:
-
-    >>> SIMPLE_LAYER.__bases__
-    (<Layer 'plone.testing.layer.Null layer'>,)
-
-    >>> SIMPLE_LAYER.__name__
-    'Simple layer'
-
-    >>> SIMPLE_LAYER.__module__
-    'plone.testing.tests'
-
-The ``name`` argument is required when using ``Layer`` directly (but not
-when using a subclass):
-
-    >>> Layer((SIMPLE_LAYER,))
-    Traceback (most recent call last):
-    ...
-    ValueError: The `name` argument is required when instantiating `Layer` directly
-
-    >>> class NullLayer(Layer):
-    ...     pass
-    >>> NullLayer()
-    <Layer '__builtin__.NullLayer'>
-
-Using ``Layer`` as a base class
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-The usual pattern is to use ``Layer`` as a base class for a custom layer.
-This can then override the lifecycle methods as appropriate, as well as
-set a default list of bases.
-
-    >>> class BaseLayer(Layer):
-    ...
-    ...     def setUp(self):
-    ...         print "Setting up base layer"
-    ...
-    ...     def tearDown(self):
-    ...         print "Tearing down base layer"
-
-    >>> BASE_LAYER = BaseLayer()
-
-The layer name and module are taken from the class.
-
-    >>> BASE_LAYER.__bases__
-    ()
-    >>> BASE_LAYER.__name__
-    'BaseLayer'
-    >>> BASE_LAYER.__module__
-    '__builtin__'
-
-We can now create a new layer that has this one as a base. We can do this in
-the instance constructor, as shown above, but the most common pattern is to
-set the default bases in the class body, using the variable ``defaultBases``.
-
-We'll also set the default name explicitly here by passing a name to the the
-super-constructor. This is mostly cosmetic, but may be desirable if the class
-name would be misleading in the test runner output.
-
-    >>> class ChildLayer(Layer):
-    ...     defaultBases = (BASE_LAYER,)
-    ...
-    ...     def __init__(self, bases=None, name='Child layer', module=None):
-    ...         super(ChildLayer, self).__init__(bases, name, module)
-    ...
-    ...     def setUp(self):
-    ...         print "Setting up child layer"
-    ...
-    ...     def tearDown(self):
-    ...         print "Tearing down child layer"
-
-    >>> CHILD_LAYER = ChildLayer()
-
-Notice how the bases have now been set using the value in ``defaultBases``.
-
-    >>> CHILD_LAYER.__bases__
-    (<Layer '__builtin__.BaseLayer'>,)
-    >>> CHILD_LAYER.__name__
-    'Child layer'
-    >>> CHILD_LAYER.__module__
-    '__builtin__'
-
-Overriding the default list of bases
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-We can override the list of bases on a per-instance basis. This may be
-dangerous, i.e. the layer is likely to expect that its bases are set up.
-Sometimes, it may be useful to inject a new base, however, especially when
-re-using layers from other packages.
-
-The new list of bases is passed to the constructor. When creating a second
-instance of a layer (most layers are global singletons created only once),
-it's useful to give the new instance a unique name, too.
-
-    >>> NEW_CHILD_LAYER = ChildLayer(bases=(SIMPLE_LAYER, BASE_LAYER,), name='New child')
-
-    >>> NEW_CHILD_LAYER.__bases__
-    (<Layer 'plone.testing.tests.Simple layer'>, <Layer '__builtin__.BaseLayer'>)
-    >>> NEW_CHILD_LAYER.__name__
-    'New child'
-    >>> NEW_CHILD_LAYER.__module__
-    '__builtin__'
-
-Inconsistent bases
-~~~~~~~~~~~~~~~~~~
-
-Layer bases are maintained in an order that is semantically equivalent to the
-"method resolution order" Python maintains for base classes. We can get this
-from the ``baseResolutionOrder`` attribute:
-
-    >>> CHILD_LAYER.baseResolutionOrder
-    (<Layer '__builtin__.Child layer'>, <Layer '__builtin__.BaseLayer'>)
-
-    >>> NEW_CHILD_LAYER.baseResolutionOrder
-    (<Layer '__builtin__.New child'>, <Layer 'plone.testing.tests.Simple layer'>,
-     <Layer 'plone.testing.layer.Null layer'>,
-     <Layer '__builtin__.BaseLayer'>)
-
-As with Python classes, it is possible to construct an invalid set of bases.
-In this case, layer instantiation will fail.
-
-    >>> INCONSISTENT_BASE1 = Layer(name="Inconsistent 1")
-    >>> INCONSISTENT_BASE2 = Layer((INCONSISTENT_BASE1,), name="Inconsistent 1")
-    >>> INCONSISTENT_BASE3 = Layer((INCONSISTENT_BASE1, INCONSISTENT_BASE2,), name="Inconsistent 1")
-    Traceback (most recent call last):
-    ...
-    TypeError: Inconsistent layer hierarchy!
-
-Using the resource manager
-~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Layers are also resource managers. Resources can be set, retrieved and
-deleted using dictionary syntax. Resources in base layers are available in
-child layers. When an item is set on a child layer, it shadows any items with
-the same key in any base layer (until it is deleted), but the original item
-still exists.
-
-Let's create a somewhat complex hierarchy of layers that all set resources
-under a key ``'foo'`` in their ``setUp()`` methods.
-
-    >>> class Layer1(Layer):
-    ...     def setUp(self):
-    ...         self['foo'] = 1
-    ...     def tearDown(self):
-    ...         del self['foo']
-    >>> LAYER1 = Layer1()
-
-    >>> class Layer2(Layer):
-    ...     defaultBases = (LAYER1,)
-    ...     def setUp(self):
-    ...         self['foo'] = 2
-    ...     def tearDown(self):
-    ...         del self['foo']
-    >>> LAYER2 = Layer2()
-
-    >>> class Layer3(Layer):
-    ...     def setUp(self):
-    ...         self['foo'] = 3
-    ...     def tearDown(self):
-    ...         del self['foo']
-    >>> LAYER3 = Layer3()
-
-    >>> class Layer4(Layer):
-    ...     defaultBases = (LAYER2, LAYER3,)
-    ...     def setUp(self):
-    ...         self['foo'] = 4
-    ...     def tearDown(self):
-    ...         del self['foo']
-    >>> LAYER4 = Layer4()
-
-    **Important:** Resources that are created in ``setUp()`` must be deleted
-    in ``tearDown()``. Similarly, resources created in ``testSetUp()`` must
-    be deleted in ``testTearDown()``. This ensures resources are properly
-    stacked and do not leak between layers.
-
-If a test was using ``LAYER4``, the test runner would call each setup step in
-turn, starting with the "deepest" layer. We'll simulate that here, so that
-each of the resources is created.
-
-    >>> LAYER1.setUp()
-    >>> LAYER2.setUp()
-    >>> LAYER3.setUp()
-    >>> LAYER4.setUp()
-
-The layers are ordered in a known "resource resolution order", which is used
-to determine in which order the layers shadow one another. This is based on
-the same algorithm as Python's method resolution order.
-
-    >>> LAYER4.baseResolutionOrder
-    (<Layer '__builtin__.Layer4'>,
-     <Layer '__builtin__.Layer2'>,
-     <Layer '__builtin__.Layer1'>,
-     <Layer '__builtin__.Layer3'>)
-
-When fetching and item from a layer, it will be obtained according to the
-resource resolution order.
-
-    >>> LAYER4['foo']
-    4
-
-This is not terribly interesting, since ``LAYER4`` has the resource ``'foo'``
-set directly. Let's tear down the layer (which deletes the resource) and see
-what happens.
-
-    >>> LAYER4.tearDown()
-    >>> LAYER4['foo']
-    2
-
-We can continue up the chain:
-
-    >>> LAYER2.tearDown()
-    >>> LAYER4['foo']
-    1
-
-    >>> LAYER1.tearDown()
-    >>> LAYER4['foo']
-    3
-
-Once we've deleted the last key, we'll get a ``KeyError``:
-
-    >>> LAYER3.tearDown()
-    >>> LAYER4['foo']
-    Traceback (most recent call last):
-    ...
-    KeyError: 'foo'
-
-To guard against this, we can use the ``get()`` method.
-
-    >>> LAYER4.get('foo', -1)
-    -1
-
-We can also test with 'in':
-
-    >>> 'foo' in LAYER4
-    False
-
-To illustrate that this indeed works, let's set the resource back on one
-of the bases.
-
-    >>> LAYER3['foo'] = 10
-    >>> LAYER4.get('foo', -1)
-    10
-
-Let's now consider a special case: a base layer sets up a resource in layer
-setup, and uses it in test setup. A child layer then shadows this resource in
-its own layer setup method. In this case, we want the base layer's
-``testSetUp()`` to use the shadowed version that the child provided.
-
-(This is similar to how instance variables work: a base class may set an
-attribute on ``self`` and use it in a method. If a subclass then sets the same
-attribute to a different value and the base class method is called on an
-instance of the subclass, the base class attribute is used).
-
-    *Hint:* If you definitely need to access the "original" resource in your
-    ``testSetUp()``/``testTearDown()`` methods, you can store a reference to
-    the resource as a layer instance variable::
-
-        self.someResource = self['someResource'] = SomeResource()
-
-    ``self.someResource`` will now be the exact resource created here, whereas
-    ``self['someResource']`` will retain the layer shadowing semantics. In
-    most cases, you probably *don't* want to do this, allowing child layers to
-    supply overridden versions of resources as appropriate.
-
-First, we'll create some base layers. We want to demonstrate having two
-"branches" of bases that both happen to define the same resource.
-
-    >>> class ResourceBaseLayer1(Layer):
-    ...     def setUp(self):
-    ...         self['resource'] = "Base 1"
-    ...     def testSetUp(self):
-    ...         print self['resource']
-    ...     def tearDown(self):
-    ...         del self['resource']
-
-    >>> RESOURCE_BASE_LAYER1 = ResourceBaseLayer1()
-
-    >>> class ResourceBaseLayer2(Layer):
-    ...     defaultBases = (RESOURCE_BASE_LAYER1,)
-    ...     def testSetUp(self):
-    ...         print self['resource']
-
-    >>> RESOURCE_BASE_LAYER2 = ResourceBaseLayer2()
-
-    >>> class ResourceBaseLayer3(Layer):
-    ...     def setUp(self):
-    ...         self['resource'] = "Base 3"
-    ...     def testSetUp(self):
-    ...         print self['resource']
-    ...     def tearDown(self):
-    ...         del self['resource']
-
-    >>> RESOURCE_BASE_LAYER3 = ResourceBaseLayer3()
-
-We'll then create the child layer that overrides this resource.
-
-    >>> class ResourceChildLayer(Layer):
-    ...     defaultBases = (RESOURCE_BASE_LAYER2, RESOURCE_BASE_LAYER3)
-    ...     def setUp(self):
-    ...         self['resource'] = "Child"
-    ...     def testSetUp(self):
-    ...         print self['resource']
-    ...     def tearDown(self):
-    ...         del self['resource']
-
-    >>> RESOURCE_CHILD_LAYER = ResourceChildLayer()
-
-We'll first set up the base layers on their own and simulate two tests.
-
-A test with RESOURCE_BASE_LAYER1 only would look like this:
-
-    >>> RESOURCE_BASE_LAYER1.setUp()
-
-    >>> RESOURCE_BASE_LAYER1.testSetUp()
-    Base 1
-    >>> RESOURCE_BASE_LAYER1.testTearDown()
-
-    >>> RESOURCE_BASE_LAYER1.tearDown()
-
-A test with RESOURCE_BASE_LAYER2 would look like this:
-
-    >>> RESOURCE_BASE_LAYER1.setUp()
-    >>> RESOURCE_BASE_LAYER2.setUp()
-
-    >>> RESOURCE_BASE_LAYER1.testSetUp()
-    Base 1
-    >>> RESOURCE_BASE_LAYER2.testSetUp()
-    Base 1
-    >>> RESOURCE_BASE_LAYER2.testTearDown()
-    >>> RESOURCE_BASE_LAYER1.testTearDown()
-
-    >>> RESOURCE_BASE_LAYER2.tearDown()
-    >>> RESOURCE_BASE_LAYER1.tearDown()
-
-A test with RESOURCE_BASE_LAYER3 only would look like this:
-
-    >>> RESOURCE_BASE_LAYER3.setUp()
-
-    >>> RESOURCE_BASE_LAYER3.testSetUp()
-    Base 3
-    >>> RESOURCE_BASE_LAYER3.testTearDown()
-
-    >>> RESOURCE_BASE_LAYER3.tearDown()
-
-Now let's set up the child layer and simulate another test. We should now be
-using the shadowed resource.
-
-    >>> RESOURCE_BASE_LAYER1.setUp()
-    >>> RESOURCE_BASE_LAYER2.setUp()
-    >>> RESOURCE_BASE_LAYER3.setUp()
-    >>> RESOURCE_CHILD_LAYER.setUp()
-
-    >>> RESOURCE_BASE_LAYER1.testSetUp()
-    Child
-    >>> RESOURCE_BASE_LAYER2.testSetUp()
-    Child
-    >>> RESOURCE_BASE_LAYER3.testSetUp()
-    Child
-    >>> RESOURCE_CHILD_LAYER.testSetUp()
-    Child
-
-    >>> RESOURCE_CHILD_LAYER.testTearDown()
-    >>> RESOURCE_BASE_LAYER3.testTearDown()
-    >>> RESOURCE_BASE_LAYER2.testTearDown()
-    >>> RESOURCE_BASE_LAYER1.testTearDown()
-
-Finally, we'll tear down the child layer again and simulate another test.
-we should have the original resources back. Note that the first and third
-layers no longer share a resource, since they don't have a common ancestor.
-
-    >>> RESOURCE_CHILD_LAYER.tearDown()
-
-    >>> RESOURCE_BASE_LAYER1.testSetUp()
-    Base 1
-    >>> RESOURCE_BASE_LAYER2.testSetUp()
-    Base 1
-    >>> RESOURCE_BASE_LAYER2.testTearDown()
-    >>> RESOURCE_BASE_LAYER1.testTearDown()
-
-    >>> RESOURCE_BASE_LAYER3.testSetUp()
-    Base 3
-    >>> RESOURCE_BASE_LAYER3.testTearDown()
-
-Finally, we'll tear down the remaining layers..
-
-    >>> RESOURCE_BASE_LAYER3.tearDown()
-    >>> RESOURCE_BASE_LAYER2.tearDown()
-    >>> RESOURCE_BASE_LAYER1.tearDown()
-
-Asymmetric deletion
-+++++++++++++++++++
-
-It is an error to create or shadow a resource in a set-up lifecycle method and
-not delete it again in the tear-down. It is also an error to delete a resource
-that was not explicitly created. These two layers break those roles:
-
-    >>> class BadLayer1(Layer):
-    ...     def setUp(self):
-    ...         pass
-    ...     def tearDown(self):
-    ...         del self['foo']
-    >>> BAD_LAYER1 = BadLayer1()
-
-    >>> class BadLayer2(Layer):
-    ...     defaultBases = (BAD_LAYER1,)
-    ...     def setUp(self):
-    ...         self['foo'] = 1
-    ...         self['bar'] = 2
-    >>> BAD_LAYER2 = BadLayer2()
-
-Let's simulate a test that uses ``BAD_LAYER2``:
-
-    >>> BAD_LAYER1.setUp()
-    >>> BAD_LAYER2.setUp()
-
-    >>> BAD_LAYER1.testSetUp()
-    >>> BAD_LAYER2.testSetUp()
-
-    >>> BAD_LAYER2.testTearDown()
-    >>> BAD_LAYER1.testTearDown()
-
-    >>> BAD_LAYER2.tearDown()
-    >>> BAD_LAYER1.tearDown()
-    Traceback (most recent call last):
-    ...
-    KeyError: 'foo'
-
-Here, we've got an error in the base layer. This is because the resource
-is actually associated with the layer that first created it, in this case
-``BASE_LAYER2``. This one remains intact and orphaned:
-
-    >>> 'foo' in BAD_LAYER2._resources
-    True
-    >>> 'bar' in BAD_LAYER2._resources
-    True
-
-Doctest layer helper
-~~~~~~~~~~~~~~~~~~~~
-
-The ``doctest`` module is not aware of ``zope.testing``'s layers concept.
-Therefore, the syntax for creating a doctest with a layer and adding it to
-a test suite is somewhat contrived: the test suite has to be created first,
-and then the layer attribute set on it:
-
-    >>> class DoctestLayer(Layer):
-    ...     pass
-    >>> DOCTEST_LAYER = DoctestLayer()
-
-    >>> try:
-    ...     import unittest2 as unittest
-    ... except ImportError: # Python 2.7
-    ...     import unittest
-    >>> import doctest
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     layerDoctest = doctest.DocFileSuite('layer.txt', package='plone.testing')
-    ...     layerDoctest.layer = DOCTEST_LAYER
-    ...     suite.addTest(layerDoctest)
-    ...     return suite
-
-    >>> suite = test_suite()
-    >>> tests = list(suite)
-    >>> len(tests)
-    1
-    >>> tests[0].layer is DOCTEST_LAYER
-    True
-
-
-To make this a little easier - especially when setting up multiple tests -
-a helper function called ``layered`` is provided:
-
-    >>> from plone.testing import layered
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         layered(doctest.DocFileSuite('layer.txt', package='plone.testing'), layer=DOCTEST_LAYER),
-    ...         # repeat with more suites if necessary
-    ...     ])
-    ...     return suite
-
-This does the same as the sample above.
-
-    >>> suite = test_suite()
-    >>> tests = list(suite)
-    >>> len(tests)
-    1
-    >>> tests[0].layer is DOCTEST_LAYER
-    True
-
-In addition, a 'layer' glob is added to each test in the suite. This allows
-the test to access layer resources.
-
-    >>> len(list(tests[0]))
-    1
-    >>> list(tests[0])[0]._dt_test.globs['layer'] is DOCTEST_LAYER
-    True
diff --git a/src/plone/testing/publisher.rst b/src/plone/testing/publisher.rst
new file mode 100644
index 0000000..5f35948
--- /dev/null
+++ b/src/plone/testing/publisher.rst
@@ -0,0 +1,126 @@
+Zope Publisher layers
+---------------------
+
+The Zope Publisher layers are found in the module ``plone.testing.publisher``:
+
+    >>> from plone.testing import publisher
+
+For testing, we need a testrunner
+
+    >>> from zope.testrunner import runner
+
+ZCML directives
+~~~~~~~~~~~~~~~
+
+The ``publisher.PUBLISHER_DIRECTIVES`` layer extends the
+``zca.ZCML_DIRECTIVES`` layer to extend its ZCML configuration context with
+the ``zope.app.publisher`` and ``zope.security`` directives available. It
+also extends ``security.CHECKERS``.
+
+    >>> from plone.testing import zca, security
+
+    >>> "%s.%s" % (publisher.PUBLISHER_DIRECTIVES.__module__, publisher.PUBLISHER_DIRECTIVES.__name__,)
+    'plone.testing.publisher.PublisherDirectives'
+
+    >>> publisher.PUBLISHER_DIRECTIVES.__bases__
+    (<Layer 'plone.testing.zca.ZCMLDirectives'>, <Layer 'plone.testing.security.Checkers'>)
+
+Before the test, we cannot use e.g. the ``<permission />`` or
+``<browser:view />`` directives without loading the necessary ``meta.zcml``
+files.
+
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.string("""\
+    ... <configure package="plone.testing"
+    ...     xmlns="http://namespaces.zope.org/zope"
+    ...     xmlns:browser="http://namespaces.zope.org/browser"
+    ...     i18n_domain="plone.testing.tests">
+    ...     <permission id="plone.testing.Test" title="plone.testing: Test" />
+    ...     <browser:view
+    ...         for="*"
+    ...         name="plone.testing-test"
+    ...         class="plone.testing.tests.DummyView"
+    ...         permission="zope.Public"
+    ...         />
+    ... </configure>""")
+    Traceback (most recent call last):
+    ...
+    ZopeXMLConfigurationError: File "<string>", line 5.4
+        ConfigurationError: ('Unknown directive', u'http://namespaces.zope.org/zope', u'permission')
+
+Layer setup creates a configuration context we can use to load further
+configuration.
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, publisher.PUBLISHER_DIRECTIVES, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.zca.ZCMLDirectives in ... seconds.
+    Set up plone.testing.security.Checkers in ... seconds.
+    Set up plone.testing.publisher.PublisherDirectives in ... seconds.
+
+
+Let's now simulate a test that uses this configuration context to load the
+same ZCML string.
+
+    >>> zca.ZCML_DIRECTIVES.testSetUp()
+    >>> security.CHECKERS.testSetUp()
+    >>> publisher.PUBLISHER_DIRECTIVES.testSetUp()
+
+    >>> context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']
+    >>> xmlconfig.string("""\
+    ... <configure package="plone.testing"
+    ...     xmlns="http://namespaces.zope.org/zope"
+    ...     xmlns:browser="http://namespaces.zope.org/browser"
+    ...     i18n_domain="plone.testing.tests">
+    ...     <permission id="plone.testing.Test" title="plone.testing: Test" />
+    ...     <browser:view
+    ...         for="*"
+    ...         name="plone.testing-test"
+    ...         class="plone.testing.tests.DummyView"
+    ...         permission="zope.Public"
+    ...         />
+    ... </configure>""", context=context) is context
+    True
+
+The permission and view are now registered:
+
+    >>> from zope.component import queryUtility
+    >>> from zope.security.interfaces import IPermission
+
+    >>> queryUtility(IPermission, name=u"plone.testing.Test")
+    <zope.security.permission.Permission object at ...>
+
+    >>> from zope.interface import Interface
+    >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer
+    >>> from zope.component import getSiteManager
+    >>> siteManager = getSiteManager()
+
+    >>> [x.factory for x in siteManager.registeredAdapters()
+    ...  if x.provided==Interface and x.required==(Interface, IDefaultBrowserLayer)
+    ...   and x.name==u"plone.testing-test"]
+    [<class '....plone.testing-test'>]
+
+We can then simulate test tear-down:
+
+    >>> publisher.PUBLISHER_DIRECTIVES.testTearDown()
+    >>> security.CHECKERS.testTearDown()
+    >>> zca.ZCML_DIRECTIVES.testTearDown()
+
+Note that you'd normally combine this layer with the ``zca.UNIT_TESTING`` or a
+similar layer to automatically tear down the component architecture between
+each test. Here, we need to do it manually.
+
+    >>> from zope.component.testing import tearDown
+    >>> tearDown()
+
+Layer tear-down does nothing.
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.publisher.PublisherDirectives in ... seconds.
+    Tear down plone.testing.zca.ZCMLDirectives in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+    Tear down plone.testing.security.Checkers in ... seconds.
+
+    >>> zca.ZCML_DIRECTIVES.get('configurationContext', None) is None
+    True
diff --git a/src/plone/testing/publisher.txt b/src/plone/testing/publisher.txt
deleted file mode 100644
index 5f35948..0000000
--- a/src/plone/testing/publisher.txt
+++ /dev/null
@@ -1,126 +0,0 @@
-Zope Publisher layers
----------------------
-
-The Zope Publisher layers are found in the module ``plone.testing.publisher``:
-
-    >>> from plone.testing import publisher
-
-For testing, we need a testrunner
-
-    >>> from zope.testrunner import runner
-
-ZCML directives
-~~~~~~~~~~~~~~~
-
-The ``publisher.PUBLISHER_DIRECTIVES`` layer extends the
-``zca.ZCML_DIRECTIVES`` layer to extend its ZCML configuration context with
-the ``zope.app.publisher`` and ``zope.security`` directives available. It
-also extends ``security.CHECKERS``.
-
-    >>> from plone.testing import zca, security
-
-    >>> "%s.%s" % (publisher.PUBLISHER_DIRECTIVES.__module__, publisher.PUBLISHER_DIRECTIVES.__name__,)
-    'plone.testing.publisher.PublisherDirectives'
-
-    >>> publisher.PUBLISHER_DIRECTIVES.__bases__
-    (<Layer 'plone.testing.zca.ZCMLDirectives'>, <Layer 'plone.testing.security.Checkers'>)
-
-Before the test, we cannot use e.g. the ``<permission />`` or
-``<browser:view />`` directives without loading the necessary ``meta.zcml``
-files.
-
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.string("""\
-    ... <configure package="plone.testing"
-    ...     xmlns="http://namespaces.zope.org/zope"
-    ...     xmlns:browser="http://namespaces.zope.org/browser"
-    ...     i18n_domain="plone.testing.tests">
-    ...     <permission id="plone.testing.Test" title="plone.testing: Test" />
-    ...     <browser:view
-    ...         for="*"
-    ...         name="plone.testing-test"
-    ...         class="plone.testing.tests.DummyView"
-    ...         permission="zope.Public"
-    ...         />
-    ... </configure>""")
-    Traceback (most recent call last):
-    ...
-    ZopeXMLConfigurationError: File "<string>", line 5.4
-        ConfigurationError: ('Unknown directive', u'http://namespaces.zope.org/zope', u'permission')
-
-Layer setup creates a configuration context we can use to load further
-configuration.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, publisher.PUBLISHER_DIRECTIVES, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.zca.ZCMLDirectives in ... seconds.
-    Set up plone.testing.security.Checkers in ... seconds.
-    Set up plone.testing.publisher.PublisherDirectives in ... seconds.
-
-
-Let's now simulate a test that uses this configuration context to load the
-same ZCML string.
-
-    >>> zca.ZCML_DIRECTIVES.testSetUp()
-    >>> security.CHECKERS.testSetUp()
-    >>> publisher.PUBLISHER_DIRECTIVES.testSetUp()
-
-    >>> context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']
-    >>> xmlconfig.string("""\
-    ... <configure package="plone.testing"
-    ...     xmlns="http://namespaces.zope.org/zope"
-    ...     xmlns:browser="http://namespaces.zope.org/browser"
-    ...     i18n_domain="plone.testing.tests">
-    ...     <permission id="plone.testing.Test" title="plone.testing: Test" />
-    ...     <browser:view
-    ...         for="*"
-    ...         name="plone.testing-test"
-    ...         class="plone.testing.tests.DummyView"
-    ...         permission="zope.Public"
-    ...         />
-    ... </configure>""", context=context) is context
-    True
-
-The permission and view are now registered:
-
-    >>> from zope.component import queryUtility
-    >>> from zope.security.interfaces import IPermission
-
-    >>> queryUtility(IPermission, name=u"plone.testing.Test")
-    <zope.security.permission.Permission object at ...>
-
-    >>> from zope.interface import Interface
-    >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer
-    >>> from zope.component import getSiteManager
-    >>> siteManager = getSiteManager()
-
-    >>> [x.factory for x in siteManager.registeredAdapters()
-    ...  if x.provided==Interface and x.required==(Interface, IDefaultBrowserLayer)
-    ...   and x.name==u"plone.testing-test"]
-    [<class '....plone.testing-test'>]
-
-We can then simulate test tear-down:
-
-    >>> publisher.PUBLISHER_DIRECTIVES.testTearDown()
-    >>> security.CHECKERS.testTearDown()
-    >>> zca.ZCML_DIRECTIVES.testTearDown()
-
-Note that you'd normally combine this layer with the ``zca.UNIT_TESTING`` or a
-similar layer to automatically tear down the component architecture between
-each test. Here, we need to do it manually.
-
-    >>> from zope.component.testing import tearDown
-    >>> tearDown()
-
-Layer tear-down does nothing.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.publisher.PublisherDirectives in ... seconds.
-    Tear down plone.testing.zca.ZCMLDirectives in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-    Tear down plone.testing.security.Checkers in ... seconds.
-
-    >>> zca.ZCML_DIRECTIVES.get('configurationContext', None) is None
-    True
diff --git a/src/plone/testing/security.rst b/src/plone/testing/security.rst
new file mode 100644
index 0000000..2cd34ca
--- /dev/null
+++ b/src/plone/testing/security.rst
@@ -0,0 +1,75 @@
+Security
+--------
+
+The Zope Security layers are found in the module ``plone.testing.security``:
+
+    >>> from plone.testing import security
+
+For testing, we need a testrunner
+
+    >>> from zope.testrunner import runner
+
+Layers
+~~~~~~
+
+The ``security.CHECKERS`` layer makes sure that ``zope.security`` checkers are
+correctly set up and torn down.
+
+    >>> "%s.%s" % (security.CHECKERS.__module__, security.CHECKERS.__name__,)
+    'plone.testing.security.Checkers'
+
+    >>> security.CHECKERS.__bases__
+    ()
+
+Before the test, our custom checker is not in the registry.
+
+    >>> class DummyObject(object):
+    ...     pass
+
+    >>> from zope.security.interfaces import IChecker
+    >>> from zope.interface import implements
+    >>> class FauxChecker(object):
+    ...     implements(IChecker)
+    ...     # we should really implement the interface here, but oh well
+
+    >>> from zope.security.checker import getCheckerForInstancesOf
+    >>> getCheckerForInstancesOf(DummyObject) is None
+    True
+
+Layer setup stacks the current checkers.
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, security.CHECKERS, setupLayers)
+    Set up plone.testing.security.Checkers in ... seconds.
+
+We can now set up a checker. In real life, this may happen during ZCML
+configuration, but here will just call the API directlyMost likely, we'd do
+this in a child layer:
+
+    >>> from zope.security.checker import defineChecker
+    >>> fauxChecker = FauxChecker()
+    >>> defineChecker(DummyObject, fauxChecker)
+
+    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
+    True
+
+Let's now simulate a test that may use the checker.
+
+    >>> security.CHECKERS.testSetUp()
+    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
+    True
+    >>> security.CHECKERS.testTearDown()
+
+We still have the checker after test tear-down:
+
+    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
+    True
+
+However, when we tear down the layer, the checker is gone:
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.security.Checkers in ... seconds.
+
+    >>> getCheckerForInstancesOf(DummyObject) is None
+    True
diff --git a/src/plone/testing/security.txt b/src/plone/testing/security.txt
deleted file mode 100644
index 2cd34ca..0000000
--- a/src/plone/testing/security.txt
+++ /dev/null
@@ -1,75 +0,0 @@
-Security
---------
-
-The Zope Security layers are found in the module ``plone.testing.security``:
-
-    >>> from plone.testing import security
-
-For testing, we need a testrunner
-
-    >>> from zope.testrunner import runner
-
-Layers
-~~~~~~
-
-The ``security.CHECKERS`` layer makes sure that ``zope.security`` checkers are
-correctly set up and torn down.
-
-    >>> "%s.%s" % (security.CHECKERS.__module__, security.CHECKERS.__name__,)
-    'plone.testing.security.Checkers'
-
-    >>> security.CHECKERS.__bases__
-    ()
-
-Before the test, our custom checker is not in the registry.
-
-    >>> class DummyObject(object):
-    ...     pass
-
-    >>> from zope.security.interfaces import IChecker
-    >>> from zope.interface import implements
-    >>> class FauxChecker(object):
-    ...     implements(IChecker)
-    ...     # we should really implement the interface here, but oh well
-
-    >>> from zope.security.checker import getCheckerForInstancesOf
-    >>> getCheckerForInstancesOf(DummyObject) is None
-    True
-
-Layer setup stacks the current checkers.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, security.CHECKERS, setupLayers)
-    Set up plone.testing.security.Checkers in ... seconds.
-
-We can now set up a checker. In real life, this may happen during ZCML
-configuration, but here will just call the API directlyMost likely, we'd do
-this in a child layer:
-
-    >>> from zope.security.checker import defineChecker
-    >>> fauxChecker = FauxChecker()
-    >>> defineChecker(DummyObject, fauxChecker)
-
-    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
-    True
-
-Let's now simulate a test that may use the checker.
-
-    >>> security.CHECKERS.testSetUp()
-    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
-    True
-    >>> security.CHECKERS.testTearDown()
-
-We still have the checker after test tear-down:
-
-    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
-    True
-
-However, when we tear down the layer, the checker is gone:
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.security.Checkers in ... seconds.
-
-    >>> getCheckerForInstancesOf(DummyObject) is None
-    True
diff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py
index a768614..5815f08 100644
--- a/src/plone/testing/tests.py
+++ b/src/plone/testing/tests.py
@@ -13,7 +13,7 @@
 from OFS.SimpleItem import SimpleItem
 from ZPublisher.Iterators import filestream_iterator
 
-# This is somewhat retarted. We execute README.txt as a doctest, mainly just
+# This is somewhat retarted. We execute README.rst as a doctest, mainly just
 # to test that the code samples import cleanly and are valid Python. However,
 # in there we also have a code sample of a doctest, which gets executed by the
 # doctest runner. Since the method inside the example code block is not yet
@@ -46,7 +46,7 @@ class DummyFile(SimpleItem):
 
     def __call__(self):
         path = get_distribution('plone.testing').location
-        path = os.path.join(path, 'plone', 'testing', 'z2.txt')
+        path = os.path.join(path, 'plone', 'testing', 'z2.rst')
 
         request = self.REQUEST
         response = request.response
@@ -67,12 +67,12 @@ def test_suite():
     suite = unittest.TestSuite()
     suite.addTests([
         doctest.DocFileSuite(
-            'layer.txt',
-            'zca.txt',
-            'security.txt',
-            'publisher.txt',
-            'zodb.txt',
-            'z2.txt',
+            'layer.rst',
+            'zca.rst',
+            'security.rst',
+            'publisher.rst',
+            'zodb.rst',
+            'z2.rst',
             setUp=setUp,
             tearDown=tearDown,
             optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,
diff --git a/src/plone/testing/z2.rst b/src/plone/testing/z2.rst
new file mode 100644
index 0000000..b861be5
--- /dev/null
+++ b/src/plone/testing/z2.rst
@@ -0,0 +1,696 @@
+Zope 2 layers
+-------------
+
+The Zope 2 layers are found in the module ``plone.testing.z2``:
+
+    >>> from plone.testing import z2
+
+For testing, we need a testrunner
+
+    >>> from zope.testrunner import runner
+
+Startup
+~~~~~~~
+
+``STARTUP`` is the base layer for all Zope 2 testing. It sets up a Zope 2
+sandbox environment that is suitable for testing. It extends the
+``zca.LAYER_CLEANUP`` layer to maximise the chances of having and leaving a
+pristine environment.
+
+**Note**: You should probably use at least ``INTEGRATION_TESTING`` for any
+real test, although ``STARTUP`` is a useful base layer if you are setting up
+your own fixture. See the description of ``INTEGRATION_TESTING`` below.
+
+    >>> "%s.%s" % (z2.STARTUP.__module__, z2.STARTUP.__name__,)
+    'plone.testing.z2.Startup'
+
+    >>> z2.STARTUP.__bases__
+    (<Layer 'plone.testing.zca.LayerCleanup'>,)
+
+On layer setup, Zope is initialised in a lightweight manner. This involves
+certain patches to global modules that Zope manages, to reduce setup time,
+a database based on ``DemoStorage``, and a minimal set of products that must
+be installed for Zope 2 to work. A minimal set of ZCML is loaded, but packages
+in the ``Products`` namespace are not automatically configured.
+
+Let's just verify that we have an empty component registry before the test:
+
+    >>> from zope.component import getSiteManager
+    >>> list(getSiteManager().registeredAdapters())
+    []
+
+Five sets a special vocabulary registry upon the layer setup, but
+there's a default one set before:
+
+    >>> from zope.schema.vocabulary import getVocabularyRegistry
+    >>> getVocabularyRegistry()
+    <zope.schema.vocabulary.VocabularyRegistry object ...>
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.STARTUP, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+
+After layer setup, the ``zodbDB`` resource is available, pointing to the
+default ZODB.
+
+    >>> z2.STARTUP['zodbDB']
+    <ZODB.DB.DB object at ...>
+
+    >>> z2.STARTUP['zodbDB'].storage
+    Startup
+
+In addition, the resources ``host`` and ``port`` are set to the default
+hostname and port that are used for URLs generated from Zope. These are
+hardcoded, but shadowed by layers that provide actual running Zope
+instances.
+
+    >>> z2.STARTUP['host']
+    'nohost'
+    >>> z2.STARTUP['port']
+    80
+
+At this point, it is also possible to get hold of a Zope application root.
+If you are setting up a layer fixture, you can obtain an application root
+with the correct database that is properly closed by using the ``zopeApp()``
+context manager.
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+If you want to use a specific database, you can pass that to ``zopeApp()`` as
+the ``db`` parameter. A new connection will be opened and closed.
+
+    >>> with z2.zopeApp(db=z2.STARTUP['zodbDB']) as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+If you want to re-use an existing connection, you can pass one to
+``zopeApp()`` as the ``connection`` argument. In this case, you will need to
+close the connection yourself.
+
+    >>> conn = z2.STARTUP['zodbDB'].open()
+    >>> with z2.zopeApp(connection=conn) as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+    >>> conn.opened is not None
+    True
+
+    >>> conn.close()
+
+If an exception is raised within the ``with`` block, the transaction is
+aborted, but the connection is still closed (if it was opened by the context
+manager):
+
+    >>> with z2.zopeApp() as app:
+    ...     raise Exception("Test error")
+    Traceback (most recent call last):
+    ...
+    Exception: Test error
+
+It is common to combine the ``zopeApp()`` context manager with a stacked
+``DemoStorage`` to set up a layer-specific fixture. As a sketch::
+
+    from plone.testing import Layer, z2, zodb
+
+    class MyLayer(Layer):
+        defaultBases = (z2.STARTUP,)
+
+        def setUp(self):
+            self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
+            with z2.zopeApp() as app:
+
+                # Set up a fixture, e.g.:
+                app.manage_addFolder('folder1')
+                folder = app['folder1']
+                folder._addRole('role1')
+                folder.manage_addUserFolder()
+
+                userFolder = folder['acl_users']
+                ignore = userFolder.userFolderAddUser('user1', 'secret', ['role1'], [])
+                folder.manage_role('role1', ('Access contents information',))
+
+        def tearDown(self):
+            self['zodbDB'].close()
+            del self['zodbDB']
+
+Note that you would normally *not* use the ``z2.zopeApp()`` in a test or in a
+``testSetUp()`` or ``testTearDown()`` method. The ``IntegrationTesting`` and
+``FunctionalTesting`` layer classes manage the application object for you,
+exposing them as the resource ``app`` (see below).
+
+After layer setup, the global component registry contains a number of
+components needed by Zope.
+
+    >>> len(list(getSiteManager().registeredAdapters())) > 1 # in fact, > a lot
+    True
+
+And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:
+
+    >>> getVocabularyRegistry()
+    <....Zope2VocabularyRegistry object at ...>
+
+To load additional ZCML, you can use the ``configurationContext`` resource:
+
+    >>> z2.STARTUP['configurationContext']
+    <zope.configuration.config.ConfigurationMachine object ...>
+
+See ``zca.rst`` for details about how to use ``zope.configuration`` for this
+purpose.
+
+The ``STARTUP`` layer does not perform any specific test setup or tear-down.
+That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING``
+layers, or other layers using their layer classes - ``IntegrationTesting``
+and ``FunctionalTesting``.
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.STARTUP.testTearDown()
+
+Layer tear-down resets the environment.
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+    >>> import Zope2
+    >>> Zope2._began_startup
+    0
+    >>> Zope2.DB is None
+    True
+    >>> Zope2.bobo_application is None
+    True
+
+    >>> list(getSiteManager().registeredAdapters())
+    []
+
+    >>> getVocabularyRegistry()
+    <zope.schema.vocabulary.VocabularyRegistry object at ...>
+
+Integration test
+~~~~~~~~~~~~~~~~
+
+``INTEGRATION_TESTING`` is intended for simple Zope 2 integration testing. It
+extends ``STARTUP`` to ensure that a transaction is begun before and rolled
+back after each test. Two resources, ``app`` and ``request``, are available
+during testing as well. It does not manage any layer state - it implements
+the test lifecycle methods only.
+
+**Note:** You would normally *not* use ``INTEGRATION_TESTING`` as a base
+layer. Instead, you'd use the ``IntegrationTesting`` class to create your
+own layer with the testing lifecycle semantics of ``INTEGRATION_TESTING``.
+See the ``plone.testing`` ``README`` file for an example.
+
+``app`` is the application root. In a test, you should use this instead of
+the ``zopeApp`` context manager (which remains the weapon of choice for
+setting up persistent fixtures), because the ``app`` resource is part of the
+transaction managed by the layer.
+
+``request`` is a test request. It is the same as ``app.REQUEST``.
+
+    >>> "%s.%s" % (z2.INTEGRATION_TESTING.__module__, z2.INTEGRATION_TESTING.__name__,)
+    'plone.testing.z2.IntegrationTesting'
+
+    >>> z2.INTEGRATION_TESTING.__bases__
+    (<Layer 'plone.testing.z2.Startup'>,)
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.INTEGRATION_TESTING, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+    Set up plone.testing.z2.IntegrationTesting in ... seconds.
+
+Let's now simulate a test. On test setup, the ``app`` resource is made
+available. In a test, you should always use this to access the application
+root.
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.INTEGRATION_TESTING.testSetUp()
+
+The test may now inspect and modify the environment.
+
+    >>> app = z2.INTEGRATION_TESTING['app'] # would normally be self.layer['app']
+    >>> app.manage_addFolder('folder1')
+    >>> app.objectIds()
+    ['acl_users', 'Control_Panel', 'folder1']
+
+The request is also available:
+
+    >>> z2.INTEGRATION_TESTING['request'] # would normally be self.layer['request']
+    <HTTPRequest, URL=http://nohost>
+
+We can create a user and simulate logging in as that user, using the
+``z2.login()`` helper:
+
+    >>> app._addRole('role1')
+    >>> ignore = app['acl_users'].userFolderAddUser('user1', 'secret', ['role1'], [])
+    >>> z2.login(app['acl_users'], 'user1')
+
+The first argument to ``z2.login()`` is the user folder that contains the
+relevant user. The second argument is the user's name. There is no need to
+give the password.
+
+    >>> from AccessControl import getSecurityManager
+    >>> getSecurityManager().getUser()
+    <User 'user1'>
+
+You can change the roles of a user using the ``z2.setRoles()`` helper:
+
+    >>> sorted(getSecurityManager().getUser().getRolesInContext(app))
+    ['Authenticated', 'role1']
+
+    >>> z2.setRoles(app['acl_users'], 'user1', [])
+    >>> getSecurityManager().getUser().getRolesInContext(app)
+    ['Authenticated']
+
+To become the anonymous user again, use ``z2.logout()``:
+
+    >>> z2.logout()
+    >>> getSecurityManager().getUser()
+    <SpecialUser 'Anonymous User'>
+
+On tear-down, the transaction is rolled back:
+
+    >>> z2.INTEGRATION_TESTING.testTearDown()
+    >>> z2.STARTUP.testTearDown()
+
+    >>> 'app' in z2.INTEGRATION_TESTING
+    False
+
+    >>> 'request' in z2.INTEGRATION_TESTING
+    False
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+Let's tear down the layers
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.IntegrationTesting in ... seconds.
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+Functional testing
+~~~~~~~~~~~~~~~~~~
+
+The ``FUNCTIONAL_TESTING`` layer is very similar to ``INTEGRATION_TESTING``,
+and exposes the same fixture and resources. However, it has different
+transaction semantics. ``INTEGRATION_TESTING`` creates a single database
+storage, and rolls back the transaction after each test.
+``FUNCTIONAL_TESTING`` creates a whole new database storage (stacked on top of
+the basic fixture) for each test. This allows testing of code that performs an
+explicit commit, which is usually required for end-to-end testing. The
+downside is that the set-up and tear-down of each test takes longer.
+
+**Note:** Again, you would normally *not* use ``FUNCTIONAL_TESTING`` as a base
+layer. Instead, you'd use the ``FunctionalTesting`` class to create your own
+layer with the testing lifecycle semantics of ``FUNCTIONAL_TESTING``. See
+the ``plone.testing`` ``README`` file for an example.
+
+Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.
+
+    >>> "%s.%s" % (z2.FUNCTIONAL_TESTING.__module__, z2.FUNCTIONAL_TESTING.__name__,)
+    'plone.testing.z2.FunctionalTesting'
+
+    >>> z2.FUNCTIONAL_TESTING.__bases__
+    (<Layer 'plone.testing.z2.Startup'>,)
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+    Set up plone.testing.z2.FunctionalTesting in ... seconds.
+
+Let's now simulate a test. On test setup, the ``app`` resource is made
+available. In a test, you should always use this to access the application
+root. The ``request`` resource can be used to access the test request.
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.FUNCTIONAL_TESTING.testSetUp()
+
+The test may now inspect and modify the environment. It may also
+commit things.
+
+    >>> app = z2.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']
+    >>> app.manage_addFolder('folder1')
+    >>> app.objectIds()
+    ['acl_users', 'Control_Panel', 'folder1']
+
+    >>> import transaction
+    >>> transaction.commit()
+
+On tear-down, the database is torn down.
+
+    >>> z2.FUNCTIONAL_TESTING.testTearDown()
+    >>> z2.STARTUP.testTearDown()
+
+    >>> 'app' in z2.FUNCTIONAL_TESTING
+    False
+
+    >>> 'request' in z2.FUNCTIONAL_TESTING
+    False
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+Let's tear down the layer:
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.FunctionalTesting in ... seconds.
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+The test browser
+~~~~~~~~~~~~~~~~
+
+The ``FUNCTIONAL_TESTING`` layer and ``FunctionalTesting`` layer class are
+the basis for functional testing using ``zope.testbrowser``. This simulates a
+web browser, allowing an application to be tested "end-to-end" via its
+user-facing interface.
+
+To use the test browser with a ``FunctionalTesting`` layer (such as the
+default ``FUNCTIONAL_TESTING`` layer instance), we need to use a custom
+browser client, which ensures that the test browser uses the correct ZODB and
+is appropriately isolated from the test code.
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+    Set up plone.testing.z2.FunctionalTesting in ... seconds.
+
+Let's simulate a test:
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.FUNCTIONAL_TESTING.testSetUp()
+
+In the test, we can create a test browser client like so::
+
+    >>> app = z2.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']
+    >>> browser = z2.Browser(app)
+
+It is usually best to let Zope errors be shown with full tracebacks:
+
+    >>> browser.handleErrors = False
+
+We can add to the test fixture in the test. For those changes to be visible to
+the test browser, however, we need to commit the transaction.
+
+    >>> app.manage_addFolder('folder1')
+    >>> import transaction; transaction.commit()
+
+We can now view this via the test browser:
+
+    >>> browser.open(app.absolute_url() + '/folder1')
+
+    >>> 'folder1' in browser.contents
+    True
+
+The test browser integration converts the URL into a request and
+passes control to Zope's publisher. Let's check that query strings are
+available for input processing:
+
+    >>> import urllib
+    >>> qs = urllib.urlencode({'foo': 'boo, bar & baz'})  # sic: the ampersand.
+    >>> _ = app['folder1'].addDTMLMethod('index_html', file='<dtml-var foo>')
+    >>> import transaction; transaction.commit()
+    >>> browser.open(app.absolute_url() + '/folder1?' + qs)
+    >>> browser.contents
+    'boo, bar & baz'
+
+The test browser also works with iterators. Let's test that with a simple
+file implementation that uses an iterator.
+
+    >>> from plone.testing.tests import DummyFile
+    >>> app._setObject('file1', DummyFile('file1'))
+    'file1'
+
+    >>> import transaction; transaction.commit()
+
+    >>> browser.open(app.absolute_url() + '/file1')
+    >>> 'The test browser also works with iterators' in browser.contents
+    True
+
+See the ``zope.testbrowser`` documentation for more information about how to
+use the browser client.
+
+On tear-down, the database is torn down.
+
+    >>> z2.FUNCTIONAL_TESTING.testTearDown()
+    >>> z2.STARTUP.testTearDown()
+
+    >>> 'app' in z2.FUNCTIONAL_TESTING
+    False
+
+    >>> 'request' in z2.FUNCTIONAL_TESTING
+    False
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+Let's tear down the layer:
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.FunctionalTesting in ... seconds.
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+HTTP server
+~~~~~~~~~~~
+
+The ``ZSERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded
+Zope server in a separate thread. This makes it possible to connect to the
+test instance using a web browser or a testing tool like Selenium or Windmill.
+
+The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has
+``ZSERVER_FIXTURE`` as its base.
+
+    >>> "%s.%s" % (z2.ZSERVER_FIXTURE.__module__, z2.ZSERVER_FIXTURE.__name__,)
+    'plone.testing.z2.ZServer'
+
+    >>> z2.ZSERVER_FIXTURE.__bases__
+    (<Layer 'plone.testing.z2.Startup'>,)
+
+
+    >>> "%s.%s" % (z2.ZSERVER.__module__, z2.ZSERVER.__name__,)
+    'plone.testing.z2.ZServer:Functional'
+
+    >>> z2.ZSERVER.__bases__
+    (<Layer 'plone.testing.z2.ZServer'>,)
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.ZSERVER, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+    Set up plone.testing.z2.ZServer in ... seconds.
+    Set up plone.testing.z2.ZServer:Functional in ... seconds.
+
+After layer setup, the resources ``host`` and ``port`` are available, and
+indicate where Zope is running.
+
+    >>> host = z2.ZSERVER['host']
+    >>> host
+    'localhost'
+
+    >>> port = z2.ZSERVER['port']
+    >>> import os
+    >>> port == int(os.environ.get('ZSERVER_PORT', 55001))
+    True
+
+Let's now simulate a test. Test setup does nothing beyond what the base layers
+do.
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.FUNCTIONAL_TESTING.testSetUp()
+    >>> z2.ZSERVER.testSetUp()
+
+It is common in a test to use the Python API to change the state of the server
+(e.g. create some content or change a setting) and then use the HTTP protocol
+to look at the results. Bear in mind that the server is running in a separate
+thread, with a separate security manager, so calls to ``z2.login()`` and
+``z2.logout()``, for instance, do not affect the server thread.
+
+    >>> app = z2.ZSERVER['app'] # would normally be self.layer['app']
+    >>> app.manage_addFolder('folder1')
+
+Note that we need to commit the transaction before it will show up in the
+other thread.
+
+    >>> import transaction; transaction.commit()
+
+We can now look for this new object through the server.
+
+    >>> app_url = app.absolute_url()
+    >>> app_url.split(':')[:-1]
+    ['http', '//localhost']
+
+    >>> import urllib2
+    >>> conn = urllib2.urlopen(app_url + '/folder1', timeout=5)
+    >>> print conn.read()
+    <Folder at folder1>
+    >>> conn.close()
+
+Test tear-down does nothing beyond what the base layers do.
+
+    >>> z2.ZSERVER.testTearDown()
+    >>> z2.FUNCTIONAL_TESTING.testTearDown()
+    >>> z2.STARTUP.testTearDown()
+
+    >>> 'app' in z2.ZSERVER
+    False
+
+    >>> 'request' in z2.ZSERVER
+    False
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+When the server is torn down, the ZServer thread is stopped.
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.ZServer:Functional in ... seconds.
+    Tear down plone.testing.z2.ZServer in ... seconds.
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+    >>> conn = urllib2.urlopen(app_url + '/folder1', timeout=5)
+    Traceback (most recent call last):
+    ...
+    URLError: <urlopen error [Errno ...] Connection refused>
+
+FTP server
+~~~~~~~~~~
+
+The ``FTP_SERVER`` layer is identical similar to ``ZSERVER``, except that it
+starts an FTP server instead of an HTTP server. The fixture is contained in
+the ``FTP_SERVER_FIXTURE`` layer.
+
+    **Warning:** It is generally not safe to run the ``ZSERVER`` and
+    ``FTP_SERVER`` layers concurrently, because they both start up the same
+    ``asyncore`` loop. If you need concurrent HTTP and FTP servers in a test,
+    you can create your own layer by subclassing the ``ZServer`` layer class,
+    and overriding the ``setUpServer()`` and ``tearDownServer()`` hooks to set
+    up and close both servers. See the code for an example.
+
+The ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.
+
+    >>> "%s.%s" % (z2.FTP_SERVER_FIXTURE.__module__, z2.FTP_SERVER_FIXTURE.__name__,)
+    'plone.testing.z2.FTPServer'
+
+    >>> z2.FTP_SERVER_FIXTURE.__bases__
+    (<Layer 'plone.testing.z2.Startup'>,)
+
+The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the
+``FunctionalTesting`` layer class.
+
+    >>> "%s.%s" % (z2.FTP_SERVER.__module__, z2.FTP_SERVER.__name__,)
+    'plone.testing.z2.FTPServer:Functional'
+
+    >>> z2.FTP_SERVER.__bases__
+    (<Layer 'plone.testing.z2.FTPServer'>,)
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.FTP_SERVER, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+    Set up plone.testing.z2.FTPServer in ... seconds.
+    Set up plone.testing.z2.FTPServer:Functional in ... seconds.
+
+After layer setup, the resources ``host`` and ``port`` are available, and
+indicate where Zope is running.
+
+    >>> host = z2.FTP_SERVER['host']
+    >>> host
+    'localhost'
+
+    >>> port = z2.FTP_SERVER['port']
+    >>> import os
+    >>> port == int(os.environ.get('FTPSERVER_PORT', 55002))
+    True
+
+Let's now simulate a test. Test setup does nothing beyond what the base layers
+do.
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.FUNCTIONAL_TESTING.testSetUp()
+    >>> z2.FTP_SERVER.testSetUp()
+
+As with ``ZSERVER``, we will set up some content for the test and then access
+it over the FTP port.
+
+    >>> app = z2.FTP_SERVER['app'] # would normally be self.layer['app']
+    >>> app.manage_addFolder('folder1')
+
+We'll also create a user in the root user folder to make FTP access easier.
+
+    >>> ignore = app['acl_users'].userFolderAddUser('admin', 'secret', ['Manager'], ())
+
+Note that we need to commit the transaction before it will show up in the
+other thread.
+
+    >>> import transaction; transaction.commit()
+
+We can now look for this new object through the server.
+
+    >>> app_path = app.absolute_url_path()
+
+    >>> import ftplib
+    >>> ftpClient = ftplib.FTP()
+    >>> ftpClient.connect(host, port, timeout=5)
+    '220 ... FTP server (...) ready.'
+
+    >>> ftpClient.login('admin', 'secret')
+    '230 Login successful.'
+
+    >>> ftpClient.cwd(app_path)
+    '250 CWD command successful.'
+
+    >>> ftpClient.retrlines('LIST')
+    drwxrwx---   1 Zope     Zope            0 ... .
+    drwxrwx---   1 Zope     Zope            0 ... Control_Panel
+    --w--w----   1 Zope     Zope            0 ... acl_users
+    drwxrwx---   1 Zope     Zope            0 ... folder1
+    '226 Transfer complete'
+
+    >>> ftpClient.quit()
+    '221 Goodbye.'
+
+Test tear-down does nothing beyond what the base layers do.
+
+    >>> z2.FTP_SERVER.testTearDown()
+    >>> z2.FUNCTIONAL_TESTING.testTearDown()
+    >>> z2.STARTUP.testTearDown()
+
+    >>> 'app' in z2.ZSERVER
+    False
+
+    >>> 'request' in z2.ZSERVER
+    False
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+When the server is torn down, the FTP thread is stopped.
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.FTPServer:Functional in ... seconds.
+    Tear down plone.testing.z2.FTPServer in ... seconds.
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+    >>> ftpClient.connect(host, port, timeout=5)
+    Traceback (most recent call last):
+    ...
+    error: [Errno ...] Connection refused
diff --git a/src/plone/testing/z2.txt b/src/plone/testing/z2.txt
deleted file mode 100644
index 9b2f471..0000000
--- a/src/plone/testing/z2.txt
+++ /dev/null
@@ -1,696 +0,0 @@
-Zope 2 layers
--------------
-
-The Zope 2 layers are found in the module ``plone.testing.z2``:
-
-    >>> from plone.testing import z2
-
-For testing, we need a testrunner
-
-    >>> from zope.testrunner import runner
-
-Startup
-~~~~~~~
-
-``STARTUP`` is the base layer for all Zope 2 testing. It sets up a Zope 2
-sandbox environment that is suitable for testing. It extends the
-``zca.LAYER_CLEANUP`` layer to maximise the chances of having and leaving a
-pristine environment.
-
-**Note**: You should probably use at least ``INTEGRATION_TESTING`` for any
-real test, although ``STARTUP`` is a useful base layer if you are setting up
-your own fixture. See the description of ``INTEGRATION_TESTING`` below.
-
-    >>> "%s.%s" % (z2.STARTUP.__module__, z2.STARTUP.__name__,)
-    'plone.testing.z2.Startup'
-
-    >>> z2.STARTUP.__bases__
-    (<Layer 'plone.testing.zca.LayerCleanup'>,)
-
-On layer setup, Zope is initialised in a lightweight manner. This involves
-certain patches to global modules that Zope manages, to reduce setup time,
-a database based on ``DemoStorage``, and a minimal set of products that must
-be installed for Zope 2 to work. A minimal set of ZCML is loaded, but packages
-in the ``Products`` namespace are not automatically configured.
-
-Let's just verify that we have an empty component registry before the test:
-
-    >>> from zope.component import getSiteManager
-    >>> list(getSiteManager().registeredAdapters())
-    []
-
-Five sets a special vocabulary registry upon the layer setup, but
-there's a default one set before:
-
-    >>> from zope.schema.vocabulary import getVocabularyRegistry
-    >>> getVocabularyRegistry()
-    <zope.schema.vocabulary.VocabularyRegistry object ...>
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.STARTUP, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-
-After layer setup, the ``zodbDB`` resource is available, pointing to the
-default ZODB.
-
-    >>> z2.STARTUP['zodbDB']
-    <ZODB.DB.DB object at ...>
-
-    >>> z2.STARTUP['zodbDB'].storage
-    Startup
-
-In addition, the resources ``host`` and ``port`` are set to the default
-hostname and port that are used for URLs generated from Zope. These are
-hardcoded, but shadowed by layers that provide actual running Zope
-instances.
-
-    >>> z2.STARTUP['host']
-    'nohost'
-    >>> z2.STARTUP['port']
-    80
-
-At this point, it is also possible to get hold of a Zope application root.
-If you are setting up a layer fixture, you can obtain an application root
-with the correct database that is properly closed by using the ``zopeApp()``
-context manager.
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-If you want to use a specific database, you can pass that to ``zopeApp()`` as
-the ``db`` parameter. A new connection will be opened and closed.
-
-    >>> with z2.zopeApp(db=z2.STARTUP['zodbDB']) as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-If you want to re-use an existing connection, you can pass one to
-``zopeApp()`` as the ``connection`` argument. In this case, you will need to
-close the connection yourself.
-
-    >>> conn = z2.STARTUP['zodbDB'].open()
-    >>> with z2.zopeApp(connection=conn) as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-    >>> conn.opened is not None
-    True
-
-    >>> conn.close()
-
-If an exception is raised within the ``with`` block, the transaction is
-aborted, but the connection is still closed (if it was opened by the context
-manager):
-
-    >>> with z2.zopeApp() as app:
-    ...     raise Exception("Test error")
-    Traceback (most recent call last):
-    ...
-    Exception: Test error
-
-It is common to combine the ``zopeApp()`` context manager with a stacked
-``DemoStorage`` to set up a layer-specific fixture. As a sketch::
-
-    from plone.testing import Layer, z2, zodb
-
-    class MyLayer(Layer):
-        defaultBases = (z2.STARTUP,)
-
-        def setUp(self):
-            self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
-            with z2.zopeApp() as app:
-
-                # Set up a fixture, e.g.:
-                app.manage_addFolder('folder1')
-                folder = app['folder1']
-                folder._addRole('role1')
-                folder.manage_addUserFolder()
-
-                userFolder = folder['acl_users']
-                ignore = userFolder.userFolderAddUser('user1', 'secret', ['role1'], [])
-                folder.manage_role('role1', ('Access contents information',))
-
-        def tearDown(self):
-            self['zodbDB'].close()
-            del self['zodbDB']
-
-Note that you would normally *not* use the ``z2.zopeApp()`` in a test or in a
-``testSetUp()`` or ``testTearDown()`` method. The ``IntegrationTesting`` and
-``FunctionalTesting`` layer classes manage the application object for you,
-exposing them as the resource ``app`` (see below).
-
-After layer setup, the global component registry contains a number of
-components needed by Zope.
-
-    >>> len(list(getSiteManager().registeredAdapters())) > 1 # in fact, > a lot
-    True
-
-And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:
-
-    >>> getVocabularyRegistry()
-    <....Zope2VocabularyRegistry object at ...>
-
-To load additional ZCML, you can use the ``configurationContext`` resource:
-
-    >>> z2.STARTUP['configurationContext']
-    <zope.configuration.config.ConfigurationMachine object ...>
-
-See ``zca.txt`` for details about how to use ``zope.configuration`` for this
-purpose.
-
-The ``STARTUP`` layer does not perform any specific test setup or tear-down.
-That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING``
-layers, or other layers using their layer classes - ``IntegrationTesting``
-and ``FunctionalTesting``.
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.STARTUP.testTearDown()
-
-Layer tear-down resets the environment.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-    >>> import Zope2
-    >>> Zope2._began_startup
-    0
-    >>> Zope2.DB is None
-    True
-    >>> Zope2.bobo_application is None
-    True
-
-    >>> list(getSiteManager().registeredAdapters())
-    []
-
-    >>> getVocabularyRegistry()
-    <zope.schema.vocabulary.VocabularyRegistry object at ...>
-
-Integration test
-~~~~~~~~~~~~~~~~
-
-``INTEGRATION_TESTING`` is intended for simple Zope 2 integration testing. It
-extends ``STARTUP`` to ensure that a transaction is begun before and rolled
-back after each test. Two resources, ``app`` and ``request``, are available
-during testing as well. It does not manage any layer state - it implements
-the test lifecycle methods only.
-
-**Note:** You would normally *not* use ``INTEGRATION_TESTING`` as a base
-layer. Instead, you'd use the ``IntegrationTesting`` class to create your
-own layer with the testing lifecycle semantics of ``INTEGRATION_TESTING``.
-See the ``plone.testing`` ``README`` file for an example.
-
-``app`` is the application root. In a test, you should use this instead of
-the ``zopeApp`` context manager (which remains the weapon of choice for
-setting up persistent fixtures), because the ``app`` resource is part of the
-transaction managed by the layer.
-
-``request`` is a test request. It is the same as ``app.REQUEST``.
-
-    >>> "%s.%s" % (z2.INTEGRATION_TESTING.__module__, z2.INTEGRATION_TESTING.__name__,)
-    'plone.testing.z2.IntegrationTesting'
-
-    >>> z2.INTEGRATION_TESTING.__bases__
-    (<Layer 'plone.testing.z2.Startup'>,)
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.INTEGRATION_TESTING, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-    Set up plone.testing.z2.IntegrationTesting in ... seconds.
-
-Let's now simulate a test. On test setup, the ``app`` resource is made
-available. In a test, you should always use this to access the application
-root.
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.INTEGRATION_TESTING.testSetUp()
-
-The test may now inspect and modify the environment.
-
-    >>> app = z2.INTEGRATION_TESTING['app'] # would normally be self.layer['app']
-    >>> app.manage_addFolder('folder1')
-    >>> app.objectIds()
-    ['acl_users', 'Control_Panel', 'folder1']
-
-The request is also available:
-
-    >>> z2.INTEGRATION_TESTING['request'] # would normally be self.layer['request']
-    <HTTPRequest, URL=http://nohost>
-
-We can create a user and simulate logging in as that user, using the
-``z2.login()`` helper:
-
-    >>> app._addRole('role1')
-    >>> ignore = app['acl_users'].userFolderAddUser('user1', 'secret', ['role1'], [])
-    >>> z2.login(app['acl_users'], 'user1')
-
-The first argument to ``z2.login()`` is the user folder that contains the
-relevant user. The second argument is the user's name. There is no need to
-give the password.
-
-    >>> from AccessControl import getSecurityManager
-    >>> getSecurityManager().getUser()
-    <User 'user1'>
-
-You can change the roles of a user using the ``z2.setRoles()`` helper:
-
-    >>> sorted(getSecurityManager().getUser().getRolesInContext(app))
-    ['Authenticated', 'role1']
-
-    >>> z2.setRoles(app['acl_users'], 'user1', [])
-    >>> getSecurityManager().getUser().getRolesInContext(app)
-    ['Authenticated']
-
-To become the anonymous user again, use ``z2.logout()``:
-
-    >>> z2.logout()
-    >>> getSecurityManager().getUser()
-    <SpecialUser 'Anonymous User'>
-
-On tear-down, the transaction is rolled back:
-
-    >>> z2.INTEGRATION_TESTING.testTearDown()
-    >>> z2.STARTUP.testTearDown()
-
-    >>> 'app' in z2.INTEGRATION_TESTING
-    False
-
-    >>> 'request' in z2.INTEGRATION_TESTING
-    False
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-Let's tear down the layers
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.IntegrationTesting in ... seconds.
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-Functional testing
-~~~~~~~~~~~~~~~~~~
-
-The ``FUNCTIONAL_TESTING`` layer is very similar to ``INTEGRATION_TESTING``,
-and exposes the same fixture and resources. However, it has different
-transaction semantics. ``INTEGRATION_TESTING`` creates a single database
-storage, and rolls back the transaction after each test.
-``FUNCTIONAL_TESTING`` creates a whole new database storage (stacked on top of
-the basic fixture) for each test. This allows testing of code that performs an
-explicit commit, which is usually required for end-to-end testing. The
-downside is that the set-up and tear-down of each test takes longer.
-
-**Note:** Again, you would normally *not* use ``FUNCTIONAL_TESTING`` as a base
-layer. Instead, you'd use the ``FunctionalTesting`` class to create your own
-layer with the testing lifecycle semantics of ``FUNCTIONAL_TESTING``. See
-the ``plone.testing`` ``README`` file for an example.
-
-Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.
-
-    >>> "%s.%s" % (z2.FUNCTIONAL_TESTING.__module__, z2.FUNCTIONAL_TESTING.__name__,)
-    'plone.testing.z2.FunctionalTesting'
-
-    >>> z2.FUNCTIONAL_TESTING.__bases__
-    (<Layer 'plone.testing.z2.Startup'>,)
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-    Set up plone.testing.z2.FunctionalTesting in ... seconds.
-
-Let's now simulate a test. On test setup, the ``app`` resource is made
-available. In a test, you should always use this to access the application
-root. The ``request`` resource can be used to access the test request.
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.FUNCTIONAL_TESTING.testSetUp()
-
-The test may now inspect and modify the environment. It may also
-commit things.
-
-    >>> app = z2.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']
-    >>> app.manage_addFolder('folder1')
-    >>> app.objectIds()
-    ['acl_users', 'Control_Panel', 'folder1']
-
-    >>> import transaction
-    >>> transaction.commit()
-
-On tear-down, the database is torn down.
-
-    >>> z2.FUNCTIONAL_TESTING.testTearDown()
-    >>> z2.STARTUP.testTearDown()
-
-    >>> 'app' in z2.FUNCTIONAL_TESTING
-    False
-
-    >>> 'request' in z2.FUNCTIONAL_TESTING
-    False
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-Let's tear down the layer:
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.FunctionalTesting in ... seconds.
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-The test browser
-~~~~~~~~~~~~~~~~
-
-The ``FUNCTIONAL_TESTING`` layer and ``FunctionalTesting`` layer class are
-the basis for functional testing using ``zope.testbrowser``. This simulates a
-web browser, allowing an application to be tested "end-to-end" via its
-user-facing interface.
-
-To use the test browser with a ``FunctionalTesting`` layer (such as the
-default ``FUNCTIONAL_TESTING`` layer instance), we need to use a custom
-browser client, which ensures that the test browser uses the correct ZODB and
-is appropriately isolated from the test code.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-    Set up plone.testing.z2.FunctionalTesting in ... seconds.
-
-Let's simulate a test:
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.FUNCTIONAL_TESTING.testSetUp()
-
-In the test, we can create a test browser client like so::
-
-    >>> app = z2.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']
-    >>> browser = z2.Browser(app)
-
-It is usually best to let Zope errors be shown with full tracebacks:
-
-    >>> browser.handleErrors = False
-
-We can add to the test fixture in the test. For those changes to be visible to
-the test browser, however, we need to commit the transaction.
-
-    >>> app.manage_addFolder('folder1')
-    >>> import transaction; transaction.commit()
-
-We can now view this via the test browser:
-
-    >>> browser.open(app.absolute_url() + '/folder1')
-
-    >>> 'folder1' in browser.contents
-    True
-
-The test browser integration converts the URL into a request and
-passes control to Zope's publisher. Let's check that query strings are
-available for input processing:
-
-    >>> import urllib
-    >>> qs = urllib.urlencode({'foo': 'boo, bar & baz'})  # sic: the ampersand.
-    >>> _ = app['folder1'].addDTMLMethod('index_html', file='<dtml-var foo>')
-    >>> import transaction; transaction.commit()
-    >>> browser.open(app.absolute_url() + '/folder1?' + qs)
-    >>> browser.contents
-    'boo, bar & baz'
-
-The test browser also works with iterators. Let's test that with a simple
-file implementation that uses an iterator.
-
-    >>> from plone.testing.tests import DummyFile
-    >>> app._setObject('file1', DummyFile('file1'))
-    'file1'
-
-    >>> import transaction; transaction.commit()
-
-    >>> browser.open(app.absolute_url() + '/file1')
-    >>> 'The test browser also works with iterators' in browser.contents
-    True
-
-See the ``zope.testbrowser`` documentation for more information about how to
-use the browser client.
-
-On tear-down, the database is torn down.
-
-    >>> z2.FUNCTIONAL_TESTING.testTearDown()
-    >>> z2.STARTUP.testTearDown()
-
-    >>> 'app' in z2.FUNCTIONAL_TESTING
-    False
-
-    >>> 'request' in z2.FUNCTIONAL_TESTING
-    False
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-Let's tear down the layer:
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.FunctionalTesting in ... seconds.
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-HTTP server
-~~~~~~~~~~~
-
-The ``ZSERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded
-Zope server in a separate thread. This makes it possible to connect to the
-test instance using a web browser or a testing tool like Selenium or Windmill.
-
-The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has
-``ZSERVER_FIXTURE`` as its base.
-
-    >>> "%s.%s" % (z2.ZSERVER_FIXTURE.__module__, z2.ZSERVER_FIXTURE.__name__,)
-    'plone.testing.z2.ZServer'
-
-    >>> z2.ZSERVER_FIXTURE.__bases__
-    (<Layer 'plone.testing.z2.Startup'>,)
-
-
-    >>> "%s.%s" % (z2.ZSERVER.__module__, z2.ZSERVER.__name__,)
-    'plone.testing.z2.ZServer:Functional'
-
-    >>> z2.ZSERVER.__bases__
-    (<Layer 'plone.testing.z2.ZServer'>,)
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.ZSERVER, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-    Set up plone.testing.z2.ZServer in ... seconds.
-    Set up plone.testing.z2.ZServer:Functional in ... seconds.
-
-After layer setup, the resources ``host`` and ``port`` are available, and
-indicate where Zope is running.
-
-    >>> host = z2.ZSERVER['host']
-    >>> host
-    'localhost'
-
-    >>> port = z2.ZSERVER['port']
-    >>> import os
-    >>> port == int(os.environ.get('ZSERVER_PORT', 55001))
-    True
-
-Let's now simulate a test. Test setup does nothing beyond what the base layers
-do.
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.FUNCTIONAL_TESTING.testSetUp()
-    >>> z2.ZSERVER.testSetUp()
-
-It is common in a test to use the Python API to change the state of the server
-(e.g. create some content or change a setting) and then use the HTTP protocol
-to look at the results. Bear in mind that the server is running in a separate
-thread, with a separate security manager, so calls to ``z2.login()`` and
-``z2.logout()``, for instance, do not affect the server thread.
-
-    >>> app = z2.ZSERVER['app'] # would normally be self.layer['app']
-    >>> app.manage_addFolder('folder1')
-
-Note that we need to commit the transaction before it will show up in the
-other thread.
-
-    >>> import transaction; transaction.commit()
-
-We can now look for this new object through the server.
-
-    >>> app_url = app.absolute_url()
-    >>> app_url.split(':')[:-1]
-    ['http', '//localhost']
-
-    >>> import urllib2
-    >>> conn = urllib2.urlopen(app_url + '/folder1', timeout=5)
-    >>> print conn.read()
-    <Folder at folder1>
-    >>> conn.close()
-
-Test tear-down does nothing beyond what the base layers do.
-
-    >>> z2.ZSERVER.testTearDown()
-    >>> z2.FUNCTIONAL_TESTING.testTearDown()
-    >>> z2.STARTUP.testTearDown()
-
-    >>> 'app' in z2.ZSERVER
-    False
-
-    >>> 'request' in z2.ZSERVER
-    False
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-When the server is torn down, the ZServer thread is stopped.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.ZServer:Functional in ... seconds.
-    Tear down plone.testing.z2.ZServer in ... seconds.
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-    >>> conn = urllib2.urlopen(app_url + '/folder1', timeout=5)
-    Traceback (most recent call last):
-    ...
-    URLError: <urlopen error [Errno ...] Connection refused>
-
-FTP server
-~~~~~~~~~~
-
-The ``FTP_SERVER`` layer is identical similar to ``ZSERVER``, except that it
-starts an FTP server instead of an HTTP server. The fixture is contained in
-the ``FTP_SERVER_FIXTURE`` layer.
-
-    **Warning:** It is generally not safe to run the ``ZSERVER`` and
-    ``FTP_SERVER`` layers concurrently, because they both start up the same
-    ``asyncore`` loop. If you need concurrent HTTP and FTP servers in a test,
-    you can create your own layer by subclassing the ``ZServer`` layer class,
-    and overriding the ``setUpServer()`` and ``tearDownServer()`` hooks to set
-    up and close both servers. See the code for an example.
-
-The ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.
-
-    >>> "%s.%s" % (z2.FTP_SERVER_FIXTURE.__module__, z2.FTP_SERVER_FIXTURE.__name__,)
-    'plone.testing.z2.FTPServer'
-
-    >>> z2.FTP_SERVER_FIXTURE.__bases__
-    (<Layer 'plone.testing.z2.Startup'>,)
-
-The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the
-``FunctionalTesting`` layer class.
-
-    >>> "%s.%s" % (z2.FTP_SERVER.__module__, z2.FTP_SERVER.__name__,)
-    'plone.testing.z2.FTPServer:Functional'
-
-    >>> z2.FTP_SERVER.__bases__
-    (<Layer 'plone.testing.z2.FTPServer'>,)
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.FTP_SERVER, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-    Set up plone.testing.z2.FTPServer in ... seconds.
-    Set up plone.testing.z2.FTPServer:Functional in ... seconds.
-
-After layer setup, the resources ``host`` and ``port`` are available, and
-indicate where Zope is running.
-
-    >>> host = z2.FTP_SERVER['host']
-    >>> host
-    'localhost'
-
-    >>> port = z2.FTP_SERVER['port']
-    >>> import os
-    >>> port == int(os.environ.get('FTPSERVER_PORT', 55002))
-    True
-
-Let's now simulate a test. Test setup does nothing beyond what the base layers
-do.
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.FUNCTIONAL_TESTING.testSetUp()
-    >>> z2.FTP_SERVER.testSetUp()
-
-As with ``ZSERVER``, we will set up some content for the test and then access
-it over the FTP port.
-
-    >>> app = z2.FTP_SERVER['app'] # would normally be self.layer['app']
-    >>> app.manage_addFolder('folder1')
-
-We'll also create a user in the root user folder to make FTP access easier.
-
-    >>> ignore = app['acl_users'].userFolderAddUser('admin', 'secret', ['Manager'], ())
-
-Note that we need to commit the transaction before it will show up in the
-other thread.
-
-    >>> import transaction; transaction.commit()
-
-We can now look for this new object through the server.
-
-    >>> app_path = app.absolute_url_path()
-
-    >>> import ftplib
-    >>> ftpClient = ftplib.FTP()
-    >>> ftpClient.connect(host, port, timeout=5)
-    '220 ... FTP server (...) ready.'
-
-    >>> ftpClient.login('admin', 'secret')
-    '230 Login successful.'
-
-    >>> ftpClient.cwd(app_path)
-    '250 CWD command successful.'
-
-    >>> ftpClient.retrlines('LIST')
-    drwxrwx---   1 Zope     Zope            0 ... .
-    drwxrwx---   1 Zope     Zope            0 ... Control_Panel
-    --w--w----   1 Zope     Zope            0 ... acl_users
-    drwxrwx---   1 Zope     Zope            0 ... folder1
-    '226 Transfer complete'
-
-    >>> ftpClient.quit()
-    '221 Goodbye.'
-
-Test tear-down does nothing beyond what the base layers do.
-
-    >>> z2.FTP_SERVER.testTearDown()
-    >>> z2.FUNCTIONAL_TESTING.testTearDown()
-    >>> z2.STARTUP.testTearDown()
-
-    >>> 'app' in z2.ZSERVER
-    False
-
-    >>> 'request' in z2.ZSERVER
-    False
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-When the server is torn down, the FTP thread is stopped.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.FTPServer:Functional in ... seconds.
-    Tear down plone.testing.z2.FTPServer in ... seconds.
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-    >>> ftpClient.connect(host, port, timeout=5)
-    Traceback (most recent call last):
-    ...
-    error: [Errno ...] Connection refused
diff --git a/src/plone/testing/zca.rst b/src/plone/testing/zca.rst
new file mode 100644
index 0000000..134fc10
--- /dev/null
+++ b/src/plone/testing/zca.rst
@@ -0,0 +1,494 @@
+Zope Component Architecture layers
+----------------------------------
+
+The ZCA layers are found in the module ``plone.testing.zca``:
+
+    >>> from plone.testing import zca
+
+For testing, we need a testrunner
+
+    >>> from zope.testrunner import runner
+
+Unit testing
+~~~~~~~~~~~~
+
+The ``UNIT_TESTING`` layer is used to set up a clean component registry
+between each test. It uses ``zope.testing.cleanup`` to clean up all global
+state.
+
+It has no bases:
+
+    >>> "%s.%s" % (zca.UNIT_TESTING.__module__, zca.UNIT_TESTING.__name__,)
+    'plone.testing.zca.UnitTesting'
+
+    >>> zca.UNIT_TESTING.__bases__
+    ()
+
+The component registry is cleaned up between each test.
+
+    >>> from zope.interface import Interface
+    >>> from zope.component import provideUtility
+
+    >>> class DummyUtility(object):
+    ...     def __init__(self, name):
+    ...         self.name = name
+    ...     def __repr__(self):
+    ...         return "<%s>" % self.name
+
+    >>> provideUtility(DummyUtility("Dummy"), provides=Interface, name="test-dummy")
+
+    >>> from zope.component import queryUtility
+    >>> queryUtility(Interface, name="test-dummy")
+    <Dummy>
+
+Layer setup does nothing.
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, zca.UNIT_TESTING, setupLayers)
+    Set up plone.testing.zca.UnitTesting in ... seconds.
+
+Let's now simulate a test. Before any test setup has happened, our previously
+registered utility is still there.
+
+    >>> queryUtility(Interface, name="test-dummy")
+    <Dummy>
+
+On test setup, it disappears.
+
+    >>> zca.UNIT_TESTING.testSetUp()
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+
+The test would now execute. It may register some components.
+
+    >>> provideUtility(DummyUtility("Dummy2"), provides=Interface, name="test-dummy")
+    >>> queryUtility(Interface, name="test-dummy")
+    <Dummy2>
+
+On test tear-down, this disappears.
+
+    >>> zca.UNIT_TESTING.testTearDown()
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+
+Layer tear-down does nothing.
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.zca.UnitTesting in ... seconds.
+
+Event testing
+~~~~~~~~~~~~~
+
+The ``EVENT_TESTING`` layer extends the ``UNIT_TESTING`` layer to add the
+necessary registrations for ``zope.component.eventtesting`` to work.
+
+    >>> "%s.%s" % (zca.EVENT_TESTING.__module__, zca.EVENT_TESTING.__name__,)
+    'plone.testing.zca.EventTesting'
+
+    >>> zca.EVENT_TESTING.__bases__
+    (<Layer 'plone.testing.zca.UnitTesting'>,)
+
+Before the test, the component registry is empty and ``getEvents()`` returns
+nothing, even if an event is fired.
+
+    >>> from zope.component.eventtesting import getEvents
+
+    >>> class DummyEvent(object):
+    ...     def __repr__(self):
+    ...         return "<Dummy event>"
+
+    >>> from zope.event import notify
+    >>> notify(DummyEvent())
+
+    >>> getEvents()
+    []
+
+Layer setup does nothing.
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, zca.EVENT_TESTING, setupLayers)
+    Set up plone.testing.zca.UnitTesting in ... seconds.
+    Set up plone.testing.zca.EventTesting in ... seconds.
+
+Let's now simulate a test. On test setup, the event testing list is emptied.
+
+    >>> zca.UNIT_TESTING.testSetUp()
+    >>> zca.EVENT_TESTING.testSetUp()
+
+    >>> getEvents()
+    []
+
+The test would now execute. It may fire some events, which would show up in
+the event testing list.
+
+    >>> notify(DummyEvent())
+    >>> getEvents()
+    [<Dummy event>]
+
+On test tear-down, the list is emptied again
+
+    >>> zca.EVENT_TESTING.testTearDown()
+    >>> zca.UNIT_TESTING.testTearDown()
+
+    >>> getEvents()
+    []
+
+Layer tear-down does nothing.
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.zca.EventTesting in ... seconds.
+    Tear down plone.testing.zca.UnitTesting in ... seconds.
+
+Layer cleanup
+~~~~~~~~~~~~~
+
+The ``LAYER_CLEANUP`` layer is used to set up a clean component registry
+at the set-up and tear-down of a layer. It uses ``zope.testing.cleanup`` to
+clean up all global state.
+
+It has no bases:
+
+    >>> "%s.%s" % (zca.LAYER_CLEANUP.__module__, zca.LAYER_CLEANUP.__name__,)
+    'plone.testing.zca.LayerCleanup'
+
+    >>> zca.LAYER_CLEANUP.__bases__
+    ()
+
+The component registry is cleaned up on layer set-up and tear-down (but not
+between tests).
+
+    >>> from zope.interface import Interface
+    >>> from zope.component import provideUtility
+
+    >>> class DummyUtility(object):
+    ...     def __init__(self, name):
+    ...         self.name = name
+    ...     def __repr__(self):
+    ...         return "<%s>" % self.name
+
+    >>> provideUtility(DummyUtility("Dummy"), provides=Interface, name="test-dummy")
+
+    >>> from zope.component import queryUtility
+    >>> queryUtility(Interface, name="test-dummy")
+    <Dummy>
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, zca.LAYER_CLEANUP, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+
+A sub-layer may register additional components:
+
+    >>> provideUtility(DummyUtility("Dummy2"), provides=Interface, name="test-dummy2")
+
+Let's now simulate a test. Test setup and tear-down does nothing.
+
+    >>> zca.LAYER_CLEANUP.testSetUp()
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+    >>> queryUtility(Interface, name="test-dummy2")
+    <Dummy2>
+
+    >>> zca.LAYER_CLEANUP.testTearDown()
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+    >>> queryUtility(Interface, name="test-dummy2")
+    <Dummy2>
+
+On tear-down, the registry is cleaned again.
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+    >>> queryUtility(Interface, name="test-dummy2") is None
+    True
+
+Basic ZCML directives
+~~~~~~~~~~~~~~~~~~~~~
+
+The ``ZCML_DIRECTIVES`` layer creates a ZCML configuration context with the
+basic ``zope.component`` directives available. It extends the
+``LAYER_CLEANUP`` layer.
+
+    >>> "%s.%s" % (zca.ZCML_DIRECTIVES.__module__, zca.ZCML_DIRECTIVES.__name__,)
+    'plone.testing.zca.ZCMLDirectives'
+
+    >>> zca.ZCML_DIRECTIVES.__bases__
+    (<Layer 'plone.testing.zca.LayerCleanup'>,)
+
+Before the test, we cannot use e.g. a ``<utility />`` directive without
+loading the necessary ``meta.zcml`` files.
+
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.string("""\
+    ... <configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
+    ...     <utility factory=".tests.DummyUtility" provides="zope.interface.Interface" name="test-dummy" />
+    ... </configure>""")
+    Traceback (most recent call last):
+    ...
+    ZopeXMLConfigurationError: File "<string>", line 2.4
+        ConfigurationError: ('Unknown directive', u'http://namespaces.zope.org/zope', u'utility')
+
+Layer setup creates a configuration context we can use to load further
+configuration.
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, zca.ZCML_DIRECTIVES, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.zca.ZCMLDirectives in ... seconds.
+
+Let's now simulate a test that uses this configuration context to load the
+same ZCML string.
+
+    >>> zca.ZCML_DIRECTIVES.testSetUp()
+
+    >>> context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']
+    >>> xmlconfig.string("""\
+    ... <configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
+    ...     <utility factory=".tests.DummyUtility" provides="zope.interface.Interface" name="test-dummy" />
+    ... </configure>""", context=context) is context
+    True
+
+The utility is now registered:
+
+    >>> queryUtility(Interface, name="test-dummy")
+    <Dummy utility>
+
+    >>> zca.UNIT_TESTING.testTearDown()
+
+Note that normally, we'd combine this with the ``UNIT_TESTING`` layer to tear
+down the component architecture as well.
+
+Layer tear-down deletes the configuration context.
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.zca.ZCMLDirectives in ... seconds.
+
+    >>> zca.ZCML_DIRECTIVES.get('configurationContext', None) is None
+    True
+
+Configuration registry sandboxing
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+For simple unit tests, the full cleanup performed between each test using the
+``UNIT_TESTING`` layer is undoubtedly the safest and most convenient way to
+ensure proper isolation of tests using the global component architecture.
+However, if you are writing a complex layer that sets up a lot of components,
+you may wish to keep some components registered at the layer level, whilst
+still allowing tests and sub-layers to register their own components in
+isolation.
+
+This is a tricky problem, because the default ZCML directives and APIs
+(``provideAdapter()``, ``provideUtility()`` and so on) explicitly work on
+a single global adapter registry object. To get around this, you can use two
+helper methods in the ``zca`` module to push a new global component registry
+before registering components, and pop the registry after. Registries are
+stacked, so the components registered in a "lower" registry are automatically
+available in a "higher" registry.
+
+Let's illustrate this with a layer that stacks two new global registries. The
+first registry is specific to the layer, and is used to house the components
+registered at the layer level. The second registry is set up and torn down for
+each test, allowing tests to register their own components freely.
+
+First, we'll create a simple dummy utility to illustrate registrations.
+
+    >>> from zope.interface import Interface, implements
+
+    >>> class IDummyUtility(Interface):
+    ...     pass
+    >>> class DummyUtility(object):
+    ...     implements(IDummyUtility)
+    ...     def __init__(self, name):
+    ...         self.name = name
+    ...     def __repr__(self):
+    ...         return "<DummyUtility %s>" % self.name
+
+The two key methods are:
+
+* ``zca.pushGlobalRegistry()``, which creates a new global registry.
+* ``zca.popGlobalRegistry()``, which restores the previous global registry.
+
+  **Warning:** You *must* balance your calls to these methods. If you call
+  ``pushGlobalRegistry()`` in ``setUp()``, call ``popGlobalRegistry()`` in
+  ``tearDown()``. Ditto for ``testSetUp()`` and ``testTearDown()``.
+
+Let's now create our layer.
+
+    >>> from zope.component import provideUtility
+    >>> from plone.testing import Layer
+    >>> from plone.testing import zca
+
+    >>> class ComponentSandbox(Layer):
+    ...     def setUp(self):
+    ...         zca.pushGlobalRegistry()
+    ...         provideUtility(DummyUtility("layer"), name="layer")
+    ...     def tearDown(self):
+    ...         zca.popGlobalRegistry()
+    ...     def testSetUp(self):
+    ...         zca.pushGlobalRegistry()
+    ...     def testTearDown(self):
+    ...         zca.popGlobalRegistry()
+    >>> COMPONENT_SANDBOX = ComponentSandbox()
+
+Let's now simulate a test using this layer.
+
+To begin with, we have the default registry.
+
+    >>> from zope.component import getGlobalSiteManager, getSiteManager
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+
+    >>> defaultGlobalSiteManager = getGlobalSiteManager()
+
+    >>> from zope.component import queryUtility
+    >>> queryUtility(IDummyUtility, name="layer") is None
+    True
+
+We'll now simulate layer setup. This will push a new registry onto the stack:
+
+    >>> COMPONENT_SANDBOX.setUp()
+
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+    >>> getGlobalSiteManager() is defaultGlobalSiteManager
+    False
+    >>> layerGlobalSiteManager = getGlobalSiteManager()
+
+    >>> queryUtility(IDummyUtility, name="layer")
+    <DummyUtility layer>
+
+We'll then simulate a test that registers a global component:
+
+    >>> COMPONENT_SANDBOX.testSetUp()
+
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+    >>> getGlobalSiteManager() is defaultGlobalSiteManager
+    False
+    >>> getGlobalSiteManager() is layerGlobalSiteManager
+    False
+
+Our previously registered component is still here.
+
+    >>> queryUtility(IDummyUtility, name="layer")
+    <DummyUtility layer>
+
+We can also register a new one.
+
+    >>> provideUtility(DummyUtility("test"), name="test")
+    >>> queryUtility(IDummyUtility, name="layer")
+    <DummyUtility layer>
+    >>> queryUtility(IDummyUtility, name="test")
+    <DummyUtility test>
+
+On test tear-down, only the second utility disappears:
+
+    >>> COMPONENT_SANDBOX.testTearDown()
+
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+    >>> getGlobalSiteManager() is defaultGlobalSiteManager
+    False
+    >>> getGlobalSiteManager() is layerGlobalSiteManager
+    True
+
+    >>> queryUtility(IDummyUtility, name="layer")
+    <DummyUtility layer>
+    >>> queryUtility(IDummyUtility, name="test") is None
+    True
+
+If we tear down the layer too, we're back where we started:
+
+    >>> COMPONENT_SANDBOX.tearDown()
+
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+    >>> getGlobalSiteManager() is defaultGlobalSiteManager
+    True
+
+    >>> queryUtility(IDummyUtility, name="layer") is None
+    True
+    >>> queryUtility(IDummyUtility, name="test") is None
+    True
+
+ZCML files helper class
+~~~~~~~~~~~~~~~~~~~~~~~
+
+One of the frequent use cases is a layer that loads a ZCML file and sandbox the
+resulting registry.
+
+The ``ZCMLSandbox`` can be instantiated with a `filename`` and ``package``
+arguments.
+
+    >>> import plone.testing
+    >>> ZCML_SANDBOX = zca.ZCMLSandbox(filename="testing_zca.zcml",
+    ...     package=plone.testing)
+
+Before layer setup, the utility is not registered.
+
+    >>> queryUtility(Interface, name="layer") is None
+    True
+
+We'll now simulate layer setup. This pushes a new registry onto the stack:
+
+    >>> ZCML_SANDBOX.setUp()
+
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+    >>> getGlobalSiteManager() is defaultGlobalSiteManager
+    False
+    >>> queryUtility(Interface, name="layer")
+    <Dummy utility>
+
+The ``ZCMLSandbox`` class can also be used as ancestor
+for your own classes when you need to load more than a single ZCML file.
+
+Your class then needs to override the ``setUpZCMLFiles()`` method. It is in
+charge of calling ``loadZCMLFile()``, once for each ZCML file that the class
+needs to load.
+
+    >>> class OtherZCML(zca.ZCMLSandbox):
+    ...     def setUpZCMLFiles(self):
+    ...         self.loadZCMLFile("testing_zca.zcml", package=plone.testing)
+    ...         self.loadZCMLFile("testing_zca_more_specific.zcml",
+    ...             package=plone.testing)
+    >>> OTHER_ZCML_SANDBOX = OtherZCML()
+
+Before layer setup, a second utility is not registered.
+
+    >>> queryUtility(Interface, name="more_specific_layer") is None
+    True
+
+We'll now simulate the setup of the more specific layer.
+
+    >>> OTHER_ZCML_SANDBOX.setUp()
+
+After setUp, the second utility is registered :
+
+    >>> queryUtility(Interface, name="more_specific_layer")
+    <Dummy utility>
+
+After layer teardown, the second utility is not registered anymore.
+
+    >>> OTHER_ZCML_SANDBOX.tearDown()
+    >>> queryUtility(Interface, name="more_specific_layer") is None
+    True
+
+After teardown of the first layer, the first utility is not registered anymore.
+
+    >>> ZCML_SANDBOX.tearDown()
+    >>> queryUtility(Interface, name="layer") is None
+    True
diff --git a/src/plone/testing/zca.txt b/src/plone/testing/zca.txt
deleted file mode 100644
index 134fc10..0000000
--- a/src/plone/testing/zca.txt
+++ /dev/null
@@ -1,494 +0,0 @@
-Zope Component Architecture layers
-----------------------------------
-
-The ZCA layers are found in the module ``plone.testing.zca``:
-
-    >>> from plone.testing import zca
-
-For testing, we need a testrunner
-
-    >>> from zope.testrunner import runner
-
-Unit testing
-~~~~~~~~~~~~
-
-The ``UNIT_TESTING`` layer is used to set up a clean component registry
-between each test. It uses ``zope.testing.cleanup`` to clean up all global
-state.
-
-It has no bases:
-
-    >>> "%s.%s" % (zca.UNIT_TESTING.__module__, zca.UNIT_TESTING.__name__,)
-    'plone.testing.zca.UnitTesting'
-
-    >>> zca.UNIT_TESTING.__bases__
-    ()
-
-The component registry is cleaned up between each test.
-
-    >>> from zope.interface import Interface
-    >>> from zope.component import provideUtility
-
-    >>> class DummyUtility(object):
-    ...     def __init__(self, name):
-    ...         self.name = name
-    ...     def __repr__(self):
-    ...         return "<%s>" % self.name
-
-    >>> provideUtility(DummyUtility("Dummy"), provides=Interface, name="test-dummy")
-
-    >>> from zope.component import queryUtility
-    >>> queryUtility(Interface, name="test-dummy")
-    <Dummy>
-
-Layer setup does nothing.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, zca.UNIT_TESTING, setupLayers)
-    Set up plone.testing.zca.UnitTesting in ... seconds.
-
-Let's now simulate a test. Before any test setup has happened, our previously
-registered utility is still there.
-
-    >>> queryUtility(Interface, name="test-dummy")
-    <Dummy>
-
-On test setup, it disappears.
-
-    >>> zca.UNIT_TESTING.testSetUp()
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-
-The test would now execute. It may register some components.
-
-    >>> provideUtility(DummyUtility("Dummy2"), provides=Interface, name="test-dummy")
-    >>> queryUtility(Interface, name="test-dummy")
-    <Dummy2>
-
-On test tear-down, this disappears.
-
-    >>> zca.UNIT_TESTING.testTearDown()
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-
-Layer tear-down does nothing.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.zca.UnitTesting in ... seconds.
-
-Event testing
-~~~~~~~~~~~~~
-
-The ``EVENT_TESTING`` layer extends the ``UNIT_TESTING`` layer to add the
-necessary registrations for ``zope.component.eventtesting`` to work.
-
-    >>> "%s.%s" % (zca.EVENT_TESTING.__module__, zca.EVENT_TESTING.__name__,)
-    'plone.testing.zca.EventTesting'
-
-    >>> zca.EVENT_TESTING.__bases__
-    (<Layer 'plone.testing.zca.UnitTesting'>,)
-
-Before the test, the component registry is empty and ``getEvents()`` returns
-nothing, even if an event is fired.
-
-    >>> from zope.component.eventtesting import getEvents
-
-    >>> class DummyEvent(object):
-    ...     def __repr__(self):
-    ...         return "<Dummy event>"
-
-    >>> from zope.event import notify
-    >>> notify(DummyEvent())
-
-    >>> getEvents()
-    []
-
-Layer setup does nothing.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, zca.EVENT_TESTING, setupLayers)
-    Set up plone.testing.zca.UnitTesting in ... seconds.
-    Set up plone.testing.zca.EventTesting in ... seconds.
-
-Let's now simulate a test. On test setup, the event testing list is emptied.
-
-    >>> zca.UNIT_TESTING.testSetUp()
-    >>> zca.EVENT_TESTING.testSetUp()
-
-    >>> getEvents()
-    []
-
-The test would now execute. It may fire some events, which would show up in
-the event testing list.
-
-    >>> notify(DummyEvent())
-    >>> getEvents()
-    [<Dummy event>]
-
-On test tear-down, the list is emptied again
-
-    >>> zca.EVENT_TESTING.testTearDown()
-    >>> zca.UNIT_TESTING.testTearDown()
-
-    >>> getEvents()
-    []
-
-Layer tear-down does nothing.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.zca.EventTesting in ... seconds.
-    Tear down plone.testing.zca.UnitTesting in ... seconds.
-
-Layer cleanup
-~~~~~~~~~~~~~
-
-The ``LAYER_CLEANUP`` layer is used to set up a clean component registry
-at the set-up and tear-down of a layer. It uses ``zope.testing.cleanup`` to
-clean up all global state.
-
-It has no bases:
-
-    >>> "%s.%s" % (zca.LAYER_CLEANUP.__module__, zca.LAYER_CLEANUP.__name__,)
-    'plone.testing.zca.LayerCleanup'
-
-    >>> zca.LAYER_CLEANUP.__bases__
-    ()
-
-The component registry is cleaned up on layer set-up and tear-down (but not
-between tests).
-
-    >>> from zope.interface import Interface
-    >>> from zope.component import provideUtility
-
-    >>> class DummyUtility(object):
-    ...     def __init__(self, name):
-    ...         self.name = name
-    ...     def __repr__(self):
-    ...         return "<%s>" % self.name
-
-    >>> provideUtility(DummyUtility("Dummy"), provides=Interface, name="test-dummy")
-
-    >>> from zope.component import queryUtility
-    >>> queryUtility(Interface, name="test-dummy")
-    <Dummy>
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, zca.LAYER_CLEANUP, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-
-A sub-layer may register additional components:
-
-    >>> provideUtility(DummyUtility("Dummy2"), provides=Interface, name="test-dummy2")
-
-Let's now simulate a test. Test setup and tear-down does nothing.
-
-    >>> zca.LAYER_CLEANUP.testSetUp()
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-    >>> queryUtility(Interface, name="test-dummy2")
-    <Dummy2>
-
-    >>> zca.LAYER_CLEANUP.testTearDown()
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-    >>> queryUtility(Interface, name="test-dummy2")
-    <Dummy2>
-
-On tear-down, the registry is cleaned again.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-    >>> queryUtility(Interface, name="test-dummy2") is None
-    True
-
-Basic ZCML directives
-~~~~~~~~~~~~~~~~~~~~~
-
-The ``ZCML_DIRECTIVES`` layer creates a ZCML configuration context with the
-basic ``zope.component`` directives available. It extends the
-``LAYER_CLEANUP`` layer.
-
-    >>> "%s.%s" % (zca.ZCML_DIRECTIVES.__module__, zca.ZCML_DIRECTIVES.__name__,)
-    'plone.testing.zca.ZCMLDirectives'
-
-    >>> zca.ZCML_DIRECTIVES.__bases__
-    (<Layer 'plone.testing.zca.LayerCleanup'>,)
-
-Before the test, we cannot use e.g. a ``<utility />`` directive without
-loading the necessary ``meta.zcml`` files.
-
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.string("""\
-    ... <configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
-    ...     <utility factory=".tests.DummyUtility" provides="zope.interface.Interface" name="test-dummy" />
-    ... </configure>""")
-    Traceback (most recent call last):
-    ...
-    ZopeXMLConfigurationError: File "<string>", line 2.4
-        ConfigurationError: ('Unknown directive', u'http://namespaces.zope.org/zope', u'utility')
-
-Layer setup creates a configuration context we can use to load further
-configuration.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, zca.ZCML_DIRECTIVES, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.zca.ZCMLDirectives in ... seconds.
-
-Let's now simulate a test that uses this configuration context to load the
-same ZCML string.
-
-    >>> zca.ZCML_DIRECTIVES.testSetUp()
-
-    >>> context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']
-    >>> xmlconfig.string("""\
-    ... <configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
-    ...     <utility factory=".tests.DummyUtility" provides="zope.interface.Interface" name="test-dummy" />
-    ... </configure>""", context=context) is context
-    True
-
-The utility is now registered:
-
-    >>> queryUtility(Interface, name="test-dummy")
-    <Dummy utility>
-
-    >>> zca.UNIT_TESTING.testTearDown()
-
-Note that normally, we'd combine this with the ``UNIT_TESTING`` layer to tear
-down the component architecture as well.
-
-Layer tear-down deletes the configuration context.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.zca.ZCMLDirectives in ... seconds.
-
-    >>> zca.ZCML_DIRECTIVES.get('configurationContext', None) is None
-    True
-
-Configuration registry sandboxing
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-For simple unit tests, the full cleanup performed between each test using the
-``UNIT_TESTING`` layer is undoubtedly the safest and most convenient way to
-ensure proper isolation of tests using the global component architecture.
-However, if you are writing a complex layer that sets up a lot of components,
-you may wish to keep some components registered at the layer level, whilst
-still allowing tests and sub-layers to register their own components in
-isolation.
-
-This is a tricky problem, because the default ZCML directives and APIs
-(``provideAdapter()``, ``provideUtility()`` and so on) explicitly work on
-a single global adapter registry object. To get around this, you can use two
-helper methods in the ``zca`` module to push a new global component registry
-before registering components, and pop the registry after. Registries are
-stacked, so the components registered in a "lower" registry are automatically
-available in a "higher" registry.
-
-Let's illustrate this with a layer that stacks two new global registries. The
-first registry is specific to the layer, and is used to house the components
-registered at the layer level. The second registry is set up and torn down for
-each test, allowing tests to register their own components freely.
-
-First, we'll create a simple dummy utility to illustrate registrations.
-
-    >>> from zope.interface import Interface, implements
-
-    >>> class IDummyUtility(Interface):
-    ...     pass
-    >>> class DummyUtility(object):
-    ...     implements(IDummyUtility)
-    ...     def __init__(self, name):
-    ...         self.name = name
-    ...     def __repr__(self):
-    ...         return "<DummyUtility %s>" % self.name
-
-The two key methods are:
-
-* ``zca.pushGlobalRegistry()``, which creates a new global registry.
-* ``zca.popGlobalRegistry()``, which restores the previous global registry.
-
-  **Warning:** You *must* balance your calls to these methods. If you call
-  ``pushGlobalRegistry()`` in ``setUp()``, call ``popGlobalRegistry()`` in
-  ``tearDown()``. Ditto for ``testSetUp()`` and ``testTearDown()``.
-
-Let's now create our layer.
-
-    >>> from zope.component import provideUtility
-    >>> from plone.testing import Layer
-    >>> from plone.testing import zca
-
-    >>> class ComponentSandbox(Layer):
-    ...     def setUp(self):
-    ...         zca.pushGlobalRegistry()
-    ...         provideUtility(DummyUtility("layer"), name="layer")
-    ...     def tearDown(self):
-    ...         zca.popGlobalRegistry()
-    ...     def testSetUp(self):
-    ...         zca.pushGlobalRegistry()
-    ...     def testTearDown(self):
-    ...         zca.popGlobalRegistry()
-    >>> COMPONENT_SANDBOX = ComponentSandbox()
-
-Let's now simulate a test using this layer.
-
-To begin with, we have the default registry.
-
-    >>> from zope.component import getGlobalSiteManager, getSiteManager
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-
-    >>> defaultGlobalSiteManager = getGlobalSiteManager()
-
-    >>> from zope.component import queryUtility
-    >>> queryUtility(IDummyUtility, name="layer") is None
-    True
-
-We'll now simulate layer setup. This will push a new registry onto the stack:
-
-    >>> COMPONENT_SANDBOX.setUp()
-
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-    >>> getGlobalSiteManager() is defaultGlobalSiteManager
-    False
-    >>> layerGlobalSiteManager = getGlobalSiteManager()
-
-    >>> queryUtility(IDummyUtility, name="layer")
-    <DummyUtility layer>
-
-We'll then simulate a test that registers a global component:
-
-    >>> COMPONENT_SANDBOX.testSetUp()
-
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-    >>> getGlobalSiteManager() is defaultGlobalSiteManager
-    False
-    >>> getGlobalSiteManager() is layerGlobalSiteManager
-    False
-
-Our previously registered component is still here.
-
-    >>> queryUtility(IDummyUtility, name="layer")
-    <DummyUtility layer>
-
-We can also register a new one.
-
-    >>> provideUtility(DummyUtility("test"), name="test")
-    >>> queryUtility(IDummyUtility, name="layer")
-    <DummyUtility layer>
-    >>> queryUtility(IDummyUtility, name="test")
-    <DummyUtility test>
-
-On test tear-down, only the second utility disappears:
-
-    >>> COMPONENT_SANDBOX.testTearDown()
-
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-    >>> getGlobalSiteManager() is defaultGlobalSiteManager
-    False
-    >>> getGlobalSiteManager() is layerGlobalSiteManager
-    True
-
-    >>> queryUtility(IDummyUtility, name="layer")
-    <DummyUtility layer>
-    >>> queryUtility(IDummyUtility, name="test") is None
-    True
-
-If we tear down the layer too, we're back where we started:
-
-    >>> COMPONENT_SANDBOX.tearDown()
-
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-    >>> getGlobalSiteManager() is defaultGlobalSiteManager
-    True
-
-    >>> queryUtility(IDummyUtility, name="layer") is None
-    True
-    >>> queryUtility(IDummyUtility, name="test") is None
-    True
-
-ZCML files helper class
-~~~~~~~~~~~~~~~~~~~~~~~
-
-One of the frequent use cases is a layer that loads a ZCML file and sandbox the
-resulting registry.
-
-The ``ZCMLSandbox`` can be instantiated with a `filename`` and ``package``
-arguments.
-
-    >>> import plone.testing
-    >>> ZCML_SANDBOX = zca.ZCMLSandbox(filename="testing_zca.zcml",
-    ...     package=plone.testing)
-
-Before layer setup, the utility is not registered.
-
-    >>> queryUtility(Interface, name="layer") is None
-    True
-
-We'll now simulate layer setup. This pushes a new registry onto the stack:
-
-    >>> ZCML_SANDBOX.setUp()
-
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-    >>> getGlobalSiteManager() is defaultGlobalSiteManager
-    False
-    >>> queryUtility(Interface, name="layer")
-    <Dummy utility>
-
-The ``ZCMLSandbox`` class can also be used as ancestor
-for your own classes when you need to load more than a single ZCML file.
-
-Your class then needs to override the ``setUpZCMLFiles()`` method. It is in
-charge of calling ``loadZCMLFile()``, once for each ZCML file that the class
-needs to load.
-
-    >>> class OtherZCML(zca.ZCMLSandbox):
-    ...     def setUpZCMLFiles(self):
-    ...         self.loadZCMLFile("testing_zca.zcml", package=plone.testing)
-    ...         self.loadZCMLFile("testing_zca_more_specific.zcml",
-    ...             package=plone.testing)
-    >>> OTHER_ZCML_SANDBOX = OtherZCML()
-
-Before layer setup, a second utility is not registered.
-
-    >>> queryUtility(Interface, name="more_specific_layer") is None
-    True
-
-We'll now simulate the setup of the more specific layer.
-
-    >>> OTHER_ZCML_SANDBOX.setUp()
-
-After setUp, the second utility is registered :
-
-    >>> queryUtility(Interface, name="more_specific_layer")
-    <Dummy utility>
-
-After layer teardown, the second utility is not registered anymore.
-
-    >>> OTHER_ZCML_SANDBOX.tearDown()
-    >>> queryUtility(Interface, name="more_specific_layer") is None
-    True
-
-After teardown of the first layer, the first utility is not registered anymore.
-
-    >>> ZCML_SANDBOX.tearDown()
-    >>> queryUtility(Interface, name="layer") is None
-    True
diff --git a/src/plone/testing/zodb.rst b/src/plone/testing/zodb.rst
new file mode 100644
index 0000000..79ff465
--- /dev/null
+++ b/src/plone/testing/zodb.rst
@@ -0,0 +1,288 @@
+Zope Object Database layers
+---------------------------
+
+The ZODB layers are found in the module ``plone.testing.zodb``:
+
+    >>> from plone.testing import zodb
+
+For testing, we need a testrunner
+
+    >>> from zope.testrunner import runner
+
+Empty ZODB layer
+~~~~~~~~~~~~~~~~
+
+The ``EMPTY_ZODB`` layer is used to set up an empty ZODB using
+``DemoStorage``.
+
+The storage and database are set up as layer fixtures. The database is exposed
+as the resource ``zodbDB``.
+
+A connection is opened for each test and exposed as ``zodbConnection``. The
+ZODB root is also exposed, as ``zodbRoot``. A new transaction is begun for
+each test. On test tear-down, the transaction is aborted, the connection is
+closed, and the two test-specific resources are deleted.
+
+The layer has no bases.
+
+    >>> "%s.%s" % (zodb.EMPTY_ZODB.__module__, zodb.EMPTY_ZODB.__name__,)
+    'plone.testing.zodb.EmptyZODB'
+
+    >>> zodb.EMPTY_ZODB.__bases__
+    ()
+
+Layer setup creates the database, but not a connection.
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, zodb.EMPTY_ZODB, setupLayers)
+    Set up plone.testing.zodb.EmptyZODB in ... seconds.
+
+    >>> db = zodb.EMPTY_ZODB['zodbDB']
+    >>> db.storage
+    EmptyZODB
+
+    >>> zodb.EMPTY_ZODB.get('zodbConnection', None) is None
+    True
+    >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None
+    True
+
+Let's now simulate a test.
+
+    >>> zodb.EMPTY_ZODB.testSetUp()
+
+The test would then execute. It may use the ZODB root.
+
+    >>> zodb.EMPTY_ZODB['zodbConnection']
+    <Connection at ...>
+
+    >>> zodb.EMPTY_ZODB['zodbRoot']
+    {}
+
+    >>> zodb.EMPTY_ZODB['zodbRoot']['foo'] = 'bar'
+
+On test tear-down, the transaction is aborted and the connection is closed.
+
+    >>> zodb.EMPTY_ZODB.testTearDown()
+
+    >>> zodb.EMPTY_ZODB.get('zodbConnection', None) is None
+    True
+
+    >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None
+    True
+
+The transaction has been rolled back.
+
+    >>> conn = zodb.EMPTY_ZODB['zodbDB'].open()
+    >>> conn.root()
+    {}
+    >>> conn.close()
+
+Layer tear-down closes and deletes the database.
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.zodb.EmptyZODB in ... seconds.
+
+    >>> zodb.EMPTY_ZODB.get('zodbDB', None) is None
+    True
+
+Extending the ZODB layer
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+When creating a test fixture, it is often desirable to add some initial data
+to the database. If you want to do that once on layer setup, you can create
+your own layer class based on ``EmptyZODB`` and override its
+``createStorage()`` and/or ``createDatabase()`` methods to return a
+pre-populated database.
+
+
+    >>> import transaction
+    >>> from ZODB.DemoStorage import DemoStorage
+    >>> from ZODB.DB import DB
+
+    >>> class PopulatedZODB(zodb.EmptyZODB):
+    ...
+    ...     def createStorage(self):
+    ...         return DemoStorage("My storage")
+    ...
+    ...     def createDatabase(self, storage):
+    ...         db = DB(storage)
+    ...         conn = db.open()
+    ...
+    ...         conn.root()['someData'] = 'a string'
+    ...
+    ...         transaction.commit()
+    ...         conn.close()
+    ...
+    ...         return db
+
+    >>> POPULATED_ZODB = PopulatedZODB()
+
+We'll use this new layer in a similar manner to the test above, showing that
+the data is there for each test, but that other changes are rolled back.
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, POPULATED_ZODB, setupLayers)
+    Set up PopulatedZODB in ... seconds.
+
+    >>> db = POPULATED_ZODB['zodbDB']
+    >>> db.storage
+    My storage
+
+    >>> POPULATED_ZODB.get('zodbConnection', None) is None
+    True
+    >>> POPULATED_ZODB.get('zodbRoot', None) is None
+    True
+
+Let's now simulate a test.
+
+    >>> POPULATED_ZODB.testSetUp()
+
+The test would then execute. It may use the ZODB root.
+
+    >>> POPULATED_ZODB['zodbConnection']
+    <Connection at ...>
+
+    >>> POPULATED_ZODB['zodbRoot']
+    {'someData': 'a string'}
+
+    >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'
+
+On test tear-down, the transaction is aborted and the connection is closed.
+
+    >>> POPULATED_ZODB.testTearDown()
+
+    >>> POPULATED_ZODB.get('zodbConnection', None) is None
+    True
+
+    >>> POPULATED_ZODB.get('zodbRoot', None) is None
+    True
+
+The transaction has been rolled back.
+
+    >>> conn = POPULATED_ZODB['zodbDB'].open()
+    >>> conn.root()
+    {'someData': 'a string'}
+    >>> conn.close()
+
+Layer tear-down closes and deletes the database.
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down PopulatedZODB in ... seconds.
+
+    >>> POPULATED_ZODB.get('zodbDB', None) is None
+    True
+
+Stacking ``DemoStorage`` storages
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The example above shows how to create a simple test fixture with a custom
+database. It is sometimes useful to be able to stack these fixtures, so that
+a base layer sets up some data for one set of tests, and a child layer
+extends this, temporarily, with more data.
+
+This can be achieved using layer bases and resource shadowing, combined with
+ZODB's stackable DemoStorage. There is even a helper function available:
+
+    >>> from plone.testing import Layer
+    >>> from plone.testing import zodb
+    >>> import transaction
+
+    >>> class ExpandedZODB(Layer):
+    ...     defaultBases = (POPULATED_ZODB,)
+    ...
+    ...     def setUp(self):
+    ...         # Get the database from the base layer
+    ...
+    ...         self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='ExpandedZODB')
+    ...
+    ...         conn = db.open()
+    ...         conn.root()['additionalData'] = "Some new data"
+    ...         transaction.commit()
+    ...         conn.close()
+    ...
+    ...     def tearDown(self):
+    ...         # Close the database and delete the shadowed copy
+    ...
+    ...         self['zodbDB'].close()
+    ...         del self['zodbDB']
+
+    >>> EXPANDED_ZODB = ExpandedZODB()
+
+Notice that we are using plain ``Layer`` as a base class here. We obtain the
+underlying database from our bases using the resource manager, and then
+create a shadow copy using a stacked storage. Stacked storages contain the
+data of the original storage, but save changes in a separate (and, in this
+case, temporary) storage.
+
+Let's simulate a test run again to show how this would work.
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, EXPANDED_ZODB, setupLayers)
+    Set up PopulatedZODB in ... seconds.
+    Set up ExpandedZODB in ... seconds.
+
+    >>> db = EXPANDED_ZODB['zodbDB']
+    >>> db.storage
+    ExpandedZODB
+
+    >>> EXPANDED_ZODB.get('zodbConnection', None) is None
+    True
+    >>> EXPANDED_ZODB.get('zodbRoot', None) is None
+    True
+
+Let's now simulate a test.
+
+    >>> POPULATED_ZODB.testSetUp()
+    >>> EXPANDED_ZODB.testSetUp()
+
+The test would then execute. It may use the ZODB root.
+
+    >>> EXPANDED_ZODB['zodbConnection']
+    <Connection at ...>
+
+    >>> EXPANDED_ZODB['zodbRoot'] == dict(someData='a string', additionalData='Some new data')
+    True
+
+    >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'
+
+On test tear-down, the transaction is aborted and the connection is closed.
+
+    >>> EXPANDED_ZODB.testTearDown()
+    >>> POPULATED_ZODB.testTearDown()
+
+    >>> EXPANDED_ZODB.get('zodbConnection', None) is None
+    True
+
+    >>> EXPANDED_ZODB.get('zodbRoot', None) is None
+    True
+
+The transaction has been rolled back.
+
+    >>> conn = EXPANDED_ZODB['zodbDB'].open()
+    >>> conn.root() == dict(someData='a string', additionalData='Some new data')
+    True
+    >>> conn.close()
+
+We'll now tear down the expanded layer and inspect the database again.
+
+    >>> runner.tear_down_unneeded(options, [POPULATED_ZODB], setupLayers)
+    Tear down ExpandedZODB in ... seconds.
+
+    >>> conn = EXPANDED_ZODB['zodbDB'].open()
+    >>> conn.root()
+    {'someData': 'a string'}
+
+    >>> conn.close()
+
+Finally, we'll tear down the rest of the layers.
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down PopulatedZODB in ... seconds.
+
+    >>> EXPANDED_ZODB.get('zodbDB', None) is None
+    True
+    >>> POPULATED_ZODB.get('zodbDB', None) is None
+    True
diff --git a/src/plone/testing/zodb.txt b/src/plone/testing/zodb.txt
deleted file mode 100644
index 79ff465..0000000
--- a/src/plone/testing/zodb.txt
+++ /dev/null
@@ -1,288 +0,0 @@
-Zope Object Database layers
----------------------------
-
-The ZODB layers are found in the module ``plone.testing.zodb``:
-
-    >>> from plone.testing import zodb
-
-For testing, we need a testrunner
-
-    >>> from zope.testrunner import runner
-
-Empty ZODB layer
-~~~~~~~~~~~~~~~~
-
-The ``EMPTY_ZODB`` layer is used to set up an empty ZODB using
-``DemoStorage``.
-
-The storage and database are set up as layer fixtures. The database is exposed
-as the resource ``zodbDB``.
-
-A connection is opened for each test and exposed as ``zodbConnection``. The
-ZODB root is also exposed, as ``zodbRoot``. A new transaction is begun for
-each test. On test tear-down, the transaction is aborted, the connection is
-closed, and the two test-specific resources are deleted.
-
-The layer has no bases.
-
-    >>> "%s.%s" % (zodb.EMPTY_ZODB.__module__, zodb.EMPTY_ZODB.__name__,)
-    'plone.testing.zodb.EmptyZODB'
-
-    >>> zodb.EMPTY_ZODB.__bases__
-    ()
-
-Layer setup creates the database, but not a connection.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, zodb.EMPTY_ZODB, setupLayers)
-    Set up plone.testing.zodb.EmptyZODB in ... seconds.
-
-    >>> db = zodb.EMPTY_ZODB['zodbDB']
-    >>> db.storage
-    EmptyZODB
-
-    >>> zodb.EMPTY_ZODB.get('zodbConnection', None) is None
-    True
-    >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None
-    True
-
-Let's now simulate a test.
-
-    >>> zodb.EMPTY_ZODB.testSetUp()
-
-The test would then execute. It may use the ZODB root.
-
-    >>> zodb.EMPTY_ZODB['zodbConnection']
-    <Connection at ...>
-
-    >>> zodb.EMPTY_ZODB['zodbRoot']
-    {}
-
-    >>> zodb.EMPTY_ZODB['zodbRoot']['foo'] = 'bar'
-
-On test tear-down, the transaction is aborted and the connection is closed.
-
-    >>> zodb.EMPTY_ZODB.testTearDown()
-
-    >>> zodb.EMPTY_ZODB.get('zodbConnection', None) is None
-    True
-
-    >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None
-    True
-
-The transaction has been rolled back.
-
-    >>> conn = zodb.EMPTY_ZODB['zodbDB'].open()
-    >>> conn.root()
-    {}
-    >>> conn.close()
-
-Layer tear-down closes and deletes the database.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.zodb.EmptyZODB in ... seconds.
-
-    >>> zodb.EMPTY_ZODB.get('zodbDB', None) is None
-    True
-
-Extending the ZODB layer
-~~~~~~~~~~~~~~~~~~~~~~~~
-
-When creating a test fixture, it is often desirable to add some initial data
-to the database. If you want to do that once on layer setup, you can create
-your own layer class based on ``EmptyZODB`` and override its
-``createStorage()`` and/or ``createDatabase()`` methods to return a
-pre-populated database.
-
-
-    >>> import transaction
-    >>> from ZODB.DemoStorage import DemoStorage
-    >>> from ZODB.DB import DB
-
-    >>> class PopulatedZODB(zodb.EmptyZODB):
-    ...
-    ...     def createStorage(self):
-    ...         return DemoStorage("My storage")
-    ...
-    ...     def createDatabase(self, storage):
-    ...         db = DB(storage)
-    ...         conn = db.open()
-    ...
-    ...         conn.root()['someData'] = 'a string'
-    ...
-    ...         transaction.commit()
-    ...         conn.close()
-    ...
-    ...         return db
-
-    >>> POPULATED_ZODB = PopulatedZODB()
-
-We'll use this new layer in a similar manner to the test above, showing that
-the data is there for each test, but that other changes are rolled back.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, POPULATED_ZODB, setupLayers)
-    Set up PopulatedZODB in ... seconds.
-
-    >>> db = POPULATED_ZODB['zodbDB']
-    >>> db.storage
-    My storage
-
-    >>> POPULATED_ZODB.get('zodbConnection', None) is None
-    True
-    >>> POPULATED_ZODB.get('zodbRoot', None) is None
-    True
-
-Let's now simulate a test.
-
-    >>> POPULATED_ZODB.testSetUp()
-
-The test would then execute. It may use the ZODB root.
-
-    >>> POPULATED_ZODB['zodbConnection']
-    <Connection at ...>
-
-    >>> POPULATED_ZODB['zodbRoot']
-    {'someData': 'a string'}
-
-    >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'
-
-On test tear-down, the transaction is aborted and the connection is closed.
-
-    >>> POPULATED_ZODB.testTearDown()
-
-    >>> POPULATED_ZODB.get('zodbConnection', None) is None
-    True
-
-    >>> POPULATED_ZODB.get('zodbRoot', None) is None
-    True
-
-The transaction has been rolled back.
-
-    >>> conn = POPULATED_ZODB['zodbDB'].open()
-    >>> conn.root()
-    {'someData': 'a string'}
-    >>> conn.close()
-
-Layer tear-down closes and deletes the database.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down PopulatedZODB in ... seconds.
-
-    >>> POPULATED_ZODB.get('zodbDB', None) is None
-    True
-
-Stacking ``DemoStorage`` storages
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-The example above shows how to create a simple test fixture with a custom
-database. It is sometimes useful to be able to stack these fixtures, so that
-a base layer sets up some data for one set of tests, and a child layer
-extends this, temporarily, with more data.
-
-This can be achieved using layer bases and resource shadowing, combined with
-ZODB's stackable DemoStorage. There is even a helper function available:
-
-    >>> from plone.testing import Layer
-    >>> from plone.testing import zodb
-    >>> import transaction
-
-    >>> class ExpandedZODB(Layer):
-    ...     defaultBases = (POPULATED_ZODB,)
-    ...
-    ...     def setUp(self):
-    ...         # Get the database from the base layer
-    ...
-    ...         self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='ExpandedZODB')
-    ...
-    ...         conn = db.open()
-    ...         conn.root()['additionalData'] = "Some new data"
-    ...         transaction.commit()
-    ...         conn.close()
-    ...
-    ...     def tearDown(self):
-    ...         # Close the database and delete the shadowed copy
-    ...
-    ...         self['zodbDB'].close()
-    ...         del self['zodbDB']
-
-    >>> EXPANDED_ZODB = ExpandedZODB()
-
-Notice that we are using plain ``Layer`` as a base class here. We obtain the
-underlying database from our bases using the resource manager, and then
-create a shadow copy using a stacked storage. Stacked storages contain the
-data of the original storage, but save changes in a separate (and, in this
-case, temporary) storage.
-
-Let's simulate a test run again to show how this would work.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, EXPANDED_ZODB, setupLayers)
-    Set up PopulatedZODB in ... seconds.
-    Set up ExpandedZODB in ... seconds.
-
-    >>> db = EXPANDED_ZODB['zodbDB']
-    >>> db.storage
-    ExpandedZODB
-
-    >>> EXPANDED_ZODB.get('zodbConnection', None) is None
-    True
-    >>> EXPANDED_ZODB.get('zodbRoot', None) is None
-    True
-
-Let's now simulate a test.
-
-    >>> POPULATED_ZODB.testSetUp()
-    >>> EXPANDED_ZODB.testSetUp()
-
-The test would then execute. It may use the ZODB root.
-
-    >>> EXPANDED_ZODB['zodbConnection']
-    <Connection at ...>
-
-    >>> EXPANDED_ZODB['zodbRoot'] == dict(someData='a string', additionalData='Some new data')
-    True
-
-    >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'
-
-On test tear-down, the transaction is aborted and the connection is closed.
-
-    >>> EXPANDED_ZODB.testTearDown()
-    >>> POPULATED_ZODB.testTearDown()
-
-    >>> EXPANDED_ZODB.get('zodbConnection', None) is None
-    True
-
-    >>> EXPANDED_ZODB.get('zodbRoot', None) is None
-    True
-
-The transaction has been rolled back.
-
-    >>> conn = EXPANDED_ZODB['zodbDB'].open()
-    >>> conn.root() == dict(someData='a string', additionalData='Some new data')
-    True
-    >>> conn.close()
-
-We'll now tear down the expanded layer and inspect the database again.
-
-    >>> runner.tear_down_unneeded(options, [POPULATED_ZODB], setupLayers)
-    Tear down ExpandedZODB in ... seconds.
-
-    >>> conn = EXPANDED_ZODB['zodbDB'].open()
-    >>> conn.root()
-    {'someData': 'a string'}
-
-    >>> conn.close()
-
-Finally, we'll tear down the rest of the layers.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down PopulatedZODB in ... seconds.
-
-    >>> EXPANDED_ZODB.get('zodbDB', None) is None
-    True
-    >>> POPULATED_ZODB.get('zodbDB', None) is None
-    True


Repository: plone.testing


Branch: refs/heads/master
Date: 2015-12-10T23:51:36+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/4aea4b663a91e7d28aabcd37f030efca90bd3481

simpler concatenating

Files changed:
M setup.py

diff --git a/setup.py b/setup.py
index e062ea2..0bc88cd 100644
--- a/setup.py
+++ b/setup.py
@@ -33,15 +33,17 @@
     name='plone.testing',
     version=version,
     description="Testing infrastructure for Zope and Plone projects.",
-    long_description=(open(os.path.join("src", "plone", "testing", "README.rst")).read() + "\n\n" +
-                      open("CHANGES.rst").read() + "\n\n" +
-                      "Detailed documentation\n" +
-                      "======================\n\n" +
-                      open(os.path.join("src", "plone", "testing", "layer.rst")).read() + "\n\n" +
-                      open(os.path.join("src", "plone", "testing", "zca.rst")).read() + "\n\n" +
-                      open(os.path.join("src", "plone", "testing", "security.rst")).read() + "\n\n" +
-                      open(os.path.join("src", "plone", "testing", "publisher.rst")).read() + "\n\n" +
-                      open(os.path.join("src", "plone", "testing", "zodb.rst")).read()),
+    long_description=(u'\n\n'.join([
+        open(os.path.join("src", "plone", "testing", "README.rst")).read(),
+        open("CHANGES.rst").read(),
+        "Detailed documentation\n" +
+        "======================",
+        open(os.path.join("src", "plone", "testing", "layer.rst")).read(),
+        open(os.path.join("src", "plone", "testing", "zca.rst")).read(),
+        open(os.path.join("src", "plone", "testing", "security.rst")).read(),
+        open(os.path.join("src", "plone", "testing", "publisher.rst")).read(),
+        open(os.path.join("src", "plone", "testing", "zodb.rst")).read()
+    ])),
     classifiers=[
         "Environment :: Web Environment",
         "Framework :: Plone",


Repository: plone.testing


Branch: refs/heads/master
Date: 2015-12-11T01:16:56+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/58624ac117d26042a459626c1f5ba82864cbd48b

reformat for semantic linebreaks. add code block indicators

Files changed:
M src/plone/testing/README.rst
M src/plone/testing/layer.rst
M src/plone/testing/publisher.rst
M src/plone/testing/security.rst
M src/plone/testing/z2.rst
M src/plone/testing/zca.rst
M src/plone/testing/zodb.rst

diff --git a/src/plone/testing/README.rst b/src/plone/testing/README.rst
index d782c05..5057086 100644
--- a/src/plone/testing/README.rst
+++ b/src/plone/testing/README.rst
@@ -3,133 +3,132 @@ Introduction
 
 .. contents:: Table of contents
 
-``plone.testing`` provides tools for writing unit and integration tests in a
-Zope and Plone environment. It is not tied to Plone, and it does not depend on
-Zope 2 (although it has some optional Zope 2-only features).
+``plone.testing`` provides tools for writing unit and integration tests in a Zope and Plone environment.
+It is not tied to Plone, and it does not depend on Zope 2 (although it has some optional Zope 2-only features).
 
 ``plone.testing`` builds on `zope.testing`_, in particular its layers concept.
-This package also aims to promote some "good practice" for writing tests of
-various types.
+This package also aims to promote some "good practice" for writing tests of various types.
 
 .. note::
 
-   If you are working with Plone, there is a complementary package
-   `plone.app.testing`_, which builds on ``plone.testing`` to provide
-   additional layers useful for testing Plone add-ons.
+   If you are working with Plone, there is a complementary package `plone.app.testing`_, which builds on ``plone.testing`` to provide additional layers useful for testing Plone add-ons.
 
-If you are new to automated testing and test driven development, you should
-spend some time learning about those concepts. Some useful references include:
+If you are new to automated testing and test driven development, you should spend some time learning about those concepts.
+Some useful references include:
 
 * `The Wikipedia article on unit testing <http://en.wikipedia.org/wiki/Unit_testing>`_
 * `The Dive Into Python chapter on testing <http://diveintopython.net/unit_testing/index.html>`_
 
-Bear in mind that different Python frameworks have slightly different takes on
-how to approach testing. Therefore, you may find examples that are different
-to those shown below. The core concepts should be consistent, however.
+Bear in mind that different Python frameworks have slightly different takes on how to approach testing.
+Therefore, you may find examples that are different to those shown below.
+The core concepts should be consistent, however.
 
 Compatibility
 -------------
 
 ``plone.testing`` 4.x has only been tested with Python 2.6 and 2.7.
-If you're using the
-optional Zope 2 layers, you must use Zope version 2.12 or later.
+If you're using the optional Zope 2 layers, you must use Zope version 2.12 or later.
 Look at ``plone.testing`` 3.x for Zope 2.10 support.
 
 Definitions
 -----------
 
-In this documentation, we will use a number of testing-related terms. The
-following definitions apply:
+In this documentation, we will use a number of testing-related terms.
+The following definitions apply:
 
 Unit test
-    An automated test (i.e. one written in code) that tests a single unit
-    (normally a function) in isolation. A unit test attempts to prove that the
-    given function works as expected and gives the correct output given a
-    particular input. It is common to have a number of unit tests for a single
-    function, testing different inputs, including boundary cases and errors.
+
+    An automated test (i.e. one written in code) that tests a single unit (normally a function) in isolation.
+    A unit test attempts to prove that the given function works as expected and gives the correct output given a particular input.
+    It is common to have a number of unit tests for a single function, testing different inputs, including boundary cases and errors.
     Unit tests are typically quick to write and run.
+
 Integration test
-    An automated test that tests how a number of units interact. In a Zope
-    context, this often pertains to how a particular object or view interacts
-    with the Zope framework, the ZODB persistence engine, and so on.
-    Integration tests usually require some setup and can be slower to run than
-    unit tests. It is common to have fewer integration tests than unit test.
+
+    An automated test that tests how a number of units interact.
+    In a Zope context, this often pertains to how a particular object or view interacts with the Zope framework, the ZODB persistence engine, and so on.
+    Integration tests usually require some setup and can be slower to run than unit tests.
+    It is common to have fewer integration tests than unit test.
+
 Functional test
-    An automated test that tests a feature in an "end-to-end" fashion. In a
-    Zope context, that normally means that it invokes an action in the same
-    way that a user would, i.e. through a web request. Functional tests are
-    normally slower to run than either unit or integration tests, and can be
-    significantly slower to run. It is therefore common to have only a few
-    functional tests for each major feature, relying on unit and integration
-    tests for the bulk of testing.
+
+    An automated test that tests a feature in an "end-to-end" fashion.
+    In a Zope context, that normally means that it invokes an action in the same way that a user would, i.e. through a web request.
+    Functional tests are normally slower to run than either unit or integration tests, and can be significantly slower to run.
+    It is therefore common to have only a few functional tests for each major feature, relying on unit and integration tests for the bulk of testing.
+
 Black box testing
-    Testing which only considers the system's defined inputs and outputs. For
-    example, a functional test is normally a black box test that provides
-    inputs only through the defined interface (e.g. URLs published in a web
-    application), and makes assertions only on end outputs (e.g. the response
-    returned for requests to those URLs).
+
+    Testing which only considers the system's defined inputs and outputs.
+    For example, a functional test is normally a black box test that provides inputs only through the defined interface (e.g. URLs published in a web application), and makes assertions only on end outputs (e.g. the response returned for requests to those URLs).
+
 White box testing
+
     Testing which examines the internal state of a system to make assertions.
-    Authors of unit and integration tests normally have significant knowledge
-    of the implementation of the code under test, and can examine such things
-    as data in a database or changes to the system's environment to determine
-    if the test succeeded or failed.
+    Authors of unit and integration tests normally have significant knowledge of the implementation of the code under test, and can examine such things as data in a database or changes to the system's environment to determine if the test succeeded or failed.
+
 Assertion
-    A check that determines whether a test succeeds or fails. For example, if
-    a unit test for the function ``foo()`` expects it to return the value 1,
-    an assertion could be written to verify this fact. A test is said to
-    *fail* if any of its assertions fail. A test always contains one or more
-    assertions.
+
+    A check that determines whether a test succeeds or fails.
+    For example, if a unit test for the function ``foo()`` expects it to return the value 1, an assertion could be written to verify this fact.
+    A test is said to *fail* if any of its assertions fail.
+    A test always contains one or more assertions.
+
 Test case
-    A single unit, integration or functional test. Often shortened to just
-    *test*. A test case sets up, executes and makes assertions against a
-    single scenario that bears testing.
+
+    A single unit, integration or functional test.
+    Often shortened to just *test*.
+    A test case sets up, executes and makes assertions against a single scenario that bears testing.
+
 Test fixture
-    The state used as a baseline for one or more tests. The test fixture is
-    *set up* before each test is executed, and *torn down* afterwards. This is
-    a pre-requisite for *test isolation* - the principle that tests should be
-    independent of one another.
+
+    The state used as a baseline for one or more tests.
+    The test fixture is *set up* before each test is executed, and *torn down* afterwards.
+    This is a pre-requisite for *test isolation* - the principle that tests should be independent of one another.
+
 Layer
-    The configuration of a test fixture shared by a number of tests. All test
-    cases that belong to a particular layer will be executed together. The
-    layer is *set up* once before the tests are executed, and *torn down* once
-    after. Layers may depend on one another. Any *base layers* are set up
-    before and torn down after a particular *child layer* is used. The test
-    runner will order test execution to minimise layer setup and tear-down.
+
+    The configuration of a test fixture shared by a number of tests.
+    All test cases that belong to a particular layer will be executed together.
+    The layer is *set up* once before the tests are executed, and *torn down* once after.
+    Layers may depend on one another.
+    Any *base layers* are set up before and torn down after a particular *child layer* is used.
+    The test runner will order test execution to minimise layer setup and tear-down.
+
 Test suite
+
     A collection of test cases (and layers) that are executed together.
+
 Test runner
-    The program which executes tests. This is responsible for calling layer
-    and test fixture set-up and tear-down methods. It also reports on the test
-    run, usually by printing output to the console.
+
+    The program which executes tests.
+    This is responsible for calling layer and test fixture set-up and tear-down methods.
+    It also reports on the test run, usually by printing output to the console.
+
 Coverage
-    To have confidence in your code, you should ensure it is adequately
-    covered by tests. That is, each line of code, and each possible branching
-    point (loops, ``if`` statements) should be executed by a test. This is
-    known as *coverage*, and is normally measured as a percentage of lines of
-    non-test code covered by tests. Coverage can be measured by the test
-    runner, which keeps track of which lines of code were executed in a given
-    test run.
+
+    To have confidence in your code, you should ensure it is adequately covered by tests.
+    That is, each line of code, and each possible branching point (loops, ``if`` statements) should be executed by a test.
+    This is known as *coverage*, and is normally measured as a percentage of lines of non-test code covered by tests.
+    Coverage can be measured by the test runner, which keeps track of which lines of code were executed in a given test run.
+
 Doctest
-    A style of testing where tests are written as examples that could be typed
-    into the interactive Python interpreter. The test runner executes each
-    example and checks the actual output against the expected output. Doctests
-    can either be placed in the docstring of a method, or in a separate file.
-    The use of doctests is largely a personal preference. Some developers like
-    to write documentation as doctests, which has the advantage that code
-    samples can be automatically tested for correctness. You can read more
-    about doctests on `Wikipedia <http://en.wikipedia.org/wiki/Doctest>`_.
+
+    A style of testing where tests are written as examples that could be typed into the interactive Python interpreter.
+    The test runner executes each example and checks the actual output against the expected output.
+    Doctests can either be placed in the docstring of a method, or in a separate file.
+    The use of doctests is largely a personal preference.
+    Some developers like to write documentation as doctests, which has the advantage that code samples can be automatically tested for correctness.
+    You can read more about doctests on `Wikipedia <http://en.wikipedia.org/wiki/Doctest>`_.
 
 Installation and usage
 ======================
 
-To use ``plone.testing`` in your own package, you need to add it as a
-dependency. Most people prefer to keep test-only dependencies separate, so
-that they do not need to be installed in scenarios (such as on a production
-server) where the tests will not be run. This can be achieved using a
-``test`` extra.
+To use ``plone.testing`` in your own package, you need to add it as a dependency.
+Most people prefer to keep test-only dependencies separate, so that they do not need to be installed in scenarios (such as on a production server) where the tests will not be run.
+This can be achieved using a ``test`` extra.
 
-In ``setup.py``, add or modify the ``extras_require`` option, like so::
+In ``setup.py``, add or modify the ``extras_require`` option, like so:::
 
     extras_require = {
         'test': [
@@ -139,9 +138,9 @@ In ``setup.py``, add or modify the ``extras_require`` option, like so::
 
 You can add other test-only dependencies to that list as well, of course.
 
-To run tests, you need a test runner. If you are using ``zc.buildout``, you
-can install a test runner using the `zc.recipe.testrunner`_ recipe. For
-example, you could add the following to your ``buildout.cfg``::
+To run tests, you need a test runner.
+If you are using ``zc.buildout``, you can install a test runner using the `zc.recipe.testrunner`_ recipe.
+For example, you could add the following to your ``buildout.cfg``:::
 
     [test]
     recipe = zc.recipe.testrunner
@@ -149,40 +148,31 @@ example, you could add the following to your ``buildout.cfg``::
         my.package [test]
     defaults = ['--auto-color', '--auto-progress']
 
-You'll also need to add this part to the ``parts`` list, of course::
+You'll also need to add this part to the ``parts`` list, of course:::
 
     [buildout]
     parts =
         ...
         test
 
-In this example, have listed a single package to test, called ``my.package``,
-and asked for it to be installed with the ``[test]`` extra. This will install
-any regular dependencies (listed in the ``install_requires`` option in
-``setup.py``), as well as those in the list associated with the ``test`` key
-in the ``extras_require`` option.
+In this example, have listed a single package to test, called ``my.package``, and asked for it to be installed with the ``[test]`` extra.
+This will install any regular dependencies (listed in the ``install_requires`` option in ``setup.py``), as well as those in the list associated with the ``test`` key in the ``extras_require`` option.
 
-Note that it becomes important to properly list your dependencies here,
-because the test runner will only be aware of the packages explicitly listed,
-and their dependencies. For example, if your package depends on Zope 2, you
-need to list ``Zope2`` in the ``install_requires`` list in ``setup.py``; ditto
-for ``Plone``, or indeed any other package you import from.
+Note that it becomes important to properly list your dependencies here, because the test runner will only be aware of the packages explicitly listed, and their dependencies.
+For example, if your package depends on Zope 2, you need to list ``Zope2`` in the ``install_requires`` list in ``setup.py``;
+ditto for ``Plone``, or indeed any other package you import from.
 
-Once you have re-run buildout, the test runner will be installed as
-``bin/test`` (the executable name is taken from the name of the buildout
-part). You can execute it without arguments to run all tests of each egg
-listed in the ``eggs`` list::
+Once you have re-run buildout, the test runner will be installed as ``bin/test`` (the executable name is taken from the name of the buildout part).
+You can execute it without arguments to run all tests of each egg listed in the ``eggs`` list::
 
     $ bin/test
 
-If you have listed several eggs, and you want to run the tests for a
-particular one, you can do::
+If you have listed several eggs, and you want to run the tests for a particular one, you can do::
 
     $ bin/test -s my.package
 
-If you want to run only a particular test within this package, use the ``-t``
-option. This can be passed a regular expression matching either a doctest file
-name or a test method name.
+If you want to run only a particular test within this package, use the ``-t`` option.
+This can be passed a regular expression matching either a doctest file name or a test method name.::
 
     $ bin/test -s my.package -t test_spaceship
 
@@ -190,16 +180,16 @@ There are other command line options, which you can find by running::
 
     $ bin/test --help
 
-Also note the ``defaults`` option in the buildout configuration. This can be
-used to set default command line options. Some commonly useful options are
-shown above.
+Also note the ``defaults`` option in the buildout configuration.
+This can be used to set default command line options.
+Some commonly useful options are shown above.
 
 Coverage reporting
 ------------------
 
 When writing tests, it is useful to know how well your tests cover your code.
-You can create coverage reports via the excellent `coverage`_ library. In
-order to use it, we need to install it and a reporting script::
+You can create coverage reports via the excellent `coverage`_ library.
+In order to use it, we need to install it and a reporting script::
 
     [buildout]
     parts =
@@ -222,20 +212,16 @@ order to use it, we need to install it and a reporting script::
     initialization =
         sys.argv = sys.argv[:] + ['html', '-i']
 
-This will run the ``bin/test`` script with arguments like `--all` to run all
-layers. You can also specify no or some other arguments. It will place coverage
-reporting information in a ``.coverage`` file inside your buildout root.
-Via the ``--source`` argument you specify the directories containing code you
-want to cover. The coverage script would otherwise generate coverage
-information for all executed code, including other packages and even the
-standard library.
+This will run the ``bin/test`` script with arguments like `--all` to run all layers.
+You can also specify no or some other arguments.
+It will place coverage reporting information in a ``.coverage`` file inside your buildout root.
+Via the ``--source`` argument you specify the directories containing code you want to cover.
+The coverage script would otherwise generate coverage information for all executed code, including other packages and even the standard library.
 
-Running the ``bin/report`` script will generate a human readable HTML
-representation of the run in the `htmlcov` directory. Open the contained
-`index.html` in a browser to see the result.
+Running the ``bin/report`` script will generate a human readable HTML representation of the run in the `htmlcov` directory.
+Open the contained `index.html` in a browser to see the result.
 
-If you want to generate an XML representation suitable for the `Cobertura`_
-plugin of `Hudson`_, you can add another part::
+If you want to generate an XML representation suitable for the `Cobertura`_ plugin of `Hudson`_, you can add another part::
 
     [buildout]
     parts =
@@ -254,19 +240,15 @@ This will generate a ``coverage.xml`` file in the buildout root.
 Optional dependencies
 ---------------------
 
-``plone.testing`` comes with a core set of tools for managing layers, which
-depends only on `zope.testing`_ and (for Python < 2.7) `unittest2`_. In addition, there are
-several layers and helper functions which can be used in your own tests (or
-as bases for your own layers). Some of these have deeper dependencies.
-However, these dependencies are optional and not installed by default. If you
-don't use the relevant layers, you can safely ignore them.
+``plone.testing`` comes with a core set of tools for managing layers, which depends only on `zope.testing`_ and (for Python < 2.7) `unittest2`_.
+In addition, there are several layers and helper functions which can be used in your own tests (or as bases for your own layers).
+Some of these have deeper dependencies.
+However, these dependencies are optional and not installed by default.
+If you don't use the relevant layers, you can safely ignore them.
 
-``plone.testing`` does specify these dependencies, however, using the
-``setuptools`` "extras" feature. You can depend on one or more extras in
-your own ``setup.py`` ``install_requires`` or ``extras_require`` option
-using the same square bracket notation shown for the ``[test]`` buildout part
-above. For example, if you need both the ``zca`` and ``publisher`` extras, you
-can have the following in your ``setup.py``::
+``plone.testing`` does specify these dependencies, however, using the ``setuptools`` "extras" feature.
+You can depend on one or more extras in your own ``setup.py`` ``install_requires`` or ``extras_require`` option using the same square bracket notation shown for the ``[test]`` buildout part above.
+For example, if you need both the ``zca`` and ``publisher`` extras, you can have the following in your ``setup.py``::
 
     extras_require = {
         'test': [
@@ -277,40 +259,51 @@ can have the following in your ``setup.py``::
 The available extras are:
 
 ``zodb``
-    ZODB testing. Depends on ``ZODB3``. The relevant layers and helpers are in
-    the module ``plone.testing.zodb``.
+
+    ZODB testing.
+    Depends on ``ZODB3``.
+    The relevant layers and helpers are in the module ``plone.testing.zodb``.
+
 ``zca``
-    Zope Component Architecture testing. Depends on core Zope Component
-    Architecture packages such as ``zope.component`` and ``zope.event``. The
-    relevant layers and helpers are in the module ``plone.testing.zca``.
+
+    Zope Component Architecture testing.
+    Depends on core Zope Component Architecture packages such as ``zope.component`` and ``zope.event``.
+    The relevant layers and helpers are in the module ``plone.testing.zca``.
+
 ``security``
-    Security testing. Depends on ``zope.security``. The relevant layers and
-    helpers are in the module ``plone.testing.security``.
+
+    Security testing.
+    Depends on ``zope.security``.
+    The relevant layers and helpers are in the module ``plone.testing.security``.
+
 ``publisher``
-    Zope Publisher testing. Depends on ``zope.app.publisher`` and sets up
-    ZCML directives. The relevant layers and helpers are in the module
-    ``plone.testing.publisher``.
+
+    Zope Publisher testing.
+    Depends on ``zope.app.publisher`` and sets up ZCML directives.
+    The relevant layers and helpers are in the module ``plone.testing.publisher``.
+
 ``z2``
-    Zope 2 testing. Depends on the ``Zope2`` egg, which includes all the
-    dependencies of the Zope 2 application server. The relevant layers and
-    helpers are in the module ``plone.testing.z2``
+
+    Zope 2 testing.
+    Depends on the ``Zope2`` egg, which includes all the dependencies of the Zope 2 application server.
+    The relevant layers and helpers are in the module ``plone.testing.z2``
 
 Adding a test buildout to your package
 --------------------------------------
 
-When creating re-usable, mostly stand-alone packages, it is often useful to be
-able to include a buildout with the package sources itself that can be used to
-create a test runner. This is a popular approach for many Zope packages, for
-example. In fact, ``plone.testing`` itself uses this kind of layout.
+When creating re-usable, mostly stand-alone packages, it is often useful to be able to include a buildout with the package sources itself that can be used to create a test runner.
+This is a popular approach for many Zope packages, for example.
+In fact, ``plone.testing`` itself uses this kind of layout.
 
 To have a self-contained buildout in your package, the following is required:
 
 * You need a ``buildout.cfg`` at the root of the package.
-* In most cases, you always want a ``bootstrap.py`` file to make it easier for
-  people to set up a fresh buildout.
-* Your package sources need to be inside a ``src`` directory. If you're using
-  namespace packages, that means the top level package should be in the
-  ``src`` directory.
+
+* In most cases, you always want a ``bootstrap.py`` file to make it easier for people to set up a fresh buildout.
+
+* Your package sources need to be inside a ``src`` directory.
+  If you're using namespace packages, that means the top level package should be in the ``src`` directory.
+
 * The ``src`` directory must be referenced in ``setup.py``.
 
 For example, ``plone.testing`` has the following layout::
@@ -368,16 +361,12 @@ The ``buildout.cfg`` for ``plone.testing`` looks like this::
     initialization =
         sys.argv = sys.argv[:] + ['xml', '-i']
 
-Obviously, you should adjust the package name in the ``eggs`` list and the
-version set in the ``extends`` line as appropriate.
+Obviously, you should adjust the package name in the ``eggs`` list and the version set in the ``extends`` line as appropriate.
 
-You can of course also add additional buildout parts, for example to include
-some development/debugging tools, or even a running application server for
-testing purposes.
+You can of course also add additional buildout parts, for example to include some development/debugging tools, or even a running application server for testing purposes.
 
-    *Hint:* If you use this package layout, you should avoid checking any
-    files or directories generated by buildout into your version control
-    repository. You want to ignore:
+    *Hint:* If you use this package layout, you should avoid checking any files or directories generated by buildout into your version control repository.
+    You want to ignore:
 
     * ``.coverage``
     * ``.installed.cfg``
@@ -391,63 +380,61 @@ testing purposes.
 Layers
 ======
 
-In large part, ``plone.testing`` is about layers. It provides:
+In large part, ``plone.testing`` is about layers.
+It provides:
 
 * A set of layers (outlined below), which you can use or extend.
+
 * A set of tools for working with layers
-* A mini-framework to make it easy to write layers and manage shared resources
-  associated with layers.
 
-We'll discuss the last two items here, before showing how to write tests that
-use layers.
+* A mini-framework to make it easy to write layers and manage shared resources associated with layers.
+
+We'll discuss the last two items here, before showing how to write tests that use layers.
 
 Layer basics
 ------------
 
-Layers are used to create test fixtures that are shared by multiple test
-cases. For example, if you are writing a set of integration tests, you may
-need to set up a database and configure various components to access that
-database. This type of test fixture setup can be resource-intensive and
-time-consuming. If it is possible to only perform the setup and tear-down once
-for a set of tests without losing isolation between those tests, test runs can
-often be sped up significantly.
+Layers are used to create test fixtures that are shared by multiple test cases.
+For example, if you are writing a set of integration tests, you may need to set up a database and configure various components to access that database.
+This type of test fixture setup can be resource-intensive and time-consuming.
+If it is possible to only perform the setup and tear-down once for a set of tests without losing isolation between those tests, test runs can often be sped up significantly.
 
 Layers also allow re-use of test fixtures and set-up/tear-down code.
-``plone.testing`` provides a number of useful (but optional) layers that
-manage test fixtures for common Zope testing scenarios, letting you focus on
-the actual test authoring.
+``plone.testing`` provides a number of useful (but optional) layers that manage test fixtures for common Zope testing scenarios, letting you focus on the actual test authoring.
 
-At the most basic, a layer is an object with the following methods and
-attributes:
+At the most basic, a layer is an object with the following methods and attributes:
 
 ``setUp()``
-    Called by the test runner when the layer is to be set up. This is called
-    exactly once for each layer used during a test run.
+
+    Called by the test runner when the layer is to be set up.
+    This is called exactly once for each layer used during a test run.
+
 ``tearDown()``
-    Called by the test runner when the layer is to be torn down. As with
-    ``setUp()``, this is called exactly once for each layer.
+
+    Called by the test runner when the layer is to be torn down.
+    As with ``setUp()``, this is called exactly once for each layer.
+
 ``testSetUp()``
+
     Called immediately before each test case that uses the layer is executed.
-    This is useful for setting up aspects of the fixture that are managed on
-    a per-test basis, as opposed to fixture shared among all tests.
+    This is useful for setting up aspects of the fixture that are managed on a per-test basis, as opposed to fixture shared among all tests.
+
 ``testTearDown()``
+
     Called immediately after each test case that uses the layer is executed.
-    This is a chance to perform any post-test cleanup to ensure the fixture
-    is ready for the next test.
+    This is a chance to perform any post-test cleanup to ensure the fixture is ready for the next test.
+
 ``__bases__``
+
     A tuple of base layers.
 
-Each test case is associated with zero or one layer. (The syntax for
-specifying the layer is shown in the section "Writing tests" below.) All the
-tests associated with a given layer will be executed together.
+Each test case is associated with zero or one layer.
+(The syntax for specifying the layer is shown in the section "Writing tests" below.) All the tests associated with a given layer will be executed together.
 
-Layers can depend on one another (as indicated in the ``__bases__`` tuple),
-allowing one layer to build on the fixture created by another. Base layers are
-set up before and torn down after their dependants.
+Layers can depend on one another (as indicated in the ``__bases__`` tuple), allowing one layer to build on the fixture created by another.
+Base layers are set up before and torn down after their dependants.
 
-For example, if the test runner is executing some tests that belong to layer
-A, and some other tests that belong to layer B, both of which depend on layer
-C, the order of execution might be::
+For example, if the test runner is executing some tests that belong to layer A, and some other tests that belong to layer B, both of which depend on layer C, the order of execution might be::
 
     1. C.setUp()
     1.1. A.setUp()
@@ -482,24 +469,20 @@ C, the order of execution might be::
     1.4. B.tearDown()
     2. C.tearDown()
 
-A base layer may of course depend on other base layers. In the case of nested
-dependencies like this, the order of set up and tear-down as calculated by the
-test runner is similar to the way in which Python searches for the method to
-invoke in the case of multiple inheritance.
+A base layer may of course depend on other base layers.
+In the case of nested dependencies like this, the order of set up and tear-down as calculated by the test runner is similar to the way in which Python searches for the method to invoke in the case of multiple inheritance.
 
 Writing layers
 --------------
 
-The easiest way to create a new layer is to use the ``Layer`` base class and
-implement the ``setUp()``, ``tearDown()``, ``testSetUp()`` and
-``testTearDown()`` methods as needed. All four are optional. The default
-implementation of each does nothing.
+The easiest way to create a new layer is to use the ``Layer`` base class and implement the ``setUp()``, ``tearDown()``, ``testSetUp()`` and ``testTearDown()`` methods as needed.
+All four are optional.
+The default implementation of each does nothing.
 
-By convention, layers are created in a module called ``testing.py`` at the top
-level of your package. The idea is that other packages that extend your
-package can re-use your layers for their own testing.
+By convention, layers are created in a module called ``testing.py`` at the top level of your package.
+The idea is that other packages that extend your package can re-use your layers for their own testing.
 
-A simple layer may look like this:
+A simple layer may look like this::
 
     >>> from plone.testing import Layer
     >>> class SpaceShip(Layer):
@@ -516,28 +499,24 @@ A simple layer may look like this:
     ...     def testTearDown(self):
     ...         print "Emptying the fuel tank"
 
-Before this layer can be used, it must be instantiated. Layers are normally
-instantiated exactly once, since by nature they are shared between tests. This
-becomes important when you start to manage resources (such as persistent data,
-database connections, or other shared resources) in layers.
+Before this layer can be used, it must be instantiated.
+Layers are normally instantiated exactly once, since by nature they are shared between tests.
+This becomes important when you start to manage resources (such as persistent data, database connections, or other shared resources) in layers.
 
-The layer instance is conventionally also found in ``testing.py``, just after
-the layer class definition.
+The layer instance is conventionally also found in ``testing.py``, just after the layer class definition.::
 
     >>> SPACE_SHIP = SpaceShip()
 
 .. note::
 
-   Since the layer is instantiated in module scope, it will be
-   created as soon as the ``testing`` module is imported. It is therefore
-   very important that the layer class is inexpensive and safe to create. In
-   general, you should avoid doing anything non-trivial in the ``__init__()``
-   method of your layer class. All setup should happen in the ``setUp()``
-   method. If you *do* implement ``__init__()``, be sure to call the ``super``
-   version as well.
+    Since the layer is instantiated in module scope, it will be created as soon as the ``testing`` module is imported.
+    It is therefore very important that the layer class is inexpensive and safe to create.
+    In general, you should avoid doing anything non-trivial in the ``__init__()`` method of your layer class.
+    All setup should happen in the ``setUp()`` method.
+    If you *do* implement ``__init__()``, be sure to call the ``super`` version as well.
 
-The layer shown above did not have any base layers (dependencies). Here is an
-example of another layer that depends on it:
+The layer shown above did not have any base layers (dependencies).
+Here is an example of another layer that depends on it:::
 
     >>> class ZIGSpaceShip(Layer):
     ...     defaultBases = (SPACE_SHIP,)
@@ -547,64 +526,43 @@ example of another layer that depends on it:
 
     >>> ZIG = ZIGSpaceShip()
 
-Here, we have explicitly listed the base layers on which ``ZIGSpaceShip``
-depends, in the ``defaultBases`` attribute. This is used by the ``Layer``
-base class to set the layer bases in a way that can also be overridden: see
-below.
+Here, we have explicitly listed the base layers on which ``ZIGSpaceShip`` depends, in the ``defaultBases`` attribute.
+This is used by the ``Layer`` base class to set the layer bases in a way that can also be overridden: see below.
 
-Note that we use the layer *instance* in the ``defaultBases`` tuple, not the
-class. Layer dependencies always pertain to specific layer instances. Above,
-we are really saying that *instances* of ``ZIGSpaceShip`` will, by default,
-require the ``SPACE_SHIP`` layer to be set up first.
+Note that we use the layer *instance* in the ``defaultBases`` tuple, not the class.
+Layer dependencies always pertain to specific layer instances.
+Above, we are really saying that *instances* of ``ZIGSpaceShip`` will, by default, require the ``SPACE_SHIP`` layer to be set up first.
 
 .. note::
 
-   You may find it useful to create other layer base/mix-in classes
-   that extend ``plone.testing.Layer`` and provide helper methods for use in
-   your own layers. This is perfectly acceptable, but please do not confuse a
-   layer base class used in this manner with the concept of a *base layer* as
-   described above:
-
-     * A class deriving from ``plone.testing.Layer`` is known as a *layer
-       class*. It defines the behaviour of the layer by implementing the
-       lifecycle methods ``setUp()``, ``tearDown()``, ``testSetUp()`` and/or
-       ``testTearDown()``.
-     * A layer class can be instantiated into an actual layer. When a layer is
-       associated with a test, it is the layer *instance* that is used.
-     * The instance is usually a shared, module-global object, although in
-       some cases it is useful to create copies of layers by instantiating the
-       class more than once.
-     * Subclassing an existing layer class is just straightforward OOP re-use:
-       the test runner is not aware of the subclassing relationship.
-     * A layer *instance* can be associated with any number of layer *bases*,
-       via its ``__bases__`` property (which is usually via the
-       ``defaultBases`` variable in the class body and/or overridden using the
-       ``bases`` argument to the ``Layer`` constructor). These bases are layer
-       *instances*, not classes. The test runner will inspect the ``__bases__``
-       attribute of each layer instance it sets up to calculate layer
-       pre-requisites and dependencies.
-
-   Also note that the `zope.testing`_ documentation contains examples of
-   layers that are "old-style" classes where the ``setUp()`` and
-   ``tearDown()`` methods are ``classmethod`` methods and class inheritance
-   syntax is used to specify base layers. Whilst this pattern works, we
-   discourage its use, because the classes created using this pattern are not
-   really used as classes. The concept of layer bases is slightly different
-   from class inheritance, and using the ``class`` keyword to create layers
-   with base layers leads to a number of "gotchas" that are best avoided.
+    You may find it useful to create other layer base/mix-in classes that extend ``plone.testing.Layer`` and provide helper methods for use in your own layers.
+    This is perfectly acceptable, but please do not confuse a layer base class used in this manner with the concept of a *base layer* as described above:
+
+        * A class deriving from ``plone.testing.Layer`` is known as a *layer class*.
+          It defines the behaviour of the layer by implementing the lifecycle methods ``setUp()``, ``tearDown()``, ``testSetUp()`` and/or ``testTearDown()``.
+
+        * A layer class can be instantiated into an actual layer.
+          When a layer is associated with a test, it is the layer *instance* that is used.
+
+        * The instance is usually a shared, module-global object, although in some cases it is useful to create copies of layers by instantiating the class more than once.
+
+        * Subclassing an existing layer class is just straightforward OOP re-use: the test runner is not aware of the subclassing relationship.
+
+        * A layer *instance* can be associated with any number of layer *bases*, via its ``__bases__`` property (which is usually via the ``defaultBases`` variable in the class body and/or overridden using the ``bases`` argument to the ``Layer`` constructor).
+         These bases are layer *instances*, not classes.
+         The test runner will inspect the ``__bases__`` attribute of each layer instance it sets up to calculate layer pre-requisites and dependencies.
+
+    Also note that the `zope.testing`_ documentation contains examples of layers that are "old-style" classes where the ``setUp()`` and ``tearDown()`` methods are ``classmethod`` methods and class inheritance syntax is used to specify base layers.
+    Whilst this pattern works, we discourage its use, because the classes created using this pattern are not really used as classes.
+    The concept of layer bases is slightly different from class inheritance, and using the ``class`` keyword to create layers with base layers leads to a number of "gotchas" that are best avoided.
 
 Advanced - overriding bases
 ---------------------------
 
-In some cases, it may be useful to create a copy of a layer, but change its
-bases. One reason to do this may if you are re-using a layer from another
-module, and you need to change the order in which layers are set up and torn
-down.
+In some cases, it may be useful to create a copy of a layer, but change its bases.
+One reason to do this may if you are re-using a layer from another module, and you need to change the order in which layers are set up and torn down.
 
-Normally, of course, you would just re-use the layer instance, either directly
-in a test, or in the ``defaultBases`` tuple of another layer, but if you need
-to change the bases, you can pass a new list of bases to the layer instance
-constructor:
+Normally, of course, you would just re-use the layer instance, either directly in a test, or in the ``defaultBases`` tuple of another layer, but if you need to change the bases, you can pass a new list of bases to the layer instance constructor:::
 
     >>> class CATSMessage(Layer):
     ...
@@ -618,49 +576,39 @@ constructor:
 
     >>> ZERO_WING = ZIGSpaceShip(bases=(SPACE_SHIP, CATS_MESSAGE,), name="ZIGSpaceShip:CATSMessage")
 
-Please note that when overriding bases like this, the ``name`` argument is
-required. This is because each layer (using in a given test run) must have
-a unique name. The default is to use the layer class name, but this obviously
-only works for one instantiation. Therefore, ``plone.testing`` requires a
-name when setting ``bases`` explicitly.
+Please note that when overriding bases like this, the ``name`` argument is required.
+This is because each layer (using in a given test run) must have a unique name.
+The default is to use the layer class name, but this obviously only works for one instantiation.
+Therefore, ``plone.testing`` requires a name when setting ``bases`` explicitly.
 
-Please take great care when changing layer bases like this. The layer
-implementation may make assumptions about the test fixture that was set up
-by its bases. If you change the order in which the bases are listed, or remove
-a base altogether, the layer may fail to set up correctly.
+Please take great care when changing layer bases like this.
+The layer implementation may make assumptions about the test fixture that was set up by its bases.
+If you change the order in which the bases are listed, or remove a base altogether, the layer may fail to set up correctly.
 
-Also, bear in mind that the new layer instance is independent of the original
-layer instance, so any resources defined in the layer are likely to be
-duplicated.
+Also, bear in mind that the new layer instance is independent of the original layer instance, so any resources defined in the layer are likely to be duplicated.
 
 Layer combinations
 ------------------
 
-Sometimes, it is useful to be able to combine several layers into one, without
-adding any new fixture. One way to do this is to use the ``Layer`` class
-directly and instantiate it with new bases:
+Sometimes, it is useful to be able to combine several layers into one, without adding any new fixture.
+One way to do this is to use the ``Layer`` class directly and instantiate it with new bases:::
 
     >>> COMBI_LAYER = Layer(bases=(CATS_MESSAGE, SPACE_SHIP,), name="Combi")
 
-Here, we have created a "no-op" layer with two bases: ``CATS_MESSAGE`` and
-``SPACE_SHIP``, named ``Combi``.
+Here, we have created a "no-op" layer with two bases: ``CATS_MESSAGE`` and ``SPACE_SHIP``, named ``Combi``.
 
-Please note that when using ``Layer`` directly like this, the ``name``
-argument is required. This is to allow the test runner to identify the layer
-correctly. Normally, the class name of the layer is used as a basis for the
-name, but when using the ``Layer`` base class directly, this is unlikely to be
-unique or descriptive.
+Please note that when using ``Layer`` directly like this, the ``name`` argument is required.
+This is to allow the test runner to identify the layer correctly.
+Normally, the class name of the layer is used as a basis for the name, but when using the ``Layer`` base class directly, this is unlikely to be unique or descriptive.
 
 Layer resources
 ---------------
 
-Many layers will manage one or more resources that are used either by other
-layers, or by tests themselves. Examples may include database connections,
-thread-local objects, or configuration data.
+Many layers will manage one or more resources that are used either by other layers, or by tests themselves.
+Examples may include database connections, thread-local objects, or configuration data.
 
-``plone.testing`` contains a simple resource storage abstraction that makes it
-easy to access resources from dependant layers or tests. The resource storage
-uses dictionary notation:
+``plone.testing`` contains a simple resource storage abstraction that makes it easy to access resources from dependant layers or tests.
+The resource storage uses dictionary notation:::
 
     >>> class WarpDrive(object):
     ...     """A shared resource"""
@@ -704,59 +652,36 @@ uses dictionary notation:
 
     >>> GALAXY_CLASS_SPACE_SHIP = GalaxyClassSpaceShip()
 
-As shown, layers (that derive from ``plone.testing.Layer``) support item
-(dict-like) assignment, access and deletion of arbitrary resources under
-string keys.
+As shown, layers (that derive from ``plone.testing.Layer``) support item (dict-like) assignment, access and deletion of arbitrary resources under string keys.
 
-    **Important:** If a layer creates a resource (by assigning an object to
-    a key on ``self`` as shown above) during fixture setup-up, it must also
-    delete the resource on tear-down. Set-up and deletion should be symmetric:
-    if the resource is assigned during ``setUp()`` it should be deleted in
-    ``tearDown()``; if it's created in ``testSetUp()`` it should be deleted
-    in ``testTearDown()``.
+    **Important:** If a layer creates a resource (by assigning an object to a key on ``self`` as shown above) during fixture setup-up, it must also delete the resource on tear-down.
+    Set-up and deletion should be symmetric: if the resource is assigned during ``setUp()`` it should be deleted in ``tearDown()``;
+    if it's created in ``testSetUp()`` it should be deleted in ``testTearDown()``.
 
-A resource defined in a base layer is accessible from and through a child
-layer. If a resource is set on a child using a key that also exists in a base
-layer, the child version will shadow the base version until the child layer is
-torn down (presuming it deletes the resource, which it should), but the base
-layer version remains intact.
+A resource defined in a base layer is accessible from and through a child layer.
+If a resource is set on a child using a key that also exists in a base layer, the child version will shadow the base version until the child layer is torn down (presuming it deletes the resource, which it should), but the base layer version remains intact.
 
 .. note::
 
-   Accessing a resource is analogous to accessing an instance
-   variable. For example, if a base layer assigns a resource to a given key
-   in its ``setUp()`` method, a child layer shadows that resource with
-   another object under the same key, the shadowed resource will by used
-   during the ``testSetUp()`` and ``testTearDown()`` lifecycle methods if
-   implemented by the *base* layer as well. This will be the case until
-   the child layer "pops" the resource by deleting it, normally in its
-   ``tearDown()``.
+    Accessing a resource is analogous to accessing an instance variable.
+    For example, if a base layer assigns a resource to a given key in its ``setUp()`` method, a child layer shadows that resource with another object under the same key, the shadowed resource will by used during the ``testSetUp()`` and ``testTearDown()`` lifecycle methods if implemented by the *base* layer as well.
+    This will be the case until the child layer "pops" the resource by deleting it, normally in its ``tearDown()``.
 
-Conversely, if (as shown above) the child layer accesses and modifies the
-object, it will modify the original.
+Conversely, if (as shown above) the child layer accesses and modifies the object, it will modify the original.
 
 .. note::
 
-   It is sometimes necessary (or desirable) to modify a shared
-   resource in a child layer, as shown in the example above. In this case,
-   however, it is very important to restore the original state when the layer
-   is torn down. Otherwise, other layers or tests using the base layer
-   directly may be affected in difficult-to-debug ways.
+   It is sometimes necessary (or desirable) to modify a shared resource in a child layer, as shown in the example above.  In this case, however, it is very important to restore the original state when the layer is torn down.  Otherwise, other layers or tests using the base layer directly may be affected in difficult-to-debug ways.
 
-If the same key is used in multiple base layers, the rules for choosing which
-version to use are similar to those that apply when choosing an attribute or
-method to use in the case of multiple inheritance.
+If the same key is used in multiple base layers, the rules for choosing which version to use are similar to those that apply when choosing an attribute or method to use in the case of multiple inheritance.
 
-In the example above, we used the resource manager for the ``warpDrive``
-object, but we assigned the ``previousMaxSpeed`` variable to ``self``. This is
-because ``previousMaxSpeed`` is internal to the layer and should not be shared
-with any other layers that happen to use this layer as a base. Nor should it
-be used by any test cases. Conversely, ``warpDrive`` is a shared resource that
-is exposed to other layers and test cases.
+In the example above, we used the resource manager for the ``warpDrive`` object, but we assigned the ``previousMaxSpeed`` variable to ``self``.
+This is because ``previousMaxSpeed`` is internal to the layer and should not be shared with any other layers that happen to use this layer as a base.
+Nor should it be used by any test cases.
+Conversely, ``warpDrive`` is a shared resource that is exposed to other layers and test cases.
 
-The distinction becomes even more important when you consider how a test case
-may access the shared resource. We'll discuss how to write test cases that use
-layers shortly, but consider the following test:
+The distinction becomes even more important when you consider how a test case may access the shared resource.
+We'll discuss how to write test cases that use layers shortly, but consider the following test:::
 
     >>> try:
     ...     import unittest2 as unittest
@@ -769,101 +694,76 @@ layers shortly, but consider the following test:
     ...         warpDrive = self.layer['warpDrive']
     ...         warpDrive.start(8)
 
-This test needs access to the shared resource. It knows that its layer defines
-one called ``warpDrive``. It does not know or care that the warp drive was
-actually initiated by the ``ConstitutionClassSpaceShip`` base layer.
+This test needs access to the shared resource.
+It knows that its layer defines one called ``warpDrive``.
+It does not know or care that the warp drive was actually initiated by the ``ConstitutionClassSpaceShip`` base layer.
 
-If, however, the base layer had assigned the resource as an instance variable,
-it would not inherit to child layers (remember: layer bases are not base
-classes!). The syntax to access it would be::
+If, however, the base layer had assigned the resource as an instance variable, it would not inherit to child layers (remember: layer bases are not base classes!).
+The syntax to access it would be:::
 
     self.layer.__bases__[0].warpDrive
 
-which is not only ugly, but brittle: if the list of bases is changed, the
-expression above may lead to an attribute error.
+which is not only ugly, but brittle: if the list of bases is changed, the expression above may lead to an attribute error.
 
 Writing tests
 =============
 
-Tests are usually written in one of two ways: As methods on a class that
-derives from ``unittest.TestCase`` (this is sometimes known as "Python tests"
-or "JUnit-style tests"), or using doctest syntax.
-
-You should realise that although the relevant frameworks (``unittest``,
-``unittest2`` and ``doctest``) often talk about unit testing, these tools are
-also used to write integration and functional tests. The distinction between
-unit, integration and functional tests is largely practical: you use the same
-techniques to set up a fixture or write assertions for an integration test as
-you would for a unit test. The difference lies in what that fixture contains,
-and how you invoke the code under test. In general, a true unit test will have
-a minimal or no test fixture, whereas an integration test will have a fixture
-that contains the components your code is integrating with. A functional test
-will have a fixture that contains enough of the full system to execute and
-test an "end-to-end" scenario.
+Tests are usually written in one of two ways: As methods on a class that derives from ``unittest.TestCase`` (this is sometimes known as "Python tests" or "JUnit-style tests"), or using doctest syntax.
+
+You should realise that although the relevant frameworks (``unittest``, ``unittest2`` and ``doctest``) often talk about unit testing, these tools are also used to write integration and functional tests.
+The distinction between unit, integration and functional tests is largely practical: you use the same techniques to set up a fixture or write assertions for an integration test as you would for a unit test.
+The difference lies in what that fixture contains, and how you invoke the code under test.
+In general, a true unit test will have a minimal or no test fixture, whereas an integration test will have a fixture that contains the components your code is integrating with.
+A functional test will have a fixture that contains enough of the full system to execute and test an "end-to-end" scenario.
 
 Python tests
 ------------
 
-Python tests use the Python `unittest`_ module, or its cousin `unittest2`_
-(see below). They should be placed in a module or package called ``tests``
-for the test runner to pick them up.
+Python tests use the Python `unittest`_ module, or its cousin `unittest2`_ (see below).
+They should be placed in a module or package called ``tests`` for the test runner to pick them up.
 
-For small packages, a single module called ``tests.py`` will normally contain
-all tests. For larger packages, it is common to have a ``tests`` package that
-contains a number of modules with tests. These need to start with the word
-``test``, e.g. ``tests/test_foo.py`` or ``tests/test_bar.py``. Don't forget
-the ``__init__.py`` in the ``tests`` package, too!
+For small packages, a single module called ``tests.py`` will normally contain all tests.
+For larger packages, it is common to have a ``tests`` package that contains a number of modules with tests.
+These need to start with the word ``test``, e.g.
+``tests/test_foo.py`` or ``tests/test_bar.py``.
+Don't forget the ``__init__.py`` in the ``tests`` package, too!
 
 unittest2
 ~~~~~~~~~
 
-In Python 2.7+, the ``unittest`` module has grown several new and useful
-features. To make use of these in Python 2.4, 2.5 and 2.6, an add-on module
-called `unittest2`_ can be installed. ``plone.testing`` depends on
-``unittest2`` for these versions (and uses it for its own tests), so you will have access to it
-if you depend on ``plone.testing``.
+In Python 2.7+, the ``unittest`` module has grown several new and useful features.
+To make use of these in Python 2.4, 2.5 and 2.6, an add-on module called `unittest2`_ can be installed.
+``plone.testing`` depends on ``unittest2`` for these versions (and uses it for its own tests), so you will have access to it if you depend on ``plone.testing``.
 
-We will use ``unittest2`` for the examples in this document, but try to import it
-with an alias of ``unittest``. This makes the code forward compatible with
-Python 2.7, where the built-in ``unittest`` module will have all the features
-of the ``unittest2`` module.
+We will use ``unittest2`` for the examples in this document, but try to import it with an alias of ``unittest``.
+This makes the code forward compatible with Python 2.7, where the built-in ``unittest`` module will have all the features of the ``unittest2`` module.
 
-Please note that the `zope.testing`_ test runner at the time of writing
-(version 3.9.3) does not (yet) support the new ``setUpClass()``,
-``tearDownClass()``, ``setUpModule()`` and ``tearDownModule()`` hooks from
-``unittest2``. This is not normally a problem, since we tend to use layers to
-manage complex fixtures, but it is important to be aware of nonetheless.
+Please note that the `zope.testing`_ test runner at the time of writing (version 3.9.3) does not (yet) support the new ``setUpClass()``, ``tearDownClass()``, ``setUpModule()`` and ``tearDownModule()`` hooks from ``unittest2``.
+This is not normally a problem, since we tend to use layers to manage complex fixtures, but it is important to be aware of nonetheless.
 
 Test modules, classes and functions
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-Python tests are written with classes that derive from the base class
-``TestCase``. Each test is written as a method that takes no arguments and
-has a name starting with ``test``. Other methods can be added and called from
-test methods as appropriate, e.g. to share some test logic.
+Python tests are written with classes that derive from the base class ``TestCase``.
+Each test is written as a method that takes no arguments and has a name starting with ``test``.
+Other methods can be added and called from test methods as appropriate, e.g.
+to share some test logic.
 
-Two special methods, ``setUp()`` and ``tearDown()``, can also be added. These
-will be called before or after each test, respectively, and provide a useful
-place to construct and clean up test fixtures without writing a custom layer.
+Two special methods, ``setUp()`` and ``tearDown()``, can also be added.
+These will be called before or after each test, respectively, and provide a useful place to construct and clean up test fixtures without writing a custom layer.
 They are obviously not as re-usable as layers, though.
 
-   *Hint:* Somewhat confusingly, the ``setUp()`` and ``tearDown()`` methods in
-   a test case class are the equivalent of the ``testSetUp()`` and
-   ``testTearDown()`` methods of a layer class.
+   *Hint:* Somewhat confusingly, the ``setUp()`` and ``tearDown()`` methods in a test case class are the equivalent of the ``testSetUp()`` and ``testTearDown()`` methods of a layer class.
 
-A layer can be specified by setting the ``layer`` class attribute to a layer
-instance. If layers are used in conjunction with ``setUp()`` and
-``tearDown()`` methods in the test class itself, the class' ``setUp()`` method
-will be called after the layer's ``testSetUp()`` method, and the class'
-``tearDown()`` method will be called before the layer's ``testTearDown()``
-method.
+A layer can be specified by setting the ``layer`` class attribute to a layer instance.
+If layers are used in conjunction with ``setUp()`` and ``tearDown()`` methods in the test class itself, the class' ``setUp()`` method will be called after the layer's ``testSetUp()`` method, and the class' ``tearDown()`` method will be called before the layer's ``testTearDown()`` method.
 
-The ``TestCase`` base class contains a number of methods which can be used to
-write assertions. They all take the form ``self.assertSomething()``, e.g.
-``self.assertEqual(result, expectedValue)``. See the `unittest`_ and/or
-`unittest2`_ documentation for details.
+The ``TestCase`` base class contains a number of methods which can be used to write assertions.
+They all take the form ``self.assertSomething()``, e.g.
+``self.assertEqual(result, expectedValue)``.
+See the `unittest`_ and/or `unittest2`_ documentation for details.
 
-Putting this together, let's expand on our previous example unit test:
+Putting this together, let's expand on our previous example unit test:::
 
     >>> try:
     ...     import unittest2 as unittest
@@ -892,40 +792,33 @@ Putting this together, let's expand on our previous example unit test:
 A few things to note:
 
 * The class derives from ``unittest.TestCase``.
-* The ``layer`` class attribute is set to a layer instance (not a layer
-  class!) defined previously. This would typically be imported from a
-  ``testing`` module.
-* There are two tests here: ``test_warp8()`` and ``test_max_speed()``.
-* We have used the ``self.assertEqual()`` assertion in both tests to check the
-  result of executing the ``start()`` method on the warp drive.
-* We have used the ``setUp()`` method to fetch the ``warpDrive`` resource and
-  ensure that it is stopped before each test is executed. Assigning a variable
-  to ``self`` is a useful way to provide some state to each test method,
-  though be careful about data leaking between tests: in general, you cannot
-  predict the order in which tests will run, and tests should always be
-  independent.
-* We have used the ``tearDown()`` method to make sure the warp
-  drive is really stopped after each test.
+
+* The ``layer`` class attribute is set to a layer instance (not a layer class!) defined previously.
+  This would typically be imported from a ``testing`` module.
+
+* There are two tests here: ``test_warp8()`` and ``test_max_speed()``.  
+
+* We have used the ``self.assertEqual()`` assertion in both tests to check the result of executing the ``start()`` method on the warp drive.
+
+* We have used the ``setUp()`` method to fetch the ``warpDrive`` resource and ensure that it is stopped before each test is executed.
+  Assigning a variable to ``self`` is a useful way to provide some state to each test method, though be careful about data leaking between tests: in general, you cannot predict the order in which tests will run, and tests should always be independent.
+
+* We have used the ``tearDown()`` method to make sure the warp drive is really stopped after each test.
 
 Test suites
 ~~~~~~~~~~~
 
-If you are using version 3.8.0 or later of `zope.testing`_, a class like the
-one above is all you need: any class deriving from ``TestCase`` in a module
-with a name starting with ``test`` will be examined for test methods. Those
-tests are then collected into a test suite and executed.
+If you are using version 3.8.0 or later of `zope.testing`_, a class like the one above is all you need: any class deriving from ``TestCase`` in a module with a name starting with ``test`` will be examined for test methods.
+Those tests are then collected into a test suite and executed.
 
-With older versions of `zope.testing`_, you need to add a ``test_suite()``
-function in each module that returns the tests in the test suite. The
-`unittest`_ module contains several tools to construct suites, but one of the
-simplest is to use the default test loader to load all tests in the current
-module:
+With older versions of `zope.testing`_, you need to add a ``test_suite()`` function in each module that returns the tests in the test suite.
+The `unittest`_ module contains several tools to construct suites, but one of the simplest is to use the default test loader to load all tests in the current module:::
 
     >>> def test_suite():
     ...     return unittest.defaultTestLoader.loadTestsFromName(__name__)
 
-If you need to load tests explicitly, you can use the ``TestSuite`` API from
-the `unittest`_ module. For example:
+If you need to load tests explicitly, you can use the ``TestSuite`` API from the `unittest`_ module.
+For example:::
 
     >>> def test_suite():
     ...     suite = unittest.TestSuite()
@@ -934,46 +827,42 @@ the `unittest`_ module. For example:
     ...     ])
     ...     return suite
 
-The ``makeSuite()`` function creates a test suite from the test methods in
-the given class (which must derive from ``TestCase``). This suite is then
-appended to an overall suite, which is returned from the ``test_suite()``
-method. Note that ``addTests()`` takes a list of suites (which are coalesced
-into a single suite). We'll add additional suites later.
+The ``makeSuite()`` function creates a test suite from the test methods in the given class (which must derive from ``TestCase``).
+This suite is then appended to an overall suite, which is returned from the ``test_suite()`` method.
+Note that ``addTests()`` takes a list of suites (which are coalesced into a single suite).
+We'll add additional suites later.
 
 See the `unittest`_ documentation for other options.
 
 .. note::
 
-   Adding a ``test_suite()`` method to a module disables automatic
-   test discovery, even when using a recent version of ``zope.testing``.
+   Adding a ``test_suite()`` method to a module disables automatic test discovery, even when using a recent version of ``zope.testing``.
 
 Doctests
 --------
 
-Doctests can be written in two ways: as the contents of a docstring (usually,
-but not always, as a means of illustrating and testing the functionality of
-the method or class where the docstring appears), or as a separate text file.
-In both cases, the standard `doctest`_ module is used. See its documentation
-for details about doctest syntax and conventions.
+Doctests can be written in two ways: as the contents of a docstring (usually, but not always, as a means of illustrating and testing the functionality of the method or class where the docstring appears), or as a separate text file.
+In both cases, the standard `doctest`_ module is used.
+See its documentation for details about doctest syntax and conventions.
 
 Doctests are used in two different ways:
 
-* To test documentation. That is, to ensure that code examples contained in
-  documentation are valid and continue to work as the software is updated.
+* To test documentation.
+  That is, to ensure that code examples contained in documentation are valid and continue to work as the software is updated.
+
 * As a convenient syntax for writing tests.
 
-These two approaches use the same testing APIs and techniques. The difference
-is mostly about mindset. However, it is important to avoid falling into the
-trap that tests can substitute for good documentation or vice-a-versa. Tests
-usually need to systematically go through inputs and outputs and cover off a
-number of corner cases. Documentation should tell a compelling narrative and
-usually focus on the main usage scenarios. Trying to kill these two birds with
-one stone normally leaves you with an unappealing pile of stones and feathers.
+These two approaches use the same testing APIs and techniques.
+The difference is mostly about mindset.
+However, it is important to avoid falling into the trap that tests can substitute for good documentation or vice-a-versa.
+Tests usually need to systematically go through inputs and outputs and cover off a number of corner cases.
+Documentation should tell a compelling narrative and usually focus on the main usage scenarios.
+Trying to kill these two birds with one stone normally leaves you with an unappealing pile of stones and feathers.
 
 Docstring doctests
 ~~~~~~~~~~~~~~~~~~
 
-Doctests can be added to any module, class or function docstring::
+Doctests can be added to any module, class or function docstring:::
 
     def canOutrunKlingons(warpDrive):
         """Find out of the given warp drive can outrun Klingons.
@@ -999,8 +888,7 @@ Doctests can be added to any module, class or function docstring::
         """
         return warpDrive.maxSpeed > 8.0
 
-To add the doctests from a particular module to a test suite, you need to
-use the ``test_suite()`` function hook:
+To add the doctests from a particular module to a test suite, you need to use the ``test_suite()`` function hook:::
 
     >>> import doctest
     >>> def test_suite():
@@ -1012,21 +900,14 @@ use the ``test_suite()`` function hook:
     ...     return suite
 
 Here, we have given the name of the module to check as a string dotted name.
-It is also possible to import a module and pass it as an object. The code
-above passes a list to ``addTests()``, making it easy to add several sets of
-tests to the suite: the list can be constructed from calls to
-``DocTestSuite()``, ``DocFileSuite()`` (shown below) and ``makeSuite()``
-(shown above).
-
-    Remember that if you add a ``test_suite()`` function to a module that
-    also has ``TestCase``-derived python tests, those tests will no longer
-    be automatically picked up by ``zope.testing``, so you need to add them
-    to the test suite explicitly.
-
-The example above illustrates a documentation-oriented doctest, where the
-doctest forms part of the docstring of a public module. The same syntax can
-be used for more systematic unit tests. For example, we could have a module
-``spaceship.tests.test_spaceship`` with a set of methods like::
+It is also possible to import a module and pass it as an object.
+The code above passes a list to ``addTests()``, making it easy to add several sets of tests to the suite: the list can be constructed from calls to ``DocTestSuite()``, ``DocFileSuite()`` (shown below) and ``makeSuite()`` (shown above).
+
+    Remember that if you add a ``test_suite()`` function to a module that also has ``TestCase``-derived python tests, those tests will no longer be automatically picked up by ``zope.testing``, so you need to add them to the test suite explicitly.
+
+The example above illustrates a documentation-oriented doctest, where the doctest forms part of the docstring of a public module.
+The same syntax can be used for more systematic unit tests.
+For example, we could have a module ``spaceship.tests.test_spaceship`` with a set of methods like::
 
     # It's often better to put the import into each method, but here we've
     # imported the code under test at module level
@@ -1059,20 +940,17 @@ be used for more systematic unit tests. For example, we could have a module
 
         """
 
-Here, we have created a number of small methods that have no body. They merely
-serve as a container for docstrings with doctests. Since the module has no
-globals, each test must import the code under test, which helps make import
-errors more explicit.
+Here, we have created a number of small methods that have no body.
+They merely serve as a container for docstrings with doctests.
+Since the module has no globals, each test must import the code under test, which helps make import errors more explicit.
 
 File doctests
 ~~~~~~~~~~~~~
 
 Doctests contained in a file are similar to those contained in docstrings.
-File doctests are better suited to narrative documentation covering the usage
-of an entire module or package.
+File doctests are better suited to narrative documentation covering the usage of an entire module or package.
 
-For example, if we had a file called ``spaceship.txt`` with doctests, we could
-add it to the test suite above with:
+For example, if we had a file called ``spaceship.txt`` with doctests, we could add it to the test suite above with:::
 
     >>> def test_suite():
     ...     suite = unittest.TestSuite()
@@ -1083,17 +961,13 @@ add it to the test suite above with:
     ...     ])
     ...     return suite
 
-By default, the file is located relative to the module where the test
-suite is defined. You can use ``../`` (even on Windows) to reference the
-parent directory, which is sometimes useful if the doctest is inside a module
-in a ``tests`` package.
+By default, the file is located relative to the module where the test suite is defined.
+You can use ``../`` (even on Windows) to reference the parent directory, which is sometimes useful if the doctest is inside a module in a ``tests`` package.
 
 .. note::
 
-   If you put the doctest ``test_suite()`` method in a module
-   inside a ``tests`` package, that module must have a name starting with
-   ``test``. It is common to have ``tests/test_doctests.py`` that contains a
-   single ``test_suite()`` method that returns a suite of multiple doctests.
+    If you put the doctest ``test_suite()`` method in a module inside a ``tests`` package, that module must have a name starting with ``test``.
+    It is common to have ``tests/test_doctests.py`` that contains a single ``test_suite()`` method that returns a suite of multiple doctests.
 
 It is possible to pass several tests to the suite, e.g.::
 
@@ -1106,30 +980,26 @@ It is possible to pass several tests to the suite, e.g.::
     ...     ])
     ...     return suite
 
-The test runner will report each file as a separate test, i.e. the
-``DocFileSuite()`` above would add two tests to the overall suite. Conversely,
-a ``DocTestSuite()`` using a module with more than one docstring containing
-doctests will report one test for each eligible docstring.
+The test runner will report each file as a separate test, i.e.
+the ``DocFileSuite()`` above would add two tests to the overall suite.
+Conversely, a ``DocTestSuite()`` using a module with more than one docstring containing doctests will report one test for each eligible docstring.
 
 Doctest fixtures and layers
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-A docstring doctest will by default have access to any global symbol available
-in the module where the docstring is found (e.g. anything defined or imported
-in the module). The global namespace can be overridden by passing a ``globs``
-keyword argument to the ``DocTestSuite()`` constructor, or augmented by
-passing an ``extraglobs`` argument. Both should be given dictionaries.
+A docstring doctest will by default have access to any global symbol available in the module where the docstring is found (e.g.
+anything defined or imported in the module).
+The global namespace can be overridden by passing a ``globs`` keyword argument to the ``DocTestSuite()`` constructor, or augmented by passing an ``extraglobs`` argument.
+Both should be given dictionaries.
 
-A file doctest has an empty globals namespace by default. Globals may be
-provided via the ``globs`` argument to ``DocFileSuite()``.
+A file doctest has an empty globals namespace by default.
+Globals may be provided via the ``globs`` argument to ``DocFileSuite()``.
 
-To manage a simple test fixture for a doctest, you can define set-up and
-tear-down functions and pass them as the ``setUp`` and ``tearDown``
-arguments respectively. These are both passed a single argument, a ``DocTest``
-object. The most useful attribute of this object is ``globs``, which is a
-mutable dictionary of globals available in the test.
+To manage a simple test fixture for a doctest, you can define set-up and tear-down functions and pass them as the ``setUp`` and ``tearDown`` arguments respectively.
+These are both passed a single argument, a ``DocTest`` object.
+The most useful attribute of this object is ``globs``, which is a mutable dictionary of globals available in the test.
 
-For example:
+For example:::
 
     >>> def setUpKlingons(doctest):
     ...     doctest.globs['oldStyleKlingons'] = True
@@ -1144,26 +1014,22 @@ For example:
     ...     ])
     ...     return suite
 
-The same arguments are available on the ``DocFileSuite()`` constructor. The
-set up method is called before each docstring in the given module for a
-``DocTestSuite``, and before each file given in a ``DocFileSuite``.
+The same arguments are available on the ``DocFileSuite()`` constructor.
+The set up method is called before each docstring in the given module for a ``DocTestSuite``, and before each file given in a ``DocFileSuite``.
 
-Of course, we often want to use layers with doctests too. Unfortunately,
-the ``unittest`` API is not aware of layers, so you can't just pass a layer
-to the ``DocTestSuite()`` and ``DocFileSuite()`` constructors. Instead,
-you have to set a ``layer`` attribute on the suite after it has been
-constructed.
+Of course, we often want to use layers with doctests too.
+Unfortunately, the ``unittest`` API is not aware of layers, so you can't just pass a layer to the ``DocTestSuite()`` and ``DocFileSuite()`` constructors.
+Instead, you have to set a ``layer`` attribute on the suite after it has been constructed.
 
-Furthermore, to use layer resources in a doctest, we need access to the layer
-instance. The easiest way to do this is to pass it as a glob, conventionally
-called 'layer'. This makes a global name 'layer' available in the doctest
-itself, giving access to the test's layer instance.
+Furthermore, to use layer resources in a doctest, we need access to the layer instance.
+The easiest way to do this is to pass it as a glob, conventionally called 'layer'.
+This makes a global name 'layer' available in the doctest itself, giving access to the test's layer instance.
 
-To make it easier to do this, ``plone.testing`` comes with a helper function
-called ``layered()``. Its first argument is a test suite. The second argument
-is the layer.
+To make it easier to do this, ``plone.testing`` comes with a helper function called ``layered()``.
+Its first argument is a test suite.
+The second argument is the layer.
 
-For example:
+For example:::
 
     >>> from plone.testing import layered
     >>> def test_suite():
@@ -1173,7 +1039,7 @@ For example:
     ...     ])
     ...     return suite
 
-This is equivalent to:
+This is equivalent to:::
 
     >>> def test_suite():
     ...     suite = unittest.TestSuite()
@@ -1184,121 +1050,101 @@ This is equivalent to:
     ...
     ...     return suite
 
-(In this example, we've opted to use ``addTest()`` to add a single suite,
-instead of using ``addTests()`` to add multiple suites in one go).
+(In this example, we've opted to use ``addTest()`` to add a single suite, instead of using ``addTests()`` to add multiple suites in one go).
 
 Zope testing tools
 ==================
 
-Everything described so far in this document relies only on the standard
-`unittest`_/`unittest2`_ and `doctest`_ modules and `zope.testing`_, and you
-can use this package without any other dependencies.
+Everything described so far in this document relies only on the standard `unittest`_/`unittest2`_ and `doctest`_ modules and `zope.testing`_, and you can use this package without any other dependencies.
 
-However, there are also some tools (and layers) available in this package, as
-well as in other packages, that are specifically useful for testing
-applications that use various Zope-related frameworks.
+However, there are also some tools (and layers) available in this package, as well as in other packages, that are specifically useful for testing applications that use various Zope-related frameworks.
 
 Test cleanup
 ------------
 
-If a test uses a global registry, it may be necessary to clean that registry
-on set up and tear down of each test fixture. ``zope.testing`` provides a
-mechanism to register cleanup handlers - methods that are called to clean
-up global state. This can then be invoked in the ``setUp()`` and
-``tearDown()`` fixture lifecycle methods of a test case.
+If a test uses a global registry, it may be necessary to clean that registry on set up and tear down of each test fixture.
+``zope.testing`` provides a mechanism to register cleanup handlers - methods that are called to clean up global state.
+This can then be invoked in the ``setUp()`` and ``tearDown()`` fixture lifecycle methods of a test case.::
 
     >>> from zope.testing import cleanup
 
-Let's say we had a global registry, implemented as a dictionary
+Let's say we had a global registry, implemented as a dictionary:::
 
     >>> SOME_GLOBAL_REGISTRY = {}
 
-If we wanted to clean this up on each test run, we could call ``clear()``
-on the dict. Since that's a no-argument method, it is perfect as a cleanup
-handler.
+If we wanted to clean this up on each test run, we could call ``clear()`` on the dict.
+Since that's a no-argument method, it is perfect as a cleanup handler.::
 
     >>> cleanup.addCleanUp(SOME_GLOBAL_REGISTRY.clear)
 
-We can now use the ``cleanUp()`` method to execute all registered
-cleanups:
+We can now use the ``cleanUp()`` method to execute all registered cleanups:::
 
     >>> cleanup.cleanUp()
 
-This call could be placed in a ``setUp()`` and/or ``tearDown()`` method in a
-test class, for example.
+This call could be placed in a ``setUp()`` and/or ``tearDown()`` method in a test class, for example.
 
 Event testing
 -------------
 
-You may wish to test some code that uses ``zope.event`` to fire specific
-events. `zope.component`_ provides some helpers to capture and analyse
-events.
+You may wish to test some code that uses ``zope.event`` to fire specific events.
+`zope.component`_ provides some helpers to capture and analyse events.::
 
     >>> from zope.component import eventtesting
 
-To use this, you first need to set up event testing. Some of the layers
-shown below will do this for you, but you can do it yourself by calling
-the ``eventtesting.setUp()`` method, e.g. from your own ``setUp()`` method:
+To use this, you first need to set up event testing.
+Some of the layers shown below will do this for you, but you can do it yourself by calling the ``eventtesting.setUp()`` method, e.g.
+from your own ``setUp()`` method:::
 
     >>> eventtesting.setUp()
 
-This simply registers a few catch-all event handlers. Once you have
-executed the code that is expected to fire events, you can use the
-``getEvents()`` helper function to obtain a list of the event instances
-caught:
+This simply registers a few catch-all event handlers.
+Once you have executed the code that is expected to fire events, you can use the ``getEvents()`` helper function to obtain a list of the event instances caught:::
 
     >>> events = eventtesting.getEvents()
 
-You can now examine ``events`` to see what events have been caught since the
-last cleanup.
+You can now examine ``events`` to see what events have been caught since the last cleanup.
 
-``getEvents()`` takes two optional arguments that can be used to filter the
-returned list of events. The first (``event_type``) is an interface. If given,
-only events providing this interface are returned. The second (``filter``) is
-a callable taking one argument. If given, it will be called with each captured
-event. Only those events where the filter function returns ``True`` will be
-included.
+``getEvents()`` takes two optional arguments that can be used to filter the returned list of events.
+The first (``event_type``) is an interface.
+If given, only events providing this interface are returned.
+The second (``filter``) is a callable taking one argument.
+If given, it will be called with each captured event.
+Only those events where the filter function returns ``True`` will be included.
 
-The ``eventtesting`` module registers a cleanup action as outlined above. When
-you call ``cleanup.cleanUp()`` (or ``eventtesting.clearEvents()``, which is
-the handler it registers), the events list will be cleared, ready for the
-next test. Here, we'll do it manually:
+The ``eventtesting`` module registers a cleanup action as outlined above.
+When you call ``cleanup.cleanUp()`` (or ``eventtesting.clearEvents()``, which is the handler it registers), the events list will be cleared, ready for the next test.
+Here, we'll do it manually:::
 
     >>> eventtesting.clearEvents()
 
 Mock requests
 -------------
 
-Many tests require a request object, often with particular request/form
-variables set. `zope.publisher`_ contains a useful class for this purpose.
+Many tests require a request object, often with particular request/form variables set.
+`zope.publisher`_ contains a useful class for this purpose.::
 
     >>> from zope.publisher.browser import TestRequest
 
-A simple test request can be constructed with no arguments:
+A simple test request can be constructed with no arguments:::
 
     >>> request = TestRequest()
 
-To add a body input stream, pass a ``StringIO`` or file as the first
-parameter. To set the environment (request headers), use the ``environ``
-keyword argument. To simulate a submitted form, use the ``form`` keyword
-argument:
+To add a body input stream, pass a ``StringIO`` or file as the first parameter.
+To set the environment (request headers), use the ``environ`` keyword argument.
+To simulate a submitted form, use the ``form`` keyword argument:::
 
     >>> request = TestRequest(form=dict(field1='foo', field2=1))
 
-Note that the ``form`` dict contains marshalled form fields, so modifiers like
-``:int`` or ``:boolean`` should not be included in the field names, and
-values should be converted to the appropriate type.
+Note that the ``form`` dict contains marshalled form fields, so modifiers like ``:int`` or ``:boolean`` should not be included in the field names, and values should be converted to the appropriate type.
 
 Registering components
 ----------------------
 
-Many test fixtures will depend on having a minimum of Zope Component
-Architecture (ZCA) components registered. In normal operation, these would
-probably be registered via ZCML, but in a unit test, you should avoid loading
-the full ZCML configuration of your package (and its dependencies).
+Many test fixtures will depend on having a minimum of Zope Component Architecture (ZCA) components registered.
+In normal operation, these would probably be registered via ZCML, but in a unit test, you should avoid loading the full ZCML configuration of your package (and its dependencies).
 
-Instead, you can use the Python API in `zope.component`_ to register
-global components instantly. The three most commonly used functions are:
+Instead, you can use the Python API in `zope.component`_ to register global components instantly.
+The three most commonly used functions are:::
 
     >>> from zope.component import provideAdapter
     >>> from zope.component import provideUtility
@@ -1306,30 +1152,25 @@ global components instantly. The three most commonly used functions are:
 
 See the `zope.component`_ documentation for details about how to use these.
 
-When registering global components like this, it is important to avoid test
-leakage. The ``cleanup`` mechanism outlined above can be used to tear down the
-component registry between each test. See also the
-``plone.testing.zca.UNIT_TESTING`` layer, described below, which performs this
-cleanup automatically via the ``testSetUp()``/``testTearDown()`` mechanism.
+When registering global components like this, it is important to avoid test leakage.
+The ``cleanup`` mechanism outlined above can be used to tear down the component registry between each test.
+See also the ``plone.testing.zca.UNIT_TESTING`` layer, described below, which performs this cleanup automatically via the ``testSetUp()``/``testTearDown()`` mechanism.
 
-Alternatively, you can "stack" a new global component registry using the
-``plone.testing.zca.pushGlobalRegistry()`` and
-``plone.testing.zca.popGlobalRegistry()`` helpers. This makes it possible to
-set up and tear down components that are specific to a given layer, and even
-allow tests to safely call the global component API (or load ZCML - see below)
-with proper tear-down. See the layer reference below for details.
+Alternatively, you can "stack" a new global component registry using the ``plone.testing.zca.pushGlobalRegistry()`` and ``plone.testing.zca.popGlobalRegistry()`` helpers.
+This makes it possible to set up and tear down components that are specific to a given layer, and even allow tests to safely call the global component API (or load ZCML - see below) with proper tear-down.
+See the layer reference below for details.
 
 Loading ZCML
 ------------
 
-Integration tests often need to load ZCML configuration. This can be achieved
-using the ``zope.configuration`` API.
+Integration tests often need to load ZCML configuration.
+This can be achieved using the ``zope.configuration`` API.::
 
     >>> from zope.configuration import xmlconfig
 
 The ``xmlconfig`` module contains two methods for loading ZCML.
 
-``xmlconfig.string()`` can be used to load a literal string of ZCML:
+``xmlconfig.string()`` can be used to load a literal string of ZCML:::
 
     >>> xmlconfig.string("""\
     ... <configure xmlns="http://namespaces.zope.org/zope" package="plone.testing">
@@ -1338,54 +1179,44 @@ The ``xmlconfig`` module contains two methods for loading ZCML.
     ... """)
     <zope.configuration.config.ConfigurationMachine object at ...>
 
-Note that we need to set a package (used for relative imports and file
-locations) explicitly here, using the ``package`` attribute of the
-``<configure />`` element.
+Note that we need to set a package (used for relative imports and file locations) explicitly here, using the ``package`` attribute of the ``<configure />`` element.
 
-Also note that unless the optional second argument (``context``) is passed,
-a new configuration machine will be created every time ``string()`` is called.
-It therefore becomes necessary to explicitly ``<include />`` the files that
-contain the directives you want to use (the one in ``zope.component`` is a
-common example). Layers that set up ZCML configuration may expose a resource
-which can be passed as the ``context`` parameter, usually called
-``configurationContext`` - see below.
+Also note that unless the optional second argument (``context``) is passed, a new configuration machine will be created every time ``string()`` is called.
+It therefore becomes necessary to explicitly ``<include />`` the files that contain the directives you want to use (the one in ``zope.component`` is a common example).
+Layers that set up ZCML configuration may expose a resource which can be passed as the ``context`` parameter, usually called ``configurationContext`` - see below.
 
-To load the configuration for a particular package, use ``xmlconfig.file()``:
+To load the configuration for a particular package, use ``xmlconfig.file()``:::
 
     >>> import zope.component
     >>> context = xmlconfig.file('meta.zcml', zope.component)
     >>> xmlconfig.file('configure.zcml', zope.component, context=context)
     <zope.configuration.config.ConfigurationMachine object at ...>
 
-This takes two required arguments: the file name and the module relative to
-which it is to be found. Here, we have loaded two files: ``meta.zcml`` and
-``configure.zcml``. The first call to ``xmlconfig.file()`` creates and
-returns a configuration context. We re-use that for the subsequent invocation,
-so that the directives configured are available.
+This takes two required arguments: the file name and the module relative to which it is to be found.
+Here, we have loaded two files: ``meta.zcml`` and ``configure.zcml``.
+The first call to ``xmlconfig.file()`` creates and returns a configuration context.
+We re-use that for the subsequent invocation, so that the directives configured are available.
 
 Installing a Zope 2 product
 ---------------------------
 
-Some packages (including all those in the ``Products.*`` namespace) have the
-special status of being Zope 2 "products". These are recorded in a special
-registry, and may have an ``initialize()`` hook in their top-level
-``__init__.py`` that needs to be called for the package to be fully configured.
+Some packages (including all those in the ``Products.*`` namespace) have the special status of being Zope 2 "products".
+These are recorded in a special registry, and may have an ``initialize()`` hook in their top-level ``__init__.py`` that needs to be called for the package to be fully configured.
 
-Zope 2 will find and execute any products during startup. For testing, we
-need to explicitly list the products to install. Provided you are using
-``plone.testing`` with Zope 2, you can use the following::
+Zope 2 will find and execute any products during startup.
+For testing, we need to explicitly list the products to install.
+Provided you are using ``plone.testing`` with Zope 2, you can use the following:::
 
     from plone.testing import z2
 
     with z2.zopeApp() as app:
         z2.installProduct(app, 'Products.ZCatalog')
 
-This would normally be used during layer ``setUp()``. Note that the basic
-Zope 2 application context must have been set up before doing this. The usual
-way to ensure this, is to use a layer that is based on ``z2.STARTUP`` - see
-below.
+This would normally be used during layer ``setUp()``.
+Note that the basic Zope 2 application context must have been set up before doing this.
+The usual way to ensure this, is to use a layer that is based on ``z2.STARTUP`` - see below.
 
-To tear down such a layer, you should do::
+To tear down such a layer, you should do:::
 
     from plone.testing import z2
 
@@ -1394,57 +1225,47 @@ To tear down such a layer, you should do::
 
 Note:
 
-* Unlike the similarly-named function from ``ZopeTestCase``, these helpers
-  will work with any type of product. There is no distinction between a
-  "product" and a "package" (and no ``installPackage()``). However, you must
-  use the full name (``Products.*``) when registering a product.
+* Unlike the similarly-named function from ``ZopeTestCase``, these helpers will work with any type of product.
+  There is no distinction between a "product" and a "package" (and no ``installPackage()``).
+  However, you must use the full name (``Products.*``) when registering a product.
+
 * Installing a product in this manner is independent of ZCML configuration.
-  However, it is almost always necessary to install the package's ZCML
-  configuration first.
+  However, it is almost always necessary to install the package's ZCML configuration first.
 
 Functional testing
 ------------------
 
-For functional tests that aim to simulate the browser, you can use
-`zope.testbrowser`_ in a Python test or doctest::
+For functional tests that aim to simulate the browser, you can use `zope.testbrowser`_ in a Python test or doctest:::
 
     >>> from zope.testbrowser.browser import Browser
     >>> browser = Browser()
 
-This provides a simple API to simulate browser input, without actually running
-a web server thread or scripting a live browser (as tools such as Windmill
-and Selenium do). The downside is that it is not possible to test JavaScript-
-dependent behaviour.
+This provides a simple API to simulate browser input, without actually running a web server thread or scripting a live browser (as tools such as Windmill and Selenium do).
+The downside is that it is not possible to test JavaScript- dependent behaviour.
 
-If you are testing a Zope 2 application, you need to change the import
-location slightly, and pass the application root to the method::
+If you are testing a Zope 2 application, you need to change the import location slightly, and pass the application root to the method:::
 
     from plone.testing.z2 import Browser
     browser = Browser(app)
 
-You can get the application root from the ``app`` resource in any of the
-Zope 2 layers in this package.
+You can get the application root from the ``app`` resource in any of the Zope 2 layers in this package.
 
-Beyond that, the `zope.testbrowser`_ documentation should cover how to use
-the test browser.
+Beyond that, the `zope.testbrowser`_ documentation should cover how to use the test browser.
 
-    **Hint:** The test browser will usually commit at the end of a request. To
-    avoid test fixture contamination, you should use a layer that fully
-    isolates each test, such as the ``z2.INTEGRATION_TESTING`` layer described
-    below.
+    **Hint:** The test browser will usually commit at the end of a request.
+    To avoid test fixture contamination, you should use a layer that fully isolates each test, such as the ``z2.INTEGRATION_TESTING`` layer described below.
 
 Layer reference
 ===============
 
-``plone.testing`` comes with several layers that are available to use directly
-or extend. These are outlined below.
+``plone.testing`` comes with several layers that are available to use directly or extend.
+These are outlined below.
 
 Zope Component Architecture
 ---------------------------
 
-The Zope Component Architecture layers are found in the module
-``plone.testing.zca``. If you depend on this, you can use the ``[zca]`` extra
-when depending on ``plone.testing``.
+The Zope Component Architecture layers are found in the module ``plone.testing.zca``.
+If you depend on this, you can use the ``[zca]`` extra when depending on ``plone.testing``.
 
 Unit testing
 ~~~~~~~~~~~~
@@ -1459,17 +1280,13 @@ Unit testing
 | Resources: | None                                             |
 +------------+--------------------------------------------------+
 
-This layer does not set up a fixture per se, but cleans up global state
-before and after each test, using ``zope.testing.cleanup`` as described
-above.
+This layer does not set up a fixture per se, but cleans up global state before and after each test, using ``zope.testing.cleanup`` as described above.
 
-The net result is that each test has a clean global component registry. Thus,
-it is safe to use the `zope.component`_ Python API (``provideAdapter()``,
-``provideUtility()``, ``provideHandler()`` and so on) to register components.
+The net result is that each test has a clean global component registry.
+Thus, it is safe to use the `zope.component`_ Python API (``provideAdapter()``, ``provideUtility()``, ``provideHandler()`` and so on) to register components.
 
-Be careful with using this layer in combination with other layers. Because
-it tears down the component registry between each test, it will clobber any
-layer that sets up more permanent test fixture in the component registry.
+Be careful with using this layer in combination with other layers.
+Because it tears down the component registry between each test, it will clobber any layer that sets up more permanent test fixture in the component registry.
 
 Event testing
 ~~~~~~~~~~~~~
@@ -1484,10 +1301,8 @@ Event testing
 | Resources: | None                                             |
 +------------+--------------------------------------------------+
 
-This layer extends the ``zca.UNIT_TESTING`` layer to enable the
-``eventtesting`` support from ``zope.component``. Using this layer, you can
-import and use ``zope.component.eventtesting.getEvent`` to inspect events
-fired by the code under test.
+This layer extends the ``zca.UNIT_TESTING`` layer to enable the ``eventtesting`` support from ``zope.component``.
+Using this layer, you can import and use ``zope.component.eventtesting.getEvent`` to inspect events fired by the code under test.
 
 See above for details.
 
@@ -1504,9 +1319,8 @@ Layer cleanup
 | Resources: | None                                             |
 +------------+--------------------------------------------------+
 
-This layer calls the cleanup functions from ``zope.testing.cleanup`` on setup
-and tear-down (but not between each test). It is useful as a base layer for
-other layers that need an environment as pristine as possible.
+This layer calls the cleanup functions from ``zope.testing.cleanup`` on setup and tear-down (but not between each test).
+It is useful as a base layer for other layers that need an environment as pristine as possible.
 
 Basic ZCML directives
 ~~~~~~~~~~~~~~~~~~~~~
@@ -1521,28 +1335,24 @@ Basic ZCML directives
 | Resources: | ``configurationContext``                         |
 +------------+--------------------------------------------------+
 
-This registers a minimal set of ZCML directives, principally those found in
-the ``zope.component`` package, and makes available a configuration context.
+This registers a minimal set of ZCML directives, principally those found in the ``zope.component`` package, and makes available a configuration context.
 This allows custom ZCML to be loaded as described above.
 
 The ``configurationContext`` resource should be used when loading custom ZCML.
-To ensure isolation, you should stack this using the
-``stackConfigurationContext()`` helper. For example, if you were writing a
-``setUp()`` method in a layer that had ``zca.ZCML_DIRECTIVES`` as a base, you
-could do::
+To ensure isolation, you should stack this using the ``stackConfigurationContext()`` helper.
+For example, if you were writing a ``setUp()`` method in a layer that had ``zca.ZCML_DIRECTIVES`` as a base, you could do:::
 
     self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
     xmlconfig.string(someZCMLString, context=context)
 
-This will create a new configuration context with the state of the base
-layer's context. On tear-down, you should delete the layer-specific resource::
+This will create a new configuration context with the state of the base layer's context.
+On tear-down, you should delete the layer-specific resource:::
 
     del self['configurationContext']
 
 .. note::
 
-   If you fail to do this, you may get problems if your layer is torn
-   down and then needs to be set up again later.
+   If you fail to do this, you may get problems if your layer is torn down and then needs to be set up again later.
 
 See above for more details about loading custom ZCML in a layer or test.
 
@@ -1555,37 +1365,30 @@ ZCML files helper class
 | Resources: | ``configurationContext``                         |
 +------------+--------------------------------------------------+
 
-The ``ZCMLSandbox`` can be instantiated with a ``filename`` and ``package``
-arguments::
+The ``ZCMLSandbox`` can be instantiated with a ``filename`` and ``package`` arguments::
 
     ZCML_SANDBOX = zca.ZCMLSandbox(filename="configure.zcml",
         package=my.package)
 
 
-That layer ``setUp`` loads the ZCML file. It avoids the need to
-using (and understand) ``configurationContext`` and ``globalRegistry`` until you
-need more flexibility or modularity for your layer and tests.
+That layer ``setUp`` loads the ZCML file.
+It avoids the need to using (and understand) ``configurationContext`` and ``globalRegistry`` until you need more flexibility or modularity for your layer and tests.
 
-See above for more details about loading custom ZCML in a layer or test.
+See above for more details about loading custom ZCML in a layer or test.  
 
 Helper functions
 ~~~~~~~~~~~~~~~~
 
-The following helper functions are available in the ``plone.testing.zca``
-module.
+The following helper functions are available in the ``plone.testing.zca`` module.
 
 ``stackConfigurationContext(context=None)``
-    Create and return a copy of the passed-in ZCML configuration context, or a
-    brand new context if it is ``None``.
 
-    The purpose of this is to ensure that if a layer loads some ZCML files
-    (using the ``zope.configuration`` API during) during its ``setUp()``, the state
-    of the configuration registry (which includes registered directives as
-    well as a list of already imported files, which will not be loaded again
-    even if explicitly included) can be torn down during ``tearDown()``.
+    Create and return a copy of the passed-in ZCML configuration context, or a brand new context if it is ``None``.
+
+    The purpose of this is to ensure that if a layer loads some ZCML files (using the ``zope.configuration`` API during) during its ``setUp()``, the state of the configuration registry (which includes registered directives as well as a list of already imported files, which will not be loaded again even if explicitly included) can be torn down during ``tearDown()``.
 
-    The usual pattern is to keep the configuration context in a layer resource
-    called ``configurationContext``. In ``setUp()``, you would then use::
+    The usual pattern is to keep the configuration context in a layer resource called ``configurationContext``.
+    In ``setUp()``, you would then use::
 
         self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
 
@@ -1596,48 +1399,37 @@ module.
         del self['configurationContext']
 
 ``pushGlobalRegistry(new=None)``
-    Create or obtain a stack of global component registries, and push a new
-    registry to the top of the stack. The net result is that
-    ``zope.component.getGlobalSiteManager()`` and (an un-hooked)
-    ``getSiteManager()`` will return the new registry instead of the default,
-    module-scope one. From this point onwards, calls to ``provideAdapter()``,
-    ``provideUtility()`` and other functions that modify the global registry
-    will use the new registry.
-
-    If ``new`` is not given, a new registry is created that has the previous
-    global registry (site manager) as its sole base. This has the effect that
-    registrations in the previous default global registry are still available,
-    but new registrations are confined to the new registry.
-
-    **Warning**: If you call this function, you *must* reciprocally call
-    ``popGlobalRegistry()``. That is, if you "push" a registry during layer
-    ``setUp()``, you must "pop" it during ``tearDown()``. If you "push" during
-    ``testSetUp()``, you must "pop" during ``testTearDown()``. If the calls
-    to push and pop are not balanced, you will leave your global registry in
-    a mess, which is not pretty.
-
-    Returns the new default global site manager. Also causes the site manager
-    hook from ``zope.site`` to be reset, clearing any local site managers as
-    appropriate.
+
+    Create or obtain a stack of global component registries, and push a new registry to the top of the stack.
+    The net result is that ``zope.component.getGlobalSiteManager()`` and (an un-hooked) ``getSiteManager()`` will return the new registry instead of the default, module-scope one.
+    From this point onwards, calls to ``provideAdapter()``, ``provideUtility()`` and other functions that modify the global registry will use the new registry.
+
+    If ``new`` is not given, a new registry is created that has the previous global registry (site manager) as its sole base.
+    This has the effect that registrations in the previous default global registry are still available, but new registrations are confined to the new registry.
+
+    **Warning**: If you call this function, you *must* reciprocally call ``popGlobalRegistry()``.
+    That is, if you "push" a registry during layer ``setUp()``, you must "pop" it during ``tearDown()``.
+    If you "push" during ``testSetUp()``, you must "pop" during ``testTearDown()``.
+    If the calls to push and pop are not balanced, you will leave your global registry in a mess, which is not pretty.
+
+    Returns the new default global site manager.
+    Also causes the site manager hook from ``zope.site`` to be reset, clearing any local site managers as appropriate.
 
 ``popGlobalRegistry()``
-    Pop the global site registry, restoring the previous registry to be the
-    default.
+
+    Pop the global site registry, restoring the previous registry to be the default.
 
     Please heed the warning above: push and pop must be balanced.
 
-    Returns the new default global site manager. Also causes the site manager
-    hook from ``zope.site`` to be reset, clearing any local site managers as
-    appropriate.
+    Returns the new default global site manager.
+    Also causes the site manager hook from ``zope.site`` to be reset, clearing any local site managers as appropriate.
 
 Zope Security
 -------------
 
-The Zope Security layers build can be found in the module
-``plone.testing.security``.
+The Zope Security layers build can be found in the module ``plone.testing.security``.
 
-If you depend on this, you can use the ``[security]`` extra when depending on
-``plone.testing``.
+If you depend on this, you can use the ``[security]`` extra when depending on ``plone.testing``.
 
 Security checker isolation
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -1652,26 +1444,25 @@ Security checker isolation
 | Resources: | None                                             |
 +------------+--------------------------------------------------+
 
-This layer ensures that security checkers used by ``zope.security`` are
-isolated. Any checkers set up in a child layer will be removed cleanly during
-tear-down.
+This layer ensures that security checkers used by ``zope.security`` are isolated.
+Any checkers set up in a child layer will be removed cleanly during tear-down.
 
 Helper functions
 ~~~~~~~~~~~~~~~~
 
-The security checker isolation outlined above is managed using two helper
-functions found in the module ``plone.testing.security``:
+The security checker isolation outlined above is managed using two helper functions found in the module ``plone.testing.security``:
 
 ``pushCheckers()``
+
     Copy the current set of security checkers for later tear-down.
+
 ``popCheckers()``
-    Restore the set of security checkers to the state of the most recent
-    call to ``pushCheckers()``.
+
+    Restore the set of security checkers to the state of the most recent call to ``pushCheckers()``.
 
 You *must* keep calls to ``pushCheckers()`` and ``popCheckers()`` in balance.
-That usually means that if you call the former during layer setup, you should
-call the latter during layer tear-down. Ditto for calls during test
-setup/tear-down or within tests themselves.
+That usually means that if you call the former during layer setup, you should call the latter during layer tear-down.
+Ditto for calls during test setup/tear-down or within tests themselves.
 
 Zope Publisher
 --------------
@@ -1679,8 +1470,7 @@ Zope Publisher
 The Zope Publisher layers build on the Zope Component Architecture layers.
 They can be found in the module ``plone.testing.publisher``.
 
-If you depend on this, you can use the ``[publisher]`` extra when depending on
-``plone.testing``.
+If you depend on this, you can use the ``[publisher]`` extra when depending on ``plone.testing``.
 
 Publisher directives
 ~~~~~~~~~~~~~~~~~~~~
@@ -1695,26 +1485,20 @@ Publisher directives
 | Resources: | None                                             |
 +------------+--------------------------------------------------+
 
-This layer extends the ``zca.ZCML_DIRECTIVES`` layer to install additional
-ZCML directives in the ``browser`` namespace (from
-``zope.app.publisher.browser``) as well as those from ``zope.security``.
-This allows browser views, browser pages and other UI components to be
-registered, as well as the definition of new permissions.
+This layer extends the ``zca.ZCML_DIRECTIVES`` layer to install additional ZCML directives in the ``browser`` namespace (from ``zope.app.publisher.browser``) as well as those from ``zope.security``.
+This allows browser views, browser pages and other UI components to be registered, as well as the definition of new permissions.
 
-As with ``zca.ZCML_DIRECTIVES``, you should use the ``configurationContext``
-resource when loading ZCML strings or files, and the
-``stackConfigurationRegistry()`` helper to create a layer-specific version
-of this resource resource. See above.
+As with ``zca.ZCML_DIRECTIVES``, you should use the ``configurationContext`` resource when loading ZCML strings or files, and the ``stackConfigurationRegistry()`` helper to create a layer-specific version of this resource resource.
+See above.
 
 ZODB
 ----
 
-The ZODB layers set up a test fixture with a persistent ZODB. The ZODB
-instance uses ``DemoStorage``, so it will not interfere with any "live"
-data.
+The ZODB layers set up a test fixture with a persistent ZODB.
+The ZODB instance uses ``DemoStorage``, so it will not interfere with any "live" data.
 
-ZODB layers can be found in the module ``plone.testing.zodb``. If you depend
-on this, you can use the ``[zodb]`` extra when depending on ``plone.testing``.
+ZODB layers can be found in the module ``plone.testing.zodb``.
+If you depend on this, you can use the ``[zodb]`` extra when depending on ``plone.testing``.
 
 Empty ZODB sandbox
 ~~~~~~~~~~~~~~~~~~
@@ -1733,24 +1517,19 @@ Empty ZODB sandbox
 |            | ``zodbConnection`` (test set-up only)            |
 +------------+--------------------------------------------------+
 
-This layer sets up a simple ZODB sandbox using ``DemoStorage``. The ZODB root
-object is a simple persistent mapping, available as the resource ``zodbRoot``.
-The ZODB database object is available as the resource ``zodbDB``. The
-connection used in the test is available as ``zodbConnection``.
+This layer sets up a simple ZODB sandbox using ``DemoStorage``.
+The ZODB root object is a simple persistent mapping, available as the resource ``zodbRoot``.
+The ZODB database object is available as the resource ``zodbDB``.
+The connection used in the test is available as ``zodbConnection``.
 
-Note that the ``zodbConnection`` and ``zodbRoot`` resources are created and
-destroyed for each test. You can use ``zodbDB`` (and the ``open()`` method)
-if you are writing a layer based on this one and need to set up a fixture
-during layer set up. Don't forget to close the connection before concluding
-the test setup!
+Note that the ``zodbConnection`` and ``zodbRoot`` resources are created and destroyed for each test.
+You can use ``zodbDB`` (and the ``open()`` method) if you are writing a layer based on this one and need to set up a fixture during layer set up.
+Don't forget to close the connection before concluding the test setup!
 
-A new transaction is begun for each test, and rolled back (aborted) on test
-tear-down. This means that so long as you don't use ``transaction.commit()``
-explicitly in your code, it should be safe to add or modify items in the
-ZODB root.
+A new transaction is begun for each test, and rolled back (aborted) on test tear-down.
+This means that so long as you don't use ``transaction.commit()`` explicitly in your code, it should be safe to add or modify items in the ZODB root.
 
-If you want to create a test fixture with persistent data in your own layer
-based on ``EMPTY_ZODB``, you can use the following pattern::
+If you want to create a test fixture with persistent data in your own layer based on ``EMPTY_ZODB``, you can use the following pattern::
 
     from plone.layer import Layer
     from plone.layer import zodb
@@ -1776,12 +1555,10 @@ based on ``EMPTY_ZODB``, you can use the following pattern::
             self['zodbDB'].close()
             del self['zodbDB']
 
-This shadows the ``zodbDB`` resource with a new database that uses a new
-``DemoStorage`` stacked on top of the underlying database storage. The fixture
-is added to this storage and committed during layer setup. (The base layer
-test set-up/tear-down will still begin and abort a new transaction for each
-*test*). On layer tear-down, the database is closed and the resource popped,
-leaving the original ``zodbDB`` database with the original, pristine storage.
+This shadows the ``zodbDB`` resource with a new database that uses a new ``DemoStorage`` stacked on top of the underlying database storage.
+The fixture is added to this storage and committed during layer setup.
+(The base layer test set-up/tear-down will still begin and abort a new transaction for each *test*).
+On layer tear-down, the database is closed and the resource popped, leaving the original ``zodbDB`` database with the original, pristine storage.
 
 Helper functions
 ~~~~~~~~~~~~~~~~
@@ -1789,12 +1566,12 @@ Helper functions
 One helper function is available in the ``plone.testing.zodb`` module.
 
 ``stackDemoStorage(db=None, name=None)``
-    Create a new ``DemoStorage`` using the storage from the passed-in database
-    as a base. If ``db`` is None, a brand new storage is created.
 
-    A ``name`` can be given to uniquely identify the storage. It is optional,
-    but it is often useful for debugging purposes to pass the name of the
-    layer.
+    Create a new ``DemoStorage`` using the storage from the passed-in database as a base.
+    If ``db`` is None, a brand new storage is created.
+
+    A ``name`` can be given to uniquely identify the storage.
+    It is optional, but it is often useful for debugging purposes to pass the name of the layer.
 
     The usual pattern is::
 
@@ -1805,21 +1582,18 @@ One helper function is available in the ``plone.testing.zodb`` module.
             self['zodbDB'].close()
             del self['zodbDB']
 
-    This will shadow the ``zodbDB`` resource with an isolated
-    ``DemoStorage``, creating a new one if that resource does not already
-    exist. All existing data continues to be available, but new changes are
-    written to the stacked storage. On tear-down, the stacked database is
-    closed and the resource removed, leaving the original data.
+    This will shadow the ``zodbDB`` resource with an isolated ``DemoStorage``, creating a new one if that resource does not already exist.
+    All existing data continues to be available, but new changes are written to the stacked storage.
+    On tear-down, the stacked database is closed and the resource removed, leaving the original data.
 
 Zope 2
 ------
 
-The Zope 2 layers provide test fixtures suitable for testing Zope 2
-applications. They set up a Zope 2 application root, install core Zope 2
-products, and manage security.
+The Zope 2 layers provide test fixtures suitable for testing Zope 2 applications.
+They set up a Zope 2 application root, install core Zope 2 products, and manage security.
 
-Zope 2 layers can be found in the module ``plone.testing.z2``. If you depend
-on this, you can use the ``[z2]`` extra when depending on ``plone.testing``.
+Zope 2 layers can be found in the module ``plone.testing.z2``.
+If you depend on this, you can use the ``[z2]`` extra when depending on ``plone.testing``.
 
 Startup
 ~~~~~~~
@@ -1840,42 +1614,37 @@ Startup
 |            | ``port``                                         |
 +------------+--------------------------------------------------+
 
-This layer sets up a Zope 2 environment, and is a required base for all other
-Zope 2 layers. You cannot run two instances of this layer in parallel, since
-Zope 2 depends on some module-global state to run, which is managed by this
-layer.
+This layer sets up a Zope 2 environment, and is a required base for all other Zope 2 layers.
+You cannot run two instances of this layer in parallel, since Zope 2 depends on some module-global state to run, which is managed by this layer.
 
 On set-up, the layer will configure a Zope environment with:
 
 .. note::
 
-   The ``STARTUP`` layer is a useful base layer for your own fixtures,
-   but should not be used directly, since it provides no test lifecycle or
-   transaction management. See the "Integration test" and "Functional" test
-   sections below for examples of how to create your own layers.
+    The ``STARTUP`` layer is a useful base layer for your own fixtures, but should not be used directly, since it provides no test lifecycle or transaction management.
+    See the "Integration test" and "Functional" test sections below for examples of how to create your own layers.
 
 * Debug mode enabled.
+
 * ZEO client cache disabled.
-* Some patches installed, which speed up Zope startup by disabling the help
-  system and some other superfluous aspects of Zope.
-* One thread (this only really affects the ``ZSERVER`` and ``FTP_SERVER``
-  layers).
-* A pristine database using ``DemoStorage``, exposed as the resource
-  ``zodbDB``. Zope is configured to use this database in a way that will
-  also work if the ``zodbDB`` resource is shadowed using the pattern shown
-  above in the description of the ``zodb.EMPTY_ZODB`` layer.
-* A fake hostname and port, exposed as the ``host`` and ``port`` resource,
-  respectively.
-* A minimal set of products installed (``Products.OFSP`` and
-  ``Products.PluginIndexes``, both required for Zope to start up).
-* A stacked ZCML configuration context, exposed as the resource
-  ``configurationContext``. As illustrated above, you should use the
-  ``zca.stackConfigurationContext()`` helper to stack your own configuration
-  context if you use this.
+
+* Some patches installed, which speed up Zope startup by disabling the help system and some other superfluous aspects of Zope.
+
+* One thread (this only really affects the ``ZSERVER`` and ``FTP_SERVER`` layers).
+
+* A pristine database using ``DemoStorage``, exposed as the resource ``zodbDB``.
+  Zope is configured to use this database in a way that will also work if the ``zodbDB`` resource is shadowed using the pattern shown above in the description of the ``zodb.EMPTY_ZODB`` layer.
+
+* A fake hostname and port, exposed as the ``host`` and ``port`` resource, respectively.
+
+* A minimal set of products installed (``Products.OFSP`` and ``Products.PluginIndexes``, both required for Zope to start up).
+
+* A stacked ZCML configuration context, exposed as the resource ``configurationContext``.
+  As illustrated above, you should use the ``zca.stackConfigurationContext()`` helper to stack your own configuration context if you use this.
+
 * A minimal set of global Zope components configured.
 
-Note that unlike a "real" Zope site, products in the ``Products.*`` namespace
-are not automatically loaded, nor is any ZCML.
+Note that unlike a "real" Zope site, products in the ``Products.*`` namespace are not automatically loaded, nor is any ZCML.
 
 Integration test
 ~~~~~~~~~~~~~~~~
@@ -1892,35 +1661,24 @@ Integration test
 |            | ``request``                                      |
 +------------+--------------------------------------------------+
 
-This layer is intended for integration testing against the simple ``STARTUP``
-fixture. If you want to create your own layer with a more advanced, shared
-fixture, see "Integration and functional testing with custom fixtures" below.
+This layer is intended for integration testing against the simple ``STARTUP`` fixture.
+If you want to create your own layer with a more advanced, shared fixture, see "Integration and functional testing with custom fixtures" below.
 
 For each test, it exposes the Zope application root as the resource ``app``.
-This is wrapped in the request container, so you can do ``app.REQUEST`` to
-acquire a fake request, but the request is also available as the resource
-``request``.
+This is wrapped in the request container, so you can do ``app.REQUEST`` to acquire a fake request, but the request is also available as the resource ``request``.
 
-A new transaction is begun for each test and rolled back on test tear-down,
-meaning that so long as the code under test does not explicitly commit any
-changes, the test may modify the ZODB.
+A new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.
 
-    *Hint:* If you want to set up a persistent test fixture in a layer based
-    on this one (or ``z2.FUNCTIONAL_TESTING``), you can stack a new
-    ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern
-    described above for the ``zodb.EMPTY_ZODB`` layer.
+    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``z2.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.
 
-    Once you've shadowed the ``zodbDB`` resource, you can do (e.g. in your
-    layer's ``setUp()`` method)::
+    Once you've shadowed the ``zodbDB`` resource, you can do (e.g. in your layer's ``setUp()`` method)::
 
         ...
         with z2.zopeApp() as app:
             # modify the Zope application root
 
-    The ``zopeApp()`` context manager will open a new connection to the Zope
-    application root, accessible here as ``app``. Provided the code within
-    the ``with`` block does not raise an exception, the transaction will be
-    committed and the database closed properly upon exiting the block.
+    The ``zopeApp()`` context manager will open a new connection to the Zope application root, accessible here as ``app``.
+    Provided the code within the ``with`` block does not raise an exception, the transaction will be committed and the database closed properly upon exiting the block.
 
 Functional testing
 ~~~~~~~~~~~~~~~~~~
@@ -1937,38 +1695,29 @@ Functional testing
 |            | ``request``                                      |
 +------------+--------------------------------------------------+
 
-This layer is intended for functional testing against the simple ``STARTUP``
-fixture. If you want to create your own layer with a more advanced, shared
-fixture, see "Integration and functional testing with custom fixtures" below.
+This layer is intended for functional testing against the simple ``STARTUP`` fixture.
+If you want to create your own layer with a more advanced, shared fixture, see "Integration and functional testing with custom fixtures" below.
 
-As its name implies, this layer is intended mainly for functional end-to-end
-testing using tools like `zope.testbrowser`_. See also the ``Browser`` object
-as described under "Helper functions" below.
+As its name implies, this layer is intended mainly for functional end-to-end testing using tools like `zope.testbrowser`_.
+See also the ``Browser`` object as described under "Helper functions" below.
 
 This layer is very similar to ``INTEGRATION_TESTING``, but is not based on it.
-It sets up the same fixture and exposes the same resources. However, instead
-of using a simple transaction abort to isolate the ZODB between tests, it uses
-a stacked ``DemoStorage`` for each test. This is slower, but allows test code
-to perform and explicit commit, as will usually happen in a functional test.
+It sets up the same fixture and exposes the same resources.
+However, instead of using a simple transaction abort to isolate the ZODB between tests, it uses a stacked ``DemoStorage`` for each test.
+This is slower, but allows test code to perform and explicit commit, as will usually happen in a functional test.
 
 Integration and functional testing with custom fixtures
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-If you want to extend the ``STARTUP`` fixture for use with integration or
-functional testing, you should use the following pattern:
+If you want to extend the ``STARTUP`` fixture for use with integration or functional testing, you should use the following pattern:
+
+* Create a layer class and a "fixture" base layer instance that has ``z2.STARTUP`` (or some intermediary layer, such as ``z2.ZSERVER_FIXTURE`` or ``z2.FTP_SERVER_FIXTURE``, shown below) as a base.
 
-* Create a layer class and a "fixture" base layer instance that has
-  ``z2.STARTUP`` (or some intermediary layer, such as ``z2.ZSERVER_FIXTURE``
-  or ``z2.FTP_SERVER_FIXTURE``, shown below) as a base.
-* Create "end user" layers by instantiating the ``z2.IntegrationTesting``
-  and/or ``FunctionalTesting`` classes with this new "fixture" layer as a
-  base.
+* Create "end user" layers by instantiating the ``z2.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new "fixture" layer as a base.
 
-This allows the same fixture to be used regardless of the "style" of testing,
-minimising the amount of set-up and tear-down. The "fixture" layers manage the
-fixture as part of the *layer* lifecycle. The layer class
-(``IntegrationTesting`` or ``FunctionalTesting``), manages the *test*
-lifecycle, and the test lifecycle only.
+This allows the same fixture to be used regardless of the "style" of testing, minimising the amount of set-up and tear-down.
+The "fixture" layers manage the fixture as part of the *layer* lifecycle.
+The layer class (``IntegrationTesting`` or ``FunctionalTesting``), manages the *test* lifecycle, and the test lifecycle only.
 
 For example::
 
@@ -1990,26 +1739,19 @@ For example::
     MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")
     MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")
 
-(Note that we need to give an explicit, unique name to the two layers that
-re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)
+(Note that we need to give an explicit, unique name to the two layers that re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)
 
-In this example, other layers could extend the "MyLayer" fixture by using
-``MY_FIXTURE`` as a base. Tests would use either ``MY_INTEGRATION_TESTING``
-or ``MY_FUNCTIONAL_TESTING`` as appropriate. However, even if both these two
-layers were used, the fixture in ``MY_FIXTURE`` would only be set up once.
+In this example, other layers could extend the "MyLayer" fixture by using ``MY_FIXTURE`` as a base.
+Tests would use either ``MY_INTEGRATION_TESTING`` or ``MY_FUNCTIONAL_TESTING`` as appropriate.
+However, even if both these two layers were used, the fixture in ``MY_FIXTURE`` would only be set up once.
 
 .. note::
 
-   If you implement the ``testSetUp()`` and ``testTearDown()`` test
-   lifecycle methods in your "fixture" layer (e.g. in the the ``MyLayer``
-   class above), they will execute before the corresponding methods from
-   ``IntegrationTesting`` and ``FunctionalTesting``. Hence, they cannot use
-   those layers' resources (``app`` and ``request``).
+    If you implement the ``testSetUp()`` and ``testTearDown()`` test lifecycle methods in your "fixture" layer (e.g. in the the ``MyLayer`` class above), they will execute before the corresponding methods from ``IntegrationTesting`` and ``FunctionalTesting``.
+    Hence, they cannot use those layers' resources (``app`` and ``request``).
 
-It may be preferable, therefore, to have your own "test lifecycle" layer
-classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and
-call base class methods as appropriate. ``plone.app.testing`` takes this
-approach, for example.
+It may be preferable, therefore, to have your own "test lifecycle" layer classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and call base class methods as appropriate.
+``plone.app.testing`` takes this approach, for example.
 
 HTTP ZServer thread (fixture only)
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -2026,23 +1768,18 @@ HTTP ZServer thread (fixture only)
 |            | ``port``                                         |
 +------------+--------------------------------------------------+
 
-This layer extends the ``z2.STARTUP`` layer to start the Zope HTTP server in
-a separate thread. This means the test site can be accessed through a web
-browser, and can thus be used with tools like `Windmill`_ or `Selenium`_.
+This layer extends the ``z2.STARTUP`` layer to start the Zope HTTP server in a separate thread.
+This means the test site can be accessed through a web browser, and can thus be used with tools like `Windmill`_ or `Selenium`_.
 
 .. note::
 
-   This layer is useful as a fixture base layer only, because it does
-   not manage the test lifecycle. Use the ``ZSERVER`` layer if you want to
-   execute functional tests against this fixture.
+    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.
+    Use the ``ZSERVER`` layer if you want to execute functional tests against this fixture.
 
-The ZServer's hostname (normally ``localhost``) is available through the
-resource ``host``, whilst the port it is running on is available through the
-resource ``port``.
+The ZServer's hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.
 
-  *Hint:* Whilst the layer is set up, you can actually access the test Zope
-  site through a web browser. The default URL will be
-  ``http://localhost:55001``.
+  *Hint:* Whilst the layer is set up, you can actually access the test Zope site through a web browser.
+  The default URL will be ``http://localhost:55001``.
 
 HTTP ZServer functional testing
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -2057,14 +1794,11 @@ HTTP ZServer functional testing
 | Resources: |                                                  |
 +------------+--------------------------------------------------+
 
-This layer provides the functional testing lifecycle against the fixture set
-up by the ``z2.ZSERVER_FIXTURE`` layer.
+This layer provides the functional testing lifecycle against the fixture set up by the ``z2.ZSERVER_FIXTURE`` layer.
 
 You can use this to run "live" functional tests against a basic Zope site.
-You should **not** use it as a base. Instead, create your own "fixture"
-layer that extends ``z2.ZSERVER_FIXTURE``, and then instantiate the
-``FunctionalTesting`` class with this extended fixture layer as a base,
-as outlined above.
+You should **not** use it as a base.
+Instead, create your own "fixture" layer that extends ``z2.ZSERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.
 
 FTP server thread (fixture only)
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -2081,28 +1815,23 @@ FTP server thread (fixture only)
 |            | ``port``                                         |
 +------------+--------------------------------------------------+
 
-This layer is the FTP server equivalent of the ``ZSERVER_FIXTURE`` layer. It
-can be used to functionally test Zope servers.
+This layer is the FTP server equivalent of the ``ZSERVER_FIXTURE`` layer.
+It can be used to functionally test Zope servers.
 
 .. note::
 
-   This layer is useful as a fixture base layer only, because it does
-   not manage the test lifecycle. Use the ``FTP_SERVER`` layer if you want to
-   execute functional tests against this fixture.
+    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.
+    Use the ``FTP_SERVER`` layer if you want to execute functional tests against this fixture.
 
-   *Hint:* Whilst the layer is set up, you can actually access the test Zope
-   site through an FTP client. The default URL will be
-   ``ftp://localhost:55002``.
+    *Hint:* Whilst the layer is set up, you can actually access the test Zope site through an FTP client.
+    The default URL will be ``ftp://localhost:55002``.
 
 .. warning::
 
-   Do not run the ``FTP_SERVER`` and ``ZSERVER`` layers concurrently in the same process.
+    Do not run the ``FTP_SERVER`` and ``ZSERVER`` layers concurrently in the same process.
 
-If you need both ZServer and FTPServer running together, you can subclass the
-``ZServer`` layer class (like the ``FTPServer`` layer class does) and
-implement the ``setUpServer()`` and ``tearDownServer()`` methods to set up
-and close down two servers on different ports. They will then share a main
-loop.
+If you need both ZServer and FTPServer running together, you can subclass the ``ZServer`` layer class (like the ``FTPServer`` layer class does) and implement the ``setUpServer()`` and ``tearDownServer()`` methods to set up and close down two servers on different ports.
+They will then share a main loop.
 
 FTP server functional testing
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -2117,14 +1846,11 @@ FTP server functional testing
 | Resources: |                                                  |
 +------------+--------------------------------------------------+
 
-This layer provides the functional testing lifecycle against the fixture set
-up by the ``z2.FTP_SERVER_FIXTURE`` layer.
+This layer provides the functional testing lifecycle against the fixture set up by the ``z2.FTP_SERVER_FIXTURE`` layer.
 
 You can use this to run "live" functional tests against a basic Zope site.
-You should **not** use it as a base. Instead, create your own "fixture"
-layer that extends ``z2.FTP_SERVER_FIXTURE``, and then instantiate the
-``FunctionalTesting`` class with this extended fixture layer as a base,
-as outlined above.
+You should **not** use it as a base.
+Instead, create your own "fixture" layer that extends ``z2.FTP_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.
 
 Helper functions
 ~~~~~~~~~~~~~~~~
@@ -2132,58 +1858,57 @@ Helper functions
 Several helper functions are available in the ``plone.testing.z2`` module.
 
 ``zopeApp(db=None, conn=Non, environ=None)``
-    This function can be used as a context manager for any code that requires
-    access to the Zope application root. By using it in a ``with`` block,
-    the database will be opened, and the application root will be obtained and
-    request-wrapped. When exiting the ``with`` block, the transaction will be
-    committed and the database properly closed, unless an exception was
-    raised::
+
+    This function can be used as a context manager for any code that requires access to the Zope application root.
+    By using it in a ``with`` block, the database will be opened, and the application root will be obtained and request-wrapped.
+    When exiting the ``with`` block, the transaction will be committed and the database properly closed, unless an exception was raised::
 
         with z2.zopeApp() as app:
             # do something with app
 
-    If you want to use a specific database or database connection, pass either
-    the ``db`` or ``conn`` arguments. If the context manager opened a new
-    connection, it will close it, but it will not close a connection passed
-    with ``conn``.
+    If you want to use a specific database or database connection, pass either the ``db`` or ``conn`` arguments.
+    If the context manager opened a new connection, it will close it, but it will not close a connection passed with ``conn``.
+
+    To set keys in the (fake) request environment, pass a dictionary of environment values as ``environ``.
 
-    To set keys in the (fake) request environment, pass a dictionary of
-    environment values as ``environ``.
+    Note that ``zopeApp()`` should *not* normally be used in tests or test set-up/tear-down, because the ``INTEGRATOIN_TEST`` and ``FUNCTIONAL_TESTING`` layers both manage the application root (as the ``app`` resource) and close it for you.
+    It is very useful in layer setup, however.
 
-    Note that ``zopeApp()`` should *not* normally be used in tests or test
-    set-up/tear-down, because the ``INTEGRATOIN_TEST`` and
-    ``FUNCTIONAL_TESTING`` layers both manage the application root (as the
-    ``app`` resource) and close it for you. It is very useful in layer setup,
-    however.
 ``installProduct(app, product, quiet=False)``
-    Install a Zope 2 style product, ensuring that its ``initialize()``
-    function is called. The product name must be the full dotted name, e.g.
-    ``plone.app.portlets`` or ``Products.CMFCore``. If ``quiet`` is true,
-    duplicate registrations will be ignored silently, otherwise a message is
-    logged.
-
-    To get hold of the application root, passed as the ``app`` argument, you
-    would normally use the ``zopeApp()`` context manager outlined above.
+
+    Install a Zope 2 style product, ensuring that its ``initialize()`` function is called.
+    The product name must be the full dotted name, e.g. ``plone.app.portlets`` or ``Products.CMFCore``.
+    If ``quiet`` is true, duplicate registrations will be ignored silently, otherwise a message is logged.
+
+    To get hold of the application root, passed as the ``app`` argument, you would normally use the ``zopeApp()`` context manager outlined above.
+
 ``uninstallProduct(app, product, quiet=False)``
-    This is the reciprocal of ``installProduct()``, normally used during layer
-    tear-down. Again, you should use ``zopeApp()`` to obtain the application
-    root.
+
+    This is the reciprocal of ``installProduct()``, normally used during layer tear-down.
+    Again, you should use ``zopeApp()`` to obtain the application root.
+
 ``login(userFolder, userName)``
-    Create a new security manager that simulates being logged in as the given
-    user. ``userFolder`` is an ``acl_users`` object, e.g.
-    ``app['acl_users']`` for the root user folder.
+
+    Create a new security manager that simulates being logged in as the given user.
+    ``userFolder`` is an ``acl_users`` object, e.g. ``app['acl_users']`` for the root user folder.
+
 ``logout()``
+
     Simulate being the anonymous user by unsetting the security manager.
+
 ``setRoles(userFolder, userName, roles)``
-    Set the roles of the given user in the given user folder to the given
-    list of roles.
+
+    Set the roles of the given user in the given user folder to the given list of roles.
+
 ``makeTestRequest()``
+
     Create a fake Zope request.
+
 ``addRequestContainer(app, environ=None)``
-    Create a fake request and wrap the given object (normally an application
-    root) in a ``RequestContainer`` with this request. This makes acquisition
-    of ``app.REQUEST`` possible. To initialise the request environment with
-    non-default values, pass a dictionary as ``environ``.
+
+    Create a fake request and wrap the given object (normally an application root) in a ``RequestContainer`` with this request.
+    This makes acquisition of ``app.REQUEST`` possible.
+    To initialise the request environment with non-default values, pass a dictionary as ``environ``.
 
     .. note::
     
@@ -2191,24 +1916,21 @@ Several helper functions are available in the ``plone.testing.z2`` module.
        context manager and the layer set-up/tear-down for
        ``z2.INTEGRATION_TESTING`` and ``z2.FUNCTIONAL_TESTING`` will wrap the
        ``app`` object before exposing it.
+
 ``Browser(app)``
-    Obtain a test browser client, for use with `zope.testbrowser`_. You should
-    use this in conjunction with the ``z2.FUNCTIONAL_TESTING`` layer or a
-    derivative. You must pass the app root, usually obtained from the ``app``
-    resource of the layer, e.g.::
+
+    Obtain a test browser client, for use with `zope.testbrowser`_.
+    You should use this in conjunction with the ``z2.FUNCTIONAL_TESTING`` layer or a derivative.
+    You must pass the app root, usually obtained from the ``app`` resource of the layer, e.g.::
 
         app = self.layer['app']
         browser = z2.Browser(app)
 
-    You can then use ``browser`` as described in the `zope.testbrowser`_
-    documentation.
+    You can then use ``browser`` as described in the `zope.testbrowser`_ documentation.
 
     Bear in mind that the test browser runs separately from the test fixture.
-    In particular, calls to helpers such as ``login()`` or ``logout()`` do
-    not affect the state that the test browser sees. If you want to set up
-    a persistent fixture (e.g. test content), you can do so before creating
-    the test browser, but you will need to explicitly commit your changes,
-    with::
+    In particular, calls to helpers such as ``login()`` or ``logout()`` do not affect the state that the test browser sees.
+    If you want to set up a persistent fixture (e.g. test content), you can do so before creating the test browser, but you will need to explicitly commit your changes, with::
 
         import transaction
         transaction.commit()
diff --git a/src/plone/testing/layer.rst b/src/plone/testing/layer.rst
index 5ae6583..f3f856b 100644
--- a/src/plone/testing/layer.rst
+++ b/src/plone/testing/layer.rst
@@ -1,18 +1,17 @@
 Layer base class
 ----------------
 
-This package provides a layer base class which can be used by the test
-runner. It is available as a convenience import from the package root.
+This package provides a layer base class which can be used by the test runner.
+It is available as a convenience import from the package root.::
 
     >>> from plone.testing import Layer
 
-A layer may be instantiated directly, though in this case the ``name``
-argument is required (see below).
+A layer may be instantiated directly, though in this case the ``name`` argument is required (see below).::
 
     >>> NULL_LAYER = Layer(name="Null layer")
 
-This is not very useful on its own. It has an empty list of bases, and each of
-the layer lifecycle methods does nothing.
+This is not very useful on its own.
+It has an empty list of bases, and each of the layer lifecycle methods does nothing.::
 
     >>> NULL_LAYER.__bases__
     ()
@@ -26,17 +25,16 @@ the layer lifecycle methods does nothing.
     >>> NULL_LAYER.tearDown()
     >>> NULL_LAYER.testTearDown()
 
-Just about the only reason to use this directly (i.e. not as a base class) is
-to group together other layers.
+Just about the only reason to use this directly (i.e. not as a base class) is to group together other layers.::
 
     >>> SIMPLE_LAYER = Layer(bases=(NULL_LAYER,), name="Simple layer", module='plone.testing.tests')
 
-Here, we've also set the module name directly. The default for all layers is
-to take the module name from the stack frame where the layer was instantiated.
-In doctests, that doesn't work, though, so we fall back on the module name of
-the layer class. The two are often the same, of course.
+Here, we've also set the module name directly.
+The default for all layers is to take the module name from the stack frame where the layer was instantiated.
+In doctests, that doesn't work, though, so we fall back on the module name of the layer class.
+The two are often the same, of course.
 
-This layer now has the bases, name and module we set:
+This layer now has the bases, name and module we set:::
 
     >>> SIMPLE_LAYER.__bases__
     (<Layer 'plone.testing.layer.Null layer'>,)
@@ -47,8 +45,7 @@ This layer now has the bases, name and module we set:
     >>> SIMPLE_LAYER.__module__
     'plone.testing.tests'
 
-The ``name`` argument is required when using ``Layer`` directly (but not
-when using a subclass):
+The ``name`` argument is required when using ``Layer`` directly (but not when using a subclass):::
 
     >>> Layer((SIMPLE_LAYER,))
     Traceback (most recent call last):
@@ -64,8 +61,7 @@ Using ``Layer`` as a base class
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 The usual pattern is to use ``Layer`` as a base class for a custom layer.
-This can then override the lifecycle methods as appropriate, as well as
-set a default list of bases.
+This can then override the lifecycle methods as appropriate, as well as set a default list of bases.::
 
     >>> class BaseLayer(Layer):
     ...
@@ -77,7 +73,7 @@ set a default list of bases.
 
     >>> BASE_LAYER = BaseLayer()
 
-The layer name and module are taken from the class.
+The layer name and module are taken from the class.::
 
     >>> BASE_LAYER.__bases__
     ()
@@ -86,13 +82,11 @@ The layer name and module are taken from the class.
     >>> BASE_LAYER.__module__
     '__builtin__'
 
-We can now create a new layer that has this one as a base. We can do this in
-the instance constructor, as shown above, but the most common pattern is to
-set the default bases in the class body, using the variable ``defaultBases``.
+We can now create a new layer that has this one as a base.
+We can do this in the instance constructor, as shown above, but the most common pattern is to set the default bases in the class body, using the variable ``defaultBases``.
 
-We'll also set the default name explicitly here by passing a name to the the
-super-constructor. This is mostly cosmetic, but may be desirable if the class
-name would be misleading in the test runner output.
+We'll also set the default name explicitly here by passing a name to the the super-constructor.
+This is mostly cosmetic, but may be desirable if the class name would be misleading in the test runner output.::
 
     >>> class ChildLayer(Layer):
     ...     defaultBases = (BASE_LAYER,)
@@ -108,7 +102,7 @@ name would be misleading in the test runner output.
 
     >>> CHILD_LAYER = ChildLayer()
 
-Notice how the bases have now been set using the value in ``defaultBases``.
+Notice how the bases have now been set using the value in ``defaultBases``.::
 
     >>> CHILD_LAYER.__bases__
     (<Layer '__builtin__.BaseLayer'>,)
@@ -120,14 +114,13 @@ Notice how the bases have now been set using the value in ``defaultBases``.
 Overriding the default list of bases
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-We can override the list of bases on a per-instance basis. This may be
-dangerous, i.e. the layer is likely to expect that its bases are set up.
-Sometimes, it may be useful to inject a new base, however, especially when
-re-using layers from other packages.
+We can override the list of bases on a per-instance basis.
+This may be dangerous, i.e.
+the layer is likely to expect that its bases are set up.
+Sometimes, it may be useful to inject a new base, however, especially when re-using layers from other packages.
 
-The new list of bases is passed to the constructor. When creating a second
-instance of a layer (most layers are global singletons created only once),
-it's useful to give the new instance a unique name, too.
+The new list of bases is passed to the constructor.
+When creating a second instance of a layer (most layers are global singletons created only once), it's useful to give the new instance a unique name, too.::
 
     >>> NEW_CHILD_LAYER = ChildLayer(bases=(SIMPLE_LAYER, BASE_LAYER,), name='New child')
 
@@ -141,9 +134,8 @@ it's useful to give the new instance a unique name, too.
 Inconsistent bases
 ~~~~~~~~~~~~~~~~~~
 
-Layer bases are maintained in an order that is semantically equivalent to the
-"method resolution order" Python maintains for base classes. We can get this
-from the ``baseResolutionOrder`` attribute:
+Layer bases are maintained in an order that is semantically equivalent to the "method resolution order" Python maintains for base classes.
+We can get this from the ``baseResolutionOrder`` attribute:::
 
     >>> CHILD_LAYER.baseResolutionOrder
     (<Layer '__builtin__.Child layer'>, <Layer '__builtin__.BaseLayer'>)
@@ -154,7 +146,7 @@ from the ``baseResolutionOrder`` attribute:
      <Layer '__builtin__.BaseLayer'>)
 
 As with Python classes, it is possible to construct an invalid set of bases.
-In this case, layer instantiation will fail.
+In this case, layer instantiation will fail.::
 
     >>> INCONSISTENT_BASE1 = Layer(name="Inconsistent 1")
     >>> INCONSISTENT_BASE2 = Layer((INCONSISTENT_BASE1,), name="Inconsistent 1")
@@ -166,14 +158,12 @@ In this case, layer instantiation will fail.
 Using the resource manager
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-Layers are also resource managers. Resources can be set, retrieved and
-deleted using dictionary syntax. Resources in base layers are available in
-child layers. When an item is set on a child layer, it shadows any items with
-the same key in any base layer (until it is deleted), but the original item
-still exists.
+Layers are also resource managers.
+Resources can be set, retrieved and deleted using dictionary syntax.
+Resources in base layers are available in child layers.
+When an item is set on a child layer, it shadows any items with the same key in any base layer (until it is deleted), but the original item still exists.
 
-Let's create a somewhat complex hierarchy of layers that all set resources
-under a key ``'foo'`` in their ``setUp()`` methods.
+Let's create a somewhat complex hierarchy of layers that all set resources under a key ``'foo'`` in their ``setUp()`` methods.::
 
     >>> class Layer1(Layer):
     ...     def setUp(self):
@@ -205,23 +195,20 @@ under a key ``'foo'`` in their ``setUp()`` methods.
     ...         del self['foo']
     >>> LAYER4 = Layer4()
 
-    **Important:** Resources that are created in ``setUp()`` must be deleted
-    in ``tearDown()``. Similarly, resources created in ``testSetUp()`` must
-    be deleted in ``testTearDown()``. This ensures resources are properly
-    stacked and do not leak between layers.
+    **Important:** Resources that are created in ``setUp()`` must be deleted in ``tearDown()``.
+    Similarly, resources created in ``testSetUp()`` must be deleted in ``testTearDown()``.
+    This ensures resources are properly stacked and do not leak between layers.
 
-If a test was using ``LAYER4``, the test runner would call each setup step in
-turn, starting with the "deepest" layer. We'll simulate that here, so that
-each of the resources is created.
+If a test was using ``LAYER4``, the test runner would call each setup step in turn, starting with the "deepest" layer.
+We'll simulate that here, so that each of the resources is created.::
 
     >>> LAYER1.setUp()
     >>> LAYER2.setUp()
     >>> LAYER3.setUp()
     >>> LAYER4.setUp()
 
-The layers are ordered in a known "resource resolution order", which is used
-to determine in which order the layers shadow one another. This is based on
-the same algorithm as Python's method resolution order.
+The layers are ordered in a known "resource resolution order", which is used to determine in which order the layers shadow one another.
+This is based on the same algorithm as Python's method resolution order.::
 
     >>> LAYER4.baseResolutionOrder
     (<Layer '__builtin__.Layer4'>,
@@ -229,21 +216,19 @@ the same algorithm as Python's method resolution order.
      <Layer '__builtin__.Layer1'>,
      <Layer '__builtin__.Layer3'>)
 
-When fetching and item from a layer, it will be obtained according to the
-resource resolution order.
+When fetching and item from a layer, it will be obtained according to the resource resolution order.::
 
     >>> LAYER4['foo']
     4
 
-This is not terribly interesting, since ``LAYER4`` has the resource ``'foo'``
-set directly. Let's tear down the layer (which deletes the resource) and see
-what happens.
+This is not terribly interesting, since ``LAYER4`` has the resource ``'foo'`` set directly.
+Let's tear down the layer (which deletes the resource) and see what happens.::
 
     >>> LAYER4.tearDown()
     >>> LAYER4['foo']
     2
 
-We can continue up the chain:
+We can continue up the chain:::
 
     >>> LAYER2.tearDown()
     >>> LAYER4['foo']
@@ -253,7 +238,7 @@ We can continue up the chain:
     >>> LAYER4['foo']
     3
 
-Once we've deleted the last key, we'll get a ``KeyError``:
+Once we've deleted the last key, we'll get a ``KeyError``:::
 
     >>> LAYER3.tearDown()
     >>> LAYER4['foo']
@@ -261,46 +246,38 @@ Once we've deleted the last key, we'll get a ``KeyError``:
     ...
     KeyError: 'foo'
 
-To guard against this, we can use the ``get()`` method.
+To guard against this, we can use the ``get()`` method.::
 
     >>> LAYER4.get('foo', -1)
     -1
 
-We can also test with 'in':
+We can also test with 'in':::
 
     >>> 'foo' in LAYER4
     False
 
-To illustrate that this indeed works, let's set the resource back on one
-of the bases.
+To illustrate that this indeed works, let's set the resource back on one of the bases.::
 
     >>> LAYER3['foo'] = 10
     >>> LAYER4.get('foo', -1)
     10
 
-Let's now consider a special case: a base layer sets up a resource in layer
-setup, and uses it in test setup. A child layer then shadows this resource in
-its own layer setup method. In this case, we want the base layer's
-``testSetUp()`` to use the shadowed version that the child provided.
+Let's now consider a special case: a base layer sets up a resource in layer setup, and uses it in test setup.
+A child layer then shadows this resource in its own layer setup method.
+In this case, we want the base layer's ``testSetUp()`` to use the shadowed version that the child provided.
 
-(This is similar to how instance variables work: a base class may set an
-attribute on ``self`` and use it in a method. If a subclass then sets the same
-attribute to a different value and the base class method is called on an
-instance of the subclass, the base class attribute is used).
+(This is similar to how instance variables work: a base class may set an attribute on ``self`` and use it in a method.
+If a subclass then sets the same attribute to a different value and the base class method is called on an instance of the subclass, the base class attribute is used).
 
-    *Hint:* If you definitely need to access the "original" resource in your
-    ``testSetUp()``/``testTearDown()`` methods, you can store a reference to
-    the resource as a layer instance variable::
+    *Hint:* If you definitely need to access the "original" resource in your ``testSetUp()``/``testTearDown()`` methods, you can store a reference to the resource as a layer instance variable::
 
         self.someResource = self['someResource'] = SomeResource()
 
-    ``self.someResource`` will now be the exact resource created here, whereas
-    ``self['someResource']`` will retain the layer shadowing semantics. In
-    most cases, you probably *don't* want to do this, allowing child layers to
-    supply overridden versions of resources as appropriate.
+    ``self.someResource`` will now be the exact resource created here, whereas ``self['someResource']`` will retain the layer shadowing semantics.
+    In most cases, you probably *don't* want to do this, allowing child layers to supply overridden versions of resources as appropriate.
 
-First, we'll create some base layers. We want to demonstrate having two
-"branches" of bases that both happen to define the same resource.
+First, we'll create some base layers.
+We want to demonstrate having two "branches" of bases that both happen to define the same resource.::
 
     >>> class ResourceBaseLayer1(Layer):
     ...     def setUp(self):
@@ -329,7 +306,7 @@ First, we'll create some base layers. We want to demonstrate having two
 
     >>> RESOURCE_BASE_LAYER3 = ResourceBaseLayer3()
 
-We'll then create the child layer that overrides this resource.
+We'll then create the child layer that overrides this resource.::
 
     >>> class ResourceChildLayer(Layer):
     ...     defaultBases = (RESOURCE_BASE_LAYER2, RESOURCE_BASE_LAYER3)
@@ -344,7 +321,7 @@ We'll then create the child layer that overrides this resource.
 
 We'll first set up the base layers on their own and simulate two tests.
 
-A test with RESOURCE_BASE_LAYER1 only would look like this:
+A test with RESOURCE_BASE_LAYER1 only would look like this:::
 
     >>> RESOURCE_BASE_LAYER1.setUp()
 
@@ -354,7 +331,7 @@ A test with RESOURCE_BASE_LAYER1 only would look like this:
 
     >>> RESOURCE_BASE_LAYER1.tearDown()
 
-A test with RESOURCE_BASE_LAYER2 would look like this:
+A test with RESOURCE_BASE_LAYER2 would look like this:::
 
     >>> RESOURCE_BASE_LAYER1.setUp()
     >>> RESOURCE_BASE_LAYER2.setUp()
@@ -369,7 +346,7 @@ A test with RESOURCE_BASE_LAYER2 would look like this:
     >>> RESOURCE_BASE_LAYER2.tearDown()
     >>> RESOURCE_BASE_LAYER1.tearDown()
 
-A test with RESOURCE_BASE_LAYER3 only would look like this:
+A test with RESOURCE_BASE_LAYER3 only would look like this:::
 
     >>> RESOURCE_BASE_LAYER3.setUp()
 
@@ -379,8 +356,8 @@ A test with RESOURCE_BASE_LAYER3 only would look like this:
 
     >>> RESOURCE_BASE_LAYER3.tearDown()
 
-Now let's set up the child layer and simulate another test. We should now be
-using the shadowed resource.
+Now let's set up the child layer and simulate another test.
+We should now be using the shadowed resource.::
 
     >>> RESOURCE_BASE_LAYER1.setUp()
     >>> RESOURCE_BASE_LAYER2.setUp()
@@ -402,8 +379,8 @@ using the shadowed resource.
     >>> RESOURCE_BASE_LAYER1.testTearDown()
 
 Finally, we'll tear down the child layer again and simulate another test.
-we should have the original resources back. Note that the first and third
-layers no longer share a resource, since they don't have a common ancestor.
+we should have the original resources back.
+Note that the first and third layers no longer share a resource, since they don't have a common ancestor.::
 
     >>> RESOURCE_CHILD_LAYER.tearDown()
 
@@ -418,7 +395,7 @@ layers no longer share a resource, since they don't have a common ancestor.
     Base 3
     >>> RESOURCE_BASE_LAYER3.testTearDown()
 
-Finally, we'll tear down the remaining layers..
+Finally, we'll tear down the remaining layers..::
 
     >>> RESOURCE_BASE_LAYER3.tearDown()
     >>> RESOURCE_BASE_LAYER2.tearDown()
@@ -427,9 +404,9 @@ Finally, we'll tear down the remaining layers..
 Asymmetric deletion
 +++++++++++++++++++
 
-It is an error to create or shadow a resource in a set-up lifecycle method and
-not delete it again in the tear-down. It is also an error to delete a resource
-that was not explicitly created. These two layers break those roles:
+It is an error to create or shadow a resource in a set-up lifecycle method and not delete it again in the tear-down.
+It is also an error to delete a resource that was not explicitly created.
+These two layers break those roles:::
 
     >>> class BadLayer1(Layer):
     ...     def setUp(self):
@@ -445,7 +422,7 @@ that was not explicitly created. These two layers break those roles:
     ...         self['bar'] = 2
     >>> BAD_LAYER2 = BadLayer2()
 
-Let's simulate a test that uses ``BAD_LAYER2``:
+Let's simulate a test that uses ``BAD_LAYER2``:::
 
     >>> BAD_LAYER1.setUp()
     >>> BAD_LAYER2.setUp()
@@ -462,9 +439,9 @@ Let's simulate a test that uses ``BAD_LAYER2``:
     ...
     KeyError: 'foo'
 
-Here, we've got an error in the base layer. This is because the resource
-is actually associated with the layer that first created it, in this case
-``BASE_LAYER2``. This one remains intact and orphaned:
+Here, we've got an error in the base layer.
+This is because the resource is actually associated with the layer that first created it, in this case ``BASE_LAYER2``.
+This one remains intact and orphaned:::
 
     >>> 'foo' in BAD_LAYER2._resources
     True
@@ -475,9 +452,7 @@ Doctest layer helper
 ~~~~~~~~~~~~~~~~~~~~
 
 The ``doctest`` module is not aware of ``zope.testing``'s layers concept.
-Therefore, the syntax for creating a doctest with a layer and adding it to
-a test suite is somewhat contrived: the test suite has to be created first,
-and then the layer attribute set on it:
+Therefore, the syntax for creating a doctest with a layer and adding it to a test suite is somewhat contrived: the test suite has to be created first, and then the layer attribute set on it:::
 
     >>> class DoctestLayer(Layer):
     ...     pass
@@ -504,8 +479,7 @@ and then the layer attribute set on it:
     True
 
 
-To make this a little easier - especially when setting up multiple tests -
-a helper function called ``layered`` is provided:
+To make this a little easier - especially when setting up multiple tests - a helper function called ``layered`` is provided:::
 
     >>> from plone.testing import layered
 
@@ -517,7 +491,7 @@ a helper function called ``layered`` is provided:
     ...     ])
     ...     return suite
 
-This does the same as the sample above.
+This does the same as the sample above.::
 
     >>> suite = test_suite()
     >>> tests = list(suite)
@@ -526,8 +500,8 @@ This does the same as the sample above.
     >>> tests[0].layer is DOCTEST_LAYER
     True
 
-In addition, a 'layer' glob is added to each test in the suite. This allows
-the test to access layer resources.
+In addition, a 'layer' glob is added to each test in the suite.
+This allows the test to access layer resources.::
 
     >>> len(list(tests[0]))
     1
diff --git a/src/plone/testing/publisher.rst b/src/plone/testing/publisher.rst
index 5f35948..921ebc9 100644
--- a/src/plone/testing/publisher.rst
+++ b/src/plone/testing/publisher.rst
@@ -1,21 +1,19 @@
 Zope Publisher layers
 ---------------------
 
-The Zope Publisher layers are found in the module ``plone.testing.publisher``:
+The Zope Publisher layers are found in the module ``plone.testing.publisher``::
 
     >>> from plone.testing import publisher
 
-For testing, we need a testrunner
+For testing, we need a testrunner:::
 
     >>> from zope.testrunner import runner
 
 ZCML directives
 ~~~~~~~~~~~~~~~
 
-The ``publisher.PUBLISHER_DIRECTIVES`` layer extends the
-``zca.ZCML_DIRECTIVES`` layer to extend its ZCML configuration context with
-the ``zope.app.publisher`` and ``zope.security`` directives available. It
-also extends ``security.CHECKERS``.
+The ``publisher.PUBLISHER_DIRECTIVES`` layer extends the ``zca.ZCML_DIRECTIVES`` layer to extend its ZCML configuration context with the ``zope.app.publisher`` and ``zope.security`` directives available.
+It also extends ``security.CHECKERS``.::
 
     >>> from plone.testing import zca, security
 
@@ -25,9 +23,8 @@ also extends ``security.CHECKERS``.
     >>> publisher.PUBLISHER_DIRECTIVES.__bases__
     (<Layer 'plone.testing.zca.ZCMLDirectives'>, <Layer 'plone.testing.security.Checkers'>)
 
-Before the test, we cannot use e.g. the ``<permission />`` or
-``<browser:view />`` directives without loading the necessary ``meta.zcml``
-files.
+Before the test, we cannot use e.g.
+the ``<permission />`` or ``<browser:view />`` directives without loading the necessary ``meta.zcml`` files.::
 
     >>> from zope.configuration import xmlconfig
     >>> xmlconfig.string("""\
@@ -48,8 +45,7 @@ files.
     ZopeXMLConfigurationError: File "<string>", line 5.4
         ConfigurationError: ('Unknown directive', u'http://namespaces.zope.org/zope', u'permission')
 
-Layer setup creates a configuration context we can use to load further
-configuration.
+Layer setup creates a configuration context we can use to load further configuration.::
 
     >>> options = runner.get_options([], [])
     >>> setupLayers = {}
@@ -60,8 +56,7 @@ configuration.
     Set up plone.testing.publisher.PublisherDirectives in ... seconds.
 
 
-Let's now simulate a test that uses this configuration context to load the
-same ZCML string.
+Let's now simulate a test that uses this configuration context to load the same ZCML string.::
 
     >>> zca.ZCML_DIRECTIVES.testSetUp()
     >>> security.CHECKERS.testSetUp()
@@ -83,7 +78,7 @@ same ZCML string.
     ... </configure>""", context=context) is context
     True
 
-The permission and view are now registered:
+The permission and view are now registered:::
 
     >>> from zope.component import queryUtility
     >>> from zope.security.interfaces import IPermission
@@ -101,20 +96,19 @@ The permission and view are now registered:
     ...   and x.name==u"plone.testing-test"]
     [<class '....plone.testing-test'>]
 
-We can then simulate test tear-down:
+We can then simulate test tear-down:::
 
     >>> publisher.PUBLISHER_DIRECTIVES.testTearDown()
     >>> security.CHECKERS.testTearDown()
     >>> zca.ZCML_DIRECTIVES.testTearDown()
 
-Note that you'd normally combine this layer with the ``zca.UNIT_TESTING`` or a
-similar layer to automatically tear down the component architecture between
-each test. Here, we need to do it manually.
+Note that you'd normally combine this layer with the ``zca.UNIT_TESTING`` or a similar layer to automatically tear down the component architecture between each test.
+Here, we need to do it manually.::
 
     >>> from zope.component.testing import tearDown
     >>> tearDown()
 
-Layer tear-down does nothing.
+Layer tear-down does nothing.::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.publisher.PublisherDirectives in ... seconds.
diff --git a/src/plone/testing/security.rst b/src/plone/testing/security.rst
index 2cd34ca..3423bd3 100644
--- a/src/plone/testing/security.rst
+++ b/src/plone/testing/security.rst
@@ -1,19 +1,18 @@
 Security
 --------
 
-The Zope Security layers are found in the module ``plone.testing.security``:
+The Zope Security layers are found in the module ``plone.testing.security``:::
 
     >>> from plone.testing import security
 
-For testing, we need a testrunner
+For testing, we need a testrunner:::
 
     >>> from zope.testrunner import runner
 
 Layers
 ~~~~~~
 
-The ``security.CHECKERS`` layer makes sure that ``zope.security`` checkers are
-correctly set up and torn down.
+The ``security.CHECKERS`` layer makes sure that ``zope.security`` checkers are correctly set up and torn down.::
 
     >>> "%s.%s" % (security.CHECKERS.__module__, security.CHECKERS.__name__,)
     'plone.testing.security.Checkers'
@@ -21,7 +20,7 @@ correctly set up and torn down.
     >>> security.CHECKERS.__bases__
     ()
 
-Before the test, our custom checker is not in the registry.
+Before the test, our custom checker is not in the registry.::
 
     >>> class DummyObject(object):
     ...     pass
@@ -36,16 +35,15 @@ Before the test, our custom checker is not in the registry.
     >>> getCheckerForInstancesOf(DummyObject) is None
     True
 
-Layer setup stacks the current checkers.
+Layer setup stacks the current checkers.::
 
     >>> options = runner.get_options([], [])
     >>> setupLayers = {}
     >>> runner.setup_layer(options, security.CHECKERS, setupLayers)
     Set up plone.testing.security.Checkers in ... seconds.
 
-We can now set up a checker. In real life, this may happen during ZCML
-configuration, but here will just call the API directlyMost likely, we'd do
-this in a child layer:
+We can now set up a checker.
+In real life, this may happen during ZCML configuration, but here will just call the API directlyMost likely, we'd do this in a child layer:::
 
     >>> from zope.security.checker import defineChecker
     >>> fauxChecker = FauxChecker()
@@ -54,19 +52,19 @@ this in a child layer:
     >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
     True
 
-Let's now simulate a test that may use the checker.
+Let's now simulate a test that may use the checker.::
 
     >>> security.CHECKERS.testSetUp()
     >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
     True
     >>> security.CHECKERS.testTearDown()
 
-We still have the checker after test tear-down:
+We still have the checker after test tear-down:::
 
     >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
     True
 
-However, when we tear down the layer, the checker is gone:
+However, when we tear down the layer, the checker is gone:::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.security.Checkers in ... seconds.
diff --git a/src/plone/testing/z2.rst b/src/plone/testing/z2.rst
index b861be5..b16280a 100644
--- a/src/plone/testing/z2.rst
+++ b/src/plone/testing/z2.rst
@@ -1,25 +1,23 @@
 Zope 2 layers
 -------------
 
-The Zope 2 layers are found in the module ``plone.testing.z2``:
+The Zope 2 layers are found in the module ``plone.testing.z2``:::
 
     >>> from plone.testing import z2
 
-For testing, we need a testrunner
+For testing, we need a testrunner:::
 
     >>> from zope.testrunner import runner
 
 Startup
 ~~~~~~~
 
-``STARTUP`` is the base layer for all Zope 2 testing. It sets up a Zope 2
-sandbox environment that is suitable for testing. It extends the
-``zca.LAYER_CLEANUP`` layer to maximise the chances of having and leaving a
-pristine environment.
+``STARTUP`` is the base layer for all Zope 2 testing.
+It sets up a Zope 2 sandbox environment that is suitable for testing.
+It extends the ``zca.LAYER_CLEANUP`` layer to maximise the chances of having and leaving a pristine environment.
 
-**Note**: You should probably use at least ``INTEGRATION_TESTING`` for any
-real test, although ``STARTUP`` is a useful base layer if you are setting up
-your own fixture. See the description of ``INTEGRATION_TESTING`` below.
+**Note**: You should probably use at least ``INTEGRATION_TESTING`` for any real test, although ``STARTUP`` is a useful base layer if you are setting up your own fixture.
+See the description of ``INTEGRATION_TESTING`` below.::
 
     >>> "%s.%s" % (z2.STARTUP.__module__, z2.STARTUP.__name__,)
     'plone.testing.z2.Startup'
@@ -27,20 +25,17 @@ your own fixture. See the description of ``INTEGRATION_TESTING`` below.
     >>> z2.STARTUP.__bases__
     (<Layer 'plone.testing.zca.LayerCleanup'>,)
 
-On layer setup, Zope is initialised in a lightweight manner. This involves
-certain patches to global modules that Zope manages, to reduce setup time,
-a database based on ``DemoStorage``, and a minimal set of products that must
-be installed for Zope 2 to work. A minimal set of ZCML is loaded, but packages
-in the ``Products`` namespace are not automatically configured.
+On layer setup, Zope is initialised in a lightweight manner.
+This involves certain patches to global modules that Zope manages, to reduce setup time, a database based on ``DemoStorage``, and a minimal set of products that must be installed for Zope 2 to work.
+A minimal set of ZCML is loaded, but packages in the ``Products`` namespace are not automatically configured.
 
-Let's just verify that we have an empty component registry before the test:
+Let's just verify that we have an empty component registry before the test:::
 
     >>> from zope.component import getSiteManager
     >>> list(getSiteManager().registeredAdapters())
     []
 
-Five sets a special vocabulary registry upon the layer setup, but
-there's a default one set before:
+Five sets a special vocabulary registry upon the layer setup, but there's a default one set before:::
 
     >>> from zope.schema.vocabulary import getVocabularyRegistry
     >>> getVocabularyRegistry()
@@ -52,8 +47,7 @@ there's a default one set before:
     Set up plone.testing.zca.LayerCleanup in ... seconds.
     Set up plone.testing.z2.Startup in ... seconds.
 
-After layer setup, the ``zodbDB`` resource is available, pointing to the
-default ZODB.
+After layer setup, the ``zodbDB`` resource is available, pointing to the default ZODB.::
 
     >>> z2.STARTUP['zodbDB']
     <ZODB.DB.DB object at ...>
@@ -61,10 +55,8 @@ default ZODB.
     >>> z2.STARTUP['zodbDB'].storage
     Startup
 
-In addition, the resources ``host`` and ``port`` are set to the default
-hostname and port that are used for URLs generated from Zope. These are
-hardcoded, but shadowed by layers that provide actual running Zope
-instances.
+In addition, the resources ``host`` and ``port`` are set to the default hostname and port that are used for URLs generated from Zope.
+These are hardcoded, but shadowed by layers that provide actual running Zope instances.::
 
     >>> z2.STARTUP['host']
     'nohost'
@@ -72,24 +64,21 @@ instances.
     80
 
 At this point, it is also possible to get hold of a Zope application root.
-If you are setting up a layer fixture, you can obtain an application root
-with the correct database that is properly closed by using the ``zopeApp()``
-context manager.
+If you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the ``zopeApp()`` context manager.::
 
     >>> with z2.zopeApp() as app:
     ...     print app.objectIds()
     ['acl_users', 'Control_Panel']
 
-If you want to use a specific database, you can pass that to ``zopeApp()`` as
-the ``db`` parameter. A new connection will be opened and closed.
+If you want to use a specific database, you can pass that to ``zopeApp()`` as the ``db`` parameter.
+A new connection will be opened and closed.::
 
     >>> with z2.zopeApp(db=z2.STARTUP['zodbDB']) as app:
     ...     print app.objectIds()
     ['acl_users', 'Control_Panel']
 
-If you want to re-use an existing connection, you can pass one to
-``zopeApp()`` as the ``connection`` argument. In this case, you will need to
-close the connection yourself.
+If you want to re-use an existing connection, you can pass one to ``zopeApp()`` as the ``connection`` argument.
+In this case, you will need to close the connection yourself.::
 
     >>> conn = z2.STARTUP['zodbDB'].open()
     >>> with z2.zopeApp(connection=conn) as app:
@@ -101,9 +90,7 @@ close the connection yourself.
 
     >>> conn.close()
 
-If an exception is raised within the ``with`` block, the transaction is
-aborted, but the connection is still closed (if it was opened by the context
-manager):
+If an exception is raised within the ``with`` block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager):::
 
     >>> with z2.zopeApp() as app:
     ...     raise Exception("Test error")
@@ -111,8 +98,8 @@ manager):
     ...
     Exception: Test error
 
-It is common to combine the ``zopeApp()`` context manager with a stacked
-``DemoStorage`` to set up a layer-specific fixture. As a sketch::
+It is common to combine the ``zopeApp()`` context manager with a stacked ``DemoStorage`` to set up a layer-specific fixture.
+As a sketch:::
 
     from plone.testing import Layer, z2, zodb
 
@@ -137,39 +124,33 @@ It is common to combine the ``zopeApp()`` context manager with a stacked
             self['zodbDB'].close()
             del self['zodbDB']
 
-Note that you would normally *not* use the ``z2.zopeApp()`` in a test or in a
-``testSetUp()`` or ``testTearDown()`` method. The ``IntegrationTesting`` and
-``FunctionalTesting`` layer classes manage the application object for you,
-exposing them as the resource ``app`` (see below).
+Note that you would normally *not* use the ``z2.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.
+The ``IntegrationTesting`` and ``FunctionalTesting`` layer classes manage the application object for you, exposing them as the resource ``app`` (see below).
 
-After layer setup, the global component registry contains a number of
-components needed by Zope.
+After layer setup, the global component registry contains a number of components needed by Zope.::
 
     >>> len(list(getSiteManager().registeredAdapters())) > 1 # in fact, > a lot
     True
 
-And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:
+And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:::
 
     >>> getVocabularyRegistry()
     <....Zope2VocabularyRegistry object at ...>
 
-To load additional ZCML, you can use the ``configurationContext`` resource:
+To load additional ZCML, you can use the ``configurationContext`` resource:::
 
     >>> z2.STARTUP['configurationContext']
     <zope.configuration.config.ConfigurationMachine object ...>
 
-See ``zca.rst`` for details about how to use ``zope.configuration`` for this
-purpose.
+See ``zca.rst`` for details about how to use ``zope.configuration`` for this purpose.
 
 The ``STARTUP`` layer does not perform any specific test setup or tear-down.
-That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING``
-layers, or other layers using their layer classes - ``IntegrationTesting``
-and ``FunctionalTesting``.
+That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING`` layers, or other layers using their layer classes - ``IntegrationTesting`` and ``FunctionalTesting``.::
 
     >>> z2.STARTUP.testSetUp()
     >>> z2.STARTUP.testTearDown()
 
-Layer tear-down resets the environment.
+Layer tear-down resets the environment.::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.z2.Startup in ... seconds.
@@ -192,23 +173,19 @@ Layer tear-down resets the environment.
 Integration test
 ~~~~~~~~~~~~~~~~
 
-``INTEGRATION_TESTING`` is intended for simple Zope 2 integration testing. It
-extends ``STARTUP`` to ensure that a transaction is begun before and rolled
-back after each test. Two resources, ``app`` and ``request``, are available
-during testing as well. It does not manage any layer state - it implements
-the test lifecycle methods only.
+``INTEGRATION_TESTING`` is intended for simple Zope 2 integration testing.
+It extends ``STARTUP`` to ensure that a transaction is begun before and rolled back after each test.
+Two resources, ``app`` and ``request``, are available during testing as well.
+It does not manage any layer state - it implements the test lifecycle methods only.
 
-**Note:** You would normally *not* use ``INTEGRATION_TESTING`` as a base
-layer. Instead, you'd use the ``IntegrationTesting`` class to create your
-own layer with the testing lifecycle semantics of ``INTEGRATION_TESTING``.
+**Note:** You would normally *not* use ``INTEGRATION_TESTING`` as a base layer.
+Instead, you'd use the ``IntegrationTesting`` class to create your own layer with the testing lifecycle semantics of ``INTEGRATION_TESTING``.
 See the ``plone.testing`` ``README`` file for an example.
 
-``app`` is the application root. In a test, you should use this instead of
-the ``zopeApp`` context manager (which remains the weapon of choice for
-setting up persistent fixtures), because the ``app`` resource is part of the
-transaction managed by the layer.
+``app`` is the application root.
+In a test, you should use this instead of the ``zopeApp`` context manager (which remains the weapon of choice for setting up persistent fixtures), because the ``app`` resource is part of the transaction managed by the layer.
 
-``request`` is a test request. It is the same as ``app.REQUEST``.
+``request`` is a test request. It is the same as ``app.REQUEST``.::
 
     >>> "%s.%s" % (z2.INTEGRATION_TESTING.__module__, z2.INTEGRATION_TESTING.__name__,)
     'plone.testing.z2.IntegrationTesting'
@@ -223,41 +200,40 @@ transaction managed by the layer.
     Set up plone.testing.z2.Startup in ... seconds.
     Set up plone.testing.z2.IntegrationTesting in ... seconds.
 
-Let's now simulate a test. On test setup, the ``app`` resource is made
-available. In a test, you should always use this to access the application
-root.
+Let's now simulate a test.
+On test setup, the ``app`` resource is made available.
+In a test, you should always use this to access the application root.::
 
     >>> z2.STARTUP.testSetUp()
     >>> z2.INTEGRATION_TESTING.testSetUp()
 
-The test may now inspect and modify the environment.
+The test may now inspect and modify the environment.::
 
     >>> app = z2.INTEGRATION_TESTING['app'] # would normally be self.layer['app']
     >>> app.manage_addFolder('folder1')
     >>> app.objectIds()
     ['acl_users', 'Control_Panel', 'folder1']
 
-The request is also available:
+The request is also available:::
 
     >>> z2.INTEGRATION_TESTING['request'] # would normally be self.layer['request']
     <HTTPRequest, URL=http://nohost>
 
-We can create a user and simulate logging in as that user, using the
-``z2.login()`` helper:
+We can create a user and simulate logging in as that user, using the ``z2.login()`` helper:::
 
     >>> app._addRole('role1')
     >>> ignore = app['acl_users'].userFolderAddUser('user1', 'secret', ['role1'], [])
     >>> z2.login(app['acl_users'], 'user1')
 
-The first argument to ``z2.login()`` is the user folder that contains the
-relevant user. The second argument is the user's name. There is no need to
-give the password.
+The first argument to ``z2.login()`` is the user folder that contains the relevant user.
+The second argument is the user's name.
+There is no need to give the password.::
 
     >>> from AccessControl import getSecurityManager
     >>> getSecurityManager().getUser()
     <User 'user1'>
 
-You can change the roles of a user using the ``z2.setRoles()`` helper:
+You can change the roles of a user using the ``z2.setRoles()`` helper:::
 
     >>> sorted(getSecurityManager().getUser().getRolesInContext(app))
     ['Authenticated', 'role1']
@@ -266,13 +242,13 @@ You can change the roles of a user using the ``z2.setRoles()`` helper:
     >>> getSecurityManager().getUser().getRolesInContext(app)
     ['Authenticated']
 
-To become the anonymous user again, use ``z2.logout()``:
+To become the anonymous user again, use ``z2.logout()``:::
 
     >>> z2.logout()
     >>> getSecurityManager().getUser()
     <SpecialUser 'Anonymous User'>
 
-On tear-down, the transaction is rolled back:
+On tear-down, the transaction is rolled back:::
 
     >>> z2.INTEGRATION_TESTING.testTearDown()
     >>> z2.STARTUP.testTearDown()
@@ -287,7 +263,7 @@ On tear-down, the transaction is rolled back:
     ...     print app.objectIds()
     ['acl_users', 'Control_Panel']
 
-Let's tear down the layers
+Let's tear down the layers:::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.z2.IntegrationTesting in ... seconds.
@@ -297,21 +273,18 @@ Let's tear down the layers
 Functional testing
 ~~~~~~~~~~~~~~~~~~
 
-The ``FUNCTIONAL_TESTING`` layer is very similar to ``INTEGRATION_TESTING``,
-and exposes the same fixture and resources. However, it has different
-transaction semantics. ``INTEGRATION_TESTING`` creates a single database
-storage, and rolls back the transaction after each test.
-``FUNCTIONAL_TESTING`` creates a whole new database storage (stacked on top of
-the basic fixture) for each test. This allows testing of code that performs an
-explicit commit, which is usually required for end-to-end testing. The
-downside is that the set-up and tear-down of each test takes longer.
+The ``FUNCTIONAL_TESTING`` layer is very similar to ``INTEGRATION_TESTING``, and exposes the same fixture and resources.
+However, it has different transaction semantics.
+``INTEGRATION_TESTING`` creates a single database storage, and rolls back the transaction after each test.
+``FUNCTIONAL_TESTING`` creates a whole new database storage (stacked on top of the basic fixture) for each test.
+This allows testing of code that performs an explicit commit, which is usually required for end-to-end testing.
+The downside is that the set-up and tear-down of each test takes longer.
 
-**Note:** Again, you would normally *not* use ``FUNCTIONAL_TESTING`` as a base
-layer. Instead, you'd use the ``FunctionalTesting`` class to create your own
-layer with the testing lifecycle semantics of ``FUNCTIONAL_TESTING``. See
-the ``plone.testing`` ``README`` file for an example.
+**Note:** Again, you would normally *not* use ``FUNCTIONAL_TESTING`` as a base layer.
+Instead, you'd use the ``FunctionalTesting`` class to create your own layer with the testing lifecycle semantics of ``FUNCTIONAL_TESTING``.
+See the ``plone.testing`` ``README`` file for an example.
 
-Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.
+Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.::
 
     >>> "%s.%s" % (z2.FUNCTIONAL_TESTING.__module__, z2.FUNCTIONAL_TESTING.__name__,)
     'plone.testing.z2.FunctionalTesting'
@@ -326,15 +299,16 @@ Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.
     Set up plone.testing.z2.Startup in ... seconds.
     Set up plone.testing.z2.FunctionalTesting in ... seconds.
 
-Let's now simulate a test. On test setup, the ``app`` resource is made
-available. In a test, you should always use this to access the application
-root. The ``request`` resource can be used to access the test request.
+Let's now simulate a test.
+On test setup, the ``app`` resource is made available.
+In a test, you should always use this to access the application root.
+The ``request`` resource can be used to access the test request.::
 
     >>> z2.STARTUP.testSetUp()
     >>> z2.FUNCTIONAL_TESTING.testSetUp()
 
-The test may now inspect and modify the environment. It may also
-commit things.
+The test may now inspect and modify the environment.
+It may also commit things.::
 
     >>> app = z2.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']
     >>> app.manage_addFolder('folder1')
@@ -344,7 +318,7 @@ commit things.
     >>> import transaction
     >>> transaction.commit()
 
-On tear-down, the database is torn down.
+On tear-down, the database is torn down.::
 
     >>> z2.FUNCTIONAL_TESTING.testTearDown()
     >>> z2.STARTUP.testTearDown()
@@ -359,7 +333,7 @@ On tear-down, the database is torn down.
     ...     print app.objectIds()
     ['acl_users', 'Control_Panel']
 
-Let's tear down the layer:
+Let's tear down the layer:::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.z2.FunctionalTesting in ... seconds.
@@ -369,15 +343,10 @@ Let's tear down the layer:
 The test browser
 ~~~~~~~~~~~~~~~~
 
-The ``FUNCTIONAL_TESTING`` layer and ``FunctionalTesting`` layer class are
-the basis for functional testing using ``zope.testbrowser``. This simulates a
-web browser, allowing an application to be tested "end-to-end" via its
-user-facing interface.
+The ``FUNCTIONAL_TESTING`` layer and ``FunctionalTesting`` layer class are the basis for functional testing using ``zope.testbrowser``.
+This simulates a web browser, allowing an application to be tested "end-to-end" via its user-facing interface.
 
-To use the test browser with a ``FunctionalTesting`` layer (such as the
-default ``FUNCTIONAL_TESTING`` layer instance), we need to use a custom
-browser client, which ensures that the test browser uses the correct ZODB and
-is appropriately isolated from the test code.
+To use the test browser with a ``FunctionalTesting`` layer (such as the default ``FUNCTIONAL_TESTING`` layer instance), we need to use a custom browser client, which ensures that the test browser uses the correct ZODB and is appropriately isolated from the test code.::
 
     >>> options = runner.get_options([], [])
     >>> setupLayers = {}
@@ -386,36 +355,35 @@ is appropriately isolated from the test code.
     Set up plone.testing.z2.Startup in ... seconds.
     Set up plone.testing.z2.FunctionalTesting in ... seconds.
 
-Let's simulate a test:
+Let's simulate a test:::
 
     >>> z2.STARTUP.testSetUp()
     >>> z2.FUNCTIONAL_TESTING.testSetUp()
 
-In the test, we can create a test browser client like so::
+In the test, we can create a test browser client like so:::
 
     >>> app = z2.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']
     >>> browser = z2.Browser(app)
 
-It is usually best to let Zope errors be shown with full tracebacks:
+It is usually best to let Zope errors be shown with full tracebacks:::
 
     >>> browser.handleErrors = False
 
-We can add to the test fixture in the test. For those changes to be visible to
-the test browser, however, we need to commit the transaction.
+We can add to the test fixture in the test.
+For those changes to be visible to the test browser, however, we need to commit the transaction.::
 
     >>> app.manage_addFolder('folder1')
     >>> import transaction; transaction.commit()
 
-We can now view this via the test browser:
+We can now view this via the test browser:::
 
     >>> browser.open(app.absolute_url() + '/folder1')
 
     >>> 'folder1' in browser.contents
     True
 
-The test browser integration converts the URL into a request and
-passes control to Zope's publisher. Let's check that query strings are
-available for input processing:
+The test browser integration converts the URL into a request and passes control to Zope's publisher.
+Let's check that query strings are available for input processing:::
 
     >>> import urllib
     >>> qs = urllib.urlencode({'foo': 'boo, bar & baz'})  # sic: the ampersand.
@@ -425,8 +393,8 @@ available for input processing:
     >>> browser.contents
     'boo, bar & baz'
 
-The test browser also works with iterators. Let's test that with a simple
-file implementation that uses an iterator.
+The test browser also works with iterators.
+Let's test that with a simple file implementation that uses an iterator.::
 
     >>> from plone.testing.tests import DummyFile
     >>> app._setObject('file1', DummyFile('file1'))
@@ -438,10 +406,9 @@ file implementation that uses an iterator.
     >>> 'The test browser also works with iterators' in browser.contents
     True
 
-See the ``zope.testbrowser`` documentation for more information about how to
-use the browser client.
+See the ``zope.testbrowser`` documentation for more information about how to use the browser client.
 
-On tear-down, the database is torn down.
+On tear-down, the database is torn down.::
 
     >>> z2.FUNCTIONAL_TESTING.testTearDown()
     >>> z2.STARTUP.testTearDown()
@@ -456,7 +423,7 @@ On tear-down, the database is torn down.
     ...     print app.objectIds()
     ['acl_users', 'Control_Panel']
 
-Let's tear down the layer:
+Let's tear down the layer:::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.z2.FunctionalTesting in ... seconds.
@@ -466,12 +433,10 @@ Let's tear down the layer:
 HTTP server
 ~~~~~~~~~~~
 
-The ``ZSERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded
-Zope server in a separate thread. This makes it possible to connect to the
-test instance using a web browser or a testing tool like Selenium or Windmill.
+The ``ZSERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded Zope server in a separate thread.
+This makes it possible to connect to the test instance using a web browser or a testing tool like Selenium or Windmill.
 
-The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has
-``ZSERVER_FIXTURE`` as its base.
+The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has ``ZSERVER_FIXTURE`` as its base.::
 
     >>> "%s.%s" % (z2.ZSERVER_FIXTURE.__module__, z2.ZSERVER_FIXTURE.__name__,)
     'plone.testing.z2.ZServer'
@@ -494,8 +459,7 @@ The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has
     Set up plone.testing.z2.ZServer in ... seconds.
     Set up plone.testing.z2.ZServer:Functional in ... seconds.
 
-After layer setup, the resources ``host`` and ``port`` are available, and
-indicate where Zope is running.
+After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::
 
     >>> host = z2.ZSERVER['host']
     >>> host
@@ -506,28 +470,25 @@ indicate where Zope is running.
     >>> port == int(os.environ.get('ZSERVER_PORT', 55001))
     True
 
-Let's now simulate a test. Test setup does nothing beyond what the base layers
-do.
+Let's now simulate a test.
+Test setup does nothing beyond what the base layers do.::
 
     >>> z2.STARTUP.testSetUp()
     >>> z2.FUNCTIONAL_TESTING.testSetUp()
     >>> z2.ZSERVER.testSetUp()
 
-It is common in a test to use the Python API to change the state of the server
-(e.g. create some content or change a setting) and then use the HTTP protocol
-to look at the results. Bear in mind that the server is running in a separate
-thread, with a separate security manager, so calls to ``z2.login()`` and
-``z2.logout()``, for instance, do not affect the server thread.
+It is common in a test to use the Python API to change the state of the server (e.g.
+create some content or change a setting) and then use the HTTP protocol to look at the results.
+Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``z2.login()`` and ``z2.logout()``, for instance, do not affect the server thread.::
 
     >>> app = z2.ZSERVER['app'] # would normally be self.layer['app']
     >>> app.manage_addFolder('folder1')
 
-Note that we need to commit the transaction before it will show up in the
-other thread.
+Note that we need to commit the transaction before it will show up in the other thread.::
 
     >>> import transaction; transaction.commit()
 
-We can now look for this new object through the server.
+We can now look for this new object through the server.::
 
     >>> app_url = app.absolute_url()
     >>> app_url.split(':')[:-1]
@@ -539,7 +500,7 @@ We can now look for this new object through the server.
     <Folder at folder1>
     >>> conn.close()
 
-Test tear-down does nothing beyond what the base layers do.
+Test tear-down does nothing beyond what the base layers do.::
 
     >>> z2.ZSERVER.testTearDown()
     >>> z2.FUNCTIONAL_TESTING.testTearDown()
@@ -555,7 +516,7 @@ Test tear-down does nothing beyond what the base layers do.
     ...     print app.objectIds()
     ['acl_users', 'Control_Panel']
 
-When the server is torn down, the ZServer thread is stopped.
+When the server is torn down, the ZServer thread is stopped.::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.z2.ZServer:Functional in ... seconds.
@@ -571,18 +532,14 @@ When the server is torn down, the ZServer thread is stopped.
 FTP server
 ~~~~~~~~~~
 
-The ``FTP_SERVER`` layer is identical similar to ``ZSERVER``, except that it
-starts an FTP server instead of an HTTP server. The fixture is contained in
-the ``FTP_SERVER_FIXTURE`` layer.
+The ``FTP_SERVER`` layer is identical similar to ``ZSERVER``, except that it starts an FTP server instead of an HTTP server.
+The fixture is contained in the ``FTP_SERVER_FIXTURE`` layer.
 
-    **Warning:** It is generally not safe to run the ``ZSERVER`` and
-    ``FTP_SERVER`` layers concurrently, because they both start up the same
-    ``asyncore`` loop. If you need concurrent HTTP and FTP servers in a test,
-    you can create your own layer by subclassing the ``ZServer`` layer class,
-    and overriding the ``setUpServer()`` and ``tearDownServer()`` hooks to set
-    up and close both servers. See the code for an example.
+    **Warning:** It is generally not safe to run the ``ZSERVER`` and ``FTP_SERVER`` layers concurrently, because they both start up the same ``asyncore`` loop.
+    If you need concurrent HTTP and FTP servers in a test, you can create your own layer by subclassing the ``ZServer`` layer class, and overriding the ``setUpServer()`` and ``tearDownServer()`` hooks to set up and close both servers.
+    See the code for an example.
 
-The ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.
+The ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.::
 
     >>> "%s.%s" % (z2.FTP_SERVER_FIXTURE.__module__, z2.FTP_SERVER_FIXTURE.__name__,)
     'plone.testing.z2.FTPServer'
@@ -590,8 +547,7 @@ The ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.
     >>> z2.FTP_SERVER_FIXTURE.__bases__
     (<Layer 'plone.testing.z2.Startup'>,)
 
-The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the
-``FunctionalTesting`` layer class.
+The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the ``FunctionalTesting`` layer class.::
 
     >>> "%s.%s" % (z2.FTP_SERVER.__module__, z2.FTP_SERVER.__name__,)
     'plone.testing.z2.FTPServer:Functional'
@@ -607,8 +563,7 @@ The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the
     Set up plone.testing.z2.FTPServer in ... seconds.
     Set up plone.testing.z2.FTPServer:Functional in ... seconds.
 
-After layer setup, the resources ``host`` and ``port`` are available, and
-indicate where Zope is running.
+After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::
 
     >>> host = z2.FTP_SERVER['host']
     >>> host
@@ -619,29 +574,27 @@ indicate where Zope is running.
     >>> port == int(os.environ.get('FTPSERVER_PORT', 55002))
     True
 
-Let's now simulate a test. Test setup does nothing beyond what the base layers
-do.
+Let's now simulate a test.
+Test setup does nothing beyond what the base layers do.::
 
     >>> z2.STARTUP.testSetUp()
     >>> z2.FUNCTIONAL_TESTING.testSetUp()
     >>> z2.FTP_SERVER.testSetUp()
 
-As with ``ZSERVER``, we will set up some content for the test and then access
-it over the FTP port.
+As with ``ZSERVER``, we will set up some content for the test and then access it over the FTP port.::
 
     >>> app = z2.FTP_SERVER['app'] # would normally be self.layer['app']
     >>> app.manage_addFolder('folder1')
 
-We'll also create a user in the root user folder to make FTP access easier.
+We'll also create a user in the root user folder to make FTP access easier.::
 
     >>> ignore = app['acl_users'].userFolderAddUser('admin', 'secret', ['Manager'], ())
 
-Note that we need to commit the transaction before it will show up in the
-other thread.
+Note that we need to commit the transaction before it will show up in the other thread.::
 
     >>> import transaction; transaction.commit()
 
-We can now look for this new object through the server.
+We can now look for this new object through the server.::
 
     >>> app_path = app.absolute_url_path()
 
@@ -666,7 +619,7 @@ We can now look for this new object through the server.
     >>> ftpClient.quit()
     '221 Goodbye.'
 
-Test tear-down does nothing beyond what the base layers do.
+Test tear-down does nothing beyond what the base layers do.::
 
     >>> z2.FTP_SERVER.testTearDown()
     >>> z2.FUNCTIONAL_TESTING.testTearDown()
@@ -682,7 +635,7 @@ Test tear-down does nothing beyond what the base layers do.
     ...     print app.objectIds()
     ['acl_users', 'Control_Panel']
 
-When the server is torn down, the FTP thread is stopped.
+When the server is torn down, the FTP thread is stopped.::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.z2.FTPServer:Functional in ... seconds.
diff --git a/src/plone/testing/zca.rst b/src/plone/testing/zca.rst
index 134fc10..5a5e7bb 100644
--- a/src/plone/testing/zca.rst
+++ b/src/plone/testing/zca.rst
@@ -1,22 +1,21 @@
 Zope Component Architecture layers
 ----------------------------------
 
-The ZCA layers are found in the module ``plone.testing.zca``:
+The ZCA layers are found in the module ``plone.testing.zca``:::
 
     >>> from plone.testing import zca
 
-For testing, we need a testrunner
+For testing, we need a testrunner:::
 
     >>> from zope.testrunner import runner
 
 Unit testing
 ~~~~~~~~~~~~
 
-The ``UNIT_TESTING`` layer is used to set up a clean component registry
-between each test. It uses ``zope.testing.cleanup`` to clean up all global
-state.
+The ``UNIT_TESTING`` layer is used to set up a clean component registry between each test.
+It uses ``zope.testing.cleanup`` to clean up all global state.
 
-It has no bases:
+It has no bases:::
 
     >>> "%s.%s" % (zca.UNIT_TESTING.__module__, zca.UNIT_TESTING.__name__,)
     'plone.testing.zca.UnitTesting'
@@ -24,7 +23,7 @@ It has no bases:
     >>> zca.UNIT_TESTING.__bases__
     ()
 
-The component registry is cleaned up between each test.
+The component registry is cleaned up between each test.::
 
     >>> from zope.interface import Interface
     >>> from zope.component import provideUtility
@@ -41,40 +40,40 @@ The component registry is cleaned up between each test.
     >>> queryUtility(Interface, name="test-dummy")
     <Dummy>
 
-Layer setup does nothing.
+Layer setup does nothing.::
 
     >>> options = runner.get_options([], [])
     >>> setupLayers = {}
     >>> runner.setup_layer(options, zca.UNIT_TESTING, setupLayers)
     Set up plone.testing.zca.UnitTesting in ... seconds.
 
-Let's now simulate a test. Before any test setup has happened, our previously
-registered utility is still there.
+Let's now simulate a test.
+Before any test setup has happened, our previously registered utility is still there.::
 
     >>> queryUtility(Interface, name="test-dummy")
     <Dummy>
 
-On test setup, it disappears.
+On test setup, it disappears.::
 
     >>> zca.UNIT_TESTING.testSetUp()
 
     >>> queryUtility(Interface, name="test-dummy") is None
     True
 
-The test would now execute. It may register some components.
+The test would now execute. It may register some components.::
 
     >>> provideUtility(DummyUtility("Dummy2"), provides=Interface, name="test-dummy")
     >>> queryUtility(Interface, name="test-dummy")
     <Dummy2>
 
-On test tear-down, this disappears.
+On test tear-down, this disappears.::
 
     >>> zca.UNIT_TESTING.testTearDown()
 
     >>> queryUtility(Interface, name="test-dummy") is None
     True
 
-Layer tear-down does nothing.
+Layer tear-down does nothing.::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.zca.UnitTesting in ... seconds.
@@ -82,8 +81,7 @@ Layer tear-down does nothing.
 Event testing
 ~~~~~~~~~~~~~
 
-The ``EVENT_TESTING`` layer extends the ``UNIT_TESTING`` layer to add the
-necessary registrations for ``zope.component.eventtesting`` to work.
+The ``EVENT_TESTING`` layer extends the ``UNIT_TESTING`` layer to add the necessary registrations for ``zope.component.eventtesting`` to work.::
 
     >>> "%s.%s" % (zca.EVENT_TESTING.__module__, zca.EVENT_TESTING.__name__,)
     'plone.testing.zca.EventTesting'
@@ -91,8 +89,7 @@ necessary registrations for ``zope.component.eventtesting`` to work.
     >>> zca.EVENT_TESTING.__bases__
     (<Layer 'plone.testing.zca.UnitTesting'>,)
 
-Before the test, the component registry is empty and ``getEvents()`` returns
-nothing, even if an event is fired.
+Before the test, the component registry is empty and ``getEvents()`` returns nothing, even if an event is fired.::
 
     >>> from zope.component.eventtesting import getEvents
 
@@ -106,7 +103,7 @@ nothing, even if an event is fired.
     >>> getEvents()
     []
 
-Layer setup does nothing.
+Layer setup does nothing.::
 
     >>> options = runner.get_options([], [])
     >>> setupLayers = {}
@@ -114,7 +111,7 @@ Layer setup does nothing.
     Set up plone.testing.zca.UnitTesting in ... seconds.
     Set up plone.testing.zca.EventTesting in ... seconds.
 
-Let's now simulate a test. On test setup, the event testing list is emptied.
+Let's now simulate a test. On test setup, the event testing list is emptied.::
 
     >>> zca.UNIT_TESTING.testSetUp()
     >>> zca.EVENT_TESTING.testSetUp()
@@ -122,14 +119,14 @@ Let's now simulate a test. On test setup, the event testing list is emptied.
     >>> getEvents()
     []
 
-The test would now execute. It may fire some events, which would show up in
-the event testing list.
+The test would now execute.
+It may fire some events, which would show up in the event testing list.::
 
     >>> notify(DummyEvent())
     >>> getEvents()
     [<Dummy event>]
 
-On test tear-down, the list is emptied again
+On test tear-down, the list is emptied again:::
 
     >>> zca.EVENT_TESTING.testTearDown()
     >>> zca.UNIT_TESTING.testTearDown()
@@ -137,7 +134,7 @@ On test tear-down, the list is emptied again
     >>> getEvents()
     []
 
-Layer tear-down does nothing.
+Layer tear-down does nothing.::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.zca.EventTesting in ... seconds.
@@ -146,11 +143,10 @@ Layer tear-down does nothing.
 Layer cleanup
 ~~~~~~~~~~~~~
 
-The ``LAYER_CLEANUP`` layer is used to set up a clean component registry
-at the set-up and tear-down of a layer. It uses ``zope.testing.cleanup`` to
-clean up all global state.
+The ``LAYER_CLEANUP`` layer is used to set up a clean component registry at the set-up and tear-down of a layer.
+It uses ``zope.testing.cleanup`` to clean up all global state.
 
-It has no bases:
+It has no bases:::
 
     >>> "%s.%s" % (zca.LAYER_CLEANUP.__module__, zca.LAYER_CLEANUP.__name__,)
     'plone.testing.zca.LayerCleanup'
@@ -158,8 +154,7 @@ It has no bases:
     >>> zca.LAYER_CLEANUP.__bases__
     ()
 
-The component registry is cleaned up on layer set-up and tear-down (but not
-between tests).
+The component registry is cleaned up on layer set-up and tear-down (but not between tests).::
 
     >>> from zope.interface import Interface
     >>> from zope.component import provideUtility
@@ -184,11 +179,11 @@ between tests).
     >>> queryUtility(Interface, name="test-dummy") is None
     True
 
-A sub-layer may register additional components:
+A sub-layer may register additional components:::
 
     >>> provideUtility(DummyUtility("Dummy2"), provides=Interface, name="test-dummy2")
 
-Let's now simulate a test. Test setup and tear-down does nothing.
+Let's now simulate a test. Test setup and tear-down does nothing.::
 
     >>> zca.LAYER_CLEANUP.testSetUp()
 
@@ -204,7 +199,7 @@ Let's now simulate a test. Test setup and tear-down does nothing.
     >>> queryUtility(Interface, name="test-dummy2")
     <Dummy2>
 
-On tear-down, the registry is cleaned again.
+On tear-down, the registry is cleaned again.::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.zca.LayerCleanup in ... seconds.
@@ -217,9 +212,8 @@ On tear-down, the registry is cleaned again.
 Basic ZCML directives
 ~~~~~~~~~~~~~~~~~~~~~
 
-The ``ZCML_DIRECTIVES`` layer creates a ZCML configuration context with the
-basic ``zope.component`` directives available. It extends the
-``LAYER_CLEANUP`` layer.
+The ``ZCML_DIRECTIVES`` layer creates a ZCML configuration context with the basic ``zope.component`` directives available.
+It extends the ``LAYER_CLEANUP`` layer.::
 
     >>> "%s.%s" % (zca.ZCML_DIRECTIVES.__module__, zca.ZCML_DIRECTIVES.__name__,)
     'plone.testing.zca.ZCMLDirectives'
@@ -227,8 +221,7 @@ basic ``zope.component`` directives available. It extends the
     >>> zca.ZCML_DIRECTIVES.__bases__
     (<Layer 'plone.testing.zca.LayerCleanup'>,)
 
-Before the test, we cannot use e.g. a ``<utility />`` directive without
-loading the necessary ``meta.zcml`` files.
+Before the test, we cannot use e.g. a ``<utility />`` directive without loading the necessary ``meta.zcml`` files.::
 
     >>> from zope.configuration import xmlconfig
     >>> xmlconfig.string("""\
@@ -240,8 +233,7 @@ loading the necessary ``meta.zcml`` files.
     ZopeXMLConfigurationError: File "<string>", line 2.4
         ConfigurationError: ('Unknown directive', u'http://namespaces.zope.org/zope', u'utility')
 
-Layer setup creates a configuration context we can use to load further
-configuration.
+Layer setup creates a configuration context we can use to load further configuration.::
 
     >>> options = runner.get_options([], [])
     >>> setupLayers = {}
@@ -249,8 +241,7 @@ configuration.
     Set up plone.testing.zca.LayerCleanup in ... seconds.
     Set up plone.testing.zca.ZCMLDirectives in ... seconds.
 
-Let's now simulate a test that uses this configuration context to load the
-same ZCML string.
+Let's now simulate a test that uses this configuration context to load the same ZCML string.::
 
     >>> zca.ZCML_DIRECTIVES.testSetUp()
 
@@ -261,17 +252,16 @@ same ZCML string.
     ... </configure>""", context=context) is context
     True
 
-The utility is now registered:
+The utility is now registered:::
 
     >>> queryUtility(Interface, name="test-dummy")
     <Dummy utility>
 
     >>> zca.UNIT_TESTING.testTearDown()
 
-Note that normally, we'd combine this with the ``UNIT_TESTING`` layer to tear
-down the component architecture as well.
+Note that normally, we'd combine this with the ``UNIT_TESTING`` layer to tear down the component architecture as well.
 
-Layer tear-down deletes the configuration context.
+Layer tear-down deletes the configuration context.::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.zca.ZCMLDirectives in ... seconds.
@@ -282,28 +272,18 @@ Layer tear-down deletes the configuration context.
 Configuration registry sandboxing
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-For simple unit tests, the full cleanup performed between each test using the
-``UNIT_TESTING`` layer is undoubtedly the safest and most convenient way to
-ensure proper isolation of tests using the global component architecture.
-However, if you are writing a complex layer that sets up a lot of components,
-you may wish to keep some components registered at the layer level, whilst
-still allowing tests and sub-layers to register their own components in
-isolation.
-
-This is a tricky problem, because the default ZCML directives and APIs
-(``provideAdapter()``, ``provideUtility()`` and so on) explicitly work on
-a single global adapter registry object. To get around this, you can use two
-helper methods in the ``zca`` module to push a new global component registry
-before registering components, and pop the registry after. Registries are
-stacked, so the components registered in a "lower" registry are automatically
-available in a "higher" registry.
-
-Let's illustrate this with a layer that stacks two new global registries. The
-first registry is specific to the layer, and is used to house the components
-registered at the layer level. The second registry is set up and torn down for
-each test, allowing tests to register their own components freely.
-
-First, we'll create a simple dummy utility to illustrate registrations.
+For simple unit tests, the full cleanup performed between each test using the ``UNIT_TESTING`` layer is undoubtedly the safest and most convenient way to ensure proper isolation of tests using the global component architecture.
+However, if you are writing a complex layer that sets up a lot of components, you may wish to keep some components registered at the layer level, whilst still allowing tests and sub-layers to register their own components in isolation.
+
+This is a tricky problem, because the default ZCML directives and APIs (``provideAdapter()``, ``provideUtility()`` and so on) explicitly work on a single global adapter registry object.
+To get around this, you can use two helper methods in the ``zca`` module to push a new global component registry before registering components, and pop the registry after.
+Registries are stacked, so the components registered in a "lower" registry are automatically available in a "higher" registry.
+
+Let's illustrate this with a layer that stacks two new global registries.
+The first registry is specific to the layer, and is used to house the components registered at the layer level.
+The second registry is set up and torn down for each test, allowing tests to register their own components freely.
+
+First, we'll create a simple dummy utility to illustrate registrations.::
 
     >>> from zope.interface import Interface, implements
 
@@ -321,11 +301,11 @@ The two key methods are:
 * ``zca.pushGlobalRegistry()``, which creates a new global registry.
 * ``zca.popGlobalRegistry()``, which restores the previous global registry.
 
-  **Warning:** You *must* balance your calls to these methods. If you call
-  ``pushGlobalRegistry()`` in ``setUp()``, call ``popGlobalRegistry()`` in
-  ``tearDown()``. Ditto for ``testSetUp()`` and ``testTearDown()``.
+  **Warning:** You *must* balance your calls to these methods.
+  If you call ``pushGlobalRegistry()`` in ``setUp()``, call ``popGlobalRegistry()`` in ``tearDown()``.
+  Ditto for ``testSetUp()`` and ``testTearDown()``.
 
-Let's now create our layer.
+Let's now create our layer.::
 
     >>> from zope.component import provideUtility
     >>> from plone.testing import Layer
@@ -345,7 +325,7 @@ Let's now create our layer.
 
 Let's now simulate a test using this layer.
 
-To begin with, we have the default registry.
+To begin with, we have the default registry.::
 
     >>> from zope.component import getGlobalSiteManager, getSiteManager
     >>> getSiteManager() is getGlobalSiteManager()
@@ -357,7 +337,7 @@ To begin with, we have the default registry.
     >>> queryUtility(IDummyUtility, name="layer") is None
     True
 
-We'll now simulate layer setup. This will push a new registry onto the stack:
+We'll now simulate layer setup. This will push a new registry onto the stack:::
 
     >>> COMPONENT_SANDBOX.setUp()
 
@@ -370,7 +350,7 @@ We'll now simulate layer setup. This will push a new registry onto the stack:
     >>> queryUtility(IDummyUtility, name="layer")
     <DummyUtility layer>
 
-We'll then simulate a test that registers a global component:
+We'll then simulate a test that registers a global component:::
 
     >>> COMPONENT_SANDBOX.testSetUp()
 
@@ -381,12 +361,12 @@ We'll then simulate a test that registers a global component:
     >>> getGlobalSiteManager() is layerGlobalSiteManager
     False
 
-Our previously registered component is still here.
+Our previously registered component is still here.::
 
     >>> queryUtility(IDummyUtility, name="layer")
     <DummyUtility layer>
 
-We can also register a new one.
+We can also register a new one.::
 
     >>> provideUtility(DummyUtility("test"), name="test")
     >>> queryUtility(IDummyUtility, name="layer")
@@ -394,7 +374,7 @@ We can also register a new one.
     >>> queryUtility(IDummyUtility, name="test")
     <DummyUtility test>
 
-On test tear-down, only the second utility disappears:
+On test tear-down, only the second utility disappears:::
 
     >>> COMPONENT_SANDBOX.testTearDown()
 
@@ -410,7 +390,7 @@ On test tear-down, only the second utility disappears:
     >>> queryUtility(IDummyUtility, name="test") is None
     True
 
-If we tear down the layer too, we're back where we started:
+If we tear down the layer too, we're back where we started:::
 
     >>> COMPONENT_SANDBOX.tearDown()
 
@@ -427,22 +407,21 @@ If we tear down the layer too, we're back where we started:
 ZCML files helper class
 ~~~~~~~~~~~~~~~~~~~~~~~
 
-One of the frequent use cases is a layer that loads a ZCML file and sandbox the
-resulting registry.
+One of the frequent use cases is a layer that loads a ZCML file and sandbox the resulting registry.
 
-The ``ZCMLSandbox`` can be instantiated with a `filename`` and ``package``
-arguments.
+The ``ZCMLSandbox`` can be instantiated with a `filename`` and ``package`` arguments.::
 
     >>> import plone.testing
     >>> ZCML_SANDBOX = zca.ZCMLSandbox(filename="testing_zca.zcml",
     ...     package=plone.testing)
 
-Before layer setup, the utility is not registered.
+Before layer setup, the utility is not registered.::
 
     >>> queryUtility(Interface, name="layer") is None
     True
 
-We'll now simulate layer setup. This pushes a new registry onto the stack:
+We'll now simulate layer setup.
+This pushes a new registry onto the stack:::
 
     >>> ZCML_SANDBOX.setUp()
 
@@ -453,12 +432,10 @@ We'll now simulate layer setup. This pushes a new registry onto the stack:
     >>> queryUtility(Interface, name="layer")
     <Dummy utility>
 
-The ``ZCMLSandbox`` class can also be used as ancestor
-for your own classes when you need to load more than a single ZCML file.
+The ``ZCMLSandbox`` class can also be used as ancestor for your own classes when you need to load more than a single ZCML file.
 
-Your class then needs to override the ``setUpZCMLFiles()`` method. It is in
-charge of calling ``loadZCMLFile()``, once for each ZCML file that the class
-needs to load.
+Your class then needs to override the ``setUpZCMLFiles()`` method.
+It is in charge of calling ``loadZCMLFile()``, once for each ZCML file that the class needs to load.::
 
     >>> class OtherZCML(zca.ZCMLSandbox):
     ...     def setUpZCMLFiles(self):
@@ -467,27 +444,27 @@ needs to load.
     ...             package=plone.testing)
     >>> OTHER_ZCML_SANDBOX = OtherZCML()
 
-Before layer setup, a second utility is not registered.
+Before layer setup, a second utility is not registered.::
 
     >>> queryUtility(Interface, name="more_specific_layer") is None
     True
 
-We'll now simulate the setup of the more specific layer.
+We'll now simulate the setup of the more specific layer.::
 
     >>> OTHER_ZCML_SANDBOX.setUp()
 
-After setUp, the second utility is registered :
+After setUp, the second utility is registered:::
 
     >>> queryUtility(Interface, name="more_specific_layer")
     <Dummy utility>
 
-After layer teardown, the second utility is not registered anymore.
+After layer teardown, the second utility is not registered anymore.::
 
     >>> OTHER_ZCML_SANDBOX.tearDown()
     >>> queryUtility(Interface, name="more_specific_layer") is None
     True
 
-After teardown of the first layer, the first utility is not registered anymore.
+After teardown of the first layer, the first utility is not registered anymore.::
 
     >>> ZCML_SANDBOX.tearDown()
     >>> queryUtility(Interface, name="layer") is None
diff --git a/src/plone/testing/zodb.rst b/src/plone/testing/zodb.rst
index 79ff465..9cc436e 100644
--- a/src/plone/testing/zodb.rst
+++ b/src/plone/testing/zodb.rst
@@ -1,29 +1,28 @@
 Zope Object Database layers
 ---------------------------
 
-The ZODB layers are found in the module ``plone.testing.zodb``:
+The ZODB layers are found in the module ``plone.testing.zodb``:::
 
     >>> from plone.testing import zodb
 
-For testing, we need a testrunner
+For testing, we need a testrunner:::
 
     >>> from zope.testrunner import runner
 
 Empty ZODB layer
 ~~~~~~~~~~~~~~~~
 
-The ``EMPTY_ZODB`` layer is used to set up an empty ZODB using
-``DemoStorage``.
+The ``EMPTY_ZODB`` layer is used to set up an empty ZODB using ``DemoStorage``.
 
-The storage and database are set up as layer fixtures. The database is exposed
-as the resource ``zodbDB``.
+The storage and database are set up as layer fixtures.
+The database is exposed as the resource ``zodbDB``.
 
-A connection is opened for each test and exposed as ``zodbConnection``. The
-ZODB root is also exposed, as ``zodbRoot``. A new transaction is begun for
-each test. On test tear-down, the transaction is aborted, the connection is
-closed, and the two test-specific resources are deleted.
+A connection is opened for each test and exposed as ``zodbConnection``.
+The ZODB root is also exposed, as ``zodbRoot``.
+A new transaction is begun for each test.
+On test tear-down, the transaction is aborted, the connection is closed, and the two test-specific resources are deleted.
 
-The layer has no bases.
+The layer has no bases.::
 
     >>> "%s.%s" % (zodb.EMPTY_ZODB.__module__, zodb.EMPTY_ZODB.__name__,)
     'plone.testing.zodb.EmptyZODB'
@@ -31,7 +30,7 @@ The layer has no bases.
     >>> zodb.EMPTY_ZODB.__bases__
     ()
 
-Layer setup creates the database, but not a connection.
+Layer setup creates the database, but not a connection.::
 
     >>> options = runner.get_options([], [])
     >>> setupLayers = {}
@@ -47,11 +46,11 @@ Layer setup creates the database, but not a connection.
     >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None
     True
 
-Let's now simulate a test.
+Let's now simulate a test.::
 
     >>> zodb.EMPTY_ZODB.testSetUp()
 
-The test would then execute. It may use the ZODB root.
+The test would then execute. It may use the ZODB root.::
 
     >>> zodb.EMPTY_ZODB['zodbConnection']
     <Connection at ...>
@@ -61,7 +60,7 @@ The test would then execute. It may use the ZODB root.
 
     >>> zodb.EMPTY_ZODB['zodbRoot']['foo'] = 'bar'
 
-On test tear-down, the transaction is aborted and the connection is closed.
+On test tear-down, the transaction is aborted and the connection is closed.::
 
     >>> zodb.EMPTY_ZODB.testTearDown()
 
@@ -71,14 +70,14 @@ On test tear-down, the transaction is aborted and the connection is closed.
     >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None
     True
 
-The transaction has been rolled back.
+The transaction has been rolled back.::
 
     >>> conn = zodb.EMPTY_ZODB['zodbDB'].open()
     >>> conn.root()
     {}
     >>> conn.close()
 
-Layer tear-down closes and deletes the database.
+Layer tear-down closes and deletes the database.::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down plone.testing.zodb.EmptyZODB in ... seconds.
@@ -89,12 +88,8 @@ Layer tear-down closes and deletes the database.
 Extending the ZODB layer
 ~~~~~~~~~~~~~~~~~~~~~~~~
 
-When creating a test fixture, it is often desirable to add some initial data
-to the database. If you want to do that once on layer setup, you can create
-your own layer class based on ``EmptyZODB`` and override its
-``createStorage()`` and/or ``createDatabase()`` methods to return a
-pre-populated database.
-
+When creating a test fixture, it is often desirable to add some initial data to the database.
+If you want to do that once on layer setup, you can create your own layer class based on ``EmptyZODB`` and override its ``createStorage()`` and/or ``createDatabase()`` methods to return a pre-populated database.::
 
     >>> import transaction
     >>> from ZODB.DemoStorage import DemoStorage
@@ -118,8 +113,7 @@ pre-populated database.
 
     >>> POPULATED_ZODB = PopulatedZODB()
 
-We'll use this new layer in a similar manner to the test above, showing that
-the data is there for each test, but that other changes are rolled back.
+We'll use this new layer in a similar manner to the test above, showing that the data is there for each test, but that other changes are rolled back.::
 
     >>> options = runner.get_options([], [])
     >>> setupLayers = {}
@@ -135,11 +129,11 @@ the data is there for each test, but that other changes are rolled back.
     >>> POPULATED_ZODB.get('zodbRoot', None) is None
     True
 
-Let's now simulate a test.
+Let's now simulate a test.::
 
     >>> POPULATED_ZODB.testSetUp()
 
-The test would then execute. It may use the ZODB root.
+The test would then execute. It may use the ZODB root.::
 
     >>> POPULATED_ZODB['zodbConnection']
     <Connection at ...>
@@ -149,7 +143,7 @@ The test would then execute. It may use the ZODB root.
 
     >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'
 
-On test tear-down, the transaction is aborted and the connection is closed.
+On test tear-down, the transaction is aborted and the connection is closed.::
 
     >>> POPULATED_ZODB.testTearDown()
 
@@ -159,14 +153,14 @@ On test tear-down, the transaction is aborted and the connection is closed.
     >>> POPULATED_ZODB.get('zodbRoot', None) is None
     True
 
-The transaction has been rolled back.
+The transaction has been rolled back.::
 
     >>> conn = POPULATED_ZODB['zodbDB'].open()
     >>> conn.root()
     {'someData': 'a string'}
     >>> conn.close()
 
-Layer tear-down closes and deletes the database.
+Layer tear-down closes and deletes the database.::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down PopulatedZODB in ... seconds.
@@ -177,13 +171,11 @@ Layer tear-down closes and deletes the database.
 Stacking ``DemoStorage`` storages
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-The example above shows how to create a simple test fixture with a custom
-database. It is sometimes useful to be able to stack these fixtures, so that
-a base layer sets up some data for one set of tests, and a child layer
-extends this, temporarily, with more data.
+The example above shows how to create a simple test fixture with a custom database.
+It is sometimes useful to be able to stack these fixtures, so that a base layer sets up some data for one set of tests, and a child layer extends this, temporarily, with more data.
 
-This can be achieved using layer bases and resource shadowing, combined with
-ZODB's stackable DemoStorage. There is even a helper function available:
+This can be achieved using layer bases and resource shadowing, combined with ZODB's stackable DemoStorage.
+There is even a helper function available:::
 
     >>> from plone.testing import Layer
     >>> from plone.testing import zodb
@@ -210,13 +202,11 @@ ZODB's stackable DemoStorage. There is even a helper function available:
 
     >>> EXPANDED_ZODB = ExpandedZODB()
 
-Notice that we are using plain ``Layer`` as a base class here. We obtain the
-underlying database from our bases using the resource manager, and then
-create a shadow copy using a stacked storage. Stacked storages contain the
-data of the original storage, but save changes in a separate (and, in this
-case, temporary) storage.
+Notice that we are using plain ``Layer`` as a base class here.
+We obtain the underlying database from our bases using the resource manager, and then create a shadow copy using a stacked storage.
+Stacked storages contain the data of the original storage, but save changes in a separate (and, in this case, temporary) storage.
 
-Let's simulate a test run again to show how this would work.
+Let's simulate a test run again to show how this would work.::
 
     >>> options = runner.get_options([], [])
     >>> setupLayers = {}
@@ -233,12 +223,12 @@ Let's simulate a test run again to show how this would work.
     >>> EXPANDED_ZODB.get('zodbRoot', None) is None
     True
 
-Let's now simulate a test.
+Let's now simulate a test.::
 
     >>> POPULATED_ZODB.testSetUp()
     >>> EXPANDED_ZODB.testSetUp()
 
-The test would then execute. It may use the ZODB root.
+The test would then execute. It may use the ZODB root.::
 
     >>> EXPANDED_ZODB['zodbConnection']
     <Connection at ...>
@@ -248,7 +238,7 @@ The test would then execute. It may use the ZODB root.
 
     >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'
 
-On test tear-down, the transaction is aborted and the connection is closed.
+On test tear-down, the transaction is aborted and the connection is closed.::
 
     >>> EXPANDED_ZODB.testTearDown()
     >>> POPULATED_ZODB.testTearDown()
@@ -259,14 +249,14 @@ On test tear-down, the transaction is aborted and the connection is closed.
     >>> EXPANDED_ZODB.get('zodbRoot', None) is None
     True
 
-The transaction has been rolled back.
+The transaction has been rolled back.::
 
     >>> conn = EXPANDED_ZODB['zodbDB'].open()
     >>> conn.root() == dict(someData='a string', additionalData='Some new data')
     True
     >>> conn.close()
 
-We'll now tear down the expanded layer and inspect the database again.
+We'll now tear down the expanded layer and inspect the database again.::
 
     >>> runner.tear_down_unneeded(options, [POPULATED_ZODB], setupLayers)
     Tear down ExpandedZODB in ... seconds.
@@ -277,7 +267,7 @@ We'll now tear down the expanded layer and inspect the database again.
 
     >>> conn.close()
 
-Finally, we'll tear down the rest of the layers.
+Finally, we'll tear down the rest of the layers.::
 
     >>> runner.tear_down_unneeded(options, [], setupLayers)
     Tear down PopulatedZODB in ... seconds.


Repository: plone.testing


Branch: refs/heads/master
Date: 2015-12-11T01:30:05+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/2aa3fbd9ab7a59409186e4baf1cb71f31b0bffca

move src/plone/testing/README.rst to docs.

Files changed:
A docs/index.rst
A docs/overview.rst
M README.rst
M setup.py
M src/plone/testing/tests.py
D src/plone/testing/README.rst

diff --git a/README.rst b/README.rst
index e41f789..bc246dc 100644
--- a/README.rst
+++ b/README.rst
@@ -1 +1,6 @@
-# See src/plone/testing/README.rst
+plone.testing
+=============
+
+Testing infrastructure for Zope and Plone projects.
+
+For more information see docs/index.rst
diff --git a/docs/index.rst b/docs/index.rst
new file mode 100644
index 0000000..3a66a55
--- /dev/null
+++ b/docs/index.rst
@@ -0,0 +1,20 @@
+plone.testing documentation
+===========================
+
+Documentation for the testing infrastructure for Zope and Plone projects.
+
+
+Contents
+--------
+
+.. toctree::
+   :maxdepth: 2
+
+   ../src/plone/testing/overview.rst
+   ../src/plone/testing/layer.rst
+   ../src/plone/testing/publisher.rst
+   ../src/plone/testing/security.rst
+   ../src/plone/testing/z2.rst
+   ../src/plone/testing/zca.rst
+   ../src/plone/testing/zodb.rst
+
diff --git a/docs/overview.rst b/docs/overview.rst
new file mode 100644
index 0000000..5057086
--- /dev/null
+++ b/docs/overview.rst
@@ -0,0 +1,1951 @@
+Introduction
+============
+
+.. contents:: Table of contents
+
+``plone.testing`` provides tools for writing unit and integration tests in a Zope and Plone environment.
+It is not tied to Plone, and it does not depend on Zope 2 (although it has some optional Zope 2-only features).
+
+``plone.testing`` builds on `zope.testing`_, in particular its layers concept.
+This package also aims to promote some "good practice" for writing tests of various types.
+
+.. note::
+
+   If you are working with Plone, there is a complementary package `plone.app.testing`_, which builds on ``plone.testing`` to provide additional layers useful for testing Plone add-ons.
+
+If you are new to automated testing and test driven development, you should spend some time learning about those concepts.
+Some useful references include:
+
+* `The Wikipedia article on unit testing <http://en.wikipedia.org/wiki/Unit_testing>`_
+* `The Dive Into Python chapter on testing <http://diveintopython.net/unit_testing/index.html>`_
+
+Bear in mind that different Python frameworks have slightly different takes on how to approach testing.
+Therefore, you may find examples that are different to those shown below.
+The core concepts should be consistent, however.
+
+Compatibility
+-------------
+
+``plone.testing`` 4.x has only been tested with Python 2.6 and 2.7.
+If you're using the optional Zope 2 layers, you must use Zope version 2.12 or later.
+Look at ``plone.testing`` 3.x for Zope 2.10 support.
+
+Definitions
+-----------
+
+In this documentation, we will use a number of testing-related terms.
+The following definitions apply:
+
+Unit test
+
+    An automated test (i.e. one written in code) that tests a single unit (normally a function) in isolation.
+    A unit test attempts to prove that the given function works as expected and gives the correct output given a particular input.
+    It is common to have a number of unit tests for a single function, testing different inputs, including boundary cases and errors.
+    Unit tests are typically quick to write and run.
+
+Integration test
+
+    An automated test that tests how a number of units interact.
+    In a Zope context, this often pertains to how a particular object or view interacts with the Zope framework, the ZODB persistence engine, and so on.
+    Integration tests usually require some setup and can be slower to run than unit tests.
+    It is common to have fewer integration tests than unit test.
+
+Functional test
+
+    An automated test that tests a feature in an "end-to-end" fashion.
+    In a Zope context, that normally means that it invokes an action in the same way that a user would, i.e. through a web request.
+    Functional tests are normally slower to run than either unit or integration tests, and can be significantly slower to run.
+    It is therefore common to have only a few functional tests for each major feature, relying on unit and integration tests for the bulk of testing.
+
+Black box testing
+
+    Testing which only considers the system's defined inputs and outputs.
+    For example, a functional test is normally a black box test that provides inputs only through the defined interface (e.g. URLs published in a web application), and makes assertions only on end outputs (e.g. the response returned for requests to those URLs).
+
+White box testing
+
+    Testing which examines the internal state of a system to make assertions.
+    Authors of unit and integration tests normally have significant knowledge of the implementation of the code under test, and can examine such things as data in a database or changes to the system's environment to determine if the test succeeded or failed.
+
+Assertion
+
+    A check that determines whether a test succeeds or fails.
+    For example, if a unit test for the function ``foo()`` expects it to return the value 1, an assertion could be written to verify this fact.
+    A test is said to *fail* if any of its assertions fail.
+    A test always contains one or more assertions.
+
+Test case
+
+    A single unit, integration or functional test.
+    Often shortened to just *test*.
+    A test case sets up, executes and makes assertions against a single scenario that bears testing.
+
+Test fixture
+
+    The state used as a baseline for one or more tests.
+    The test fixture is *set up* before each test is executed, and *torn down* afterwards.
+    This is a pre-requisite for *test isolation* - the principle that tests should be independent of one another.
+
+Layer
+
+    The configuration of a test fixture shared by a number of tests.
+    All test cases that belong to a particular layer will be executed together.
+    The layer is *set up* once before the tests are executed, and *torn down* once after.
+    Layers may depend on one another.
+    Any *base layers* are set up before and torn down after a particular *child layer* is used.
+    The test runner will order test execution to minimise layer setup and tear-down.
+
+Test suite
+
+    A collection of test cases (and layers) that are executed together.
+
+Test runner
+
+    The program which executes tests.
+    This is responsible for calling layer and test fixture set-up and tear-down methods.
+    It also reports on the test run, usually by printing output to the console.
+
+Coverage
+
+    To have confidence in your code, you should ensure it is adequately covered by tests.
+    That is, each line of code, and each possible branching point (loops, ``if`` statements) should be executed by a test.
+    This is known as *coverage*, and is normally measured as a percentage of lines of non-test code covered by tests.
+    Coverage can be measured by the test runner, which keeps track of which lines of code were executed in a given test run.
+
+Doctest
+
+    A style of testing where tests are written as examples that could be typed into the interactive Python interpreter.
+    The test runner executes each example and checks the actual output against the expected output.
+    Doctests can either be placed in the docstring of a method, or in a separate file.
+    The use of doctests is largely a personal preference.
+    Some developers like to write documentation as doctests, which has the advantage that code samples can be automatically tested for correctness.
+    You can read more about doctests on `Wikipedia <http://en.wikipedia.org/wiki/Doctest>`_.
+
+Installation and usage
+======================
+
+To use ``plone.testing`` in your own package, you need to add it as a dependency.
+Most people prefer to keep test-only dependencies separate, so that they do not need to be installed in scenarios (such as on a production server) where the tests will not be run.
+This can be achieved using a ``test`` extra.
+
+In ``setup.py``, add or modify the ``extras_require`` option, like so:::
+
+    extras_require = {
+        'test': [
+                'plone.testing',
+            ]
+    },
+
+You can add other test-only dependencies to that list as well, of course.
+
+To run tests, you need a test runner.
+If you are using ``zc.buildout``, you can install a test runner using the `zc.recipe.testrunner`_ recipe.
+For example, you could add the following to your ``buildout.cfg``:::
+
+    [test]
+    recipe = zc.recipe.testrunner
+    eggs =
+        my.package [test]
+    defaults = ['--auto-color', '--auto-progress']
+
+You'll also need to add this part to the ``parts`` list, of course:::
+
+    [buildout]
+    parts =
+        ...
+        test
+
+In this example, have listed a single package to test, called ``my.package``, and asked for it to be installed with the ``[test]`` extra.
+This will install any regular dependencies (listed in the ``install_requires`` option in ``setup.py``), as well as those in the list associated with the ``test`` key in the ``extras_require`` option.
+
+Note that it becomes important to properly list your dependencies here, because the test runner will only be aware of the packages explicitly listed, and their dependencies.
+For example, if your package depends on Zope 2, you need to list ``Zope2`` in the ``install_requires`` list in ``setup.py``;
+ditto for ``Plone``, or indeed any other package you import from.
+
+Once you have re-run buildout, the test runner will be installed as ``bin/test`` (the executable name is taken from the name of the buildout part).
+You can execute it without arguments to run all tests of each egg listed in the ``eggs`` list::
+
+    $ bin/test
+
+If you have listed several eggs, and you want to run the tests for a particular one, you can do::
+
+    $ bin/test -s my.package
+
+If you want to run only a particular test within this package, use the ``-t`` option.
+This can be passed a regular expression matching either a doctest file name or a test method name.::
+
+    $ bin/test -s my.package -t test_spaceship
+
+There are other command line options, which you can find by running::
+
+    $ bin/test --help
+
+Also note the ``defaults`` option in the buildout configuration.
+This can be used to set default command line options.
+Some commonly useful options are shown above.
+
+Coverage reporting
+------------------
+
+When writing tests, it is useful to know how well your tests cover your code.
+You can create coverage reports via the excellent `coverage`_ library.
+In order to use it, we need to install it and a reporting script::
+
+    [buildout]
+    parts =
+        ...
+        test
+        coverage
+        report
+
+    [coverage]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    initialization =
+        include = '--source=${buildout:directory}/src'
+        sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all']
+
+    [report]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    scripts = coverage=report
+    initialization =
+        sys.argv = sys.argv[:] + ['html', '-i']
+
+This will run the ``bin/test`` script with arguments like `--all` to run all layers.
+You can also specify no or some other arguments.
+It will place coverage reporting information in a ``.coverage`` file inside your buildout root.
+Via the ``--source`` argument you specify the directories containing code you want to cover.
+The coverage script would otherwise generate coverage information for all executed code, including other packages and even the standard library.
+
+Running the ``bin/report`` script will generate a human readable HTML representation of the run in the `htmlcov` directory.
+Open the contained `index.html` in a browser to see the result.
+
+If you want to generate an XML representation suitable for the `Cobertura`_ plugin of `Hudson`_, you can add another part::
+
+    [buildout]
+    parts =
+        ...
+        report-xml
+
+    [report-xml]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    scripts = coverage=report-xml
+    initialization =
+        sys.argv = sys.argv[:] + ['xml', '-i']
+
+This will generate a ``coverage.xml`` file in the buildout root.
+
+Optional dependencies
+---------------------
+
+``plone.testing`` comes with a core set of tools for managing layers, which depends only on `zope.testing`_ and (for Python < 2.7) `unittest2`_.
+In addition, there are several layers and helper functions which can be used in your own tests (or as bases for your own layers).
+Some of these have deeper dependencies.
+However, these dependencies are optional and not installed by default.
+If you don't use the relevant layers, you can safely ignore them.
+
+``plone.testing`` does specify these dependencies, however, using the ``setuptools`` "extras" feature.
+You can depend on one or more extras in your own ``setup.py`` ``install_requires`` or ``extras_require`` option using the same square bracket notation shown for the ``[test]`` buildout part above.
+For example, if you need both the ``zca`` and ``publisher`` extras, you can have the following in your ``setup.py``::
+
+    extras_require = {
+        'test': [
+                'plone.testing [zca, publisher]',
+            ]
+    },
+
+The available extras are:
+
+``zodb``
+
+    ZODB testing.
+    Depends on ``ZODB3``.
+    The relevant layers and helpers are in the module ``plone.testing.zodb``.
+
+``zca``
+
+    Zope Component Architecture testing.
+    Depends on core Zope Component Architecture packages such as ``zope.component`` and ``zope.event``.
+    The relevant layers and helpers are in the module ``plone.testing.zca``.
+
+``security``
+
+    Security testing.
+    Depends on ``zope.security``.
+    The relevant layers and helpers are in the module ``plone.testing.security``.
+
+``publisher``
+
+    Zope Publisher testing.
+    Depends on ``zope.app.publisher`` and sets up ZCML directives.
+    The relevant layers and helpers are in the module ``plone.testing.publisher``.
+
+``z2``
+
+    Zope 2 testing.
+    Depends on the ``Zope2`` egg, which includes all the dependencies of the Zope 2 application server.
+    The relevant layers and helpers are in the module ``plone.testing.z2``
+
+Adding a test buildout to your package
+--------------------------------------
+
+When creating re-usable, mostly stand-alone packages, it is often useful to be able to include a buildout with the package sources itself that can be used to create a test runner.
+This is a popular approach for many Zope packages, for example.
+In fact, ``plone.testing`` itself uses this kind of layout.
+
+To have a self-contained buildout in your package, the following is required:
+
+* You need a ``buildout.cfg`` at the root of the package.
+
+* In most cases, you always want a ``bootstrap.py`` file to make it easier for people to set up a fresh buildout.
+
+* Your package sources need to be inside a ``src`` directory.
+  If you're using namespace packages, that means the top level package should be in the ``src`` directory.
+
+* The ``src`` directory must be referenced in ``setup.py``.
+
+For example, ``plone.testing`` has the following layout::
+
+    plone.testing/
+    plone.testing/setup.py
+    plone.testing/bootstrap.py
+    plone.testing/buildout.cfg
+    plone.testing/README.rst
+    plone.testing/src/
+    plone.testing/src/plone
+    plone.testing/src/plone/__init__.py
+    plone.testing/src/plone/testing/
+    plone.testing/src/plone/testing/*
+
+In ``setup.py``, the following arguments are required::
+
+        packages=find_packages('src'),
+        package_dir={'': 'src'},
+
+This tells ``setuptools`` where to find the source code.
+
+The ``buildout.cfg`` for ``plone.testing`` looks like this::
+
+    [buildout]
+    extends =
+        http://download.zope.org/Zope2/index/2.12.12/versions.cfg
+    parts = coverage test report report-xml
+    develop = .
+
+    [test]
+    recipe = collective.xmltestreport
+    eggs =
+        plone.testing [test]
+    defaults = ['--auto-color', '--auto-progress']
+
+    [coverage]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    initialization =
+        include = '--source=${buildout:directory}/src'
+        sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all', '--xml']
+
+    [report]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    scripts = coverage=report
+    initialization =
+        sys.argv = sys.argv[:] + ['html', '-i']
+
+    [report-xml]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    scripts = coverage=report-xml
+    initialization =
+        sys.argv = sys.argv[:] + ['xml', '-i']
+
+Obviously, you should adjust the package name in the ``eggs`` list and the version set in the ``extends`` line as appropriate.
+
+You can of course also add additional buildout parts, for example to include some development/debugging tools, or even a running application server for testing purposes.
+
+    *Hint:* If you use this package layout, you should avoid checking any files or directories generated by buildout into your version control repository.
+    You want to ignore:
+
+    * ``.coverage``
+    * ``.installed.cfg``
+    * ``bin``
+    * ``coverage.xml``
+    * ``develop-eggs``
+    * ``htmlcov``
+    * ``parts``
+    * ``src/*.egg-info``
+
+Layers
+======
+
+In large part, ``plone.testing`` is about layers.
+It provides:
+
+* A set of layers (outlined below), which you can use or extend.
+
+* A set of tools for working with layers
+
+* A mini-framework to make it easy to write layers and manage shared resources associated with layers.
+
+We'll discuss the last two items here, before showing how to write tests that use layers.
+
+Layer basics
+------------
+
+Layers are used to create test fixtures that are shared by multiple test cases.
+For example, if you are writing a set of integration tests, you may need to set up a database and configure various components to access that database.
+This type of test fixture setup can be resource-intensive and time-consuming.
+If it is possible to only perform the setup and tear-down once for a set of tests without losing isolation between those tests, test runs can often be sped up significantly.
+
+Layers also allow re-use of test fixtures and set-up/tear-down code.
+``plone.testing`` provides a number of useful (but optional) layers that manage test fixtures for common Zope testing scenarios, letting you focus on the actual test authoring.
+
+At the most basic, a layer is an object with the following methods and attributes:
+
+``setUp()``
+
+    Called by the test runner when the layer is to be set up.
+    This is called exactly once for each layer used during a test run.
+
+``tearDown()``
+
+    Called by the test runner when the layer is to be torn down.
+    As with ``setUp()``, this is called exactly once for each layer.
+
+``testSetUp()``
+
+    Called immediately before each test case that uses the layer is executed.
+    This is useful for setting up aspects of the fixture that are managed on a per-test basis, as opposed to fixture shared among all tests.
+
+``testTearDown()``
+
+    Called immediately after each test case that uses the layer is executed.
+    This is a chance to perform any post-test cleanup to ensure the fixture is ready for the next test.
+
+``__bases__``
+
+    A tuple of base layers.
+
+Each test case is associated with zero or one layer.
+(The syntax for specifying the layer is shown in the section "Writing tests" below.) All the tests associated with a given layer will be executed together.
+
+Layers can depend on one another (as indicated in the ``__bases__`` tuple), allowing one layer to build on the fixture created by another.
+Base layers are set up before and torn down after their dependants.
+
+For example, if the test runner is executing some tests that belong to layer A, and some other tests that belong to layer B, both of which depend on layer C, the order of execution might be::
+
+    1. C.setUp()
+    1.1. A.setUp()
+
+    1.1.1. C.testSetUp()
+    1.1.2. A.testSetUp()
+    1.1.3. [One test using layer A]
+    1.1.4. A.testTearDown()
+    1.1.5. C.testTearDown()
+
+    1.1.6. C.testSetUp()
+    1.1.7. A.testSetUp()
+    1.1.8. [Another test using layer A]
+    1.1.9. A.testTearDown()
+    1.1.10. C.testTearDown()
+
+    1.2. A.tearDown()
+    1.3. B.setUp()
+
+    1.3.1. C.testSetUp()
+    1.3.2. B.testSetUp()
+    1.3.3. [One test using layer B]
+    1.3.4. B.testTearDown()
+    1.3.5. C.testTearDown()
+
+    1.3.6. C.testSetUp()
+    1.3.7. B.testSetUp()
+    1.3.8. [Another test using layer B]
+    1.3.9. B.testTearDown()
+    1.3.10. C.testTearDown()
+
+    1.4. B.tearDown()
+    2. C.tearDown()
+
+A base layer may of course depend on other base layers.
+In the case of nested dependencies like this, the order of set up and tear-down as calculated by the test runner is similar to the way in which Python searches for the method to invoke in the case of multiple inheritance.
+
+Writing layers
+--------------
+
+The easiest way to create a new layer is to use the ``Layer`` base class and implement the ``setUp()``, ``tearDown()``, ``testSetUp()`` and ``testTearDown()`` methods as needed.
+All four are optional.
+The default implementation of each does nothing.
+
+By convention, layers are created in a module called ``testing.py`` at the top level of your package.
+The idea is that other packages that extend your package can re-use your layers for their own testing.
+
+A simple layer may look like this::
+
+    >>> from plone.testing import Layer
+    >>> class SpaceShip(Layer):
+    ...
+    ...     def setUp(self):
+    ...         print "Assembling space ship"
+    ...
+    ...     def tearDown(self):
+    ...         print "Disasembling space ship"
+    ...
+    ...     def testSetUp(self):
+    ...         print "Fuelling space ship in preparation for test"
+    ...
+    ...     def testTearDown(self):
+    ...         print "Emptying the fuel tank"
+
+Before this layer can be used, it must be instantiated.
+Layers are normally instantiated exactly once, since by nature they are shared between tests.
+This becomes important when you start to manage resources (such as persistent data, database connections, or other shared resources) in layers.
+
+The layer instance is conventionally also found in ``testing.py``, just after the layer class definition.::
+
+    >>> SPACE_SHIP = SpaceShip()
+
+.. note::
+
+    Since the layer is instantiated in module scope, it will be created as soon as the ``testing`` module is imported.
+    It is therefore very important that the layer class is inexpensive and safe to create.
+    In general, you should avoid doing anything non-trivial in the ``__init__()`` method of your layer class.
+    All setup should happen in the ``setUp()`` method.
+    If you *do* implement ``__init__()``, be sure to call the ``super`` version as well.
+
+The layer shown above did not have any base layers (dependencies).
+Here is an example of another layer that depends on it:::
+
+    >>> class ZIGSpaceShip(Layer):
+    ...     defaultBases = (SPACE_SHIP,)
+    ...
+    ...     def setUp(self):
+    ...         print "Installing main canon"
+
+    >>> ZIG = ZIGSpaceShip()
+
+Here, we have explicitly listed the base layers on which ``ZIGSpaceShip`` depends, in the ``defaultBases`` attribute.
+This is used by the ``Layer`` base class to set the layer bases in a way that can also be overridden: see below.
+
+Note that we use the layer *instance* in the ``defaultBases`` tuple, not the class.
+Layer dependencies always pertain to specific layer instances.
+Above, we are really saying that *instances* of ``ZIGSpaceShip`` will, by default, require the ``SPACE_SHIP`` layer to be set up first.
+
+.. note::
+
+    You may find it useful to create other layer base/mix-in classes that extend ``plone.testing.Layer`` and provide helper methods for use in your own layers.
+    This is perfectly acceptable, but please do not confuse a layer base class used in this manner with the concept of a *base layer* as described above:
+
+        * A class deriving from ``plone.testing.Layer`` is known as a *layer class*.
+          It defines the behaviour of the layer by implementing the lifecycle methods ``setUp()``, ``tearDown()``, ``testSetUp()`` and/or ``testTearDown()``.
+
+        * A layer class can be instantiated into an actual layer.
+          When a layer is associated with a test, it is the layer *instance* that is used.
+
+        * The instance is usually a shared, module-global object, although in some cases it is useful to create copies of layers by instantiating the class more than once.
+
+        * Subclassing an existing layer class is just straightforward OOP re-use: the test runner is not aware of the subclassing relationship.
+
+        * A layer *instance* can be associated with any number of layer *bases*, via its ``__bases__`` property (which is usually via the ``defaultBases`` variable in the class body and/or overridden using the ``bases`` argument to the ``Layer`` constructor).
+         These bases are layer *instances*, not classes.
+         The test runner will inspect the ``__bases__`` attribute of each layer instance it sets up to calculate layer pre-requisites and dependencies.
+
+    Also note that the `zope.testing`_ documentation contains examples of layers that are "old-style" classes where the ``setUp()`` and ``tearDown()`` methods are ``classmethod`` methods and class inheritance syntax is used to specify base layers.
+    Whilst this pattern works, we discourage its use, because the classes created using this pattern are not really used as classes.
+    The concept of layer bases is slightly different from class inheritance, and using the ``class`` keyword to create layers with base layers leads to a number of "gotchas" that are best avoided.
+
+Advanced - overriding bases
+---------------------------
+
+In some cases, it may be useful to create a copy of a layer, but change its bases.
+One reason to do this may if you are re-using a layer from another module, and you need to change the order in which layers are set up and torn down.
+
+Normally, of course, you would just re-use the layer instance, either directly in a test, or in the ``defaultBases`` tuple of another layer, but if you need to change the bases, you can pass a new list of bases to the layer instance constructor:::
+
+    >>> class CATSMessage(Layer):
+    ...
+    ...     def setUp(self):
+    ...         print "All your base are belong to us"
+    ...
+    ...     def tearDown(self):
+    ...         print "For great justice"
+
+    >>> CATS_MESSAGE = CATSMessage()
+
+    >>> ZERO_WING = ZIGSpaceShip(bases=(SPACE_SHIP, CATS_MESSAGE,), name="ZIGSpaceShip:CATSMessage")
+
+Please note that when overriding bases like this, the ``name`` argument is required.
+This is because each layer (using in a given test run) must have a unique name.
+The default is to use the layer class name, but this obviously only works for one instantiation.
+Therefore, ``plone.testing`` requires a name when setting ``bases`` explicitly.
+
+Please take great care when changing layer bases like this.
+The layer implementation may make assumptions about the test fixture that was set up by its bases.
+If you change the order in which the bases are listed, or remove a base altogether, the layer may fail to set up correctly.
+
+Also, bear in mind that the new layer instance is independent of the original layer instance, so any resources defined in the layer are likely to be duplicated.
+
+Layer combinations
+------------------
+
+Sometimes, it is useful to be able to combine several layers into one, without adding any new fixture.
+One way to do this is to use the ``Layer`` class directly and instantiate it with new bases:::
+
+    >>> COMBI_LAYER = Layer(bases=(CATS_MESSAGE, SPACE_SHIP,), name="Combi")
+
+Here, we have created a "no-op" layer with two bases: ``CATS_MESSAGE`` and ``SPACE_SHIP``, named ``Combi``.
+
+Please note that when using ``Layer`` directly like this, the ``name`` argument is required.
+This is to allow the test runner to identify the layer correctly.
+Normally, the class name of the layer is used as a basis for the name, but when using the ``Layer`` base class directly, this is unlikely to be unique or descriptive.
+
+Layer resources
+---------------
+
+Many layers will manage one or more resources that are used either by other layers, or by tests themselves.
+Examples may include database connections, thread-local objects, or configuration data.
+
+``plone.testing`` contains a simple resource storage abstraction that makes it easy to access resources from dependant layers or tests.
+The resource storage uses dictionary notation:::
+
+    >>> class WarpDrive(object):
+    ...     """A shared resource"""
+    ...
+    ...     def __init__(self, maxSpeed):
+    ...         self.maxSpeed = maxSpeed
+    ...         self.running = False
+    ...
+    ...     def start(self, speed):
+    ...         if speed > self.maxSpeed:
+    ...             print "We need more power!"
+    ...         else:
+    ...             print "Going to warp at speed", speed
+    ...             self.running = True
+    ...
+    ...     def stop(self):
+    ...         self.running = False
+
+    >>> class ConstitutionClassSpaceShip(Layer):
+    ...     defaultBases = (SPACE_SHIP,)
+    ...
+    ...     def setUp(self):
+    ...         self['warpDrive'] = WarpDrive(8.0)
+    ...
+    ...     def tearDown(self):
+    ...         del self['warpDrive']
+
+    >>> CONSTITUTION_CLASS_SPACE_SHIP = ConstitutionClassSpaceShip()
+
+    >>> class GalaxyClassSpaceShip(Layer):
+    ...     defaultBases = (CONSTITUTION_CLASS_SPACE_SHIP,)
+    ...
+    ...     def setUp(self):
+    ...         # Upgrade the warp drive
+    ...         self.previousMaxSpeed = self['warpDrive'].maxSpeed
+    ...         self['warpDrive'].maxSpeed = 9.5
+    ...
+    ...     def tearDown(self):
+    ...         # Restore warp drive to its previous speed
+    ...         self['warpDrive'].maxSpeed = self.previousMaxSpeed
+
+    >>> GALAXY_CLASS_SPACE_SHIP = GalaxyClassSpaceShip()
+
+As shown, layers (that derive from ``plone.testing.Layer``) support item (dict-like) assignment, access and deletion of arbitrary resources under string keys.
+
+    **Important:** If a layer creates a resource (by assigning an object to a key on ``self`` as shown above) during fixture setup-up, it must also delete the resource on tear-down.
+    Set-up and deletion should be symmetric: if the resource is assigned during ``setUp()`` it should be deleted in ``tearDown()``;
+    if it's created in ``testSetUp()`` it should be deleted in ``testTearDown()``.
+
+A resource defined in a base layer is accessible from and through a child layer.
+If a resource is set on a child using a key that also exists in a base layer, the child version will shadow the base version until the child layer is torn down (presuming it deletes the resource, which it should), but the base layer version remains intact.
+
+.. note::
+
+    Accessing a resource is analogous to accessing an instance variable.
+    For example, if a base layer assigns a resource to a given key in its ``setUp()`` method, a child layer shadows that resource with another object under the same key, the shadowed resource will by used during the ``testSetUp()`` and ``testTearDown()`` lifecycle methods if implemented by the *base* layer as well.
+    This will be the case until the child layer "pops" the resource by deleting it, normally in its ``tearDown()``.
+
+Conversely, if (as shown above) the child layer accesses and modifies the object, it will modify the original.
+
+.. note::
+
+   It is sometimes necessary (or desirable) to modify a shared resource in a child layer, as shown in the example above.  In this case, however, it is very important to restore the original state when the layer is torn down.  Otherwise, other layers or tests using the base layer directly may be affected in difficult-to-debug ways.
+
+If the same key is used in multiple base layers, the rules for choosing which version to use are similar to those that apply when choosing an attribute or method to use in the case of multiple inheritance.
+
+In the example above, we used the resource manager for the ``warpDrive`` object, but we assigned the ``previousMaxSpeed`` variable to ``self``.
+This is because ``previousMaxSpeed`` is internal to the layer and should not be shared with any other layers that happen to use this layer as a base.
+Nor should it be used by any test cases.
+Conversely, ``warpDrive`` is a shared resource that is exposed to other layers and test cases.
+
+The distinction becomes even more important when you consider how a test case may access the shared resource.
+We'll discuss how to write test cases that use layers shortly, but consider the following test:::
+
+    >>> try:
+    ...     import unittest2 as unittest
+    ... except ImportError: # Python 2.7
+    ...     import unittest
+    >>> class TestFasterThanLightTravel(unittest.TestCase):
+    ...     layer = GALAXY_CLASS_SPACE_SHIP
+    ...
+    ...     def test_hyperdrive(self):
+    ...         warpDrive = self.layer['warpDrive']
+    ...         warpDrive.start(8)
+
+This test needs access to the shared resource.
+It knows that its layer defines one called ``warpDrive``.
+It does not know or care that the warp drive was actually initiated by the ``ConstitutionClassSpaceShip`` base layer.
+
+If, however, the base layer had assigned the resource as an instance variable, it would not inherit to child layers (remember: layer bases are not base classes!).
+The syntax to access it would be:::
+
+    self.layer.__bases__[0].warpDrive
+
+which is not only ugly, but brittle: if the list of bases is changed, the expression above may lead to an attribute error.
+
+Writing tests
+=============
+
+Tests are usually written in one of two ways: As methods on a class that derives from ``unittest.TestCase`` (this is sometimes known as "Python tests" or "JUnit-style tests"), or using doctest syntax.
+
+You should realise that although the relevant frameworks (``unittest``, ``unittest2`` and ``doctest``) often talk about unit testing, these tools are also used to write integration and functional tests.
+The distinction between unit, integration and functional tests is largely practical: you use the same techniques to set up a fixture or write assertions for an integration test as you would for a unit test.
+The difference lies in what that fixture contains, and how you invoke the code under test.
+In general, a true unit test will have a minimal or no test fixture, whereas an integration test will have a fixture that contains the components your code is integrating with.
+A functional test will have a fixture that contains enough of the full system to execute and test an "end-to-end" scenario.
+
+Python tests
+------------
+
+Python tests use the Python `unittest`_ module, or its cousin `unittest2`_ (see below).
+They should be placed in a module or package called ``tests`` for the test runner to pick them up.
+
+For small packages, a single module called ``tests.py`` will normally contain all tests.
+For larger packages, it is common to have a ``tests`` package that contains a number of modules with tests.
+These need to start with the word ``test``, e.g.
+``tests/test_foo.py`` or ``tests/test_bar.py``.
+Don't forget the ``__init__.py`` in the ``tests`` package, too!
+
+unittest2
+~~~~~~~~~
+
+In Python 2.7+, the ``unittest`` module has grown several new and useful features.
+To make use of these in Python 2.4, 2.5 and 2.6, an add-on module called `unittest2`_ can be installed.
+``plone.testing`` depends on ``unittest2`` for these versions (and uses it for its own tests), so you will have access to it if you depend on ``plone.testing``.
+
+We will use ``unittest2`` for the examples in this document, but try to import it with an alias of ``unittest``.
+This makes the code forward compatible with Python 2.7, where the built-in ``unittest`` module will have all the features of the ``unittest2`` module.
+
+Please note that the `zope.testing`_ test runner at the time of writing (version 3.9.3) does not (yet) support the new ``setUpClass()``, ``tearDownClass()``, ``setUpModule()`` and ``tearDownModule()`` hooks from ``unittest2``.
+This is not normally a problem, since we tend to use layers to manage complex fixtures, but it is important to be aware of nonetheless.
+
+Test modules, classes and functions
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Python tests are written with classes that derive from the base class ``TestCase``.
+Each test is written as a method that takes no arguments and has a name starting with ``test``.
+Other methods can be added and called from test methods as appropriate, e.g.
+to share some test logic.
+
+Two special methods, ``setUp()`` and ``tearDown()``, can also be added.
+These will be called before or after each test, respectively, and provide a useful place to construct and clean up test fixtures without writing a custom layer.
+They are obviously not as re-usable as layers, though.
+
+   *Hint:* Somewhat confusingly, the ``setUp()`` and ``tearDown()`` methods in a test case class are the equivalent of the ``testSetUp()`` and ``testTearDown()`` methods of a layer class.
+
+A layer can be specified by setting the ``layer`` class attribute to a layer instance.
+If layers are used in conjunction with ``setUp()`` and ``tearDown()`` methods in the test class itself, the class' ``setUp()`` method will be called after the layer's ``testSetUp()`` method, and the class' ``tearDown()`` method will be called before the layer's ``testTearDown()`` method.
+
+The ``TestCase`` base class contains a number of methods which can be used to write assertions.
+They all take the form ``self.assertSomething()``, e.g.
+``self.assertEqual(result, expectedValue)``.
+See the `unittest`_ and/or `unittest2`_ documentation for details.
+
+Putting this together, let's expand on our previous example unit test:::
+
+    >>> try:
+    ...     import unittest2 as unittest
+    ... except ImportError: # Python 2.7
+    ...     import unittest
+
+    >>> class TestFasterThanLightTravel(unittest.TestCase):
+    ...     layer = GALAXY_CLASS_SPACE_SHIP
+    ...
+    ...     def setUp(self):
+    ...         self.warpDrive = self.layer['warpDrive']
+    ...         self.warpDrive.stop()
+    ...
+    ...     def tearDown(self):
+    ...         self.warpDrive.stop()
+    ...
+    ...     def test_warp8(self):
+    ...         self.warpDrive.start(8)
+    ...         self.assertEqual(self.warpDrive.running, True)
+    ...
+    ...     def test_max_speed(self):
+    ...         tooFast = self.warpDrive.maxSpeed + 0.1
+    ...         self.warpDrive.start(tooFast)
+    ...         self.assertEqual(self.warpDrive.running, False)
+
+A few things to note:
+
+* The class derives from ``unittest.TestCase``.
+
+* The ``layer`` class attribute is set to a layer instance (not a layer class!) defined previously.
+  This would typically be imported from a ``testing`` module.
+
+* There are two tests here: ``test_warp8()`` and ``test_max_speed()``.  
+
+* We have used the ``self.assertEqual()`` assertion in both tests to check the result of executing the ``start()`` method on the warp drive.
+
+* We have used the ``setUp()`` method to fetch the ``warpDrive`` resource and ensure that it is stopped before each test is executed.
+  Assigning a variable to ``self`` is a useful way to provide some state to each test method, though be careful about data leaking between tests: in general, you cannot predict the order in which tests will run, and tests should always be independent.
+
+* We have used the ``tearDown()`` method to make sure the warp drive is really stopped after each test.
+
+Test suites
+~~~~~~~~~~~
+
+If you are using version 3.8.0 or later of `zope.testing`_, a class like the one above is all you need: any class deriving from ``TestCase`` in a module with a name starting with ``test`` will be examined for test methods.
+Those tests are then collected into a test suite and executed.
+
+With older versions of `zope.testing`_, you need to add a ``test_suite()`` function in each module that returns the tests in the test suite.
+The `unittest`_ module contains several tools to construct suites, but one of the simplest is to use the default test loader to load all tests in the current module:::
+
+    >>> def test_suite():
+    ...     return unittest.defaultTestLoader.loadTestsFromName(__name__)
+
+If you need to load tests explicitly, you can use the ``TestSuite`` API from the `unittest`_ module.
+For example:::
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         unittest.makeSuite(TestFasterThanLightTravel)
+    ...     ])
+    ...     return suite
+
+The ``makeSuite()`` function creates a test suite from the test methods in the given class (which must derive from ``TestCase``).
+This suite is then appended to an overall suite, which is returned from the ``test_suite()`` method.
+Note that ``addTests()`` takes a list of suites (which are coalesced into a single suite).
+We'll add additional suites later.
+
+See the `unittest`_ documentation for other options.
+
+.. note::
+
+   Adding a ``test_suite()`` method to a module disables automatic test discovery, even when using a recent version of ``zope.testing``.
+
+Doctests
+--------
+
+Doctests can be written in two ways: as the contents of a docstring (usually, but not always, as a means of illustrating and testing the functionality of the method or class where the docstring appears), or as a separate text file.
+In both cases, the standard `doctest`_ module is used.
+See its documentation for details about doctest syntax and conventions.
+
+Doctests are used in two different ways:
+
+* To test documentation.
+  That is, to ensure that code examples contained in documentation are valid and continue to work as the software is updated.
+
+* As a convenient syntax for writing tests.
+
+These two approaches use the same testing APIs and techniques.
+The difference is mostly about mindset.
+However, it is important to avoid falling into the trap that tests can substitute for good documentation or vice-a-versa.
+Tests usually need to systematically go through inputs and outputs and cover off a number of corner cases.
+Documentation should tell a compelling narrative and usually focus on the main usage scenarios.
+Trying to kill these two birds with one stone normally leaves you with an unappealing pile of stones and feathers.
+
+Docstring doctests
+~~~~~~~~~~~~~~~~~~
+
+Doctests can be added to any module, class or function docstring:::
+
+    def canOutrunKlingons(warpDrive):
+        """Find out of the given warp drive can outrun Klingons.
+
+        Klingons travel at warp 8
+
+        >>> drive = WarpDrive(5)
+        >>> canOutrunKlingons(drive)
+        False
+
+        We have to be faster than that to outrun them.
+
+        >>> drive = WarpDrive(8.1)
+        >>> canOutrunKlingons(drive)
+        True
+
+        We can't outrun them if we're travelling exactly the same speed
+
+        >>> drive = WarpDrive(8.0)
+        >>> canOutrunKlingons(drive)
+        False
+
+        """
+        return warpDrive.maxSpeed > 8.0
+
+To add the doctests from a particular module to a test suite, you need to use the ``test_suite()`` function hook:::
+
+    >>> import doctest
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         unittest.makeSuite(TestFasterThanLightTravel), # our previous test
+    ...         doctest.DocTestSuite('spaceship.utils'),
+    ...     ])
+    ...     return suite
+
+Here, we have given the name of the module to check as a string dotted name.
+It is also possible to import a module and pass it as an object.
+The code above passes a list to ``addTests()``, making it easy to add several sets of tests to the suite: the list can be constructed from calls to ``DocTestSuite()``, ``DocFileSuite()`` (shown below) and ``makeSuite()`` (shown above).
+
+    Remember that if you add a ``test_suite()`` function to a module that also has ``TestCase``-derived python tests, those tests will no longer be automatically picked up by ``zope.testing``, so you need to add them to the test suite explicitly.
+
+The example above illustrates a documentation-oriented doctest, where the doctest forms part of the docstring of a public module.
+The same syntax can be used for more systematic unit tests.
+For example, we could have a module ``spaceship.tests.test_spaceship`` with a set of methods like::
+
+    # It's often better to put the import into each method, but here we've
+    # imported the code under test at module level
+    from spaceship.utils import WarpDrive, canOutrunKlingons
+
+    def test_canOutrunKlingons_too_small():
+        """Klingons travel at warp 8.0
+
+        >>> drive = WarpDrive(7.9)
+        >>> canOutrunKlingons(drive)
+        False
+
+        """
+
+    def test_canOutrunKlingons_big():
+        """Klingons travel at warp 8.0
+
+        >>> drive = WarpDrive(8.1)
+        >>> canOutrunKlingons(drive)
+        True
+
+        """
+
+    def test_canOutrunKlingons_must_be_greater():
+        """Klingons travel at warp 8.0
+
+        >>> drive = WarpDrive(8.0)
+        >>> canOutrunKlingons(drive)
+        False
+
+        """
+
+Here, we have created a number of small methods that have no body.
+They merely serve as a container for docstrings with doctests.
+Since the module has no globals, each test must import the code under test, which helps make import errors more explicit.
+
+File doctests
+~~~~~~~~~~~~~
+
+Doctests contained in a file are similar to those contained in docstrings.
+File doctests are better suited to narrative documentation covering the usage of an entire module or package.
+
+For example, if we had a file called ``spaceship.txt`` with doctests, we could add it to the test suite above with:::
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         unittest.makeSuite(TestFasterThanLightTravel),
+    ...         doctest.DocTestSuite('spaceship.utils'),
+    ...         doctest.DocFileSuite('spaceship.txt'),
+    ...     ])
+    ...     return suite
+
+By default, the file is located relative to the module where the test suite is defined.
+You can use ``../`` (even on Windows) to reference the parent directory, which is sometimes useful if the doctest is inside a module in a ``tests`` package.
+
+.. note::
+
+    If you put the doctest ``test_suite()`` method in a module inside a ``tests`` package, that module must have a name starting with ``test``.
+    It is common to have ``tests/test_doctests.py`` that contains a single ``test_suite()`` method that returns a suite of multiple doctests.
+
+It is possible to pass several tests to the suite, e.g.::
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         unittest.makeSuite(TestFasterThanLightTravel),
+    ...         doctest.DocTestSuite('spaceship.utils'),
+    ...         doctest.DocFileSuite('spaceship.txt', 'warpdrive.txt',),
+    ...     ])
+    ...     return suite
+
+The test runner will report each file as a separate test, i.e.
+the ``DocFileSuite()`` above would add two tests to the overall suite.
+Conversely, a ``DocTestSuite()`` using a module with more than one docstring containing doctests will report one test for each eligible docstring.
+
+Doctest fixtures and layers
+~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+A docstring doctest will by default have access to any global symbol available in the module where the docstring is found (e.g.
+anything defined or imported in the module).
+The global namespace can be overridden by passing a ``globs`` keyword argument to the ``DocTestSuite()`` constructor, or augmented by passing an ``extraglobs`` argument.
+Both should be given dictionaries.
+
+A file doctest has an empty globals namespace by default.
+Globals may be provided via the ``globs`` argument to ``DocFileSuite()``.
+
+To manage a simple test fixture for a doctest, you can define set-up and tear-down functions and pass them as the ``setUp`` and ``tearDown`` arguments respectively.
+These are both passed a single argument, a ``DocTest`` object.
+The most useful attribute of this object is ``globs``, which is a mutable dictionary of globals available in the test.
+
+For example:::
+
+    >>> def setUpKlingons(doctest):
+    ...     doctest.globs['oldStyleKlingons'] = True
+
+    >>> def tearDownKlingons(doctest):
+    ...     doctest.globs['oldStyleKlingons'] = False
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         doctest.DocTestSuite('spaceship.utils', setUp=setUpKlingons, tearDown=tearDownKlingons),
+    ...     ])
+    ...     return suite
+
+The same arguments are available on the ``DocFileSuite()`` constructor.
+The set up method is called before each docstring in the given module for a ``DocTestSuite``, and before each file given in a ``DocFileSuite``.
+
+Of course, we often want to use layers with doctests too.
+Unfortunately, the ``unittest`` API is not aware of layers, so you can't just pass a layer to the ``DocTestSuite()`` and ``DocFileSuite()`` constructors.
+Instead, you have to set a ``layer`` attribute on the suite after it has been constructed.
+
+Furthermore, to use layer resources in a doctest, we need access to the layer instance.
+The easiest way to do this is to pass it as a glob, conventionally called 'layer'.
+This makes a global name 'layer' available in the doctest itself, giving access to the test's layer instance.
+
+To make it easier to do this, ``plone.testing`` comes with a helper function called ``layered()``.
+Its first argument is a test suite.
+The second argument is the layer.
+
+For example:::
+
+    >>> from plone.testing import layered
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         layered(doctest.DocTestSuite('spaceship.utils'), layer=CONSTITUTION_CLASS_SPACE_SHIP),
+    ...     ])
+    ...     return suite
+
+This is equivalent to:::
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...
+    ...     spaceshipUtilTests = doctest.DocTestSuite('spaceship.utils', globs={'layer': CONSTITUTION_CLASS_SPACE_SHIP})
+    ...     spaceshipUtilTests.layer = CONSTITUTION_CLASS_SPACE_SHIP
+    ...     suite.addTest(spaceshipUtilTests)
+    ...
+    ...     return suite
+
+(In this example, we've opted to use ``addTest()`` to add a single suite, instead of using ``addTests()`` to add multiple suites in one go).
+
+Zope testing tools
+==================
+
+Everything described so far in this document relies only on the standard `unittest`_/`unittest2`_ and `doctest`_ modules and `zope.testing`_, and you can use this package without any other dependencies.
+
+However, there are also some tools (and layers) available in this package, as well as in other packages, that are specifically useful for testing applications that use various Zope-related frameworks.
+
+Test cleanup
+------------
+
+If a test uses a global registry, it may be necessary to clean that registry on set up and tear down of each test fixture.
+``zope.testing`` provides a mechanism to register cleanup handlers - methods that are called to clean up global state.
+This can then be invoked in the ``setUp()`` and ``tearDown()`` fixture lifecycle methods of a test case.::
+
+    >>> from zope.testing import cleanup
+
+Let's say we had a global registry, implemented as a dictionary:::
+
+    >>> SOME_GLOBAL_REGISTRY = {}
+
+If we wanted to clean this up on each test run, we could call ``clear()`` on the dict.
+Since that's a no-argument method, it is perfect as a cleanup handler.::
+
+    >>> cleanup.addCleanUp(SOME_GLOBAL_REGISTRY.clear)
+
+We can now use the ``cleanUp()`` method to execute all registered cleanups:::
+
+    >>> cleanup.cleanUp()
+
+This call could be placed in a ``setUp()`` and/or ``tearDown()`` method in a test class, for example.
+
+Event testing
+-------------
+
+You may wish to test some code that uses ``zope.event`` to fire specific events.
+`zope.component`_ provides some helpers to capture and analyse events.::
+
+    >>> from zope.component import eventtesting
+
+To use this, you first need to set up event testing.
+Some of the layers shown below will do this for you, but you can do it yourself by calling the ``eventtesting.setUp()`` method, e.g.
+from your own ``setUp()`` method:::
+
+    >>> eventtesting.setUp()
+
+This simply registers a few catch-all event handlers.
+Once you have executed the code that is expected to fire events, you can use the ``getEvents()`` helper function to obtain a list of the event instances caught:::
+
+    >>> events = eventtesting.getEvents()
+
+You can now examine ``events`` to see what events have been caught since the last cleanup.
+
+``getEvents()`` takes two optional arguments that can be used to filter the returned list of events.
+The first (``event_type``) is an interface.
+If given, only events providing this interface are returned.
+The second (``filter``) is a callable taking one argument.
+If given, it will be called with each captured event.
+Only those events where the filter function returns ``True`` will be included.
+
+The ``eventtesting`` module registers a cleanup action as outlined above.
+When you call ``cleanup.cleanUp()`` (or ``eventtesting.clearEvents()``, which is the handler it registers), the events list will be cleared, ready for the next test.
+Here, we'll do it manually:::
+
+    >>> eventtesting.clearEvents()
+
+Mock requests
+-------------
+
+Many tests require a request object, often with particular request/form variables set.
+`zope.publisher`_ contains a useful class for this purpose.::
+
+    >>> from zope.publisher.browser import TestRequest
+
+A simple test request can be constructed with no arguments:::
+
+    >>> request = TestRequest()
+
+To add a body input stream, pass a ``StringIO`` or file as the first parameter.
+To set the environment (request headers), use the ``environ`` keyword argument.
+To simulate a submitted form, use the ``form`` keyword argument:::
+
+    >>> request = TestRequest(form=dict(field1='foo', field2=1))
+
+Note that the ``form`` dict contains marshalled form fields, so modifiers like ``:int`` or ``:boolean`` should not be included in the field names, and values should be converted to the appropriate type.
+
+Registering components
+----------------------
+
+Many test fixtures will depend on having a minimum of Zope Component Architecture (ZCA) components registered.
+In normal operation, these would probably be registered via ZCML, but in a unit test, you should avoid loading the full ZCML configuration of your package (and its dependencies).
+
+Instead, you can use the Python API in `zope.component`_ to register global components instantly.
+The three most commonly used functions are:::
+
+    >>> from zope.component import provideAdapter
+    >>> from zope.component import provideUtility
+    >>> from zope.component import provideHandler
+
+See the `zope.component`_ documentation for details about how to use these.
+
+When registering global components like this, it is important to avoid test leakage.
+The ``cleanup`` mechanism outlined above can be used to tear down the component registry between each test.
+See also the ``plone.testing.zca.UNIT_TESTING`` layer, described below, which performs this cleanup automatically via the ``testSetUp()``/``testTearDown()`` mechanism.
+
+Alternatively, you can "stack" a new global component registry using the ``plone.testing.zca.pushGlobalRegistry()`` and ``plone.testing.zca.popGlobalRegistry()`` helpers.
+This makes it possible to set up and tear down components that are specific to a given layer, and even allow tests to safely call the global component API (or load ZCML - see below) with proper tear-down.
+See the layer reference below for details.
+
+Loading ZCML
+------------
+
+Integration tests often need to load ZCML configuration.
+This can be achieved using the ``zope.configuration`` API.::
+
+    >>> from zope.configuration import xmlconfig
+
+The ``xmlconfig`` module contains two methods for loading ZCML.
+
+``xmlconfig.string()`` can be used to load a literal string of ZCML:::
+
+    >>> xmlconfig.string("""\
+    ... <configure xmlns="http://namespaces.zope.org/zope" package="plone.testing">
+    ...     <include package="zope.component" file="meta.zcml" />
+    ... </configure>
+    ... """)
+    <zope.configuration.config.ConfigurationMachine object at ...>
+
+Note that we need to set a package (used for relative imports and file locations) explicitly here, using the ``package`` attribute of the ``<configure />`` element.
+
+Also note that unless the optional second argument (``context``) is passed, a new configuration machine will be created every time ``string()`` is called.
+It therefore becomes necessary to explicitly ``<include />`` the files that contain the directives you want to use (the one in ``zope.component`` is a common example).
+Layers that set up ZCML configuration may expose a resource which can be passed as the ``context`` parameter, usually called ``configurationContext`` - see below.
+
+To load the configuration for a particular package, use ``xmlconfig.file()``:::
+
+    >>> import zope.component
+    >>> context = xmlconfig.file('meta.zcml', zope.component)
+    >>> xmlconfig.file('configure.zcml', zope.component, context=context)
+    <zope.configuration.config.ConfigurationMachine object at ...>
+
+This takes two required arguments: the file name and the module relative to which it is to be found.
+Here, we have loaded two files: ``meta.zcml`` and ``configure.zcml``.
+The first call to ``xmlconfig.file()`` creates and returns a configuration context.
+We re-use that for the subsequent invocation, so that the directives configured are available.
+
+Installing a Zope 2 product
+---------------------------
+
+Some packages (including all those in the ``Products.*`` namespace) have the special status of being Zope 2 "products".
+These are recorded in a special registry, and may have an ``initialize()`` hook in their top-level ``__init__.py`` that needs to be called for the package to be fully configured.
+
+Zope 2 will find and execute any products during startup.
+For testing, we need to explicitly list the products to install.
+Provided you are using ``plone.testing`` with Zope 2, you can use the following:::
+
+    from plone.testing import z2
+
+    with z2.zopeApp() as app:
+        z2.installProduct(app, 'Products.ZCatalog')
+
+This would normally be used during layer ``setUp()``.
+Note that the basic Zope 2 application context must have been set up before doing this.
+The usual way to ensure this, is to use a layer that is based on ``z2.STARTUP`` - see below.
+
+To tear down such a layer, you should do:::
+
+    from plone.testing import z2
+
+    with z2.zopeApp() as app:
+        z2.uninstallProduct(app, 'Products.ZCatalog')
+
+Note:
+
+* Unlike the similarly-named function from ``ZopeTestCase``, these helpers will work with any type of product.
+  There is no distinction between a "product" and a "package" (and no ``installPackage()``).
+  However, you must use the full name (``Products.*``) when registering a product.
+
+* Installing a product in this manner is independent of ZCML configuration.
+  However, it is almost always necessary to install the package's ZCML configuration first.
+
+Functional testing
+------------------
+
+For functional tests that aim to simulate the browser, you can use `zope.testbrowser`_ in a Python test or doctest:::
+
+    >>> from zope.testbrowser.browser import Browser
+    >>> browser = Browser()
+
+This provides a simple API to simulate browser input, without actually running a web server thread or scripting a live browser (as tools such as Windmill and Selenium do).
+The downside is that it is not possible to test JavaScript- dependent behaviour.
+
+If you are testing a Zope 2 application, you need to change the import location slightly, and pass the application root to the method:::
+
+    from plone.testing.z2 import Browser
+    browser = Browser(app)
+
+You can get the application root from the ``app`` resource in any of the Zope 2 layers in this package.
+
+Beyond that, the `zope.testbrowser`_ documentation should cover how to use the test browser.
+
+    **Hint:** The test browser will usually commit at the end of a request.
+    To avoid test fixture contamination, you should use a layer that fully isolates each test, such as the ``z2.INTEGRATION_TESTING`` layer described below.
+
+Layer reference
+===============
+
+``plone.testing`` comes with several layers that are available to use directly or extend.
+These are outlined below.
+
+Zope Component Architecture
+---------------------------
+
+The Zope Component Architecture layers are found in the module ``plone.testing.zca``.
+If you depend on this, you can use the ``[zca]`` extra when depending on ``plone.testing``.
+
+Unit testing
+~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.zca.UNIT_TESTING``               |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zca.UnitTesting``                |
++------------+--------------------------------------------------+
+| Bases:     | None                                             |
++------------+--------------------------------------------------+
+| Resources: | None                                             |
++------------+--------------------------------------------------+
+
+This layer does not set up a fixture per se, but cleans up global state before and after each test, using ``zope.testing.cleanup`` as described above.
+
+The net result is that each test has a clean global component registry.
+Thus, it is safe to use the `zope.component`_ Python API (``provideAdapter()``, ``provideUtility()``, ``provideHandler()`` and so on) to register components.
+
+Be careful with using this layer in combination with other layers.
+Because it tears down the component registry between each test, it will clobber any layer that sets up more permanent test fixture in the component registry.
+
+Event testing
+~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.zca.EVENT_TESTING``              |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zca.EventTesting``               |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.zca.UNIT_TESTING``               |
++------------+--------------------------------------------------+
+| Resources: | None                                             |
++------------+--------------------------------------------------+
+
+This layer extends the ``zca.UNIT_TESTING`` layer to enable the ``eventtesting`` support from ``zope.component``.
+Using this layer, you can import and use ``zope.component.eventtesting.getEvent`` to inspect events fired by the code under test.
+
+See above for details.
+
+Layer cleanup
+~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.zca.LAYER_CLEANUP``              |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zca.LayerCleanup``               |
++------------+--------------------------------------------------+
+| Bases:     | None                                             |
++------------+--------------------------------------------------+
+| Resources: | None                                             |
++------------+--------------------------------------------------+
+
+This layer calls the cleanup functions from ``zope.testing.cleanup`` on setup and tear-down (but not between each test).
+It is useful as a base layer for other layers that need an environment as pristine as possible.
+
+Basic ZCML directives
+~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.zca.ZCML_DIRECTIVES``            |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zca.ZCMLDirectives``             |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |
++------------+--------------------------------------------------+
+| Resources: | ``configurationContext``                         |
++------------+--------------------------------------------------+
+
+This registers a minimal set of ZCML directives, principally those found in the ``zope.component`` package, and makes available a configuration context.
+This allows custom ZCML to be loaded as described above.
+
+The ``configurationContext`` resource should be used when loading custom ZCML.
+To ensure isolation, you should stack this using the ``stackConfigurationContext()`` helper.
+For example, if you were writing a ``setUp()`` method in a layer that had ``zca.ZCML_DIRECTIVES`` as a base, you could do:::
+
+    self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
+    xmlconfig.string(someZCMLString, context=context)
+
+This will create a new configuration context with the state of the base layer's context.
+On tear-down, you should delete the layer-specific resource:::
+
+    del self['configurationContext']
+
+.. note::
+
+   If you fail to do this, you may get problems if your layer is torn down and then needs to be set up again later.
+
+See above for more details about loading custom ZCML in a layer or test.
+
+ZCML files helper class
+~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zca.ZCMLSandbox``                |
++------------+--------------------------------------------------+
+| Resources: | ``configurationContext``                         |
++------------+--------------------------------------------------+
+
+The ``ZCMLSandbox`` can be instantiated with a ``filename`` and ``package`` arguments::
+
+    ZCML_SANDBOX = zca.ZCMLSandbox(filename="configure.zcml",
+        package=my.package)
+
+
+That layer ``setUp`` loads the ZCML file.
+It avoids the need to using (and understand) ``configurationContext`` and ``globalRegistry`` until you need more flexibility or modularity for your layer and tests.
+
+See above for more details about loading custom ZCML in a layer or test.  
+
+Helper functions
+~~~~~~~~~~~~~~~~
+
+The following helper functions are available in the ``plone.testing.zca`` module.
+
+``stackConfigurationContext(context=None)``
+
+    Create and return a copy of the passed-in ZCML configuration context, or a brand new context if it is ``None``.
+
+    The purpose of this is to ensure that if a layer loads some ZCML files (using the ``zope.configuration`` API during) during its ``setUp()``, the state of the configuration registry (which includes registered directives as well as a list of already imported files, which will not be loaded again even if explicitly included) can be torn down during ``tearDown()``.
+
+    The usual pattern is to keep the configuration context in a layer resource called ``configurationContext``.
+    In ``setUp()``, you would then use::
+
+        self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
+
+        # use 'context' to load some ZCML
+
+    In ``tearDown()``, you can then simply do::
+
+        del self['configurationContext']
+
+``pushGlobalRegistry(new=None)``
+
+    Create or obtain a stack of global component registries, and push a new registry to the top of the stack.
+    The net result is that ``zope.component.getGlobalSiteManager()`` and (an un-hooked) ``getSiteManager()`` will return the new registry instead of the default, module-scope one.
+    From this point onwards, calls to ``provideAdapter()``, ``provideUtility()`` and other functions that modify the global registry will use the new registry.
+
+    If ``new`` is not given, a new registry is created that has the previous global registry (site manager) as its sole base.
+    This has the effect that registrations in the previous default global registry are still available, but new registrations are confined to the new registry.
+
+    **Warning**: If you call this function, you *must* reciprocally call ``popGlobalRegistry()``.
+    That is, if you "push" a registry during layer ``setUp()``, you must "pop" it during ``tearDown()``.
+    If you "push" during ``testSetUp()``, you must "pop" during ``testTearDown()``.
+    If the calls to push and pop are not balanced, you will leave your global registry in a mess, which is not pretty.
+
+    Returns the new default global site manager.
+    Also causes the site manager hook from ``zope.site`` to be reset, clearing any local site managers as appropriate.
+
+``popGlobalRegistry()``
+
+    Pop the global site registry, restoring the previous registry to be the default.
+
+    Please heed the warning above: push and pop must be balanced.
+
+    Returns the new default global site manager.
+    Also causes the site manager hook from ``zope.site`` to be reset, clearing any local site managers as appropriate.
+
+Zope Security
+-------------
+
+The Zope Security layers build can be found in the module ``plone.testing.security``.
+
+If you depend on this, you can use the ``[security]`` extra when depending on ``plone.testing``.
+
+Security checker isolation
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.security.CHECKERS``              |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.security.Checkers``              |
++------------+--------------------------------------------------+
+| Bases:     | None                                             |
++------------+--------------------------------------------------+
+| Resources: | None                                             |
++------------+--------------------------------------------------+
+
+This layer ensures that security checkers used by ``zope.security`` are isolated.
+Any checkers set up in a child layer will be removed cleanly during tear-down.
+
+Helper functions
+~~~~~~~~~~~~~~~~
+
+The security checker isolation outlined above is managed using two helper functions found in the module ``plone.testing.security``:
+
+``pushCheckers()``
+
+    Copy the current set of security checkers for later tear-down.
+
+``popCheckers()``
+
+    Restore the set of security checkers to the state of the most recent call to ``pushCheckers()``.
+
+You *must* keep calls to ``pushCheckers()`` and ``popCheckers()`` in balance.
+That usually means that if you call the former during layer setup, you should call the latter during layer tear-down.
+Ditto for calls during test setup/tear-down or within tests themselves.
+
+Zope Publisher
+--------------
+
+The Zope Publisher layers build on the Zope Component Architecture layers.
+They can be found in the module ``plone.testing.publisher``.
+
+If you depend on this, you can use the ``[publisher]`` extra when depending on ``plone.testing``.
+
+Publisher directives
+~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.publisher.PUBLISHER_DIRECTIVES`` |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.publisher.PublisherDirectives``  |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.zca.ZCML_DIRECTIVES``            |
++------------+--------------------------------------------------+
+| Resources: | None                                             |
++------------+--------------------------------------------------+
+
+This layer extends the ``zca.ZCML_DIRECTIVES`` layer to install additional ZCML directives in the ``browser`` namespace (from ``zope.app.publisher.browser``) as well as those from ``zope.security``.
+This allows browser views, browser pages and other UI components to be registered, as well as the definition of new permissions.
+
+As with ``zca.ZCML_DIRECTIVES``, you should use the ``configurationContext`` resource when loading ZCML strings or files, and the ``stackConfigurationRegistry()`` helper to create a layer-specific version of this resource resource.
+See above.
+
+ZODB
+----
+
+The ZODB layers set up a test fixture with a persistent ZODB.
+The ZODB instance uses ``DemoStorage``, so it will not interfere with any "live" data.
+
+ZODB layers can be found in the module ``plone.testing.zodb``.
+If you depend on this, you can use the ``[zodb]`` extra when depending on ``plone.testing``.
+
+Empty ZODB sandbox
+~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.zodb.EMPTY_ZODB``                |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zodb.EmptyZODB``                 |
++------------+--------------------------------------------------+
+| Bases:     |  None                                            |
++------------+--------------------------------------------------+
+| Resources: | ``zodbRoot``                                     |
+|            +--------------------------------------------------+
+|            | ``zodbDB`` (test set-up only)                    |
+|            +--------------------------------------------------+
+|            | ``zodbConnection`` (test set-up only)            |
++------------+--------------------------------------------------+
+
+This layer sets up a simple ZODB sandbox using ``DemoStorage``.
+The ZODB root object is a simple persistent mapping, available as the resource ``zodbRoot``.
+The ZODB database object is available as the resource ``zodbDB``.
+The connection used in the test is available as ``zodbConnection``.
+
+Note that the ``zodbConnection`` and ``zodbRoot`` resources are created and destroyed for each test.
+You can use ``zodbDB`` (and the ``open()`` method) if you are writing a layer based on this one and need to set up a fixture during layer set up.
+Don't forget to close the connection before concluding the test setup!
+
+A new transaction is begun for each test, and rolled back (aborted) on test tear-down.
+This means that so long as you don't use ``transaction.commit()`` explicitly in your code, it should be safe to add or modify items in the ZODB root.
+
+If you want to create a test fixture with persistent data in your own layer based on ``EMPTY_ZODB``, you can use the following pattern::
+
+    from plone.layer import Layer
+    from plone.layer import zodb
+
+    class MyLayer(Layer):
+        defaultBases = (zodb.EMPTY_ZODB,)
+
+        def setUp(self):
+
+            import transaction
+            self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
+
+            conn = db.open()
+            root = conn.root()
+
+            # modify the root object here
+
+            transaction.commit()
+            conn.close()
+
+        def tearDown(self):
+
+            self['zodbDB'].close()
+            del self['zodbDB']
+
+This shadows the ``zodbDB`` resource with a new database that uses a new ``DemoStorage`` stacked on top of the underlying database storage.
+The fixture is added to this storage and committed during layer setup.
+(The base layer test set-up/tear-down will still begin and abort a new transaction for each *test*).
+On layer tear-down, the database is closed and the resource popped, leaving the original ``zodbDB`` database with the original, pristine storage.
+
+Helper functions
+~~~~~~~~~~~~~~~~
+
+One helper function is available in the ``plone.testing.zodb`` module.
+
+``stackDemoStorage(db=None, name=None)``
+
+    Create a new ``DemoStorage`` using the storage from the passed-in database as a base.
+    If ``db`` is None, a brand new storage is created.
+
+    A ``name`` can be given to uniquely identify the storage.
+    It is optional, but it is often useful for debugging purposes to pass the name of the layer.
+
+    The usual pattern is::
+
+        def setUp(self):
+            self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
+
+        def tearDown(self):
+            self['zodbDB'].close()
+            del self['zodbDB']
+
+    This will shadow the ``zodbDB`` resource with an isolated ``DemoStorage``, creating a new one if that resource does not already exist.
+    All existing data continues to be available, but new changes are written to the stacked storage.
+    On tear-down, the stacked database is closed and the resource removed, leaving the original data.
+
+Zope 2
+------
+
+The Zope 2 layers provide test fixtures suitable for testing Zope 2 applications.
+They set up a Zope 2 application root, install core Zope 2 products, and manage security.
+
+Zope 2 layers can be found in the module ``plone.testing.z2``.
+If you depend on this, you can use the ``[z2]`` extra when depending on ``plone.testing``.
+
+Startup
+~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.STARTUP``                     |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.Startup``                     |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |
++------------+--------------------------------------------------+
+| Resources: | ``zodbDB``                                       |
+|            +--------------------------------------------------+
+|            | ``configurationContext``                         |
+|            +--------------------------------------------------+
+|            | ``host``                                         |
+|            +--------------------------------------------------+
+|            | ``port``                                         |
++------------+--------------------------------------------------+
+
+This layer sets up a Zope 2 environment, and is a required base for all other Zope 2 layers.
+You cannot run two instances of this layer in parallel, since Zope 2 depends on some module-global state to run, which is managed by this layer.
+
+On set-up, the layer will configure a Zope environment with:
+
+.. note::
+
+    The ``STARTUP`` layer is a useful base layer for your own fixtures, but should not be used directly, since it provides no test lifecycle or transaction management.
+    See the "Integration test" and "Functional" test sections below for examples of how to create your own layers.
+
+* Debug mode enabled.
+
+* ZEO client cache disabled.
+
+* Some patches installed, which speed up Zope startup by disabling the help system and some other superfluous aspects of Zope.
+
+* One thread (this only really affects the ``ZSERVER`` and ``FTP_SERVER`` layers).
+
+* A pristine database using ``DemoStorage``, exposed as the resource ``zodbDB``.
+  Zope is configured to use this database in a way that will also work if the ``zodbDB`` resource is shadowed using the pattern shown above in the description of the ``zodb.EMPTY_ZODB`` layer.
+
+* A fake hostname and port, exposed as the ``host`` and ``port`` resource, respectively.
+
+* A minimal set of products installed (``Products.OFSP`` and ``Products.PluginIndexes``, both required for Zope to start up).
+
+* A stacked ZCML configuration context, exposed as the resource ``configurationContext``.
+  As illustrated above, you should use the ``zca.stackConfigurationContext()`` helper to stack your own configuration context if you use this.
+
+* A minimal set of global Zope components configured.
+
+Note that unlike a "real" Zope site, products in the ``Products.*`` namespace are not automatically loaded, nor is any ZCML.
+
+Integration test
+~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.INTEGRATION_TESTING``         |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.IntegrationTesting``          |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.STARTUP``                     |
++------------+--------------------------------------------------+
+| Resources: | ``app``                                          |
+|            +--------------------------------------------------+
+|            | ``request``                                      |
++------------+--------------------------------------------------+
+
+This layer is intended for integration testing against the simple ``STARTUP`` fixture.
+If you want to create your own layer with a more advanced, shared fixture, see "Integration and functional testing with custom fixtures" below.
+
+For each test, it exposes the Zope application root as the resource ``app``.
+This is wrapped in the request container, so you can do ``app.REQUEST`` to acquire a fake request, but the request is also available as the resource ``request``.
+
+A new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.
+
+    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``z2.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.
+
+    Once you've shadowed the ``zodbDB`` resource, you can do (e.g. in your layer's ``setUp()`` method)::
+
+        ...
+        with z2.zopeApp() as app:
+            # modify the Zope application root
+
+    The ``zopeApp()`` context manager will open a new connection to the Zope application root, accessible here as ``app``.
+    Provided the code within the ``with`` block does not raise an exception, the transaction will be committed and the database closed properly upon exiting the block.
+
+Functional testing
+~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.FUNCTIONAL_TESTING``          |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.FunctionalTesting``           |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.STARTUP``                     |
++------------+--------------------------------------------------+
+| Resources: | ``app``                                          |
+|            +--------------------------------------------------+
+|            | ``request``                                      |
++------------+--------------------------------------------------+
+
+This layer is intended for functional testing against the simple ``STARTUP`` fixture.
+If you want to create your own layer with a more advanced, shared fixture, see "Integration and functional testing with custom fixtures" below.
+
+As its name implies, this layer is intended mainly for functional end-to-end testing using tools like `zope.testbrowser`_.
+See also the ``Browser`` object as described under "Helper functions" below.
+
+This layer is very similar to ``INTEGRATION_TESTING``, but is not based on it.
+It sets up the same fixture and exposes the same resources.
+However, instead of using a simple transaction abort to isolate the ZODB between tests, it uses a stacked ``DemoStorage`` for each test.
+This is slower, but allows test code to perform and explicit commit, as will usually happen in a functional test.
+
+Integration and functional testing with custom fixtures
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+If you want to extend the ``STARTUP`` fixture for use with integration or functional testing, you should use the following pattern:
+
+* Create a layer class and a "fixture" base layer instance that has ``z2.STARTUP`` (or some intermediary layer, such as ``z2.ZSERVER_FIXTURE`` or ``z2.FTP_SERVER_FIXTURE``, shown below) as a base.
+
+* Create "end user" layers by instantiating the ``z2.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new "fixture" layer as a base.
+
+This allows the same fixture to be used regardless of the "style" of testing, minimising the amount of set-up and tear-down.
+The "fixture" layers manage the fixture as part of the *layer* lifecycle.
+The layer class (``IntegrationTesting`` or ``FunctionalTesting``), manages the *test* lifecycle, and the test lifecycle only.
+
+For example::
+
+    from plone.testing import Layer, z2, zodb
+
+    class MyLayer(Layer):
+        defaultBases = (z2.STARTUP,)
+
+        def setUp(self):
+            # Set up the fixture here
+            ...
+
+        def tearDown(self):
+            # Tear down the fixture here
+            ...
+
+    MY_FIXTURE = MyLayer()
+
+    MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")
+    MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")
+
+(Note that we need to give an explicit, unique name to the two layers that re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)
+
+In this example, other layers could extend the "MyLayer" fixture by using ``MY_FIXTURE`` as a base.
+Tests would use either ``MY_INTEGRATION_TESTING`` or ``MY_FUNCTIONAL_TESTING`` as appropriate.
+However, even if both these two layers were used, the fixture in ``MY_FIXTURE`` would only be set up once.
+
+.. note::
+
+    If you implement the ``testSetUp()`` and ``testTearDown()`` test lifecycle methods in your "fixture" layer (e.g. in the the ``MyLayer`` class above), they will execute before the corresponding methods from ``IntegrationTesting`` and ``FunctionalTesting``.
+    Hence, they cannot use those layers' resources (``app`` and ``request``).
+
+It may be preferable, therefore, to have your own "test lifecycle" layer classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and call base class methods as appropriate.
+``plone.app.testing`` takes this approach, for example.
+
+HTTP ZServer thread (fixture only)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.ZServer``                     |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.STARTUP``                     |
++------------+--------------------------------------------------+
+| Resources: | ``host``                                         |
+|            +--------------------------------------------------+
+|            | ``port``                                         |
++------------+--------------------------------------------------+
+
+This layer extends the ``z2.STARTUP`` layer to start the Zope HTTP server in a separate thread.
+This means the test site can be accessed through a web browser, and can thus be used with tools like `Windmill`_ or `Selenium`_.
+
+.. note::
+
+    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.
+    Use the ``ZSERVER`` layer if you want to execute functional tests against this fixture.
+
+The ZServer's hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.
+
+  *Hint:* Whilst the layer is set up, you can actually access the test Zope site through a web browser.
+  The default URL will be ``http://localhost:55001``.
+
+HTTP ZServer functional testing
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.ZSERVER``                     |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.FunctionalTesting``           |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |
++------------+--------------------------------------------------+
+| Resources: |                                                  |
++------------+--------------------------------------------------+
+
+This layer provides the functional testing lifecycle against the fixture set up by the ``z2.ZSERVER_FIXTURE`` layer.
+
+You can use this to run "live" functional tests against a basic Zope site.
+You should **not** use it as a base.
+Instead, create your own "fixture" layer that extends ``z2.ZSERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.
+
+FTP server thread (fixture only)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.FTPServer``                   |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.STARTUP``                     |
++------------+--------------------------------------------------+
+| Resources: | ``host``                                         |
+|            +--------------------------------------------------+
+|            | ``port``                                         |
++------------+--------------------------------------------------+
+
+This layer is the FTP server equivalent of the ``ZSERVER_FIXTURE`` layer.
+It can be used to functionally test Zope servers.
+
+.. note::
+
+    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.
+    Use the ``FTP_SERVER`` layer if you want to execute functional tests against this fixture.
+
+    *Hint:* Whilst the layer is set up, you can actually access the test Zope site through an FTP client.
+    The default URL will be ``ftp://localhost:55002``.
+
+.. warning::
+
+    Do not run the ``FTP_SERVER`` and ``ZSERVER`` layers concurrently in the same process.
+
+If you need both ZServer and FTPServer running together, you can subclass the ``ZServer`` layer class (like the ``FTPServer`` layer class does) and implement the ``setUpServer()`` and ``tearDownServer()`` methods to set up and close down two servers on different ports.
+They will then share a main loop.
+
+FTP server functional testing
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.FTP_SERVER``                  |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.FunctionalTesting``           |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |
++------------+--------------------------------------------------+
+| Resources: |                                                  |
++------------+--------------------------------------------------+
+
+This layer provides the functional testing lifecycle against the fixture set up by the ``z2.FTP_SERVER_FIXTURE`` layer.
+
+You can use this to run "live" functional tests against a basic Zope site.
+You should **not** use it as a base.
+Instead, create your own "fixture" layer that extends ``z2.FTP_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.
+
+Helper functions
+~~~~~~~~~~~~~~~~
+
+Several helper functions are available in the ``plone.testing.z2`` module.
+
+``zopeApp(db=None, conn=Non, environ=None)``
+
+    This function can be used as a context manager for any code that requires access to the Zope application root.
+    By using it in a ``with`` block, the database will be opened, and the application root will be obtained and request-wrapped.
+    When exiting the ``with`` block, the transaction will be committed and the database properly closed, unless an exception was raised::
+
+        with z2.zopeApp() as app:
+            # do something with app
+
+    If you want to use a specific database or database connection, pass either the ``db`` or ``conn`` arguments.
+    If the context manager opened a new connection, it will close it, but it will not close a connection passed with ``conn``.
+
+    To set keys in the (fake) request environment, pass a dictionary of environment values as ``environ``.
+
+    Note that ``zopeApp()`` should *not* normally be used in tests or test set-up/tear-down, because the ``INTEGRATOIN_TEST`` and ``FUNCTIONAL_TESTING`` layers both manage the application root (as the ``app`` resource) and close it for you.
+    It is very useful in layer setup, however.
+
+``installProduct(app, product, quiet=False)``
+
+    Install a Zope 2 style product, ensuring that its ``initialize()`` function is called.
+    The product name must be the full dotted name, e.g. ``plone.app.portlets`` or ``Products.CMFCore``.
+    If ``quiet`` is true, duplicate registrations will be ignored silently, otherwise a message is logged.
+
+    To get hold of the application root, passed as the ``app`` argument, you would normally use the ``zopeApp()`` context manager outlined above.
+
+``uninstallProduct(app, product, quiet=False)``
+
+    This is the reciprocal of ``installProduct()``, normally used during layer tear-down.
+    Again, you should use ``zopeApp()`` to obtain the application root.
+
+``login(userFolder, userName)``
+
+    Create a new security manager that simulates being logged in as the given user.
+    ``userFolder`` is an ``acl_users`` object, e.g. ``app['acl_users']`` for the root user folder.
+
+``logout()``
+
+    Simulate being the anonymous user by unsetting the security manager.
+
+``setRoles(userFolder, userName, roles)``
+
+    Set the roles of the given user in the given user folder to the given list of roles.
+
+``makeTestRequest()``
+
+    Create a fake Zope request.
+
+``addRequestContainer(app, environ=None)``
+
+    Create a fake request and wrap the given object (normally an application root) in a ``RequestContainer`` with this request.
+    This makes acquisition of ``app.REQUEST`` possible.
+    To initialise the request environment with non-default values, pass a dictionary as ``environ``.
+
+    .. note::
+    
+       This method is rarely used, because both the ``zopeApp()``
+       context manager and the layer set-up/tear-down for
+       ``z2.INTEGRATION_TESTING`` and ``z2.FUNCTIONAL_TESTING`` will wrap the
+       ``app`` object before exposing it.
+
+``Browser(app)``
+
+    Obtain a test browser client, for use with `zope.testbrowser`_.
+    You should use this in conjunction with the ``z2.FUNCTIONAL_TESTING`` layer or a derivative.
+    You must pass the app root, usually obtained from the ``app`` resource of the layer, e.g.::
+
+        app = self.layer['app']
+        browser = z2.Browser(app)
+
+    You can then use ``browser`` as described in the `zope.testbrowser`_ documentation.
+
+    Bear in mind that the test browser runs separately from the test fixture.
+    In particular, calls to helpers such as ``login()`` or ``logout()`` do not affect the state that the test browser sees.
+    If you want to set up a persistent fixture (e.g. test content), you can do so before creating the test browser, but you will need to explicitly commit your changes, with::
+
+        import transaction
+        transaction.commit()
+
+.. _zope.testing: http://pypi.python.org/pypi/zope.testing
+.. _zope.testbrowser: http://pypi.python.org/pypi/zope.testbrowser
+.. _zope.component: http://pypi.python.org/pypi/zope.component
+.. _zope.publisher: http://pypi.python.org/pypi/zope.publisher
+.. _plone.app.testing: http://pypi.python.org/pypi/plone.app.testing
+.. _zc.recipe.testrunner: http://pypi.python.org/pypi/zc.recipe.testrunner
+.. _coverage: http://pypi.python.org/pypi/coverage
+.. _Cobertura: http://wiki.hudson-ci.org/display/HUDSON/Cobertura+Plugin
+.. _Hudson: http://www.hudson-labs.org/
+.. _unittest: http://doc.python.org/library/unittest.html
+.. _unittest2: http://pypi.python.org/pypi/unittest2
+.. _doctest: http://docs.python.org/dev/library/doctest.html
+.. _Windmill: http://getwindmill.com/
+.. _Selenium: http://seleniumhq.org/
diff --git a/setup.py b/setup.py
index 0bc88cd..e793f5f 100644
--- a/setup.py
+++ b/setup.py
@@ -34,7 +34,7 @@
     version=version,
     description="Testing infrastructure for Zope and Plone projects.",
     long_description=(u'\n\n'.join([
-        open(os.path.join("src", "plone", "testing", "README.rst")).read(),
+        open(os.path.join("docs", "overview.rst")).read(),
         open("CHANGES.rst").read(),
         "Detailed documentation\n" +
         "======================",
@@ -42,7 +42,8 @@
         open(os.path.join("src", "plone", "testing", "zca.rst")).read(),
         open(os.path.join("src", "plone", "testing", "security.rst")).read(),
         open(os.path.join("src", "plone", "testing", "publisher.rst")).read(),
-        open(os.path.join("src", "plone", "testing", "zodb.rst")).read()
+        open(os.path.join("src", "plone", "testing", "zodb.rst")).read(),
+        open(os.path.join("src", "plone", "testing", "z2.rst")).read()
     ])),
     classifiers=[
         "Environment :: Web Environment",
diff --git a/src/plone/testing/README.rst b/src/plone/testing/README.rst
deleted file mode 100644
index 5057086..0000000
--- a/src/plone/testing/README.rst
+++ /dev/null
@@ -1,1951 +0,0 @@
-Introduction
-============
-
-.. contents:: Table of contents
-
-``plone.testing`` provides tools for writing unit and integration tests in a Zope and Plone environment.
-It is not tied to Plone, and it does not depend on Zope 2 (although it has some optional Zope 2-only features).
-
-``plone.testing`` builds on `zope.testing`_, in particular its layers concept.
-This package also aims to promote some "good practice" for writing tests of various types.
-
-.. note::
-
-   If you are working with Plone, there is a complementary package `plone.app.testing`_, which builds on ``plone.testing`` to provide additional layers useful for testing Plone add-ons.
-
-If you are new to automated testing and test driven development, you should spend some time learning about those concepts.
-Some useful references include:
-
-* `The Wikipedia article on unit testing <http://en.wikipedia.org/wiki/Unit_testing>`_
-* `The Dive Into Python chapter on testing <http://diveintopython.net/unit_testing/index.html>`_
-
-Bear in mind that different Python frameworks have slightly different takes on how to approach testing.
-Therefore, you may find examples that are different to those shown below.
-The core concepts should be consistent, however.
-
-Compatibility
--------------
-
-``plone.testing`` 4.x has only been tested with Python 2.6 and 2.7.
-If you're using the optional Zope 2 layers, you must use Zope version 2.12 or later.
-Look at ``plone.testing`` 3.x for Zope 2.10 support.
-
-Definitions
------------
-
-In this documentation, we will use a number of testing-related terms.
-The following definitions apply:
-
-Unit test
-
-    An automated test (i.e. one written in code) that tests a single unit (normally a function) in isolation.
-    A unit test attempts to prove that the given function works as expected and gives the correct output given a particular input.
-    It is common to have a number of unit tests for a single function, testing different inputs, including boundary cases and errors.
-    Unit tests are typically quick to write and run.
-
-Integration test
-
-    An automated test that tests how a number of units interact.
-    In a Zope context, this often pertains to how a particular object or view interacts with the Zope framework, the ZODB persistence engine, and so on.
-    Integration tests usually require some setup and can be slower to run than unit tests.
-    It is common to have fewer integration tests than unit test.
-
-Functional test
-
-    An automated test that tests a feature in an "end-to-end" fashion.
-    In a Zope context, that normally means that it invokes an action in the same way that a user would, i.e. through a web request.
-    Functional tests are normally slower to run than either unit or integration tests, and can be significantly slower to run.
-    It is therefore common to have only a few functional tests for each major feature, relying on unit and integration tests for the bulk of testing.
-
-Black box testing
-
-    Testing which only considers the system's defined inputs and outputs.
-    For example, a functional test is normally a black box test that provides inputs only through the defined interface (e.g. URLs published in a web application), and makes assertions only on end outputs (e.g. the response returned for requests to those URLs).
-
-White box testing
-
-    Testing which examines the internal state of a system to make assertions.
-    Authors of unit and integration tests normally have significant knowledge of the implementation of the code under test, and can examine such things as data in a database or changes to the system's environment to determine if the test succeeded or failed.
-
-Assertion
-
-    A check that determines whether a test succeeds or fails.
-    For example, if a unit test for the function ``foo()`` expects it to return the value 1, an assertion could be written to verify this fact.
-    A test is said to *fail* if any of its assertions fail.
-    A test always contains one or more assertions.
-
-Test case
-
-    A single unit, integration or functional test.
-    Often shortened to just *test*.
-    A test case sets up, executes and makes assertions against a single scenario that bears testing.
-
-Test fixture
-
-    The state used as a baseline for one or more tests.
-    The test fixture is *set up* before each test is executed, and *torn down* afterwards.
-    This is a pre-requisite for *test isolation* - the principle that tests should be independent of one another.
-
-Layer
-
-    The configuration of a test fixture shared by a number of tests.
-    All test cases that belong to a particular layer will be executed together.
-    The layer is *set up* once before the tests are executed, and *torn down* once after.
-    Layers may depend on one another.
-    Any *base layers* are set up before and torn down after a particular *child layer* is used.
-    The test runner will order test execution to minimise layer setup and tear-down.
-
-Test suite
-
-    A collection of test cases (and layers) that are executed together.
-
-Test runner
-
-    The program which executes tests.
-    This is responsible for calling layer and test fixture set-up and tear-down methods.
-    It also reports on the test run, usually by printing output to the console.
-
-Coverage
-
-    To have confidence in your code, you should ensure it is adequately covered by tests.
-    That is, each line of code, and each possible branching point (loops, ``if`` statements) should be executed by a test.
-    This is known as *coverage*, and is normally measured as a percentage of lines of non-test code covered by tests.
-    Coverage can be measured by the test runner, which keeps track of which lines of code were executed in a given test run.
-
-Doctest
-
-    A style of testing where tests are written as examples that could be typed into the interactive Python interpreter.
-    The test runner executes each example and checks the actual output against the expected output.
-    Doctests can either be placed in the docstring of a method, or in a separate file.
-    The use of doctests is largely a personal preference.
-    Some developers like to write documentation as doctests, which has the advantage that code samples can be automatically tested for correctness.
-    You can read more about doctests on `Wikipedia <http://en.wikipedia.org/wiki/Doctest>`_.
-
-Installation and usage
-======================
-
-To use ``plone.testing`` in your own package, you need to add it as a dependency.
-Most people prefer to keep test-only dependencies separate, so that they do not need to be installed in scenarios (such as on a production server) where the tests will not be run.
-This can be achieved using a ``test`` extra.
-
-In ``setup.py``, add or modify the ``extras_require`` option, like so:::
-
-    extras_require = {
-        'test': [
-                'plone.testing',
-            ]
-    },
-
-You can add other test-only dependencies to that list as well, of course.
-
-To run tests, you need a test runner.
-If you are using ``zc.buildout``, you can install a test runner using the `zc.recipe.testrunner`_ recipe.
-For example, you could add the following to your ``buildout.cfg``:::
-
-    [test]
-    recipe = zc.recipe.testrunner
-    eggs =
-        my.package [test]
-    defaults = ['--auto-color', '--auto-progress']
-
-You'll also need to add this part to the ``parts`` list, of course:::
-
-    [buildout]
-    parts =
-        ...
-        test
-
-In this example, have listed a single package to test, called ``my.package``, and asked for it to be installed with the ``[test]`` extra.
-This will install any regular dependencies (listed in the ``install_requires`` option in ``setup.py``), as well as those in the list associated with the ``test`` key in the ``extras_require`` option.
-
-Note that it becomes important to properly list your dependencies here, because the test runner will only be aware of the packages explicitly listed, and their dependencies.
-For example, if your package depends on Zope 2, you need to list ``Zope2`` in the ``install_requires`` list in ``setup.py``;
-ditto for ``Plone``, or indeed any other package you import from.
-
-Once you have re-run buildout, the test runner will be installed as ``bin/test`` (the executable name is taken from the name of the buildout part).
-You can execute it without arguments to run all tests of each egg listed in the ``eggs`` list::
-
-    $ bin/test
-
-If you have listed several eggs, and you want to run the tests for a particular one, you can do::
-
-    $ bin/test -s my.package
-
-If you want to run only a particular test within this package, use the ``-t`` option.
-This can be passed a regular expression matching either a doctest file name or a test method name.::
-
-    $ bin/test -s my.package -t test_spaceship
-
-There are other command line options, which you can find by running::
-
-    $ bin/test --help
-
-Also note the ``defaults`` option in the buildout configuration.
-This can be used to set default command line options.
-Some commonly useful options are shown above.
-
-Coverage reporting
-------------------
-
-When writing tests, it is useful to know how well your tests cover your code.
-You can create coverage reports via the excellent `coverage`_ library.
-In order to use it, we need to install it and a reporting script::
-
-    [buildout]
-    parts =
-        ...
-        test
-        coverage
-        report
-
-    [coverage]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    initialization =
-        include = '--source=${buildout:directory}/src'
-        sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all']
-
-    [report]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    scripts = coverage=report
-    initialization =
-        sys.argv = sys.argv[:] + ['html', '-i']
-
-This will run the ``bin/test`` script with arguments like `--all` to run all layers.
-You can also specify no or some other arguments.
-It will place coverage reporting information in a ``.coverage`` file inside your buildout root.
-Via the ``--source`` argument you specify the directories containing code you want to cover.
-The coverage script would otherwise generate coverage information for all executed code, including other packages and even the standard library.
-
-Running the ``bin/report`` script will generate a human readable HTML representation of the run in the `htmlcov` directory.
-Open the contained `index.html` in a browser to see the result.
-
-If you want to generate an XML representation suitable for the `Cobertura`_ plugin of `Hudson`_, you can add another part::
-
-    [buildout]
-    parts =
-        ...
-        report-xml
-
-    [report-xml]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    scripts = coverage=report-xml
-    initialization =
-        sys.argv = sys.argv[:] + ['xml', '-i']
-
-This will generate a ``coverage.xml`` file in the buildout root.
-
-Optional dependencies
----------------------
-
-``plone.testing`` comes with a core set of tools for managing layers, which depends only on `zope.testing`_ and (for Python < 2.7) `unittest2`_.
-In addition, there are several layers and helper functions which can be used in your own tests (or as bases for your own layers).
-Some of these have deeper dependencies.
-However, these dependencies are optional and not installed by default.
-If you don't use the relevant layers, you can safely ignore them.
-
-``plone.testing`` does specify these dependencies, however, using the ``setuptools`` "extras" feature.
-You can depend on one or more extras in your own ``setup.py`` ``install_requires`` or ``extras_require`` option using the same square bracket notation shown for the ``[test]`` buildout part above.
-For example, if you need both the ``zca`` and ``publisher`` extras, you can have the following in your ``setup.py``::
-
-    extras_require = {
-        'test': [
-                'plone.testing [zca, publisher]',
-            ]
-    },
-
-The available extras are:
-
-``zodb``
-
-    ZODB testing.
-    Depends on ``ZODB3``.
-    The relevant layers and helpers are in the module ``plone.testing.zodb``.
-
-``zca``
-
-    Zope Component Architecture testing.
-    Depends on core Zope Component Architecture packages such as ``zope.component`` and ``zope.event``.
-    The relevant layers and helpers are in the module ``plone.testing.zca``.
-
-``security``
-
-    Security testing.
-    Depends on ``zope.security``.
-    The relevant layers and helpers are in the module ``plone.testing.security``.
-
-``publisher``
-
-    Zope Publisher testing.
-    Depends on ``zope.app.publisher`` and sets up ZCML directives.
-    The relevant layers and helpers are in the module ``plone.testing.publisher``.
-
-``z2``
-
-    Zope 2 testing.
-    Depends on the ``Zope2`` egg, which includes all the dependencies of the Zope 2 application server.
-    The relevant layers and helpers are in the module ``plone.testing.z2``
-
-Adding a test buildout to your package
---------------------------------------
-
-When creating re-usable, mostly stand-alone packages, it is often useful to be able to include a buildout with the package sources itself that can be used to create a test runner.
-This is a popular approach for many Zope packages, for example.
-In fact, ``plone.testing`` itself uses this kind of layout.
-
-To have a self-contained buildout in your package, the following is required:
-
-* You need a ``buildout.cfg`` at the root of the package.
-
-* In most cases, you always want a ``bootstrap.py`` file to make it easier for people to set up a fresh buildout.
-
-* Your package sources need to be inside a ``src`` directory.
-  If you're using namespace packages, that means the top level package should be in the ``src`` directory.
-
-* The ``src`` directory must be referenced in ``setup.py``.
-
-For example, ``plone.testing`` has the following layout::
-
-    plone.testing/
-    plone.testing/setup.py
-    plone.testing/bootstrap.py
-    plone.testing/buildout.cfg
-    plone.testing/README.rst
-    plone.testing/src/
-    plone.testing/src/plone
-    plone.testing/src/plone/__init__.py
-    plone.testing/src/plone/testing/
-    plone.testing/src/plone/testing/*
-
-In ``setup.py``, the following arguments are required::
-
-        packages=find_packages('src'),
-        package_dir={'': 'src'},
-
-This tells ``setuptools`` where to find the source code.
-
-The ``buildout.cfg`` for ``plone.testing`` looks like this::
-
-    [buildout]
-    extends =
-        http://download.zope.org/Zope2/index/2.12.12/versions.cfg
-    parts = coverage test report report-xml
-    develop = .
-
-    [test]
-    recipe = collective.xmltestreport
-    eggs =
-        plone.testing [test]
-    defaults = ['--auto-color', '--auto-progress']
-
-    [coverage]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    initialization =
-        include = '--source=${buildout:directory}/src'
-        sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all', '--xml']
-
-    [report]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    scripts = coverage=report
-    initialization =
-        sys.argv = sys.argv[:] + ['html', '-i']
-
-    [report-xml]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    scripts = coverage=report-xml
-    initialization =
-        sys.argv = sys.argv[:] + ['xml', '-i']
-
-Obviously, you should adjust the package name in the ``eggs`` list and the version set in the ``extends`` line as appropriate.
-
-You can of course also add additional buildout parts, for example to include some development/debugging tools, or even a running application server for testing purposes.
-
-    *Hint:* If you use this package layout, you should avoid checking any files or directories generated by buildout into your version control repository.
-    You want to ignore:
-
-    * ``.coverage``
-    * ``.installed.cfg``
-    * ``bin``
-    * ``coverage.xml``
-    * ``develop-eggs``
-    * ``htmlcov``
-    * ``parts``
-    * ``src/*.egg-info``
-
-Layers
-======
-
-In large part, ``plone.testing`` is about layers.
-It provides:
-
-* A set of layers (outlined below), which you can use or extend.
-
-* A set of tools for working with layers
-
-* A mini-framework to make it easy to write layers and manage shared resources associated with layers.
-
-We'll discuss the last two items here, before showing how to write tests that use layers.
-
-Layer basics
-------------
-
-Layers are used to create test fixtures that are shared by multiple test cases.
-For example, if you are writing a set of integration tests, you may need to set up a database and configure various components to access that database.
-This type of test fixture setup can be resource-intensive and time-consuming.
-If it is possible to only perform the setup and tear-down once for a set of tests without losing isolation between those tests, test runs can often be sped up significantly.
-
-Layers also allow re-use of test fixtures and set-up/tear-down code.
-``plone.testing`` provides a number of useful (but optional) layers that manage test fixtures for common Zope testing scenarios, letting you focus on the actual test authoring.
-
-At the most basic, a layer is an object with the following methods and attributes:
-
-``setUp()``
-
-    Called by the test runner when the layer is to be set up.
-    This is called exactly once for each layer used during a test run.
-
-``tearDown()``
-
-    Called by the test runner when the layer is to be torn down.
-    As with ``setUp()``, this is called exactly once for each layer.
-
-``testSetUp()``
-
-    Called immediately before each test case that uses the layer is executed.
-    This is useful for setting up aspects of the fixture that are managed on a per-test basis, as opposed to fixture shared among all tests.
-
-``testTearDown()``
-
-    Called immediately after each test case that uses the layer is executed.
-    This is a chance to perform any post-test cleanup to ensure the fixture is ready for the next test.
-
-``__bases__``
-
-    A tuple of base layers.
-
-Each test case is associated with zero or one layer.
-(The syntax for specifying the layer is shown in the section "Writing tests" below.) All the tests associated with a given layer will be executed together.
-
-Layers can depend on one another (as indicated in the ``__bases__`` tuple), allowing one layer to build on the fixture created by another.
-Base layers are set up before and torn down after their dependants.
-
-For example, if the test runner is executing some tests that belong to layer A, and some other tests that belong to layer B, both of which depend on layer C, the order of execution might be::
-
-    1. C.setUp()
-    1.1. A.setUp()
-
-    1.1.1. C.testSetUp()
-    1.1.2. A.testSetUp()
-    1.1.3. [One test using layer A]
-    1.1.4. A.testTearDown()
-    1.1.5. C.testTearDown()
-
-    1.1.6. C.testSetUp()
-    1.1.7. A.testSetUp()
-    1.1.8. [Another test using layer A]
-    1.1.9. A.testTearDown()
-    1.1.10. C.testTearDown()
-
-    1.2. A.tearDown()
-    1.3. B.setUp()
-
-    1.3.1. C.testSetUp()
-    1.3.2. B.testSetUp()
-    1.3.3. [One test using layer B]
-    1.3.4. B.testTearDown()
-    1.3.5. C.testTearDown()
-
-    1.3.6. C.testSetUp()
-    1.3.7. B.testSetUp()
-    1.3.8. [Another test using layer B]
-    1.3.9. B.testTearDown()
-    1.3.10. C.testTearDown()
-
-    1.4. B.tearDown()
-    2. C.tearDown()
-
-A base layer may of course depend on other base layers.
-In the case of nested dependencies like this, the order of set up and tear-down as calculated by the test runner is similar to the way in which Python searches for the method to invoke in the case of multiple inheritance.
-
-Writing layers
---------------
-
-The easiest way to create a new layer is to use the ``Layer`` base class and implement the ``setUp()``, ``tearDown()``, ``testSetUp()`` and ``testTearDown()`` methods as needed.
-All four are optional.
-The default implementation of each does nothing.
-
-By convention, layers are created in a module called ``testing.py`` at the top level of your package.
-The idea is that other packages that extend your package can re-use your layers for their own testing.
-
-A simple layer may look like this::
-
-    >>> from plone.testing import Layer
-    >>> class SpaceShip(Layer):
-    ...
-    ...     def setUp(self):
-    ...         print "Assembling space ship"
-    ...
-    ...     def tearDown(self):
-    ...         print "Disasembling space ship"
-    ...
-    ...     def testSetUp(self):
-    ...         print "Fuelling space ship in preparation for test"
-    ...
-    ...     def testTearDown(self):
-    ...         print "Emptying the fuel tank"
-
-Before this layer can be used, it must be instantiated.
-Layers are normally instantiated exactly once, since by nature they are shared between tests.
-This becomes important when you start to manage resources (such as persistent data, database connections, or other shared resources) in layers.
-
-The layer instance is conventionally also found in ``testing.py``, just after the layer class definition.::
-
-    >>> SPACE_SHIP = SpaceShip()
-
-.. note::
-
-    Since the layer is instantiated in module scope, it will be created as soon as the ``testing`` module is imported.
-    It is therefore very important that the layer class is inexpensive and safe to create.
-    In general, you should avoid doing anything non-trivial in the ``__init__()`` method of your layer class.
-    All setup should happen in the ``setUp()`` method.
-    If you *do* implement ``__init__()``, be sure to call the ``super`` version as well.
-
-The layer shown above did not have any base layers (dependencies).
-Here is an example of another layer that depends on it:::
-
-    >>> class ZIGSpaceShip(Layer):
-    ...     defaultBases = (SPACE_SHIP,)
-    ...
-    ...     def setUp(self):
-    ...         print "Installing main canon"
-
-    >>> ZIG = ZIGSpaceShip()
-
-Here, we have explicitly listed the base layers on which ``ZIGSpaceShip`` depends, in the ``defaultBases`` attribute.
-This is used by the ``Layer`` base class to set the layer bases in a way that can also be overridden: see below.
-
-Note that we use the layer *instance* in the ``defaultBases`` tuple, not the class.
-Layer dependencies always pertain to specific layer instances.
-Above, we are really saying that *instances* of ``ZIGSpaceShip`` will, by default, require the ``SPACE_SHIP`` layer to be set up first.
-
-.. note::
-
-    You may find it useful to create other layer base/mix-in classes that extend ``plone.testing.Layer`` and provide helper methods for use in your own layers.
-    This is perfectly acceptable, but please do not confuse a layer base class used in this manner with the concept of a *base layer* as described above:
-
-        * A class deriving from ``plone.testing.Layer`` is known as a *layer class*.
-          It defines the behaviour of the layer by implementing the lifecycle methods ``setUp()``, ``tearDown()``, ``testSetUp()`` and/or ``testTearDown()``.
-
-        * A layer class can be instantiated into an actual layer.
-          When a layer is associated with a test, it is the layer *instance* that is used.
-
-        * The instance is usually a shared, module-global object, although in some cases it is useful to create copies of layers by instantiating the class more than once.
-
-        * Subclassing an existing layer class is just straightforward OOP re-use: the test runner is not aware of the subclassing relationship.
-
-        * A layer *instance* can be associated with any number of layer *bases*, via its ``__bases__`` property (which is usually via the ``defaultBases`` variable in the class body and/or overridden using the ``bases`` argument to the ``Layer`` constructor).
-         These bases are layer *instances*, not classes.
-         The test runner will inspect the ``__bases__`` attribute of each layer instance it sets up to calculate layer pre-requisites and dependencies.
-
-    Also note that the `zope.testing`_ documentation contains examples of layers that are "old-style" classes where the ``setUp()`` and ``tearDown()`` methods are ``classmethod`` methods and class inheritance syntax is used to specify base layers.
-    Whilst this pattern works, we discourage its use, because the classes created using this pattern are not really used as classes.
-    The concept of layer bases is slightly different from class inheritance, and using the ``class`` keyword to create layers with base layers leads to a number of "gotchas" that are best avoided.
-
-Advanced - overriding bases
----------------------------
-
-In some cases, it may be useful to create a copy of a layer, but change its bases.
-One reason to do this may if you are re-using a layer from another module, and you need to change the order in which layers are set up and torn down.
-
-Normally, of course, you would just re-use the layer instance, either directly in a test, or in the ``defaultBases`` tuple of another layer, but if you need to change the bases, you can pass a new list of bases to the layer instance constructor:::
-
-    >>> class CATSMessage(Layer):
-    ...
-    ...     def setUp(self):
-    ...         print "All your base are belong to us"
-    ...
-    ...     def tearDown(self):
-    ...         print "For great justice"
-
-    >>> CATS_MESSAGE = CATSMessage()
-
-    >>> ZERO_WING = ZIGSpaceShip(bases=(SPACE_SHIP, CATS_MESSAGE,), name="ZIGSpaceShip:CATSMessage")
-
-Please note that when overriding bases like this, the ``name`` argument is required.
-This is because each layer (using in a given test run) must have a unique name.
-The default is to use the layer class name, but this obviously only works for one instantiation.
-Therefore, ``plone.testing`` requires a name when setting ``bases`` explicitly.
-
-Please take great care when changing layer bases like this.
-The layer implementation may make assumptions about the test fixture that was set up by its bases.
-If you change the order in which the bases are listed, or remove a base altogether, the layer may fail to set up correctly.
-
-Also, bear in mind that the new layer instance is independent of the original layer instance, so any resources defined in the layer are likely to be duplicated.
-
-Layer combinations
-------------------
-
-Sometimes, it is useful to be able to combine several layers into one, without adding any new fixture.
-One way to do this is to use the ``Layer`` class directly and instantiate it with new bases:::
-
-    >>> COMBI_LAYER = Layer(bases=(CATS_MESSAGE, SPACE_SHIP,), name="Combi")
-
-Here, we have created a "no-op" layer with two bases: ``CATS_MESSAGE`` and ``SPACE_SHIP``, named ``Combi``.
-
-Please note that when using ``Layer`` directly like this, the ``name`` argument is required.
-This is to allow the test runner to identify the layer correctly.
-Normally, the class name of the layer is used as a basis for the name, but when using the ``Layer`` base class directly, this is unlikely to be unique or descriptive.
-
-Layer resources
----------------
-
-Many layers will manage one or more resources that are used either by other layers, or by tests themselves.
-Examples may include database connections, thread-local objects, or configuration data.
-
-``plone.testing`` contains a simple resource storage abstraction that makes it easy to access resources from dependant layers or tests.
-The resource storage uses dictionary notation:::
-
-    >>> class WarpDrive(object):
-    ...     """A shared resource"""
-    ...
-    ...     def __init__(self, maxSpeed):
-    ...         self.maxSpeed = maxSpeed
-    ...         self.running = False
-    ...
-    ...     def start(self, speed):
-    ...         if speed > self.maxSpeed:
-    ...             print "We need more power!"
-    ...         else:
-    ...             print "Going to warp at speed", speed
-    ...             self.running = True
-    ...
-    ...     def stop(self):
-    ...         self.running = False
-
-    >>> class ConstitutionClassSpaceShip(Layer):
-    ...     defaultBases = (SPACE_SHIP,)
-    ...
-    ...     def setUp(self):
-    ...         self['warpDrive'] = WarpDrive(8.0)
-    ...
-    ...     def tearDown(self):
-    ...         del self['warpDrive']
-
-    >>> CONSTITUTION_CLASS_SPACE_SHIP = ConstitutionClassSpaceShip()
-
-    >>> class GalaxyClassSpaceShip(Layer):
-    ...     defaultBases = (CONSTITUTION_CLASS_SPACE_SHIP,)
-    ...
-    ...     def setUp(self):
-    ...         # Upgrade the warp drive
-    ...         self.previousMaxSpeed = self['warpDrive'].maxSpeed
-    ...         self['warpDrive'].maxSpeed = 9.5
-    ...
-    ...     def tearDown(self):
-    ...         # Restore warp drive to its previous speed
-    ...         self['warpDrive'].maxSpeed = self.previousMaxSpeed
-
-    >>> GALAXY_CLASS_SPACE_SHIP = GalaxyClassSpaceShip()
-
-As shown, layers (that derive from ``plone.testing.Layer``) support item (dict-like) assignment, access and deletion of arbitrary resources under string keys.
-
-    **Important:** If a layer creates a resource (by assigning an object to a key on ``self`` as shown above) during fixture setup-up, it must also delete the resource on tear-down.
-    Set-up and deletion should be symmetric: if the resource is assigned during ``setUp()`` it should be deleted in ``tearDown()``;
-    if it's created in ``testSetUp()`` it should be deleted in ``testTearDown()``.
-
-A resource defined in a base layer is accessible from and through a child layer.
-If a resource is set on a child using a key that also exists in a base layer, the child version will shadow the base version until the child layer is torn down (presuming it deletes the resource, which it should), but the base layer version remains intact.
-
-.. note::
-
-    Accessing a resource is analogous to accessing an instance variable.
-    For example, if a base layer assigns a resource to a given key in its ``setUp()`` method, a child layer shadows that resource with another object under the same key, the shadowed resource will by used during the ``testSetUp()`` and ``testTearDown()`` lifecycle methods if implemented by the *base* layer as well.
-    This will be the case until the child layer "pops" the resource by deleting it, normally in its ``tearDown()``.
-
-Conversely, if (as shown above) the child layer accesses and modifies the object, it will modify the original.
-
-.. note::
-
-   It is sometimes necessary (or desirable) to modify a shared resource in a child layer, as shown in the example above.  In this case, however, it is very important to restore the original state when the layer is torn down.  Otherwise, other layers or tests using the base layer directly may be affected in difficult-to-debug ways.
-
-If the same key is used in multiple base layers, the rules for choosing which version to use are similar to those that apply when choosing an attribute or method to use in the case of multiple inheritance.
-
-In the example above, we used the resource manager for the ``warpDrive`` object, but we assigned the ``previousMaxSpeed`` variable to ``self``.
-This is because ``previousMaxSpeed`` is internal to the layer and should not be shared with any other layers that happen to use this layer as a base.
-Nor should it be used by any test cases.
-Conversely, ``warpDrive`` is a shared resource that is exposed to other layers and test cases.
-
-The distinction becomes even more important when you consider how a test case may access the shared resource.
-We'll discuss how to write test cases that use layers shortly, but consider the following test:::
-
-    >>> try:
-    ...     import unittest2 as unittest
-    ... except ImportError: # Python 2.7
-    ...     import unittest
-    >>> class TestFasterThanLightTravel(unittest.TestCase):
-    ...     layer = GALAXY_CLASS_SPACE_SHIP
-    ...
-    ...     def test_hyperdrive(self):
-    ...         warpDrive = self.layer['warpDrive']
-    ...         warpDrive.start(8)
-
-This test needs access to the shared resource.
-It knows that its layer defines one called ``warpDrive``.
-It does not know or care that the warp drive was actually initiated by the ``ConstitutionClassSpaceShip`` base layer.
-
-If, however, the base layer had assigned the resource as an instance variable, it would not inherit to child layers (remember: layer bases are not base classes!).
-The syntax to access it would be:::
-
-    self.layer.__bases__[0].warpDrive
-
-which is not only ugly, but brittle: if the list of bases is changed, the expression above may lead to an attribute error.
-
-Writing tests
-=============
-
-Tests are usually written in one of two ways: As methods on a class that derives from ``unittest.TestCase`` (this is sometimes known as "Python tests" or "JUnit-style tests"), or using doctest syntax.
-
-You should realise that although the relevant frameworks (``unittest``, ``unittest2`` and ``doctest``) often talk about unit testing, these tools are also used to write integration and functional tests.
-The distinction between unit, integration and functional tests is largely practical: you use the same techniques to set up a fixture or write assertions for an integration test as you would for a unit test.
-The difference lies in what that fixture contains, and how you invoke the code under test.
-In general, a true unit test will have a minimal or no test fixture, whereas an integration test will have a fixture that contains the components your code is integrating with.
-A functional test will have a fixture that contains enough of the full system to execute and test an "end-to-end" scenario.
-
-Python tests
-------------
-
-Python tests use the Python `unittest`_ module, or its cousin `unittest2`_ (see below).
-They should be placed in a module or package called ``tests`` for the test runner to pick them up.
-
-For small packages, a single module called ``tests.py`` will normally contain all tests.
-For larger packages, it is common to have a ``tests`` package that contains a number of modules with tests.
-These need to start with the word ``test``, e.g.
-``tests/test_foo.py`` or ``tests/test_bar.py``.
-Don't forget the ``__init__.py`` in the ``tests`` package, too!
-
-unittest2
-~~~~~~~~~
-
-In Python 2.7+, the ``unittest`` module has grown several new and useful features.
-To make use of these in Python 2.4, 2.5 and 2.6, an add-on module called `unittest2`_ can be installed.
-``plone.testing`` depends on ``unittest2`` for these versions (and uses it for its own tests), so you will have access to it if you depend on ``plone.testing``.
-
-We will use ``unittest2`` for the examples in this document, but try to import it with an alias of ``unittest``.
-This makes the code forward compatible with Python 2.7, where the built-in ``unittest`` module will have all the features of the ``unittest2`` module.
-
-Please note that the `zope.testing`_ test runner at the time of writing (version 3.9.3) does not (yet) support the new ``setUpClass()``, ``tearDownClass()``, ``setUpModule()`` and ``tearDownModule()`` hooks from ``unittest2``.
-This is not normally a problem, since we tend to use layers to manage complex fixtures, but it is important to be aware of nonetheless.
-
-Test modules, classes and functions
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Python tests are written with classes that derive from the base class ``TestCase``.
-Each test is written as a method that takes no arguments and has a name starting with ``test``.
-Other methods can be added and called from test methods as appropriate, e.g.
-to share some test logic.
-
-Two special methods, ``setUp()`` and ``tearDown()``, can also be added.
-These will be called before or after each test, respectively, and provide a useful place to construct and clean up test fixtures without writing a custom layer.
-They are obviously not as re-usable as layers, though.
-
-   *Hint:* Somewhat confusingly, the ``setUp()`` and ``tearDown()`` methods in a test case class are the equivalent of the ``testSetUp()`` and ``testTearDown()`` methods of a layer class.
-
-A layer can be specified by setting the ``layer`` class attribute to a layer instance.
-If layers are used in conjunction with ``setUp()`` and ``tearDown()`` methods in the test class itself, the class' ``setUp()`` method will be called after the layer's ``testSetUp()`` method, and the class' ``tearDown()`` method will be called before the layer's ``testTearDown()`` method.
-
-The ``TestCase`` base class contains a number of methods which can be used to write assertions.
-They all take the form ``self.assertSomething()``, e.g.
-``self.assertEqual(result, expectedValue)``.
-See the `unittest`_ and/or `unittest2`_ documentation for details.
-
-Putting this together, let's expand on our previous example unit test:::
-
-    >>> try:
-    ...     import unittest2 as unittest
-    ... except ImportError: # Python 2.7
-    ...     import unittest
-
-    >>> class TestFasterThanLightTravel(unittest.TestCase):
-    ...     layer = GALAXY_CLASS_SPACE_SHIP
-    ...
-    ...     def setUp(self):
-    ...         self.warpDrive = self.layer['warpDrive']
-    ...         self.warpDrive.stop()
-    ...
-    ...     def tearDown(self):
-    ...         self.warpDrive.stop()
-    ...
-    ...     def test_warp8(self):
-    ...         self.warpDrive.start(8)
-    ...         self.assertEqual(self.warpDrive.running, True)
-    ...
-    ...     def test_max_speed(self):
-    ...         tooFast = self.warpDrive.maxSpeed + 0.1
-    ...         self.warpDrive.start(tooFast)
-    ...         self.assertEqual(self.warpDrive.running, False)
-
-A few things to note:
-
-* The class derives from ``unittest.TestCase``.
-
-* The ``layer`` class attribute is set to a layer instance (not a layer class!) defined previously.
-  This would typically be imported from a ``testing`` module.
-
-* There are two tests here: ``test_warp8()`` and ``test_max_speed()``.  
-
-* We have used the ``self.assertEqual()`` assertion in both tests to check the result of executing the ``start()`` method on the warp drive.
-
-* We have used the ``setUp()`` method to fetch the ``warpDrive`` resource and ensure that it is stopped before each test is executed.
-  Assigning a variable to ``self`` is a useful way to provide some state to each test method, though be careful about data leaking between tests: in general, you cannot predict the order in which tests will run, and tests should always be independent.
-
-* We have used the ``tearDown()`` method to make sure the warp drive is really stopped after each test.
-
-Test suites
-~~~~~~~~~~~
-
-If you are using version 3.8.0 or later of `zope.testing`_, a class like the one above is all you need: any class deriving from ``TestCase`` in a module with a name starting with ``test`` will be examined for test methods.
-Those tests are then collected into a test suite and executed.
-
-With older versions of `zope.testing`_, you need to add a ``test_suite()`` function in each module that returns the tests in the test suite.
-The `unittest`_ module contains several tools to construct suites, but one of the simplest is to use the default test loader to load all tests in the current module:::
-
-    >>> def test_suite():
-    ...     return unittest.defaultTestLoader.loadTestsFromName(__name__)
-
-If you need to load tests explicitly, you can use the ``TestSuite`` API from the `unittest`_ module.
-For example:::
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         unittest.makeSuite(TestFasterThanLightTravel)
-    ...     ])
-    ...     return suite
-
-The ``makeSuite()`` function creates a test suite from the test methods in the given class (which must derive from ``TestCase``).
-This suite is then appended to an overall suite, which is returned from the ``test_suite()`` method.
-Note that ``addTests()`` takes a list of suites (which are coalesced into a single suite).
-We'll add additional suites later.
-
-See the `unittest`_ documentation for other options.
-
-.. note::
-
-   Adding a ``test_suite()`` method to a module disables automatic test discovery, even when using a recent version of ``zope.testing``.
-
-Doctests
---------
-
-Doctests can be written in two ways: as the contents of a docstring (usually, but not always, as a means of illustrating and testing the functionality of the method or class where the docstring appears), or as a separate text file.
-In both cases, the standard `doctest`_ module is used.
-See its documentation for details about doctest syntax and conventions.
-
-Doctests are used in two different ways:
-
-* To test documentation.
-  That is, to ensure that code examples contained in documentation are valid and continue to work as the software is updated.
-
-* As a convenient syntax for writing tests.
-
-These two approaches use the same testing APIs and techniques.
-The difference is mostly about mindset.
-However, it is important to avoid falling into the trap that tests can substitute for good documentation or vice-a-versa.
-Tests usually need to systematically go through inputs and outputs and cover off a number of corner cases.
-Documentation should tell a compelling narrative and usually focus on the main usage scenarios.
-Trying to kill these two birds with one stone normally leaves you with an unappealing pile of stones and feathers.
-
-Docstring doctests
-~~~~~~~~~~~~~~~~~~
-
-Doctests can be added to any module, class or function docstring:::
-
-    def canOutrunKlingons(warpDrive):
-        """Find out of the given warp drive can outrun Klingons.
-
-        Klingons travel at warp 8
-
-        >>> drive = WarpDrive(5)
-        >>> canOutrunKlingons(drive)
-        False
-
-        We have to be faster than that to outrun them.
-
-        >>> drive = WarpDrive(8.1)
-        >>> canOutrunKlingons(drive)
-        True
-
-        We can't outrun them if we're travelling exactly the same speed
-
-        >>> drive = WarpDrive(8.0)
-        >>> canOutrunKlingons(drive)
-        False
-
-        """
-        return warpDrive.maxSpeed > 8.0
-
-To add the doctests from a particular module to a test suite, you need to use the ``test_suite()`` function hook:::
-
-    >>> import doctest
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         unittest.makeSuite(TestFasterThanLightTravel), # our previous test
-    ...         doctest.DocTestSuite('spaceship.utils'),
-    ...     ])
-    ...     return suite
-
-Here, we have given the name of the module to check as a string dotted name.
-It is also possible to import a module and pass it as an object.
-The code above passes a list to ``addTests()``, making it easy to add several sets of tests to the suite: the list can be constructed from calls to ``DocTestSuite()``, ``DocFileSuite()`` (shown below) and ``makeSuite()`` (shown above).
-
-    Remember that if you add a ``test_suite()`` function to a module that also has ``TestCase``-derived python tests, those tests will no longer be automatically picked up by ``zope.testing``, so you need to add them to the test suite explicitly.
-
-The example above illustrates a documentation-oriented doctest, where the doctest forms part of the docstring of a public module.
-The same syntax can be used for more systematic unit tests.
-For example, we could have a module ``spaceship.tests.test_spaceship`` with a set of methods like::
-
-    # It's often better to put the import into each method, but here we've
-    # imported the code under test at module level
-    from spaceship.utils import WarpDrive, canOutrunKlingons
-
-    def test_canOutrunKlingons_too_small():
-        """Klingons travel at warp 8.0
-
-        >>> drive = WarpDrive(7.9)
-        >>> canOutrunKlingons(drive)
-        False
-
-        """
-
-    def test_canOutrunKlingons_big():
-        """Klingons travel at warp 8.0
-
-        >>> drive = WarpDrive(8.1)
-        >>> canOutrunKlingons(drive)
-        True
-
-        """
-
-    def test_canOutrunKlingons_must_be_greater():
-        """Klingons travel at warp 8.0
-
-        >>> drive = WarpDrive(8.0)
-        >>> canOutrunKlingons(drive)
-        False
-
-        """
-
-Here, we have created a number of small methods that have no body.
-They merely serve as a container for docstrings with doctests.
-Since the module has no globals, each test must import the code under test, which helps make import errors more explicit.
-
-File doctests
-~~~~~~~~~~~~~
-
-Doctests contained in a file are similar to those contained in docstrings.
-File doctests are better suited to narrative documentation covering the usage of an entire module or package.
-
-For example, if we had a file called ``spaceship.txt`` with doctests, we could add it to the test suite above with:::
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         unittest.makeSuite(TestFasterThanLightTravel),
-    ...         doctest.DocTestSuite('spaceship.utils'),
-    ...         doctest.DocFileSuite('spaceship.txt'),
-    ...     ])
-    ...     return suite
-
-By default, the file is located relative to the module where the test suite is defined.
-You can use ``../`` (even on Windows) to reference the parent directory, which is sometimes useful if the doctest is inside a module in a ``tests`` package.
-
-.. note::
-
-    If you put the doctest ``test_suite()`` method in a module inside a ``tests`` package, that module must have a name starting with ``test``.
-    It is common to have ``tests/test_doctests.py`` that contains a single ``test_suite()`` method that returns a suite of multiple doctests.
-
-It is possible to pass several tests to the suite, e.g.::
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         unittest.makeSuite(TestFasterThanLightTravel),
-    ...         doctest.DocTestSuite('spaceship.utils'),
-    ...         doctest.DocFileSuite('spaceship.txt', 'warpdrive.txt',),
-    ...     ])
-    ...     return suite
-
-The test runner will report each file as a separate test, i.e.
-the ``DocFileSuite()`` above would add two tests to the overall suite.
-Conversely, a ``DocTestSuite()`` using a module with more than one docstring containing doctests will report one test for each eligible docstring.
-
-Doctest fixtures and layers
-~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-A docstring doctest will by default have access to any global symbol available in the module where the docstring is found (e.g.
-anything defined or imported in the module).
-The global namespace can be overridden by passing a ``globs`` keyword argument to the ``DocTestSuite()`` constructor, or augmented by passing an ``extraglobs`` argument.
-Both should be given dictionaries.
-
-A file doctest has an empty globals namespace by default.
-Globals may be provided via the ``globs`` argument to ``DocFileSuite()``.
-
-To manage a simple test fixture for a doctest, you can define set-up and tear-down functions and pass them as the ``setUp`` and ``tearDown`` arguments respectively.
-These are both passed a single argument, a ``DocTest`` object.
-The most useful attribute of this object is ``globs``, which is a mutable dictionary of globals available in the test.
-
-For example:::
-
-    >>> def setUpKlingons(doctest):
-    ...     doctest.globs['oldStyleKlingons'] = True
-
-    >>> def tearDownKlingons(doctest):
-    ...     doctest.globs['oldStyleKlingons'] = False
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         doctest.DocTestSuite('spaceship.utils', setUp=setUpKlingons, tearDown=tearDownKlingons),
-    ...     ])
-    ...     return suite
-
-The same arguments are available on the ``DocFileSuite()`` constructor.
-The set up method is called before each docstring in the given module for a ``DocTestSuite``, and before each file given in a ``DocFileSuite``.
-
-Of course, we often want to use layers with doctests too.
-Unfortunately, the ``unittest`` API is not aware of layers, so you can't just pass a layer to the ``DocTestSuite()`` and ``DocFileSuite()`` constructors.
-Instead, you have to set a ``layer`` attribute on the suite after it has been constructed.
-
-Furthermore, to use layer resources in a doctest, we need access to the layer instance.
-The easiest way to do this is to pass it as a glob, conventionally called 'layer'.
-This makes a global name 'layer' available in the doctest itself, giving access to the test's layer instance.
-
-To make it easier to do this, ``plone.testing`` comes with a helper function called ``layered()``.
-Its first argument is a test suite.
-The second argument is the layer.
-
-For example:::
-
-    >>> from plone.testing import layered
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         layered(doctest.DocTestSuite('spaceship.utils'), layer=CONSTITUTION_CLASS_SPACE_SHIP),
-    ...     ])
-    ...     return suite
-
-This is equivalent to:::
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...
-    ...     spaceshipUtilTests = doctest.DocTestSuite('spaceship.utils', globs={'layer': CONSTITUTION_CLASS_SPACE_SHIP})
-    ...     spaceshipUtilTests.layer = CONSTITUTION_CLASS_SPACE_SHIP
-    ...     suite.addTest(spaceshipUtilTests)
-    ...
-    ...     return suite
-
-(In this example, we've opted to use ``addTest()`` to add a single suite, instead of using ``addTests()`` to add multiple suites in one go).
-
-Zope testing tools
-==================
-
-Everything described so far in this document relies only on the standard `unittest`_/`unittest2`_ and `doctest`_ modules and `zope.testing`_, and you can use this package without any other dependencies.
-
-However, there are also some tools (and layers) available in this package, as well as in other packages, that are specifically useful for testing applications that use various Zope-related frameworks.
-
-Test cleanup
-------------
-
-If a test uses a global registry, it may be necessary to clean that registry on set up and tear down of each test fixture.
-``zope.testing`` provides a mechanism to register cleanup handlers - methods that are called to clean up global state.
-This can then be invoked in the ``setUp()`` and ``tearDown()`` fixture lifecycle methods of a test case.::
-
-    >>> from zope.testing import cleanup
-
-Let's say we had a global registry, implemented as a dictionary:::
-
-    >>> SOME_GLOBAL_REGISTRY = {}
-
-If we wanted to clean this up on each test run, we could call ``clear()`` on the dict.
-Since that's a no-argument method, it is perfect as a cleanup handler.::
-
-    >>> cleanup.addCleanUp(SOME_GLOBAL_REGISTRY.clear)
-
-We can now use the ``cleanUp()`` method to execute all registered cleanups:::
-
-    >>> cleanup.cleanUp()
-
-This call could be placed in a ``setUp()`` and/or ``tearDown()`` method in a test class, for example.
-
-Event testing
--------------
-
-You may wish to test some code that uses ``zope.event`` to fire specific events.
-`zope.component`_ provides some helpers to capture and analyse events.::
-
-    >>> from zope.component import eventtesting
-
-To use this, you first need to set up event testing.
-Some of the layers shown below will do this for you, but you can do it yourself by calling the ``eventtesting.setUp()`` method, e.g.
-from your own ``setUp()`` method:::
-
-    >>> eventtesting.setUp()
-
-This simply registers a few catch-all event handlers.
-Once you have executed the code that is expected to fire events, you can use the ``getEvents()`` helper function to obtain a list of the event instances caught:::
-
-    >>> events = eventtesting.getEvents()
-
-You can now examine ``events`` to see what events have been caught since the last cleanup.
-
-``getEvents()`` takes two optional arguments that can be used to filter the returned list of events.
-The first (``event_type``) is an interface.
-If given, only events providing this interface are returned.
-The second (``filter``) is a callable taking one argument.
-If given, it will be called with each captured event.
-Only those events where the filter function returns ``True`` will be included.
-
-The ``eventtesting`` module registers a cleanup action as outlined above.
-When you call ``cleanup.cleanUp()`` (or ``eventtesting.clearEvents()``, which is the handler it registers), the events list will be cleared, ready for the next test.
-Here, we'll do it manually:::
-
-    >>> eventtesting.clearEvents()
-
-Mock requests
--------------
-
-Many tests require a request object, often with particular request/form variables set.
-`zope.publisher`_ contains a useful class for this purpose.::
-
-    >>> from zope.publisher.browser import TestRequest
-
-A simple test request can be constructed with no arguments:::
-
-    >>> request = TestRequest()
-
-To add a body input stream, pass a ``StringIO`` or file as the first parameter.
-To set the environment (request headers), use the ``environ`` keyword argument.
-To simulate a submitted form, use the ``form`` keyword argument:::
-
-    >>> request = TestRequest(form=dict(field1='foo', field2=1))
-
-Note that the ``form`` dict contains marshalled form fields, so modifiers like ``:int`` or ``:boolean`` should not be included in the field names, and values should be converted to the appropriate type.
-
-Registering components
-----------------------
-
-Many test fixtures will depend on having a minimum of Zope Component Architecture (ZCA) components registered.
-In normal operation, these would probably be registered via ZCML, but in a unit test, you should avoid loading the full ZCML configuration of your package (and its dependencies).
-
-Instead, you can use the Python API in `zope.component`_ to register global components instantly.
-The three most commonly used functions are:::
-
-    >>> from zope.component import provideAdapter
-    >>> from zope.component import provideUtility
-    >>> from zope.component import provideHandler
-
-See the `zope.component`_ documentation for details about how to use these.
-
-When registering global components like this, it is important to avoid test leakage.
-The ``cleanup`` mechanism outlined above can be used to tear down the component registry between each test.
-See also the ``plone.testing.zca.UNIT_TESTING`` layer, described below, which performs this cleanup automatically via the ``testSetUp()``/``testTearDown()`` mechanism.
-
-Alternatively, you can "stack" a new global component registry using the ``plone.testing.zca.pushGlobalRegistry()`` and ``plone.testing.zca.popGlobalRegistry()`` helpers.
-This makes it possible to set up and tear down components that are specific to a given layer, and even allow tests to safely call the global component API (or load ZCML - see below) with proper tear-down.
-See the layer reference below for details.
-
-Loading ZCML
-------------
-
-Integration tests often need to load ZCML configuration.
-This can be achieved using the ``zope.configuration`` API.::
-
-    >>> from zope.configuration import xmlconfig
-
-The ``xmlconfig`` module contains two methods for loading ZCML.
-
-``xmlconfig.string()`` can be used to load a literal string of ZCML:::
-
-    >>> xmlconfig.string("""\
-    ... <configure xmlns="http://namespaces.zope.org/zope" package="plone.testing">
-    ...     <include package="zope.component" file="meta.zcml" />
-    ... </configure>
-    ... """)
-    <zope.configuration.config.ConfigurationMachine object at ...>
-
-Note that we need to set a package (used for relative imports and file locations) explicitly here, using the ``package`` attribute of the ``<configure />`` element.
-
-Also note that unless the optional second argument (``context``) is passed, a new configuration machine will be created every time ``string()`` is called.
-It therefore becomes necessary to explicitly ``<include />`` the files that contain the directives you want to use (the one in ``zope.component`` is a common example).
-Layers that set up ZCML configuration may expose a resource which can be passed as the ``context`` parameter, usually called ``configurationContext`` - see below.
-
-To load the configuration for a particular package, use ``xmlconfig.file()``:::
-
-    >>> import zope.component
-    >>> context = xmlconfig.file('meta.zcml', zope.component)
-    >>> xmlconfig.file('configure.zcml', zope.component, context=context)
-    <zope.configuration.config.ConfigurationMachine object at ...>
-
-This takes two required arguments: the file name and the module relative to which it is to be found.
-Here, we have loaded two files: ``meta.zcml`` and ``configure.zcml``.
-The first call to ``xmlconfig.file()`` creates and returns a configuration context.
-We re-use that for the subsequent invocation, so that the directives configured are available.
-
-Installing a Zope 2 product
----------------------------
-
-Some packages (including all those in the ``Products.*`` namespace) have the special status of being Zope 2 "products".
-These are recorded in a special registry, and may have an ``initialize()`` hook in their top-level ``__init__.py`` that needs to be called for the package to be fully configured.
-
-Zope 2 will find and execute any products during startup.
-For testing, we need to explicitly list the products to install.
-Provided you are using ``plone.testing`` with Zope 2, you can use the following:::
-
-    from plone.testing import z2
-
-    with z2.zopeApp() as app:
-        z2.installProduct(app, 'Products.ZCatalog')
-
-This would normally be used during layer ``setUp()``.
-Note that the basic Zope 2 application context must have been set up before doing this.
-The usual way to ensure this, is to use a layer that is based on ``z2.STARTUP`` - see below.
-
-To tear down such a layer, you should do:::
-
-    from plone.testing import z2
-
-    with z2.zopeApp() as app:
-        z2.uninstallProduct(app, 'Products.ZCatalog')
-
-Note:
-
-* Unlike the similarly-named function from ``ZopeTestCase``, these helpers will work with any type of product.
-  There is no distinction between a "product" and a "package" (and no ``installPackage()``).
-  However, you must use the full name (``Products.*``) when registering a product.
-
-* Installing a product in this manner is independent of ZCML configuration.
-  However, it is almost always necessary to install the package's ZCML configuration first.
-
-Functional testing
-------------------
-
-For functional tests that aim to simulate the browser, you can use `zope.testbrowser`_ in a Python test or doctest:::
-
-    >>> from zope.testbrowser.browser import Browser
-    >>> browser = Browser()
-
-This provides a simple API to simulate browser input, without actually running a web server thread or scripting a live browser (as tools such as Windmill and Selenium do).
-The downside is that it is not possible to test JavaScript- dependent behaviour.
-
-If you are testing a Zope 2 application, you need to change the import location slightly, and pass the application root to the method:::
-
-    from plone.testing.z2 import Browser
-    browser = Browser(app)
-
-You can get the application root from the ``app`` resource in any of the Zope 2 layers in this package.
-
-Beyond that, the `zope.testbrowser`_ documentation should cover how to use the test browser.
-
-    **Hint:** The test browser will usually commit at the end of a request.
-    To avoid test fixture contamination, you should use a layer that fully isolates each test, such as the ``z2.INTEGRATION_TESTING`` layer described below.
-
-Layer reference
-===============
-
-``plone.testing`` comes with several layers that are available to use directly or extend.
-These are outlined below.
-
-Zope Component Architecture
----------------------------
-
-The Zope Component Architecture layers are found in the module ``plone.testing.zca``.
-If you depend on this, you can use the ``[zca]`` extra when depending on ``plone.testing``.
-
-Unit testing
-~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.zca.UNIT_TESTING``               |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zca.UnitTesting``                |
-+------------+--------------------------------------------------+
-| Bases:     | None                                             |
-+------------+--------------------------------------------------+
-| Resources: | None                                             |
-+------------+--------------------------------------------------+
-
-This layer does not set up a fixture per se, but cleans up global state before and after each test, using ``zope.testing.cleanup`` as described above.
-
-The net result is that each test has a clean global component registry.
-Thus, it is safe to use the `zope.component`_ Python API (``provideAdapter()``, ``provideUtility()``, ``provideHandler()`` and so on) to register components.
-
-Be careful with using this layer in combination with other layers.
-Because it tears down the component registry between each test, it will clobber any layer that sets up more permanent test fixture in the component registry.
-
-Event testing
-~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.zca.EVENT_TESTING``              |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zca.EventTesting``               |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.zca.UNIT_TESTING``               |
-+------------+--------------------------------------------------+
-| Resources: | None                                             |
-+------------+--------------------------------------------------+
-
-This layer extends the ``zca.UNIT_TESTING`` layer to enable the ``eventtesting`` support from ``zope.component``.
-Using this layer, you can import and use ``zope.component.eventtesting.getEvent`` to inspect events fired by the code under test.
-
-See above for details.
-
-Layer cleanup
-~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.zca.LAYER_CLEANUP``              |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zca.LayerCleanup``               |
-+------------+--------------------------------------------------+
-| Bases:     | None                                             |
-+------------+--------------------------------------------------+
-| Resources: | None                                             |
-+------------+--------------------------------------------------+
-
-This layer calls the cleanup functions from ``zope.testing.cleanup`` on setup and tear-down (but not between each test).
-It is useful as a base layer for other layers that need an environment as pristine as possible.
-
-Basic ZCML directives
-~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.zca.ZCML_DIRECTIVES``            |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zca.ZCMLDirectives``             |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |
-+------------+--------------------------------------------------+
-| Resources: | ``configurationContext``                         |
-+------------+--------------------------------------------------+
-
-This registers a minimal set of ZCML directives, principally those found in the ``zope.component`` package, and makes available a configuration context.
-This allows custom ZCML to be loaded as described above.
-
-The ``configurationContext`` resource should be used when loading custom ZCML.
-To ensure isolation, you should stack this using the ``stackConfigurationContext()`` helper.
-For example, if you were writing a ``setUp()`` method in a layer that had ``zca.ZCML_DIRECTIVES`` as a base, you could do:::
-
-    self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
-    xmlconfig.string(someZCMLString, context=context)
-
-This will create a new configuration context with the state of the base layer's context.
-On tear-down, you should delete the layer-specific resource:::
-
-    del self['configurationContext']
-
-.. note::
-
-   If you fail to do this, you may get problems if your layer is torn down and then needs to be set up again later.
-
-See above for more details about loading custom ZCML in a layer or test.
-
-ZCML files helper class
-~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zca.ZCMLSandbox``                |
-+------------+--------------------------------------------------+
-| Resources: | ``configurationContext``                         |
-+------------+--------------------------------------------------+
-
-The ``ZCMLSandbox`` can be instantiated with a ``filename`` and ``package`` arguments::
-
-    ZCML_SANDBOX = zca.ZCMLSandbox(filename="configure.zcml",
-        package=my.package)
-
-
-That layer ``setUp`` loads the ZCML file.
-It avoids the need to using (and understand) ``configurationContext`` and ``globalRegistry`` until you need more flexibility or modularity for your layer and tests.
-
-See above for more details about loading custom ZCML in a layer or test.  
-
-Helper functions
-~~~~~~~~~~~~~~~~
-
-The following helper functions are available in the ``plone.testing.zca`` module.
-
-``stackConfigurationContext(context=None)``
-
-    Create and return a copy of the passed-in ZCML configuration context, or a brand new context if it is ``None``.
-
-    The purpose of this is to ensure that if a layer loads some ZCML files (using the ``zope.configuration`` API during) during its ``setUp()``, the state of the configuration registry (which includes registered directives as well as a list of already imported files, which will not be loaded again even if explicitly included) can be torn down during ``tearDown()``.
-
-    The usual pattern is to keep the configuration context in a layer resource called ``configurationContext``.
-    In ``setUp()``, you would then use::
-
-        self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
-
-        # use 'context' to load some ZCML
-
-    In ``tearDown()``, you can then simply do::
-
-        del self['configurationContext']
-
-``pushGlobalRegistry(new=None)``
-
-    Create or obtain a stack of global component registries, and push a new registry to the top of the stack.
-    The net result is that ``zope.component.getGlobalSiteManager()`` and (an un-hooked) ``getSiteManager()`` will return the new registry instead of the default, module-scope one.
-    From this point onwards, calls to ``provideAdapter()``, ``provideUtility()`` and other functions that modify the global registry will use the new registry.
-
-    If ``new`` is not given, a new registry is created that has the previous global registry (site manager) as its sole base.
-    This has the effect that registrations in the previous default global registry are still available, but new registrations are confined to the new registry.
-
-    **Warning**: If you call this function, you *must* reciprocally call ``popGlobalRegistry()``.
-    That is, if you "push" a registry during layer ``setUp()``, you must "pop" it during ``tearDown()``.
-    If you "push" during ``testSetUp()``, you must "pop" during ``testTearDown()``.
-    If the calls to push and pop are not balanced, you will leave your global registry in a mess, which is not pretty.
-
-    Returns the new default global site manager.
-    Also causes the site manager hook from ``zope.site`` to be reset, clearing any local site managers as appropriate.
-
-``popGlobalRegistry()``
-
-    Pop the global site registry, restoring the previous registry to be the default.
-
-    Please heed the warning above: push and pop must be balanced.
-
-    Returns the new default global site manager.
-    Also causes the site manager hook from ``zope.site`` to be reset, clearing any local site managers as appropriate.
-
-Zope Security
--------------
-
-The Zope Security layers build can be found in the module ``plone.testing.security``.
-
-If you depend on this, you can use the ``[security]`` extra when depending on ``plone.testing``.
-
-Security checker isolation
-~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.security.CHECKERS``              |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.security.Checkers``              |
-+------------+--------------------------------------------------+
-| Bases:     | None                                             |
-+------------+--------------------------------------------------+
-| Resources: | None                                             |
-+------------+--------------------------------------------------+
-
-This layer ensures that security checkers used by ``zope.security`` are isolated.
-Any checkers set up in a child layer will be removed cleanly during tear-down.
-
-Helper functions
-~~~~~~~~~~~~~~~~
-
-The security checker isolation outlined above is managed using two helper functions found in the module ``plone.testing.security``:
-
-``pushCheckers()``
-
-    Copy the current set of security checkers for later tear-down.
-
-``popCheckers()``
-
-    Restore the set of security checkers to the state of the most recent call to ``pushCheckers()``.
-
-You *must* keep calls to ``pushCheckers()`` and ``popCheckers()`` in balance.
-That usually means that if you call the former during layer setup, you should call the latter during layer tear-down.
-Ditto for calls during test setup/tear-down or within tests themselves.
-
-Zope Publisher
---------------
-
-The Zope Publisher layers build on the Zope Component Architecture layers.
-They can be found in the module ``plone.testing.publisher``.
-
-If you depend on this, you can use the ``[publisher]`` extra when depending on ``plone.testing``.
-
-Publisher directives
-~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.publisher.PUBLISHER_DIRECTIVES`` |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.publisher.PublisherDirectives``  |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.zca.ZCML_DIRECTIVES``            |
-+------------+--------------------------------------------------+
-| Resources: | None                                             |
-+------------+--------------------------------------------------+
-
-This layer extends the ``zca.ZCML_DIRECTIVES`` layer to install additional ZCML directives in the ``browser`` namespace (from ``zope.app.publisher.browser``) as well as those from ``zope.security``.
-This allows browser views, browser pages and other UI components to be registered, as well as the definition of new permissions.
-
-As with ``zca.ZCML_DIRECTIVES``, you should use the ``configurationContext`` resource when loading ZCML strings or files, and the ``stackConfigurationRegistry()`` helper to create a layer-specific version of this resource resource.
-See above.
-
-ZODB
-----
-
-The ZODB layers set up a test fixture with a persistent ZODB.
-The ZODB instance uses ``DemoStorage``, so it will not interfere with any "live" data.
-
-ZODB layers can be found in the module ``plone.testing.zodb``.
-If you depend on this, you can use the ``[zodb]`` extra when depending on ``plone.testing``.
-
-Empty ZODB sandbox
-~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.zodb.EMPTY_ZODB``                |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zodb.EmptyZODB``                 |
-+------------+--------------------------------------------------+
-| Bases:     |  None                                            |
-+------------+--------------------------------------------------+
-| Resources: | ``zodbRoot``                                     |
-|            +--------------------------------------------------+
-|            | ``zodbDB`` (test set-up only)                    |
-|            +--------------------------------------------------+
-|            | ``zodbConnection`` (test set-up only)            |
-+------------+--------------------------------------------------+
-
-This layer sets up a simple ZODB sandbox using ``DemoStorage``.
-The ZODB root object is a simple persistent mapping, available as the resource ``zodbRoot``.
-The ZODB database object is available as the resource ``zodbDB``.
-The connection used in the test is available as ``zodbConnection``.
-
-Note that the ``zodbConnection`` and ``zodbRoot`` resources are created and destroyed for each test.
-You can use ``zodbDB`` (and the ``open()`` method) if you are writing a layer based on this one and need to set up a fixture during layer set up.
-Don't forget to close the connection before concluding the test setup!
-
-A new transaction is begun for each test, and rolled back (aborted) on test tear-down.
-This means that so long as you don't use ``transaction.commit()`` explicitly in your code, it should be safe to add or modify items in the ZODB root.
-
-If you want to create a test fixture with persistent data in your own layer based on ``EMPTY_ZODB``, you can use the following pattern::
-
-    from plone.layer import Layer
-    from plone.layer import zodb
-
-    class MyLayer(Layer):
-        defaultBases = (zodb.EMPTY_ZODB,)
-
-        def setUp(self):
-
-            import transaction
-            self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
-
-            conn = db.open()
-            root = conn.root()
-
-            # modify the root object here
-
-            transaction.commit()
-            conn.close()
-
-        def tearDown(self):
-
-            self['zodbDB'].close()
-            del self['zodbDB']
-
-This shadows the ``zodbDB`` resource with a new database that uses a new ``DemoStorage`` stacked on top of the underlying database storage.
-The fixture is added to this storage and committed during layer setup.
-(The base layer test set-up/tear-down will still begin and abort a new transaction for each *test*).
-On layer tear-down, the database is closed and the resource popped, leaving the original ``zodbDB`` database with the original, pristine storage.
-
-Helper functions
-~~~~~~~~~~~~~~~~
-
-One helper function is available in the ``plone.testing.zodb`` module.
-
-``stackDemoStorage(db=None, name=None)``
-
-    Create a new ``DemoStorage`` using the storage from the passed-in database as a base.
-    If ``db`` is None, a brand new storage is created.
-
-    A ``name`` can be given to uniquely identify the storage.
-    It is optional, but it is often useful for debugging purposes to pass the name of the layer.
-
-    The usual pattern is::
-
-        def setUp(self):
-            self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
-
-        def tearDown(self):
-            self['zodbDB'].close()
-            del self['zodbDB']
-
-    This will shadow the ``zodbDB`` resource with an isolated ``DemoStorage``, creating a new one if that resource does not already exist.
-    All existing data continues to be available, but new changes are written to the stacked storage.
-    On tear-down, the stacked database is closed and the resource removed, leaving the original data.
-
-Zope 2
-------
-
-The Zope 2 layers provide test fixtures suitable for testing Zope 2 applications.
-They set up a Zope 2 application root, install core Zope 2 products, and manage security.
-
-Zope 2 layers can be found in the module ``plone.testing.z2``.
-If you depend on this, you can use the ``[z2]`` extra when depending on ``plone.testing``.
-
-Startup
-~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.STARTUP``                     |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.Startup``                     |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |
-+------------+--------------------------------------------------+
-| Resources: | ``zodbDB``                                       |
-|            +--------------------------------------------------+
-|            | ``configurationContext``                         |
-|            +--------------------------------------------------+
-|            | ``host``                                         |
-|            +--------------------------------------------------+
-|            | ``port``                                         |
-+------------+--------------------------------------------------+
-
-This layer sets up a Zope 2 environment, and is a required base for all other Zope 2 layers.
-You cannot run two instances of this layer in parallel, since Zope 2 depends on some module-global state to run, which is managed by this layer.
-
-On set-up, the layer will configure a Zope environment with:
-
-.. note::
-
-    The ``STARTUP`` layer is a useful base layer for your own fixtures, but should not be used directly, since it provides no test lifecycle or transaction management.
-    See the "Integration test" and "Functional" test sections below for examples of how to create your own layers.
-
-* Debug mode enabled.
-
-* ZEO client cache disabled.
-
-* Some patches installed, which speed up Zope startup by disabling the help system and some other superfluous aspects of Zope.
-
-* One thread (this only really affects the ``ZSERVER`` and ``FTP_SERVER`` layers).
-
-* A pristine database using ``DemoStorage``, exposed as the resource ``zodbDB``.
-  Zope is configured to use this database in a way that will also work if the ``zodbDB`` resource is shadowed using the pattern shown above in the description of the ``zodb.EMPTY_ZODB`` layer.
-
-* A fake hostname and port, exposed as the ``host`` and ``port`` resource, respectively.
-
-* A minimal set of products installed (``Products.OFSP`` and ``Products.PluginIndexes``, both required for Zope to start up).
-
-* A stacked ZCML configuration context, exposed as the resource ``configurationContext``.
-  As illustrated above, you should use the ``zca.stackConfigurationContext()`` helper to stack your own configuration context if you use this.
-
-* A minimal set of global Zope components configured.
-
-Note that unlike a "real" Zope site, products in the ``Products.*`` namespace are not automatically loaded, nor is any ZCML.
-
-Integration test
-~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.INTEGRATION_TESTING``         |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.IntegrationTesting``          |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.STARTUP``                     |
-+------------+--------------------------------------------------+
-| Resources: | ``app``                                          |
-|            +--------------------------------------------------+
-|            | ``request``                                      |
-+------------+--------------------------------------------------+
-
-This layer is intended for integration testing against the simple ``STARTUP`` fixture.
-If you want to create your own layer with a more advanced, shared fixture, see "Integration and functional testing with custom fixtures" below.
-
-For each test, it exposes the Zope application root as the resource ``app``.
-This is wrapped in the request container, so you can do ``app.REQUEST`` to acquire a fake request, but the request is also available as the resource ``request``.
-
-A new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.
-
-    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``z2.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.
-
-    Once you've shadowed the ``zodbDB`` resource, you can do (e.g. in your layer's ``setUp()`` method)::
-
-        ...
-        with z2.zopeApp() as app:
-            # modify the Zope application root
-
-    The ``zopeApp()`` context manager will open a new connection to the Zope application root, accessible here as ``app``.
-    Provided the code within the ``with`` block does not raise an exception, the transaction will be committed and the database closed properly upon exiting the block.
-
-Functional testing
-~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.FUNCTIONAL_TESTING``          |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.FunctionalTesting``           |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.STARTUP``                     |
-+------------+--------------------------------------------------+
-| Resources: | ``app``                                          |
-|            +--------------------------------------------------+
-|            | ``request``                                      |
-+------------+--------------------------------------------------+
-
-This layer is intended for functional testing against the simple ``STARTUP`` fixture.
-If you want to create your own layer with a more advanced, shared fixture, see "Integration and functional testing with custom fixtures" below.
-
-As its name implies, this layer is intended mainly for functional end-to-end testing using tools like `zope.testbrowser`_.
-See also the ``Browser`` object as described under "Helper functions" below.
-
-This layer is very similar to ``INTEGRATION_TESTING``, but is not based on it.
-It sets up the same fixture and exposes the same resources.
-However, instead of using a simple transaction abort to isolate the ZODB between tests, it uses a stacked ``DemoStorage`` for each test.
-This is slower, but allows test code to perform and explicit commit, as will usually happen in a functional test.
-
-Integration and functional testing with custom fixtures
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-If you want to extend the ``STARTUP`` fixture for use with integration or functional testing, you should use the following pattern:
-
-* Create a layer class and a "fixture" base layer instance that has ``z2.STARTUP`` (or some intermediary layer, such as ``z2.ZSERVER_FIXTURE`` or ``z2.FTP_SERVER_FIXTURE``, shown below) as a base.
-
-* Create "end user" layers by instantiating the ``z2.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new "fixture" layer as a base.
-
-This allows the same fixture to be used regardless of the "style" of testing, minimising the amount of set-up and tear-down.
-The "fixture" layers manage the fixture as part of the *layer* lifecycle.
-The layer class (``IntegrationTesting`` or ``FunctionalTesting``), manages the *test* lifecycle, and the test lifecycle only.
-
-For example::
-
-    from plone.testing import Layer, z2, zodb
-
-    class MyLayer(Layer):
-        defaultBases = (z2.STARTUP,)
-
-        def setUp(self):
-            # Set up the fixture here
-            ...
-
-        def tearDown(self):
-            # Tear down the fixture here
-            ...
-
-    MY_FIXTURE = MyLayer()
-
-    MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")
-    MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")
-
-(Note that we need to give an explicit, unique name to the two layers that re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)
-
-In this example, other layers could extend the "MyLayer" fixture by using ``MY_FIXTURE`` as a base.
-Tests would use either ``MY_INTEGRATION_TESTING`` or ``MY_FUNCTIONAL_TESTING`` as appropriate.
-However, even if both these two layers were used, the fixture in ``MY_FIXTURE`` would only be set up once.
-
-.. note::
-
-    If you implement the ``testSetUp()`` and ``testTearDown()`` test lifecycle methods in your "fixture" layer (e.g. in the the ``MyLayer`` class above), they will execute before the corresponding methods from ``IntegrationTesting`` and ``FunctionalTesting``.
-    Hence, they cannot use those layers' resources (``app`` and ``request``).
-
-It may be preferable, therefore, to have your own "test lifecycle" layer classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and call base class methods as appropriate.
-``plone.app.testing`` takes this approach, for example.
-
-HTTP ZServer thread (fixture only)
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.ZServer``                     |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.STARTUP``                     |
-+------------+--------------------------------------------------+
-| Resources: | ``host``                                         |
-|            +--------------------------------------------------+
-|            | ``port``                                         |
-+------------+--------------------------------------------------+
-
-This layer extends the ``z2.STARTUP`` layer to start the Zope HTTP server in a separate thread.
-This means the test site can be accessed through a web browser, and can thus be used with tools like `Windmill`_ or `Selenium`_.
-
-.. note::
-
-    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.
-    Use the ``ZSERVER`` layer if you want to execute functional tests against this fixture.
-
-The ZServer's hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.
-
-  *Hint:* Whilst the layer is set up, you can actually access the test Zope site through a web browser.
-  The default URL will be ``http://localhost:55001``.
-
-HTTP ZServer functional testing
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.ZSERVER``                     |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.FunctionalTesting``           |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |
-+------------+--------------------------------------------------+
-| Resources: |                                                  |
-+------------+--------------------------------------------------+
-
-This layer provides the functional testing lifecycle against the fixture set up by the ``z2.ZSERVER_FIXTURE`` layer.
-
-You can use this to run "live" functional tests against a basic Zope site.
-You should **not** use it as a base.
-Instead, create your own "fixture" layer that extends ``z2.ZSERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.
-
-FTP server thread (fixture only)
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.FTPServer``                   |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.STARTUP``                     |
-+------------+--------------------------------------------------+
-| Resources: | ``host``                                         |
-|            +--------------------------------------------------+
-|            | ``port``                                         |
-+------------+--------------------------------------------------+
-
-This layer is the FTP server equivalent of the ``ZSERVER_FIXTURE`` layer.
-It can be used to functionally test Zope servers.
-
-.. note::
-
-    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.
-    Use the ``FTP_SERVER`` layer if you want to execute functional tests against this fixture.
-
-    *Hint:* Whilst the layer is set up, you can actually access the test Zope site through an FTP client.
-    The default URL will be ``ftp://localhost:55002``.
-
-.. warning::
-
-    Do not run the ``FTP_SERVER`` and ``ZSERVER`` layers concurrently in the same process.
-
-If you need both ZServer and FTPServer running together, you can subclass the ``ZServer`` layer class (like the ``FTPServer`` layer class does) and implement the ``setUpServer()`` and ``tearDownServer()`` methods to set up and close down two servers on different ports.
-They will then share a main loop.
-
-FTP server functional testing
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.FTP_SERVER``                  |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.FunctionalTesting``           |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |
-+------------+--------------------------------------------------+
-| Resources: |                                                  |
-+------------+--------------------------------------------------+
-
-This layer provides the functional testing lifecycle against the fixture set up by the ``z2.FTP_SERVER_FIXTURE`` layer.
-
-You can use this to run "live" functional tests against a basic Zope site.
-You should **not** use it as a base.
-Instead, create your own "fixture" layer that extends ``z2.FTP_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.
-
-Helper functions
-~~~~~~~~~~~~~~~~
-
-Several helper functions are available in the ``plone.testing.z2`` module.
-
-``zopeApp(db=None, conn=Non, environ=None)``
-
-    This function can be used as a context manager for any code that requires access to the Zope application root.
-    By using it in a ``with`` block, the database will be opened, and the application root will be obtained and request-wrapped.
-    When exiting the ``with`` block, the transaction will be committed and the database properly closed, unless an exception was raised::
-
-        with z2.zopeApp() as app:
-            # do something with app
-
-    If you want to use a specific database or database connection, pass either the ``db`` or ``conn`` arguments.
-    If the context manager opened a new connection, it will close it, but it will not close a connection passed with ``conn``.
-
-    To set keys in the (fake) request environment, pass a dictionary of environment values as ``environ``.
-
-    Note that ``zopeApp()`` should *not* normally be used in tests or test set-up/tear-down, because the ``INTEGRATOIN_TEST`` and ``FUNCTIONAL_TESTING`` layers both manage the application root (as the ``app`` resource) and close it for you.
-    It is very useful in layer setup, however.
-
-``installProduct(app, product, quiet=False)``
-
-    Install a Zope 2 style product, ensuring that its ``initialize()`` function is called.
-    The product name must be the full dotted name, e.g. ``plone.app.portlets`` or ``Products.CMFCore``.
-    If ``quiet`` is true, duplicate registrations will be ignored silently, otherwise a message is logged.
-
-    To get hold of the application root, passed as the ``app`` argument, you would normally use the ``zopeApp()`` context manager outlined above.
-
-``uninstallProduct(app, product, quiet=False)``
-
-    This is the reciprocal of ``installProduct()``, normally used during layer tear-down.
-    Again, you should use ``zopeApp()`` to obtain the application root.
-
-``login(userFolder, userName)``
-
-    Create a new security manager that simulates being logged in as the given user.
-    ``userFolder`` is an ``acl_users`` object, e.g. ``app['acl_users']`` for the root user folder.
-
-``logout()``
-
-    Simulate being the anonymous user by unsetting the security manager.
-
-``setRoles(userFolder, userName, roles)``
-
-    Set the roles of the given user in the given user folder to the given list of roles.
-
-``makeTestRequest()``
-
-    Create a fake Zope request.
-
-``addRequestContainer(app, environ=None)``
-
-    Create a fake request and wrap the given object (normally an application root) in a ``RequestContainer`` with this request.
-    This makes acquisition of ``app.REQUEST`` possible.
-    To initialise the request environment with non-default values, pass a dictionary as ``environ``.
-
-    .. note::
-    
-       This method is rarely used, because both the ``zopeApp()``
-       context manager and the layer set-up/tear-down for
-       ``z2.INTEGRATION_TESTING`` and ``z2.FUNCTIONAL_TESTING`` will wrap the
-       ``app`` object before exposing it.
-
-``Browser(app)``
-
-    Obtain a test browser client, for use with `zope.testbrowser`_.
-    You should use this in conjunction with the ``z2.FUNCTIONAL_TESTING`` layer or a derivative.
-    You must pass the app root, usually obtained from the ``app`` resource of the layer, e.g.::
-
-        app = self.layer['app']
-        browser = z2.Browser(app)
-
-    You can then use ``browser`` as described in the `zope.testbrowser`_ documentation.
-
-    Bear in mind that the test browser runs separately from the test fixture.
-    In particular, calls to helpers such as ``login()`` or ``logout()`` do not affect the state that the test browser sees.
-    If you want to set up a persistent fixture (e.g. test content), you can do so before creating the test browser, but you will need to explicitly commit your changes, with::
-
-        import transaction
-        transaction.commit()
-
-.. _zope.testing: http://pypi.python.org/pypi/zope.testing
-.. _zope.testbrowser: http://pypi.python.org/pypi/zope.testbrowser
-.. _zope.component: http://pypi.python.org/pypi/zope.component
-.. _zope.publisher: http://pypi.python.org/pypi/zope.publisher
-.. _plone.app.testing: http://pypi.python.org/pypi/plone.app.testing
-.. _zc.recipe.testrunner: http://pypi.python.org/pypi/zc.recipe.testrunner
-.. _coverage: http://pypi.python.org/pypi/coverage
-.. _Cobertura: http://wiki.hudson-ci.org/display/HUDSON/Cobertura+Plugin
-.. _Hudson: http://www.hudson-labs.org/
-.. _unittest: http://doc.python.org/library/unittest.html
-.. _unittest2: http://pypi.python.org/pypi/unittest2
-.. _doctest: http://docs.python.org/dev/library/doctest.html
-.. _Windmill: http://getwindmill.com/
-.. _Selenium: http://seleniumhq.org/
diff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py
index 5815f08..ca99bd9 100644
--- a/src/plone/testing/tests.py
+++ b/src/plone/testing/tests.py
@@ -78,7 +78,7 @@ def test_suite():
             optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,
         ),
         doctest.DocFileSuite(
-            'README.rst',
+            '../../../docs/overview.rst',
             globs={'canOutrunKlingons': _canOutrunKlingons, },
             setUp=setUp,
             tearDown=tearDown,


Repository: plone.testing


Branch: refs/heads/master
Date: 2015-12-11T01:32:49+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/758784eb8794fa8350651a4fb603c17087a0428d

missing changelog

Files changed:
M CHANGES.rst

diff --git a/CHANGES.rst b/CHANGES.rst
index 181f93c..b923bf9 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,7 +10,9 @@ New:
 
 Fixes:
 
-- Rename all txt doctest files to rst.
+
+- Rename all txt doctest files to rst. Reformat doctests.
+  Move src/plone/testing/README.rst to docs/overview.rst.
   [thet]
 
 - PEP 8.


Repository: plone.testing


Branch: refs/heads/master
Date: 2015-12-11T01:46:58+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/e29c992a6d435b8e2f3d2cd4afb84195c0d4fc3e

fix toctree link

Files changed:
M docs/index.rst

diff --git a/docs/index.rst b/docs/index.rst
index 3a66a55..1092666 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -10,7 +10,7 @@ Contents
 .. toctree::
    :maxdepth: 2
 
-   ../src/plone/testing/overview.rst
+   overview.rst
    ../src/plone/testing/layer.rst
    ../src/plone/testing/publisher.rst
    ../src/plone/testing/security.rst


Repository: plone.testing


Branch: refs/heads/master
Date: 2015-12-11T01:49:41+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/0ca838b6230b041f22d62384ccf7722d07c7e658

omit heading level

Files changed:
M docs/index.rst

diff --git a/docs/index.rst b/docs/index.rst
index 1092666..cc51ee7 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -3,10 +3,6 @@ plone.testing documentation
 
 Documentation for the testing infrastructure for Zope and Plone projects.
 
-
-Contents
---------
-
 .. toctree::
    :maxdepth: 2
 


Repository: plone.testing


Branch: refs/heads/master
Date: 2015-12-11T01:55:34+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/a5e4fe4d2ec5ca2c7a67efece67e15a627124618

Merge pull request #17 from plone/thet-cleanup

doctests cleanup

Files changed:
A docs/index.rst
A docs/overview.rst
A src/plone/testing/layer.rst
A src/plone/testing/publisher.rst
A src/plone/testing/security.rst
A src/plone/testing/z2.rst
A src/plone/testing/zca.rst
A src/plone/testing/zodb.rst
M CHANGES.rst
M MANIFEST.in
M README.rst
M setup.py
M src/plone/__init__.py
M src/plone/testing/__init__.py
M src/plone/testing/_z2_testbrowser.py
M src/plone/testing/layer.py
M src/plone/testing/publisher.py
M src/plone/testing/security.py
M src/plone/testing/testing_zca.zcml
M src/plone/testing/testing_zca_more_specific.zcml
M src/plone/testing/tests.py
M src/plone/testing/z2.py
M src/plone/testing/zca.py
M src/plone/testing/zodb.py
D src/plone/testing/README.rst
D src/plone/testing/layer.txt
D src/plone/testing/publisher.txt
D src/plone/testing/security.txt
D src/plone/testing/z2.txt
D src/plone/testing/zca.txt
D src/plone/testing/zodb.txt

diff --git a/CHANGES.rst b/CHANGES.rst
index 9ad20c9..b923bf9 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,7 +10,14 @@ New:
 
 Fixes:
 
-- *add item here*
+
+- Rename all txt doctest files to rst. Reformat doctests.
+  Move src/plone/testing/README.rst to docs/overview.rst.
+  [thet]
+
+- PEP 8.
+  [thet]
+
 - Depend on zope.testrunner, which was moved out from
   zope.testing.testrunner.
   [thet]
diff --git a/MANIFEST.in b/MANIFEST.in
index 2ab7cc5..c0525da 100644
--- a/MANIFEST.in
+++ b/MANIFEST.in
@@ -1,5 +1,4 @@
 include *.rst
-include *.txt
 
 recursive-include docs *
 recursive-include src *
diff --git a/README.rst b/README.rst
index 9773da5..bc246dc 100644
--- a/README.rst
+++ b/README.rst
@@ -1 +1,6 @@
-# See src/plone/testing/README.txt
\ No newline at end of file
+plone.testing
+=============
+
+Testing infrastructure for Zope and Plone projects.
+
+For more information see docs/index.rst
diff --git a/docs/index.rst b/docs/index.rst
new file mode 100644
index 0000000..cc51ee7
--- /dev/null
+++ b/docs/index.rst
@@ -0,0 +1,16 @@
+plone.testing documentation
+===========================
+
+Documentation for the testing infrastructure for Zope and Plone projects.
+
+.. toctree::
+   :maxdepth: 2
+
+   overview.rst
+   ../src/plone/testing/layer.rst
+   ../src/plone/testing/publisher.rst
+   ../src/plone/testing/security.rst
+   ../src/plone/testing/z2.rst
+   ../src/plone/testing/zca.rst
+   ../src/plone/testing/zodb.rst
+
diff --git a/docs/overview.rst b/docs/overview.rst
new file mode 100644
index 0000000..5057086
--- /dev/null
+++ b/docs/overview.rst
@@ -0,0 +1,1951 @@
+Introduction
+============
+
+.. contents:: Table of contents
+
+``plone.testing`` provides tools for writing unit and integration tests in a Zope and Plone environment.
+It is not tied to Plone, and it does not depend on Zope 2 (although it has some optional Zope 2-only features).
+
+``plone.testing`` builds on `zope.testing`_, in particular its layers concept.
+This package also aims to promote some "good practice" for writing tests of various types.
+
+.. note::
+
+   If you are working with Plone, there is a complementary package `plone.app.testing`_, which builds on ``plone.testing`` to provide additional layers useful for testing Plone add-ons.
+
+If you are new to automated testing and test driven development, you should spend some time learning about those concepts.
+Some useful references include:
+
+* `The Wikipedia article on unit testing <http://en.wikipedia.org/wiki/Unit_testing>`_
+* `The Dive Into Python chapter on testing <http://diveintopython.net/unit_testing/index.html>`_
+
+Bear in mind that different Python frameworks have slightly different takes on how to approach testing.
+Therefore, you may find examples that are different to those shown below.
+The core concepts should be consistent, however.
+
+Compatibility
+-------------
+
+``plone.testing`` 4.x has only been tested with Python 2.6 and 2.7.
+If you're using the optional Zope 2 layers, you must use Zope version 2.12 or later.
+Look at ``plone.testing`` 3.x for Zope 2.10 support.
+
+Definitions
+-----------
+
+In this documentation, we will use a number of testing-related terms.
+The following definitions apply:
+
+Unit test
+
+    An automated test (i.e. one written in code) that tests a single unit (normally a function) in isolation.
+    A unit test attempts to prove that the given function works as expected and gives the correct output given a particular input.
+    It is common to have a number of unit tests for a single function, testing different inputs, including boundary cases and errors.
+    Unit tests are typically quick to write and run.
+
+Integration test
+
+    An automated test that tests how a number of units interact.
+    In a Zope context, this often pertains to how a particular object or view interacts with the Zope framework, the ZODB persistence engine, and so on.
+    Integration tests usually require some setup and can be slower to run than unit tests.
+    It is common to have fewer integration tests than unit test.
+
+Functional test
+
+    An automated test that tests a feature in an "end-to-end" fashion.
+    In a Zope context, that normally means that it invokes an action in the same way that a user would, i.e. through a web request.
+    Functional tests are normally slower to run than either unit or integration tests, and can be significantly slower to run.
+    It is therefore common to have only a few functional tests for each major feature, relying on unit and integration tests for the bulk of testing.
+
+Black box testing
+
+    Testing which only considers the system's defined inputs and outputs.
+    For example, a functional test is normally a black box test that provides inputs only through the defined interface (e.g. URLs published in a web application), and makes assertions only on end outputs (e.g. the response returned for requests to those URLs).
+
+White box testing
+
+    Testing which examines the internal state of a system to make assertions.
+    Authors of unit and integration tests normally have significant knowledge of the implementation of the code under test, and can examine such things as data in a database or changes to the system's environment to determine if the test succeeded or failed.
+
+Assertion
+
+    A check that determines whether a test succeeds or fails.
+    For example, if a unit test for the function ``foo()`` expects it to return the value 1, an assertion could be written to verify this fact.
+    A test is said to *fail* if any of its assertions fail.
+    A test always contains one or more assertions.
+
+Test case
+
+    A single unit, integration or functional test.
+    Often shortened to just *test*.
+    A test case sets up, executes and makes assertions against a single scenario that bears testing.
+
+Test fixture
+
+    The state used as a baseline for one or more tests.
+    The test fixture is *set up* before each test is executed, and *torn down* afterwards.
+    This is a pre-requisite for *test isolation* - the principle that tests should be independent of one another.
+
+Layer
+
+    The configuration of a test fixture shared by a number of tests.
+    All test cases that belong to a particular layer will be executed together.
+    The layer is *set up* once before the tests are executed, and *torn down* once after.
+    Layers may depend on one another.
+    Any *base layers* are set up before and torn down after a particular *child layer* is used.
+    The test runner will order test execution to minimise layer setup and tear-down.
+
+Test suite
+
+    A collection of test cases (and layers) that are executed together.
+
+Test runner
+
+    The program which executes tests.
+    This is responsible for calling layer and test fixture set-up and tear-down methods.
+    It also reports on the test run, usually by printing output to the console.
+
+Coverage
+
+    To have confidence in your code, you should ensure it is adequately covered by tests.
+    That is, each line of code, and each possible branching point (loops, ``if`` statements) should be executed by a test.
+    This is known as *coverage*, and is normally measured as a percentage of lines of non-test code covered by tests.
+    Coverage can be measured by the test runner, which keeps track of which lines of code were executed in a given test run.
+
+Doctest
+
+    A style of testing where tests are written as examples that could be typed into the interactive Python interpreter.
+    The test runner executes each example and checks the actual output against the expected output.
+    Doctests can either be placed in the docstring of a method, or in a separate file.
+    The use of doctests is largely a personal preference.
+    Some developers like to write documentation as doctests, which has the advantage that code samples can be automatically tested for correctness.
+    You can read more about doctests on `Wikipedia <http://en.wikipedia.org/wiki/Doctest>`_.
+
+Installation and usage
+======================
+
+To use ``plone.testing`` in your own package, you need to add it as a dependency.
+Most people prefer to keep test-only dependencies separate, so that they do not need to be installed in scenarios (such as on a production server) where the tests will not be run.
+This can be achieved using a ``test`` extra.
+
+In ``setup.py``, add or modify the ``extras_require`` option, like so:::
+
+    extras_require = {
+        'test': [
+                'plone.testing',
+            ]
+    },
+
+You can add other test-only dependencies to that list as well, of course.
+
+To run tests, you need a test runner.
+If you are using ``zc.buildout``, you can install a test runner using the `zc.recipe.testrunner`_ recipe.
+For example, you could add the following to your ``buildout.cfg``:::
+
+    [test]
+    recipe = zc.recipe.testrunner
+    eggs =
+        my.package [test]
+    defaults = ['--auto-color', '--auto-progress']
+
+You'll also need to add this part to the ``parts`` list, of course:::
+
+    [buildout]
+    parts =
+        ...
+        test
+
+In this example, have listed a single package to test, called ``my.package``, and asked for it to be installed with the ``[test]`` extra.
+This will install any regular dependencies (listed in the ``install_requires`` option in ``setup.py``), as well as those in the list associated with the ``test`` key in the ``extras_require`` option.
+
+Note that it becomes important to properly list your dependencies here, because the test runner will only be aware of the packages explicitly listed, and their dependencies.
+For example, if your package depends on Zope 2, you need to list ``Zope2`` in the ``install_requires`` list in ``setup.py``;
+ditto for ``Plone``, or indeed any other package you import from.
+
+Once you have re-run buildout, the test runner will be installed as ``bin/test`` (the executable name is taken from the name of the buildout part).
+You can execute it without arguments to run all tests of each egg listed in the ``eggs`` list::
+
+    $ bin/test
+
+If you have listed several eggs, and you want to run the tests for a particular one, you can do::
+
+    $ bin/test -s my.package
+
+If you want to run only a particular test within this package, use the ``-t`` option.
+This can be passed a regular expression matching either a doctest file name or a test method name.::
+
+    $ bin/test -s my.package -t test_spaceship
+
+There are other command line options, which you can find by running::
+
+    $ bin/test --help
+
+Also note the ``defaults`` option in the buildout configuration.
+This can be used to set default command line options.
+Some commonly useful options are shown above.
+
+Coverage reporting
+------------------
+
+When writing tests, it is useful to know how well your tests cover your code.
+You can create coverage reports via the excellent `coverage`_ library.
+In order to use it, we need to install it and a reporting script::
+
+    [buildout]
+    parts =
+        ...
+        test
+        coverage
+        report
+
+    [coverage]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    initialization =
+        include = '--source=${buildout:directory}/src'
+        sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all']
+
+    [report]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    scripts = coverage=report
+    initialization =
+        sys.argv = sys.argv[:] + ['html', '-i']
+
+This will run the ``bin/test`` script with arguments like `--all` to run all layers.
+You can also specify no or some other arguments.
+It will place coverage reporting information in a ``.coverage`` file inside your buildout root.
+Via the ``--source`` argument you specify the directories containing code you want to cover.
+The coverage script would otherwise generate coverage information for all executed code, including other packages and even the standard library.
+
+Running the ``bin/report`` script will generate a human readable HTML representation of the run in the `htmlcov` directory.
+Open the contained `index.html` in a browser to see the result.
+
+If you want to generate an XML representation suitable for the `Cobertura`_ plugin of `Hudson`_, you can add another part::
+
+    [buildout]
+    parts =
+        ...
+        report-xml
+
+    [report-xml]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    scripts = coverage=report-xml
+    initialization =
+        sys.argv = sys.argv[:] + ['xml', '-i']
+
+This will generate a ``coverage.xml`` file in the buildout root.
+
+Optional dependencies
+---------------------
+
+``plone.testing`` comes with a core set of tools for managing layers, which depends only on `zope.testing`_ and (for Python < 2.7) `unittest2`_.
+In addition, there are several layers and helper functions which can be used in your own tests (or as bases for your own layers).
+Some of these have deeper dependencies.
+However, these dependencies are optional and not installed by default.
+If you don't use the relevant layers, you can safely ignore them.
+
+``plone.testing`` does specify these dependencies, however, using the ``setuptools`` "extras" feature.
+You can depend on one or more extras in your own ``setup.py`` ``install_requires`` or ``extras_require`` option using the same square bracket notation shown for the ``[test]`` buildout part above.
+For example, if you need both the ``zca`` and ``publisher`` extras, you can have the following in your ``setup.py``::
+
+    extras_require = {
+        'test': [
+                'plone.testing [zca, publisher]',
+            ]
+    },
+
+The available extras are:
+
+``zodb``
+
+    ZODB testing.
+    Depends on ``ZODB3``.
+    The relevant layers and helpers are in the module ``plone.testing.zodb``.
+
+``zca``
+
+    Zope Component Architecture testing.
+    Depends on core Zope Component Architecture packages such as ``zope.component`` and ``zope.event``.
+    The relevant layers and helpers are in the module ``plone.testing.zca``.
+
+``security``
+
+    Security testing.
+    Depends on ``zope.security``.
+    The relevant layers and helpers are in the module ``plone.testing.security``.
+
+``publisher``
+
+    Zope Publisher testing.
+    Depends on ``zope.app.publisher`` and sets up ZCML directives.
+    The relevant layers and helpers are in the module ``plone.testing.publisher``.
+
+``z2``
+
+    Zope 2 testing.
+    Depends on the ``Zope2`` egg, which includes all the dependencies of the Zope 2 application server.
+    The relevant layers and helpers are in the module ``plone.testing.z2``
+
+Adding a test buildout to your package
+--------------------------------------
+
+When creating re-usable, mostly stand-alone packages, it is often useful to be able to include a buildout with the package sources itself that can be used to create a test runner.
+This is a popular approach for many Zope packages, for example.
+In fact, ``plone.testing`` itself uses this kind of layout.
+
+To have a self-contained buildout in your package, the following is required:
+
+* You need a ``buildout.cfg`` at the root of the package.
+
+* In most cases, you always want a ``bootstrap.py`` file to make it easier for people to set up a fresh buildout.
+
+* Your package sources need to be inside a ``src`` directory.
+  If you're using namespace packages, that means the top level package should be in the ``src`` directory.
+
+* The ``src`` directory must be referenced in ``setup.py``.
+
+For example, ``plone.testing`` has the following layout::
+
+    plone.testing/
+    plone.testing/setup.py
+    plone.testing/bootstrap.py
+    plone.testing/buildout.cfg
+    plone.testing/README.rst
+    plone.testing/src/
+    plone.testing/src/plone
+    plone.testing/src/plone/__init__.py
+    plone.testing/src/plone/testing/
+    plone.testing/src/plone/testing/*
+
+In ``setup.py``, the following arguments are required::
+
+        packages=find_packages('src'),
+        package_dir={'': 'src'},
+
+This tells ``setuptools`` where to find the source code.
+
+The ``buildout.cfg`` for ``plone.testing`` looks like this::
+
+    [buildout]
+    extends =
+        http://download.zope.org/Zope2/index/2.12.12/versions.cfg
+    parts = coverage test report report-xml
+    develop = .
+
+    [test]
+    recipe = collective.xmltestreport
+    eggs =
+        plone.testing [test]
+    defaults = ['--auto-color', '--auto-progress']
+
+    [coverage]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    initialization =
+        include = '--source=${buildout:directory}/src'
+        sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all', '--xml']
+
+    [report]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    scripts = coverage=report
+    initialization =
+        sys.argv = sys.argv[:] + ['html', '-i']
+
+    [report-xml]
+    recipe = zc.recipe.egg
+    eggs = coverage
+    scripts = coverage=report-xml
+    initialization =
+        sys.argv = sys.argv[:] + ['xml', '-i']
+
+Obviously, you should adjust the package name in the ``eggs`` list and the version set in the ``extends`` line as appropriate.
+
+You can of course also add additional buildout parts, for example to include some development/debugging tools, or even a running application server for testing purposes.
+
+    *Hint:* If you use this package layout, you should avoid checking any files or directories generated by buildout into your version control repository.
+    You want to ignore:
+
+    * ``.coverage``
+    * ``.installed.cfg``
+    * ``bin``
+    * ``coverage.xml``
+    * ``develop-eggs``
+    * ``htmlcov``
+    * ``parts``
+    * ``src/*.egg-info``
+
+Layers
+======
+
+In large part, ``plone.testing`` is about layers.
+It provides:
+
+* A set of layers (outlined below), which you can use or extend.
+
+* A set of tools for working with layers
+
+* A mini-framework to make it easy to write layers and manage shared resources associated with layers.
+
+We'll discuss the last two items here, before showing how to write tests that use layers.
+
+Layer basics
+------------
+
+Layers are used to create test fixtures that are shared by multiple test cases.
+For example, if you are writing a set of integration tests, you may need to set up a database and configure various components to access that database.
+This type of test fixture setup can be resource-intensive and time-consuming.
+If it is possible to only perform the setup and tear-down once for a set of tests without losing isolation between those tests, test runs can often be sped up significantly.
+
+Layers also allow re-use of test fixtures and set-up/tear-down code.
+``plone.testing`` provides a number of useful (but optional) layers that manage test fixtures for common Zope testing scenarios, letting you focus on the actual test authoring.
+
+At the most basic, a layer is an object with the following methods and attributes:
+
+``setUp()``
+
+    Called by the test runner when the layer is to be set up.
+    This is called exactly once for each layer used during a test run.
+
+``tearDown()``
+
+    Called by the test runner when the layer is to be torn down.
+    As with ``setUp()``, this is called exactly once for each layer.
+
+``testSetUp()``
+
+    Called immediately before each test case that uses the layer is executed.
+    This is useful for setting up aspects of the fixture that are managed on a per-test basis, as opposed to fixture shared among all tests.
+
+``testTearDown()``
+
+    Called immediately after each test case that uses the layer is executed.
+    This is a chance to perform any post-test cleanup to ensure the fixture is ready for the next test.
+
+``__bases__``
+
+    A tuple of base layers.
+
+Each test case is associated with zero or one layer.
+(The syntax for specifying the layer is shown in the section "Writing tests" below.) All the tests associated with a given layer will be executed together.
+
+Layers can depend on one another (as indicated in the ``__bases__`` tuple), allowing one layer to build on the fixture created by another.
+Base layers are set up before and torn down after their dependants.
+
+For example, if the test runner is executing some tests that belong to layer A, and some other tests that belong to layer B, both of which depend on layer C, the order of execution might be::
+
+    1. C.setUp()
+    1.1. A.setUp()
+
+    1.1.1. C.testSetUp()
+    1.1.2. A.testSetUp()
+    1.1.3. [One test using layer A]
+    1.1.4. A.testTearDown()
+    1.1.5. C.testTearDown()
+
+    1.1.6. C.testSetUp()
+    1.1.7. A.testSetUp()
+    1.1.8. [Another test using layer A]
+    1.1.9. A.testTearDown()
+    1.1.10. C.testTearDown()
+
+    1.2. A.tearDown()
+    1.3. B.setUp()
+
+    1.3.1. C.testSetUp()
+    1.3.2. B.testSetUp()
+    1.3.3. [One test using layer B]
+    1.3.4. B.testTearDown()
+    1.3.5. C.testTearDown()
+
+    1.3.6. C.testSetUp()
+    1.3.7. B.testSetUp()
+    1.3.8. [Another test using layer B]
+    1.3.9. B.testTearDown()
+    1.3.10. C.testTearDown()
+
+    1.4. B.tearDown()
+    2. C.tearDown()
+
+A base layer may of course depend on other base layers.
+In the case of nested dependencies like this, the order of set up and tear-down as calculated by the test runner is similar to the way in which Python searches for the method to invoke in the case of multiple inheritance.
+
+Writing layers
+--------------
+
+The easiest way to create a new layer is to use the ``Layer`` base class and implement the ``setUp()``, ``tearDown()``, ``testSetUp()`` and ``testTearDown()`` methods as needed.
+All four are optional.
+The default implementation of each does nothing.
+
+By convention, layers are created in a module called ``testing.py`` at the top level of your package.
+The idea is that other packages that extend your package can re-use your layers for their own testing.
+
+A simple layer may look like this::
+
+    >>> from plone.testing import Layer
+    >>> class SpaceShip(Layer):
+    ...
+    ...     def setUp(self):
+    ...         print "Assembling space ship"
+    ...
+    ...     def tearDown(self):
+    ...         print "Disasembling space ship"
+    ...
+    ...     def testSetUp(self):
+    ...         print "Fuelling space ship in preparation for test"
+    ...
+    ...     def testTearDown(self):
+    ...         print "Emptying the fuel tank"
+
+Before this layer can be used, it must be instantiated.
+Layers are normally instantiated exactly once, since by nature they are shared between tests.
+This becomes important when you start to manage resources (such as persistent data, database connections, or other shared resources) in layers.
+
+The layer instance is conventionally also found in ``testing.py``, just after the layer class definition.::
+
+    >>> SPACE_SHIP = SpaceShip()
+
+.. note::
+
+    Since the layer is instantiated in module scope, it will be created as soon as the ``testing`` module is imported.
+    It is therefore very important that the layer class is inexpensive and safe to create.
+    In general, you should avoid doing anything non-trivial in the ``__init__()`` method of your layer class.
+    All setup should happen in the ``setUp()`` method.
+    If you *do* implement ``__init__()``, be sure to call the ``super`` version as well.
+
+The layer shown above did not have any base layers (dependencies).
+Here is an example of another layer that depends on it:::
+
+    >>> class ZIGSpaceShip(Layer):
+    ...     defaultBases = (SPACE_SHIP,)
+    ...
+    ...     def setUp(self):
+    ...         print "Installing main canon"
+
+    >>> ZIG = ZIGSpaceShip()
+
+Here, we have explicitly listed the base layers on which ``ZIGSpaceShip`` depends, in the ``defaultBases`` attribute.
+This is used by the ``Layer`` base class to set the layer bases in a way that can also be overridden: see below.
+
+Note that we use the layer *instance* in the ``defaultBases`` tuple, not the class.
+Layer dependencies always pertain to specific layer instances.
+Above, we are really saying that *instances* of ``ZIGSpaceShip`` will, by default, require the ``SPACE_SHIP`` layer to be set up first.
+
+.. note::
+
+    You may find it useful to create other layer base/mix-in classes that extend ``plone.testing.Layer`` and provide helper methods for use in your own layers.
+    This is perfectly acceptable, but please do not confuse a layer base class used in this manner with the concept of a *base layer* as described above:
+
+        * A class deriving from ``plone.testing.Layer`` is known as a *layer class*.
+          It defines the behaviour of the layer by implementing the lifecycle methods ``setUp()``, ``tearDown()``, ``testSetUp()`` and/or ``testTearDown()``.
+
+        * A layer class can be instantiated into an actual layer.
+          When a layer is associated with a test, it is the layer *instance* that is used.
+
+        * The instance is usually a shared, module-global object, although in some cases it is useful to create copies of layers by instantiating the class more than once.
+
+        * Subclassing an existing layer class is just straightforward OOP re-use: the test runner is not aware of the subclassing relationship.
+
+        * A layer *instance* can be associated with any number of layer *bases*, via its ``__bases__`` property (which is usually via the ``defaultBases`` variable in the class body and/or overridden using the ``bases`` argument to the ``Layer`` constructor).
+         These bases are layer *instances*, not classes.
+         The test runner will inspect the ``__bases__`` attribute of each layer instance it sets up to calculate layer pre-requisites and dependencies.
+
+    Also note that the `zope.testing`_ documentation contains examples of layers that are "old-style" classes where the ``setUp()`` and ``tearDown()`` methods are ``classmethod`` methods and class inheritance syntax is used to specify base layers.
+    Whilst this pattern works, we discourage its use, because the classes created using this pattern are not really used as classes.
+    The concept of layer bases is slightly different from class inheritance, and using the ``class`` keyword to create layers with base layers leads to a number of "gotchas" that are best avoided.
+
+Advanced - overriding bases
+---------------------------
+
+In some cases, it may be useful to create a copy of a layer, but change its bases.
+One reason to do this may if you are re-using a layer from another module, and you need to change the order in which layers are set up and torn down.
+
+Normally, of course, you would just re-use the layer instance, either directly in a test, or in the ``defaultBases`` tuple of another layer, but if you need to change the bases, you can pass a new list of bases to the layer instance constructor:::
+
+    >>> class CATSMessage(Layer):
+    ...
+    ...     def setUp(self):
+    ...         print "All your base are belong to us"
+    ...
+    ...     def tearDown(self):
+    ...         print "For great justice"
+
+    >>> CATS_MESSAGE = CATSMessage()
+
+    >>> ZERO_WING = ZIGSpaceShip(bases=(SPACE_SHIP, CATS_MESSAGE,), name="ZIGSpaceShip:CATSMessage")
+
+Please note that when overriding bases like this, the ``name`` argument is required.
+This is because each layer (using in a given test run) must have a unique name.
+The default is to use the layer class name, but this obviously only works for one instantiation.
+Therefore, ``plone.testing`` requires a name when setting ``bases`` explicitly.
+
+Please take great care when changing layer bases like this.
+The layer implementation may make assumptions about the test fixture that was set up by its bases.
+If you change the order in which the bases are listed, or remove a base altogether, the layer may fail to set up correctly.
+
+Also, bear in mind that the new layer instance is independent of the original layer instance, so any resources defined in the layer are likely to be duplicated.
+
+Layer combinations
+------------------
+
+Sometimes, it is useful to be able to combine several layers into one, without adding any new fixture.
+One way to do this is to use the ``Layer`` class directly and instantiate it with new bases:::
+
+    >>> COMBI_LAYER = Layer(bases=(CATS_MESSAGE, SPACE_SHIP,), name="Combi")
+
+Here, we have created a "no-op" layer with two bases: ``CATS_MESSAGE`` and ``SPACE_SHIP``, named ``Combi``.
+
+Please note that when using ``Layer`` directly like this, the ``name`` argument is required.
+This is to allow the test runner to identify the layer correctly.
+Normally, the class name of the layer is used as a basis for the name, but when using the ``Layer`` base class directly, this is unlikely to be unique or descriptive.
+
+Layer resources
+---------------
+
+Many layers will manage one or more resources that are used either by other layers, or by tests themselves.
+Examples may include database connections, thread-local objects, or configuration data.
+
+``plone.testing`` contains a simple resource storage abstraction that makes it easy to access resources from dependant layers or tests.
+The resource storage uses dictionary notation:::
+
+    >>> class WarpDrive(object):
+    ...     """A shared resource"""
+    ...
+    ...     def __init__(self, maxSpeed):
+    ...         self.maxSpeed = maxSpeed
+    ...         self.running = False
+    ...
+    ...     def start(self, speed):
+    ...         if speed > self.maxSpeed:
+    ...             print "We need more power!"
+    ...         else:
+    ...             print "Going to warp at speed", speed
+    ...             self.running = True
+    ...
+    ...     def stop(self):
+    ...         self.running = False
+
+    >>> class ConstitutionClassSpaceShip(Layer):
+    ...     defaultBases = (SPACE_SHIP,)
+    ...
+    ...     def setUp(self):
+    ...         self['warpDrive'] = WarpDrive(8.0)
+    ...
+    ...     def tearDown(self):
+    ...         del self['warpDrive']
+
+    >>> CONSTITUTION_CLASS_SPACE_SHIP = ConstitutionClassSpaceShip()
+
+    >>> class GalaxyClassSpaceShip(Layer):
+    ...     defaultBases = (CONSTITUTION_CLASS_SPACE_SHIP,)
+    ...
+    ...     def setUp(self):
+    ...         # Upgrade the warp drive
+    ...         self.previousMaxSpeed = self['warpDrive'].maxSpeed
+    ...         self['warpDrive'].maxSpeed = 9.5
+    ...
+    ...     def tearDown(self):
+    ...         # Restore warp drive to its previous speed
+    ...         self['warpDrive'].maxSpeed = self.previousMaxSpeed
+
+    >>> GALAXY_CLASS_SPACE_SHIP = GalaxyClassSpaceShip()
+
+As shown, layers (that derive from ``plone.testing.Layer``) support item (dict-like) assignment, access and deletion of arbitrary resources under string keys.
+
+    **Important:** If a layer creates a resource (by assigning an object to a key on ``self`` as shown above) during fixture setup-up, it must also delete the resource on tear-down.
+    Set-up and deletion should be symmetric: if the resource is assigned during ``setUp()`` it should be deleted in ``tearDown()``;
+    if it's created in ``testSetUp()`` it should be deleted in ``testTearDown()``.
+
+A resource defined in a base layer is accessible from and through a child layer.
+If a resource is set on a child using a key that also exists in a base layer, the child version will shadow the base version until the child layer is torn down (presuming it deletes the resource, which it should), but the base layer version remains intact.
+
+.. note::
+
+    Accessing a resource is analogous to accessing an instance variable.
+    For example, if a base layer assigns a resource to a given key in its ``setUp()`` method, a child layer shadows that resource with another object under the same key, the shadowed resource will by used during the ``testSetUp()`` and ``testTearDown()`` lifecycle methods if implemented by the *base* layer as well.
+    This will be the case until the child layer "pops" the resource by deleting it, normally in its ``tearDown()``.
+
+Conversely, if (as shown above) the child layer accesses and modifies the object, it will modify the original.
+
+.. note::
+
+   It is sometimes necessary (or desirable) to modify a shared resource in a child layer, as shown in the example above.  In this case, however, it is very important to restore the original state when the layer is torn down.  Otherwise, other layers or tests using the base layer directly may be affected in difficult-to-debug ways.
+
+If the same key is used in multiple base layers, the rules for choosing which version to use are similar to those that apply when choosing an attribute or method to use in the case of multiple inheritance.
+
+In the example above, we used the resource manager for the ``warpDrive`` object, but we assigned the ``previousMaxSpeed`` variable to ``self``.
+This is because ``previousMaxSpeed`` is internal to the layer and should not be shared with any other layers that happen to use this layer as a base.
+Nor should it be used by any test cases.
+Conversely, ``warpDrive`` is a shared resource that is exposed to other layers and test cases.
+
+The distinction becomes even more important when you consider how a test case may access the shared resource.
+We'll discuss how to write test cases that use layers shortly, but consider the following test:::
+
+    >>> try:
+    ...     import unittest2 as unittest
+    ... except ImportError: # Python 2.7
+    ...     import unittest
+    >>> class TestFasterThanLightTravel(unittest.TestCase):
+    ...     layer = GALAXY_CLASS_SPACE_SHIP
+    ...
+    ...     def test_hyperdrive(self):
+    ...         warpDrive = self.layer['warpDrive']
+    ...         warpDrive.start(8)
+
+This test needs access to the shared resource.
+It knows that its layer defines one called ``warpDrive``.
+It does not know or care that the warp drive was actually initiated by the ``ConstitutionClassSpaceShip`` base layer.
+
+If, however, the base layer had assigned the resource as an instance variable, it would not inherit to child layers (remember: layer bases are not base classes!).
+The syntax to access it would be:::
+
+    self.layer.__bases__[0].warpDrive
+
+which is not only ugly, but brittle: if the list of bases is changed, the expression above may lead to an attribute error.
+
+Writing tests
+=============
+
+Tests are usually written in one of two ways: As methods on a class that derives from ``unittest.TestCase`` (this is sometimes known as "Python tests" or "JUnit-style tests"), or using doctest syntax.
+
+You should realise that although the relevant frameworks (``unittest``, ``unittest2`` and ``doctest``) often talk about unit testing, these tools are also used to write integration and functional tests.
+The distinction between unit, integration and functional tests is largely practical: you use the same techniques to set up a fixture or write assertions for an integration test as you would for a unit test.
+The difference lies in what that fixture contains, and how you invoke the code under test.
+In general, a true unit test will have a minimal or no test fixture, whereas an integration test will have a fixture that contains the components your code is integrating with.
+A functional test will have a fixture that contains enough of the full system to execute and test an "end-to-end" scenario.
+
+Python tests
+------------
+
+Python tests use the Python `unittest`_ module, or its cousin `unittest2`_ (see below).
+They should be placed in a module or package called ``tests`` for the test runner to pick them up.
+
+For small packages, a single module called ``tests.py`` will normally contain all tests.
+For larger packages, it is common to have a ``tests`` package that contains a number of modules with tests.
+These need to start with the word ``test``, e.g.
+``tests/test_foo.py`` or ``tests/test_bar.py``.
+Don't forget the ``__init__.py`` in the ``tests`` package, too!
+
+unittest2
+~~~~~~~~~
+
+In Python 2.7+, the ``unittest`` module has grown several new and useful features.
+To make use of these in Python 2.4, 2.5 and 2.6, an add-on module called `unittest2`_ can be installed.
+``plone.testing`` depends on ``unittest2`` for these versions (and uses it for its own tests), so you will have access to it if you depend on ``plone.testing``.
+
+We will use ``unittest2`` for the examples in this document, but try to import it with an alias of ``unittest``.
+This makes the code forward compatible with Python 2.7, where the built-in ``unittest`` module will have all the features of the ``unittest2`` module.
+
+Please note that the `zope.testing`_ test runner at the time of writing (version 3.9.3) does not (yet) support the new ``setUpClass()``, ``tearDownClass()``, ``setUpModule()`` and ``tearDownModule()`` hooks from ``unittest2``.
+This is not normally a problem, since we tend to use layers to manage complex fixtures, but it is important to be aware of nonetheless.
+
+Test modules, classes and functions
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Python tests are written with classes that derive from the base class ``TestCase``.
+Each test is written as a method that takes no arguments and has a name starting with ``test``.
+Other methods can be added and called from test methods as appropriate, e.g.
+to share some test logic.
+
+Two special methods, ``setUp()`` and ``tearDown()``, can also be added.
+These will be called before or after each test, respectively, and provide a useful place to construct and clean up test fixtures without writing a custom layer.
+They are obviously not as re-usable as layers, though.
+
+   *Hint:* Somewhat confusingly, the ``setUp()`` and ``tearDown()`` methods in a test case class are the equivalent of the ``testSetUp()`` and ``testTearDown()`` methods of a layer class.
+
+A layer can be specified by setting the ``layer`` class attribute to a layer instance.
+If layers are used in conjunction with ``setUp()`` and ``tearDown()`` methods in the test class itself, the class' ``setUp()`` method will be called after the layer's ``testSetUp()`` method, and the class' ``tearDown()`` method will be called before the layer's ``testTearDown()`` method.
+
+The ``TestCase`` base class contains a number of methods which can be used to write assertions.
+They all take the form ``self.assertSomething()``, e.g.
+``self.assertEqual(result, expectedValue)``.
+See the `unittest`_ and/or `unittest2`_ documentation for details.
+
+Putting this together, let's expand on our previous example unit test:::
+
+    >>> try:
+    ...     import unittest2 as unittest
+    ... except ImportError: # Python 2.7
+    ...     import unittest
+
+    >>> class TestFasterThanLightTravel(unittest.TestCase):
+    ...     layer = GALAXY_CLASS_SPACE_SHIP
+    ...
+    ...     def setUp(self):
+    ...         self.warpDrive = self.layer['warpDrive']
+    ...         self.warpDrive.stop()
+    ...
+    ...     def tearDown(self):
+    ...         self.warpDrive.stop()
+    ...
+    ...     def test_warp8(self):
+    ...         self.warpDrive.start(8)
+    ...         self.assertEqual(self.warpDrive.running, True)
+    ...
+    ...     def test_max_speed(self):
+    ...         tooFast = self.warpDrive.maxSpeed + 0.1
+    ...         self.warpDrive.start(tooFast)
+    ...         self.assertEqual(self.warpDrive.running, False)
+
+A few things to note:
+
+* The class derives from ``unittest.TestCase``.
+
+* The ``layer`` class attribute is set to a layer instance (not a layer class!) defined previously.
+  This would typically be imported from a ``testing`` module.
+
+* There are two tests here: ``test_warp8()`` and ``test_max_speed()``.  
+
+* We have used the ``self.assertEqual()`` assertion in both tests to check the result of executing the ``start()`` method on the warp drive.
+
+* We have used the ``setUp()`` method to fetch the ``warpDrive`` resource and ensure that it is stopped before each test is executed.
+  Assigning a variable to ``self`` is a useful way to provide some state to each test method, though be careful about data leaking between tests: in general, you cannot predict the order in which tests will run, and tests should always be independent.
+
+* We have used the ``tearDown()`` method to make sure the warp drive is really stopped after each test.
+
+Test suites
+~~~~~~~~~~~
+
+If you are using version 3.8.0 or later of `zope.testing`_, a class like the one above is all you need: any class deriving from ``TestCase`` in a module with a name starting with ``test`` will be examined for test methods.
+Those tests are then collected into a test suite and executed.
+
+With older versions of `zope.testing`_, you need to add a ``test_suite()`` function in each module that returns the tests in the test suite.
+The `unittest`_ module contains several tools to construct suites, but one of the simplest is to use the default test loader to load all tests in the current module:::
+
+    >>> def test_suite():
+    ...     return unittest.defaultTestLoader.loadTestsFromName(__name__)
+
+If you need to load tests explicitly, you can use the ``TestSuite`` API from the `unittest`_ module.
+For example:::
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         unittest.makeSuite(TestFasterThanLightTravel)
+    ...     ])
+    ...     return suite
+
+The ``makeSuite()`` function creates a test suite from the test methods in the given class (which must derive from ``TestCase``).
+This suite is then appended to an overall suite, which is returned from the ``test_suite()`` method.
+Note that ``addTests()`` takes a list of suites (which are coalesced into a single suite).
+We'll add additional suites later.
+
+See the `unittest`_ documentation for other options.
+
+.. note::
+
+   Adding a ``test_suite()`` method to a module disables automatic test discovery, even when using a recent version of ``zope.testing``.
+
+Doctests
+--------
+
+Doctests can be written in two ways: as the contents of a docstring (usually, but not always, as a means of illustrating and testing the functionality of the method or class where the docstring appears), or as a separate text file.
+In both cases, the standard `doctest`_ module is used.
+See its documentation for details about doctest syntax and conventions.
+
+Doctests are used in two different ways:
+
+* To test documentation.
+  That is, to ensure that code examples contained in documentation are valid and continue to work as the software is updated.
+
+* As a convenient syntax for writing tests.
+
+These two approaches use the same testing APIs and techniques.
+The difference is mostly about mindset.
+However, it is important to avoid falling into the trap that tests can substitute for good documentation or vice-a-versa.
+Tests usually need to systematically go through inputs and outputs and cover off a number of corner cases.
+Documentation should tell a compelling narrative and usually focus on the main usage scenarios.
+Trying to kill these two birds with one stone normally leaves you with an unappealing pile of stones and feathers.
+
+Docstring doctests
+~~~~~~~~~~~~~~~~~~
+
+Doctests can be added to any module, class or function docstring:::
+
+    def canOutrunKlingons(warpDrive):
+        """Find out of the given warp drive can outrun Klingons.
+
+        Klingons travel at warp 8
+
+        >>> drive = WarpDrive(5)
+        >>> canOutrunKlingons(drive)
+        False
+
+        We have to be faster than that to outrun them.
+
+        >>> drive = WarpDrive(8.1)
+        >>> canOutrunKlingons(drive)
+        True
+
+        We can't outrun them if we're travelling exactly the same speed
+
+        >>> drive = WarpDrive(8.0)
+        >>> canOutrunKlingons(drive)
+        False
+
+        """
+        return warpDrive.maxSpeed > 8.0
+
+To add the doctests from a particular module to a test suite, you need to use the ``test_suite()`` function hook:::
+
+    >>> import doctest
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         unittest.makeSuite(TestFasterThanLightTravel), # our previous test
+    ...         doctest.DocTestSuite('spaceship.utils'),
+    ...     ])
+    ...     return suite
+
+Here, we have given the name of the module to check as a string dotted name.
+It is also possible to import a module and pass it as an object.
+The code above passes a list to ``addTests()``, making it easy to add several sets of tests to the suite: the list can be constructed from calls to ``DocTestSuite()``, ``DocFileSuite()`` (shown below) and ``makeSuite()`` (shown above).
+
+    Remember that if you add a ``test_suite()`` function to a module that also has ``TestCase``-derived python tests, those tests will no longer be automatically picked up by ``zope.testing``, so you need to add them to the test suite explicitly.
+
+The example above illustrates a documentation-oriented doctest, where the doctest forms part of the docstring of a public module.
+The same syntax can be used for more systematic unit tests.
+For example, we could have a module ``spaceship.tests.test_spaceship`` with a set of methods like::
+
+    # It's often better to put the import into each method, but here we've
+    # imported the code under test at module level
+    from spaceship.utils import WarpDrive, canOutrunKlingons
+
+    def test_canOutrunKlingons_too_small():
+        """Klingons travel at warp 8.0
+
+        >>> drive = WarpDrive(7.9)
+        >>> canOutrunKlingons(drive)
+        False
+
+        """
+
+    def test_canOutrunKlingons_big():
+        """Klingons travel at warp 8.0
+
+        >>> drive = WarpDrive(8.1)
+        >>> canOutrunKlingons(drive)
+        True
+
+        """
+
+    def test_canOutrunKlingons_must_be_greater():
+        """Klingons travel at warp 8.0
+
+        >>> drive = WarpDrive(8.0)
+        >>> canOutrunKlingons(drive)
+        False
+
+        """
+
+Here, we have created a number of small methods that have no body.
+They merely serve as a container for docstrings with doctests.
+Since the module has no globals, each test must import the code under test, which helps make import errors more explicit.
+
+File doctests
+~~~~~~~~~~~~~
+
+Doctests contained in a file are similar to those contained in docstrings.
+File doctests are better suited to narrative documentation covering the usage of an entire module or package.
+
+For example, if we had a file called ``spaceship.txt`` with doctests, we could add it to the test suite above with:::
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         unittest.makeSuite(TestFasterThanLightTravel),
+    ...         doctest.DocTestSuite('spaceship.utils'),
+    ...         doctest.DocFileSuite('spaceship.txt'),
+    ...     ])
+    ...     return suite
+
+By default, the file is located relative to the module where the test suite is defined.
+You can use ``../`` (even on Windows) to reference the parent directory, which is sometimes useful if the doctest is inside a module in a ``tests`` package.
+
+.. note::
+
+    If you put the doctest ``test_suite()`` method in a module inside a ``tests`` package, that module must have a name starting with ``test``.
+    It is common to have ``tests/test_doctests.py`` that contains a single ``test_suite()`` method that returns a suite of multiple doctests.
+
+It is possible to pass several tests to the suite, e.g.::
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         unittest.makeSuite(TestFasterThanLightTravel),
+    ...         doctest.DocTestSuite('spaceship.utils'),
+    ...         doctest.DocFileSuite('spaceship.txt', 'warpdrive.txt',),
+    ...     ])
+    ...     return suite
+
+The test runner will report each file as a separate test, i.e.
+the ``DocFileSuite()`` above would add two tests to the overall suite.
+Conversely, a ``DocTestSuite()`` using a module with more than one docstring containing doctests will report one test for each eligible docstring.
+
+Doctest fixtures and layers
+~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+A docstring doctest will by default have access to any global symbol available in the module where the docstring is found (e.g.
+anything defined or imported in the module).
+The global namespace can be overridden by passing a ``globs`` keyword argument to the ``DocTestSuite()`` constructor, or augmented by passing an ``extraglobs`` argument.
+Both should be given dictionaries.
+
+A file doctest has an empty globals namespace by default.
+Globals may be provided via the ``globs`` argument to ``DocFileSuite()``.
+
+To manage a simple test fixture for a doctest, you can define set-up and tear-down functions and pass them as the ``setUp`` and ``tearDown`` arguments respectively.
+These are both passed a single argument, a ``DocTest`` object.
+The most useful attribute of this object is ``globs``, which is a mutable dictionary of globals available in the test.
+
+For example:::
+
+    >>> def setUpKlingons(doctest):
+    ...     doctest.globs['oldStyleKlingons'] = True
+
+    >>> def tearDownKlingons(doctest):
+    ...     doctest.globs['oldStyleKlingons'] = False
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         doctest.DocTestSuite('spaceship.utils', setUp=setUpKlingons, tearDown=tearDownKlingons),
+    ...     ])
+    ...     return suite
+
+The same arguments are available on the ``DocFileSuite()`` constructor.
+The set up method is called before each docstring in the given module for a ``DocTestSuite``, and before each file given in a ``DocFileSuite``.
+
+Of course, we often want to use layers with doctests too.
+Unfortunately, the ``unittest`` API is not aware of layers, so you can't just pass a layer to the ``DocTestSuite()`` and ``DocFileSuite()`` constructors.
+Instead, you have to set a ``layer`` attribute on the suite after it has been constructed.
+
+Furthermore, to use layer resources in a doctest, we need access to the layer instance.
+The easiest way to do this is to pass it as a glob, conventionally called 'layer'.
+This makes a global name 'layer' available in the doctest itself, giving access to the test's layer instance.
+
+To make it easier to do this, ``plone.testing`` comes with a helper function called ``layered()``.
+Its first argument is a test suite.
+The second argument is the layer.
+
+For example:::
+
+    >>> from plone.testing import layered
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         layered(doctest.DocTestSuite('spaceship.utils'), layer=CONSTITUTION_CLASS_SPACE_SHIP),
+    ...     ])
+    ...     return suite
+
+This is equivalent to:::
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...
+    ...     spaceshipUtilTests = doctest.DocTestSuite('spaceship.utils', globs={'layer': CONSTITUTION_CLASS_SPACE_SHIP})
+    ...     spaceshipUtilTests.layer = CONSTITUTION_CLASS_SPACE_SHIP
+    ...     suite.addTest(spaceshipUtilTests)
+    ...
+    ...     return suite
+
+(In this example, we've opted to use ``addTest()`` to add a single suite, instead of using ``addTests()`` to add multiple suites in one go).
+
+Zope testing tools
+==================
+
+Everything described so far in this document relies only on the standard `unittest`_/`unittest2`_ and `doctest`_ modules and `zope.testing`_, and you can use this package without any other dependencies.
+
+However, there are also some tools (and layers) available in this package, as well as in other packages, that are specifically useful for testing applications that use various Zope-related frameworks.
+
+Test cleanup
+------------
+
+If a test uses a global registry, it may be necessary to clean that registry on set up and tear down of each test fixture.
+``zope.testing`` provides a mechanism to register cleanup handlers - methods that are called to clean up global state.
+This can then be invoked in the ``setUp()`` and ``tearDown()`` fixture lifecycle methods of a test case.::
+
+    >>> from zope.testing import cleanup
+
+Let's say we had a global registry, implemented as a dictionary:::
+
+    >>> SOME_GLOBAL_REGISTRY = {}
+
+If we wanted to clean this up on each test run, we could call ``clear()`` on the dict.
+Since that's a no-argument method, it is perfect as a cleanup handler.::
+
+    >>> cleanup.addCleanUp(SOME_GLOBAL_REGISTRY.clear)
+
+We can now use the ``cleanUp()`` method to execute all registered cleanups:::
+
+    >>> cleanup.cleanUp()
+
+This call could be placed in a ``setUp()`` and/or ``tearDown()`` method in a test class, for example.
+
+Event testing
+-------------
+
+You may wish to test some code that uses ``zope.event`` to fire specific events.
+`zope.component`_ provides some helpers to capture and analyse events.::
+
+    >>> from zope.component import eventtesting
+
+To use this, you first need to set up event testing.
+Some of the layers shown below will do this for you, but you can do it yourself by calling the ``eventtesting.setUp()`` method, e.g.
+from your own ``setUp()`` method:::
+
+    >>> eventtesting.setUp()
+
+This simply registers a few catch-all event handlers.
+Once you have executed the code that is expected to fire events, you can use the ``getEvents()`` helper function to obtain a list of the event instances caught:::
+
+    >>> events = eventtesting.getEvents()
+
+You can now examine ``events`` to see what events have been caught since the last cleanup.
+
+``getEvents()`` takes two optional arguments that can be used to filter the returned list of events.
+The first (``event_type``) is an interface.
+If given, only events providing this interface are returned.
+The second (``filter``) is a callable taking one argument.
+If given, it will be called with each captured event.
+Only those events where the filter function returns ``True`` will be included.
+
+The ``eventtesting`` module registers a cleanup action as outlined above.
+When you call ``cleanup.cleanUp()`` (or ``eventtesting.clearEvents()``, which is the handler it registers), the events list will be cleared, ready for the next test.
+Here, we'll do it manually:::
+
+    >>> eventtesting.clearEvents()
+
+Mock requests
+-------------
+
+Many tests require a request object, often with particular request/form variables set.
+`zope.publisher`_ contains a useful class for this purpose.::
+
+    >>> from zope.publisher.browser import TestRequest
+
+A simple test request can be constructed with no arguments:::
+
+    >>> request = TestRequest()
+
+To add a body input stream, pass a ``StringIO`` or file as the first parameter.
+To set the environment (request headers), use the ``environ`` keyword argument.
+To simulate a submitted form, use the ``form`` keyword argument:::
+
+    >>> request = TestRequest(form=dict(field1='foo', field2=1))
+
+Note that the ``form`` dict contains marshalled form fields, so modifiers like ``:int`` or ``:boolean`` should not be included in the field names, and values should be converted to the appropriate type.
+
+Registering components
+----------------------
+
+Many test fixtures will depend on having a minimum of Zope Component Architecture (ZCA) components registered.
+In normal operation, these would probably be registered via ZCML, but in a unit test, you should avoid loading the full ZCML configuration of your package (and its dependencies).
+
+Instead, you can use the Python API in `zope.component`_ to register global components instantly.
+The three most commonly used functions are:::
+
+    >>> from zope.component import provideAdapter
+    >>> from zope.component import provideUtility
+    >>> from zope.component import provideHandler
+
+See the `zope.component`_ documentation for details about how to use these.
+
+When registering global components like this, it is important to avoid test leakage.
+The ``cleanup`` mechanism outlined above can be used to tear down the component registry between each test.
+See also the ``plone.testing.zca.UNIT_TESTING`` layer, described below, which performs this cleanup automatically via the ``testSetUp()``/``testTearDown()`` mechanism.
+
+Alternatively, you can "stack" a new global component registry using the ``plone.testing.zca.pushGlobalRegistry()`` and ``plone.testing.zca.popGlobalRegistry()`` helpers.
+This makes it possible to set up and tear down components that are specific to a given layer, and even allow tests to safely call the global component API (or load ZCML - see below) with proper tear-down.
+See the layer reference below for details.
+
+Loading ZCML
+------------
+
+Integration tests often need to load ZCML configuration.
+This can be achieved using the ``zope.configuration`` API.::
+
+    >>> from zope.configuration import xmlconfig
+
+The ``xmlconfig`` module contains two methods for loading ZCML.
+
+``xmlconfig.string()`` can be used to load a literal string of ZCML:::
+
+    >>> xmlconfig.string("""\
+    ... <configure xmlns="http://namespaces.zope.org/zope" package="plone.testing">
+    ...     <include package="zope.component" file="meta.zcml" />
+    ... </configure>
+    ... """)
+    <zope.configuration.config.ConfigurationMachine object at ...>
+
+Note that we need to set a package (used for relative imports and file locations) explicitly here, using the ``package`` attribute of the ``<configure />`` element.
+
+Also note that unless the optional second argument (``context``) is passed, a new configuration machine will be created every time ``string()`` is called.
+It therefore becomes necessary to explicitly ``<include />`` the files that contain the directives you want to use (the one in ``zope.component`` is a common example).
+Layers that set up ZCML configuration may expose a resource which can be passed as the ``context`` parameter, usually called ``configurationContext`` - see below.
+
+To load the configuration for a particular package, use ``xmlconfig.file()``:::
+
+    >>> import zope.component
+    >>> context = xmlconfig.file('meta.zcml', zope.component)
+    >>> xmlconfig.file('configure.zcml', zope.component, context=context)
+    <zope.configuration.config.ConfigurationMachine object at ...>
+
+This takes two required arguments: the file name and the module relative to which it is to be found.
+Here, we have loaded two files: ``meta.zcml`` and ``configure.zcml``.
+The first call to ``xmlconfig.file()`` creates and returns a configuration context.
+We re-use that for the subsequent invocation, so that the directives configured are available.
+
+Installing a Zope 2 product
+---------------------------
+
+Some packages (including all those in the ``Products.*`` namespace) have the special status of being Zope 2 "products".
+These are recorded in a special registry, and may have an ``initialize()`` hook in their top-level ``__init__.py`` that needs to be called for the package to be fully configured.
+
+Zope 2 will find and execute any products during startup.
+For testing, we need to explicitly list the products to install.
+Provided you are using ``plone.testing`` with Zope 2, you can use the following:::
+
+    from plone.testing import z2
+
+    with z2.zopeApp() as app:
+        z2.installProduct(app, 'Products.ZCatalog')
+
+This would normally be used during layer ``setUp()``.
+Note that the basic Zope 2 application context must have been set up before doing this.
+The usual way to ensure this, is to use a layer that is based on ``z2.STARTUP`` - see below.
+
+To tear down such a layer, you should do:::
+
+    from plone.testing import z2
+
+    with z2.zopeApp() as app:
+        z2.uninstallProduct(app, 'Products.ZCatalog')
+
+Note:
+
+* Unlike the similarly-named function from ``ZopeTestCase``, these helpers will work with any type of product.
+  There is no distinction between a "product" and a "package" (and no ``installPackage()``).
+  However, you must use the full name (``Products.*``) when registering a product.
+
+* Installing a product in this manner is independent of ZCML configuration.
+  However, it is almost always necessary to install the package's ZCML configuration first.
+
+Functional testing
+------------------
+
+For functional tests that aim to simulate the browser, you can use `zope.testbrowser`_ in a Python test or doctest:::
+
+    >>> from zope.testbrowser.browser import Browser
+    >>> browser = Browser()
+
+This provides a simple API to simulate browser input, without actually running a web server thread or scripting a live browser (as tools such as Windmill and Selenium do).
+The downside is that it is not possible to test JavaScript- dependent behaviour.
+
+If you are testing a Zope 2 application, you need to change the import location slightly, and pass the application root to the method:::
+
+    from plone.testing.z2 import Browser
+    browser = Browser(app)
+
+You can get the application root from the ``app`` resource in any of the Zope 2 layers in this package.
+
+Beyond that, the `zope.testbrowser`_ documentation should cover how to use the test browser.
+
+    **Hint:** The test browser will usually commit at the end of a request.
+    To avoid test fixture contamination, you should use a layer that fully isolates each test, such as the ``z2.INTEGRATION_TESTING`` layer described below.
+
+Layer reference
+===============
+
+``plone.testing`` comes with several layers that are available to use directly or extend.
+These are outlined below.
+
+Zope Component Architecture
+---------------------------
+
+The Zope Component Architecture layers are found in the module ``plone.testing.zca``.
+If you depend on this, you can use the ``[zca]`` extra when depending on ``plone.testing``.
+
+Unit testing
+~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.zca.UNIT_TESTING``               |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zca.UnitTesting``                |
++------------+--------------------------------------------------+
+| Bases:     | None                                             |
++------------+--------------------------------------------------+
+| Resources: | None                                             |
++------------+--------------------------------------------------+
+
+This layer does not set up a fixture per se, but cleans up global state before and after each test, using ``zope.testing.cleanup`` as described above.
+
+The net result is that each test has a clean global component registry.
+Thus, it is safe to use the `zope.component`_ Python API (``provideAdapter()``, ``provideUtility()``, ``provideHandler()`` and so on) to register components.
+
+Be careful with using this layer in combination with other layers.
+Because it tears down the component registry between each test, it will clobber any layer that sets up more permanent test fixture in the component registry.
+
+Event testing
+~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.zca.EVENT_TESTING``              |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zca.EventTesting``               |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.zca.UNIT_TESTING``               |
++------------+--------------------------------------------------+
+| Resources: | None                                             |
++------------+--------------------------------------------------+
+
+This layer extends the ``zca.UNIT_TESTING`` layer to enable the ``eventtesting`` support from ``zope.component``.
+Using this layer, you can import and use ``zope.component.eventtesting.getEvent`` to inspect events fired by the code under test.
+
+See above for details.
+
+Layer cleanup
+~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.zca.LAYER_CLEANUP``              |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zca.LayerCleanup``               |
++------------+--------------------------------------------------+
+| Bases:     | None                                             |
++------------+--------------------------------------------------+
+| Resources: | None                                             |
++------------+--------------------------------------------------+
+
+This layer calls the cleanup functions from ``zope.testing.cleanup`` on setup and tear-down (but not between each test).
+It is useful as a base layer for other layers that need an environment as pristine as possible.
+
+Basic ZCML directives
+~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.zca.ZCML_DIRECTIVES``            |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zca.ZCMLDirectives``             |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |
++------------+--------------------------------------------------+
+| Resources: | ``configurationContext``                         |
++------------+--------------------------------------------------+
+
+This registers a minimal set of ZCML directives, principally those found in the ``zope.component`` package, and makes available a configuration context.
+This allows custom ZCML to be loaded as described above.
+
+The ``configurationContext`` resource should be used when loading custom ZCML.
+To ensure isolation, you should stack this using the ``stackConfigurationContext()`` helper.
+For example, if you were writing a ``setUp()`` method in a layer that had ``zca.ZCML_DIRECTIVES`` as a base, you could do:::
+
+    self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
+    xmlconfig.string(someZCMLString, context=context)
+
+This will create a new configuration context with the state of the base layer's context.
+On tear-down, you should delete the layer-specific resource:::
+
+    del self['configurationContext']
+
+.. note::
+
+   If you fail to do this, you may get problems if your layer is torn down and then needs to be set up again later.
+
+See above for more details about loading custom ZCML in a layer or test.
+
+ZCML files helper class
+~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zca.ZCMLSandbox``                |
++------------+--------------------------------------------------+
+| Resources: | ``configurationContext``                         |
++------------+--------------------------------------------------+
+
+The ``ZCMLSandbox`` can be instantiated with a ``filename`` and ``package`` arguments::
+
+    ZCML_SANDBOX = zca.ZCMLSandbox(filename="configure.zcml",
+        package=my.package)
+
+
+That layer ``setUp`` loads the ZCML file.
+It avoids the need to using (and understand) ``configurationContext`` and ``globalRegistry`` until you need more flexibility or modularity for your layer and tests.
+
+See above for more details about loading custom ZCML in a layer or test.  
+
+Helper functions
+~~~~~~~~~~~~~~~~
+
+The following helper functions are available in the ``plone.testing.zca`` module.
+
+``stackConfigurationContext(context=None)``
+
+    Create and return a copy of the passed-in ZCML configuration context, or a brand new context if it is ``None``.
+
+    The purpose of this is to ensure that if a layer loads some ZCML files (using the ``zope.configuration`` API during) during its ``setUp()``, the state of the configuration registry (which includes registered directives as well as a list of already imported files, which will not be loaded again even if explicitly included) can be torn down during ``tearDown()``.
+
+    The usual pattern is to keep the configuration context in a layer resource called ``configurationContext``.
+    In ``setUp()``, you would then use::
+
+        self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
+
+        # use 'context' to load some ZCML
+
+    In ``tearDown()``, you can then simply do::
+
+        del self['configurationContext']
+
+``pushGlobalRegistry(new=None)``
+
+    Create or obtain a stack of global component registries, and push a new registry to the top of the stack.
+    The net result is that ``zope.component.getGlobalSiteManager()`` and (an un-hooked) ``getSiteManager()`` will return the new registry instead of the default, module-scope one.
+    From this point onwards, calls to ``provideAdapter()``, ``provideUtility()`` and other functions that modify the global registry will use the new registry.
+
+    If ``new`` is not given, a new registry is created that has the previous global registry (site manager) as its sole base.
+    This has the effect that registrations in the previous default global registry are still available, but new registrations are confined to the new registry.
+
+    **Warning**: If you call this function, you *must* reciprocally call ``popGlobalRegistry()``.
+    That is, if you "push" a registry during layer ``setUp()``, you must "pop" it during ``tearDown()``.
+    If you "push" during ``testSetUp()``, you must "pop" during ``testTearDown()``.
+    If the calls to push and pop are not balanced, you will leave your global registry in a mess, which is not pretty.
+
+    Returns the new default global site manager.
+    Also causes the site manager hook from ``zope.site`` to be reset, clearing any local site managers as appropriate.
+
+``popGlobalRegistry()``
+
+    Pop the global site registry, restoring the previous registry to be the default.
+
+    Please heed the warning above: push and pop must be balanced.
+
+    Returns the new default global site manager.
+    Also causes the site manager hook from ``zope.site`` to be reset, clearing any local site managers as appropriate.
+
+Zope Security
+-------------
+
+The Zope Security layers build can be found in the module ``plone.testing.security``.
+
+If you depend on this, you can use the ``[security]`` extra when depending on ``plone.testing``.
+
+Security checker isolation
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.security.CHECKERS``              |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.security.Checkers``              |
++------------+--------------------------------------------------+
+| Bases:     | None                                             |
++------------+--------------------------------------------------+
+| Resources: | None                                             |
++------------+--------------------------------------------------+
+
+This layer ensures that security checkers used by ``zope.security`` are isolated.
+Any checkers set up in a child layer will be removed cleanly during tear-down.
+
+Helper functions
+~~~~~~~~~~~~~~~~
+
+The security checker isolation outlined above is managed using two helper functions found in the module ``plone.testing.security``:
+
+``pushCheckers()``
+
+    Copy the current set of security checkers for later tear-down.
+
+``popCheckers()``
+
+    Restore the set of security checkers to the state of the most recent call to ``pushCheckers()``.
+
+You *must* keep calls to ``pushCheckers()`` and ``popCheckers()`` in balance.
+That usually means that if you call the former during layer setup, you should call the latter during layer tear-down.
+Ditto for calls during test setup/tear-down or within tests themselves.
+
+Zope Publisher
+--------------
+
+The Zope Publisher layers build on the Zope Component Architecture layers.
+They can be found in the module ``plone.testing.publisher``.
+
+If you depend on this, you can use the ``[publisher]`` extra when depending on ``plone.testing``.
+
+Publisher directives
+~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.publisher.PUBLISHER_DIRECTIVES`` |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.publisher.PublisherDirectives``  |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.zca.ZCML_DIRECTIVES``            |
++------------+--------------------------------------------------+
+| Resources: | None                                             |
++------------+--------------------------------------------------+
+
+This layer extends the ``zca.ZCML_DIRECTIVES`` layer to install additional ZCML directives in the ``browser`` namespace (from ``zope.app.publisher.browser``) as well as those from ``zope.security``.
+This allows browser views, browser pages and other UI components to be registered, as well as the definition of new permissions.
+
+As with ``zca.ZCML_DIRECTIVES``, you should use the ``configurationContext`` resource when loading ZCML strings or files, and the ``stackConfigurationRegistry()`` helper to create a layer-specific version of this resource resource.
+See above.
+
+ZODB
+----
+
+The ZODB layers set up a test fixture with a persistent ZODB.
+The ZODB instance uses ``DemoStorage``, so it will not interfere with any "live" data.
+
+ZODB layers can be found in the module ``plone.testing.zodb``.
+If you depend on this, you can use the ``[zodb]`` extra when depending on ``plone.testing``.
+
+Empty ZODB sandbox
+~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.zodb.EMPTY_ZODB``                |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.zodb.EmptyZODB``                 |
++------------+--------------------------------------------------+
+| Bases:     |  None                                            |
++------------+--------------------------------------------------+
+| Resources: | ``zodbRoot``                                     |
+|            +--------------------------------------------------+
+|            | ``zodbDB`` (test set-up only)                    |
+|            +--------------------------------------------------+
+|            | ``zodbConnection`` (test set-up only)            |
++------------+--------------------------------------------------+
+
+This layer sets up a simple ZODB sandbox using ``DemoStorage``.
+The ZODB root object is a simple persistent mapping, available as the resource ``zodbRoot``.
+The ZODB database object is available as the resource ``zodbDB``.
+The connection used in the test is available as ``zodbConnection``.
+
+Note that the ``zodbConnection`` and ``zodbRoot`` resources are created and destroyed for each test.
+You can use ``zodbDB`` (and the ``open()`` method) if you are writing a layer based on this one and need to set up a fixture during layer set up.
+Don't forget to close the connection before concluding the test setup!
+
+A new transaction is begun for each test, and rolled back (aborted) on test tear-down.
+This means that so long as you don't use ``transaction.commit()`` explicitly in your code, it should be safe to add or modify items in the ZODB root.
+
+If you want to create a test fixture with persistent data in your own layer based on ``EMPTY_ZODB``, you can use the following pattern::
+
+    from plone.layer import Layer
+    from plone.layer import zodb
+
+    class MyLayer(Layer):
+        defaultBases = (zodb.EMPTY_ZODB,)
+
+        def setUp(self):
+
+            import transaction
+            self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
+
+            conn = db.open()
+            root = conn.root()
+
+            # modify the root object here
+
+            transaction.commit()
+            conn.close()
+
+        def tearDown(self):
+
+            self['zodbDB'].close()
+            del self['zodbDB']
+
+This shadows the ``zodbDB`` resource with a new database that uses a new ``DemoStorage`` stacked on top of the underlying database storage.
+The fixture is added to this storage and committed during layer setup.
+(The base layer test set-up/tear-down will still begin and abort a new transaction for each *test*).
+On layer tear-down, the database is closed and the resource popped, leaving the original ``zodbDB`` database with the original, pristine storage.
+
+Helper functions
+~~~~~~~~~~~~~~~~
+
+One helper function is available in the ``plone.testing.zodb`` module.
+
+``stackDemoStorage(db=None, name=None)``
+
+    Create a new ``DemoStorage`` using the storage from the passed-in database as a base.
+    If ``db`` is None, a brand new storage is created.
+
+    A ``name`` can be given to uniquely identify the storage.
+    It is optional, but it is often useful for debugging purposes to pass the name of the layer.
+
+    The usual pattern is::
+
+        def setUp(self):
+            self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
+
+        def tearDown(self):
+            self['zodbDB'].close()
+            del self['zodbDB']
+
+    This will shadow the ``zodbDB`` resource with an isolated ``DemoStorage``, creating a new one if that resource does not already exist.
+    All existing data continues to be available, but new changes are written to the stacked storage.
+    On tear-down, the stacked database is closed and the resource removed, leaving the original data.
+
+Zope 2
+------
+
+The Zope 2 layers provide test fixtures suitable for testing Zope 2 applications.
+They set up a Zope 2 application root, install core Zope 2 products, and manage security.
+
+Zope 2 layers can be found in the module ``plone.testing.z2``.
+If you depend on this, you can use the ``[z2]`` extra when depending on ``plone.testing``.
+
+Startup
+~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.STARTUP``                     |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.Startup``                     |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |
++------------+--------------------------------------------------+
+| Resources: | ``zodbDB``                                       |
+|            +--------------------------------------------------+
+|            | ``configurationContext``                         |
+|            +--------------------------------------------------+
+|            | ``host``                                         |
+|            +--------------------------------------------------+
+|            | ``port``                                         |
++------------+--------------------------------------------------+
+
+This layer sets up a Zope 2 environment, and is a required base for all other Zope 2 layers.
+You cannot run two instances of this layer in parallel, since Zope 2 depends on some module-global state to run, which is managed by this layer.
+
+On set-up, the layer will configure a Zope environment with:
+
+.. note::
+
+    The ``STARTUP`` layer is a useful base layer for your own fixtures, but should not be used directly, since it provides no test lifecycle or transaction management.
+    See the "Integration test" and "Functional" test sections below for examples of how to create your own layers.
+
+* Debug mode enabled.
+
+* ZEO client cache disabled.
+
+* Some patches installed, which speed up Zope startup by disabling the help system and some other superfluous aspects of Zope.
+
+* One thread (this only really affects the ``ZSERVER`` and ``FTP_SERVER`` layers).
+
+* A pristine database using ``DemoStorage``, exposed as the resource ``zodbDB``.
+  Zope is configured to use this database in a way that will also work if the ``zodbDB`` resource is shadowed using the pattern shown above in the description of the ``zodb.EMPTY_ZODB`` layer.
+
+* A fake hostname and port, exposed as the ``host`` and ``port`` resource, respectively.
+
+* A minimal set of products installed (``Products.OFSP`` and ``Products.PluginIndexes``, both required for Zope to start up).
+
+* A stacked ZCML configuration context, exposed as the resource ``configurationContext``.
+  As illustrated above, you should use the ``zca.stackConfigurationContext()`` helper to stack your own configuration context if you use this.
+
+* A minimal set of global Zope components configured.
+
+Note that unlike a "real" Zope site, products in the ``Products.*`` namespace are not automatically loaded, nor is any ZCML.
+
+Integration test
+~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.INTEGRATION_TESTING``         |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.IntegrationTesting``          |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.STARTUP``                     |
++------------+--------------------------------------------------+
+| Resources: | ``app``                                          |
+|            +--------------------------------------------------+
+|            | ``request``                                      |
++------------+--------------------------------------------------+
+
+This layer is intended for integration testing against the simple ``STARTUP`` fixture.
+If you want to create your own layer with a more advanced, shared fixture, see "Integration and functional testing with custom fixtures" below.
+
+For each test, it exposes the Zope application root as the resource ``app``.
+This is wrapped in the request container, so you can do ``app.REQUEST`` to acquire a fake request, but the request is also available as the resource ``request``.
+
+A new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.
+
+    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``z2.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.
+
+    Once you've shadowed the ``zodbDB`` resource, you can do (e.g. in your layer's ``setUp()`` method)::
+
+        ...
+        with z2.zopeApp() as app:
+            # modify the Zope application root
+
+    The ``zopeApp()`` context manager will open a new connection to the Zope application root, accessible here as ``app``.
+    Provided the code within the ``with`` block does not raise an exception, the transaction will be committed and the database closed properly upon exiting the block.
+
+Functional testing
+~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.FUNCTIONAL_TESTING``          |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.FunctionalTesting``           |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.STARTUP``                     |
++------------+--------------------------------------------------+
+| Resources: | ``app``                                          |
+|            +--------------------------------------------------+
+|            | ``request``                                      |
++------------+--------------------------------------------------+
+
+This layer is intended for functional testing against the simple ``STARTUP`` fixture.
+If you want to create your own layer with a more advanced, shared fixture, see "Integration and functional testing with custom fixtures" below.
+
+As its name implies, this layer is intended mainly for functional end-to-end testing using tools like `zope.testbrowser`_.
+See also the ``Browser`` object as described under "Helper functions" below.
+
+This layer is very similar to ``INTEGRATION_TESTING``, but is not based on it.
+It sets up the same fixture and exposes the same resources.
+However, instead of using a simple transaction abort to isolate the ZODB between tests, it uses a stacked ``DemoStorage`` for each test.
+This is slower, but allows test code to perform and explicit commit, as will usually happen in a functional test.
+
+Integration and functional testing with custom fixtures
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+If you want to extend the ``STARTUP`` fixture for use with integration or functional testing, you should use the following pattern:
+
+* Create a layer class and a "fixture" base layer instance that has ``z2.STARTUP`` (or some intermediary layer, such as ``z2.ZSERVER_FIXTURE`` or ``z2.FTP_SERVER_FIXTURE``, shown below) as a base.
+
+* Create "end user" layers by instantiating the ``z2.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new "fixture" layer as a base.
+
+This allows the same fixture to be used regardless of the "style" of testing, minimising the amount of set-up and tear-down.
+The "fixture" layers manage the fixture as part of the *layer* lifecycle.
+The layer class (``IntegrationTesting`` or ``FunctionalTesting``), manages the *test* lifecycle, and the test lifecycle only.
+
+For example::
+
+    from plone.testing import Layer, z2, zodb
+
+    class MyLayer(Layer):
+        defaultBases = (z2.STARTUP,)
+
+        def setUp(self):
+            # Set up the fixture here
+            ...
+
+        def tearDown(self):
+            # Tear down the fixture here
+            ...
+
+    MY_FIXTURE = MyLayer()
+
+    MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")
+    MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")
+
+(Note that we need to give an explicit, unique name to the two layers that re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)
+
+In this example, other layers could extend the "MyLayer" fixture by using ``MY_FIXTURE`` as a base.
+Tests would use either ``MY_INTEGRATION_TESTING`` or ``MY_FUNCTIONAL_TESTING`` as appropriate.
+However, even if both these two layers were used, the fixture in ``MY_FIXTURE`` would only be set up once.
+
+.. note::
+
+    If you implement the ``testSetUp()`` and ``testTearDown()`` test lifecycle methods in your "fixture" layer (e.g. in the the ``MyLayer`` class above), they will execute before the corresponding methods from ``IntegrationTesting`` and ``FunctionalTesting``.
+    Hence, they cannot use those layers' resources (``app`` and ``request``).
+
+It may be preferable, therefore, to have your own "test lifecycle" layer classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and call base class methods as appropriate.
+``plone.app.testing`` takes this approach, for example.
+
+HTTP ZServer thread (fixture only)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.ZServer``                     |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.STARTUP``                     |
++------------+--------------------------------------------------+
+| Resources: | ``host``                                         |
+|            +--------------------------------------------------+
+|            | ``port``                                         |
++------------+--------------------------------------------------+
+
+This layer extends the ``z2.STARTUP`` layer to start the Zope HTTP server in a separate thread.
+This means the test site can be accessed through a web browser, and can thus be used with tools like `Windmill`_ or `Selenium`_.
+
+.. note::
+
+    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.
+    Use the ``ZSERVER`` layer if you want to execute functional tests against this fixture.
+
+The ZServer's hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.
+
+  *Hint:* Whilst the layer is set up, you can actually access the test Zope site through a web browser.
+  The default URL will be ``http://localhost:55001``.
+
+HTTP ZServer functional testing
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.ZSERVER``                     |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.FunctionalTesting``           |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |
++------------+--------------------------------------------------+
+| Resources: |                                                  |
++------------+--------------------------------------------------+
+
+This layer provides the functional testing lifecycle against the fixture set up by the ``z2.ZSERVER_FIXTURE`` layer.
+
+You can use this to run "live" functional tests against a basic Zope site.
+You should **not** use it as a base.
+Instead, create your own "fixture" layer that extends ``z2.ZSERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.
+
+FTP server thread (fixture only)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.FTPServer``                   |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.STARTUP``                     |
++------------+--------------------------------------------------+
+| Resources: | ``host``                                         |
+|            +--------------------------------------------------+
+|            | ``port``                                         |
++------------+--------------------------------------------------+
+
+This layer is the FTP server equivalent of the ``ZSERVER_FIXTURE`` layer.
+It can be used to functionally test Zope servers.
+
+.. note::
+
+    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.
+    Use the ``FTP_SERVER`` layer if you want to execute functional tests against this fixture.
+
+    *Hint:* Whilst the layer is set up, you can actually access the test Zope site through an FTP client.
+    The default URL will be ``ftp://localhost:55002``.
+
+.. warning::
+
+    Do not run the ``FTP_SERVER`` and ``ZSERVER`` layers concurrently in the same process.
+
+If you need both ZServer and FTPServer running together, you can subclass the ``ZServer`` layer class (like the ``FTPServer`` layer class does) and implement the ``setUpServer()`` and ``tearDownServer()`` methods to set up and close down two servers on different ports.
+They will then share a main loop.
+
+FTP server functional testing
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++------------+--------------------------------------------------+
+| Layer:     | ``plone.testing.z2.FTP_SERVER``                  |
++------------+--------------------------------------------------+
+| Class:     | ``plone.testing.z2.FunctionalTesting``           |
++------------+--------------------------------------------------+
+| Bases:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |
++------------+--------------------------------------------------+
+| Resources: |                                                  |
++------------+--------------------------------------------------+
+
+This layer provides the functional testing lifecycle against the fixture set up by the ``z2.FTP_SERVER_FIXTURE`` layer.
+
+You can use this to run "live" functional tests against a basic Zope site.
+You should **not** use it as a base.
+Instead, create your own "fixture" layer that extends ``z2.FTP_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.
+
+Helper functions
+~~~~~~~~~~~~~~~~
+
+Several helper functions are available in the ``plone.testing.z2`` module.
+
+``zopeApp(db=None, conn=Non, environ=None)``
+
+    This function can be used as a context manager for any code that requires access to the Zope application root.
+    By using it in a ``with`` block, the database will be opened, and the application root will be obtained and request-wrapped.
+    When exiting the ``with`` block, the transaction will be committed and the database properly closed, unless an exception was raised::
+
+        with z2.zopeApp() as app:
+            # do something with app
+
+    If you want to use a specific database or database connection, pass either the ``db`` or ``conn`` arguments.
+    If the context manager opened a new connection, it will close it, but it will not close a connection passed with ``conn``.
+
+    To set keys in the (fake) request environment, pass a dictionary of environment values as ``environ``.
+
+    Note that ``zopeApp()`` should *not* normally be used in tests or test set-up/tear-down, because the ``INTEGRATOIN_TEST`` and ``FUNCTIONAL_TESTING`` layers both manage the application root (as the ``app`` resource) and close it for you.
+    It is very useful in layer setup, however.
+
+``installProduct(app, product, quiet=False)``
+
+    Install a Zope 2 style product, ensuring that its ``initialize()`` function is called.
+    The product name must be the full dotted name, e.g. ``plone.app.portlets`` or ``Products.CMFCore``.
+    If ``quiet`` is true, duplicate registrations will be ignored silently, otherwise a message is logged.
+
+    To get hold of the application root, passed as the ``app`` argument, you would normally use the ``zopeApp()`` context manager outlined above.
+
+``uninstallProduct(app, product, quiet=False)``
+
+    This is the reciprocal of ``installProduct()``, normally used during layer tear-down.
+    Again, you should use ``zopeApp()`` to obtain the application root.
+
+``login(userFolder, userName)``
+
+    Create a new security manager that simulates being logged in as the given user.
+    ``userFolder`` is an ``acl_users`` object, e.g. ``app['acl_users']`` for the root user folder.
+
+``logout()``
+
+    Simulate being the anonymous user by unsetting the security manager.
+
+``setRoles(userFolder, userName, roles)``
+
+    Set the roles of the given user in the given user folder to the given list of roles.
+
+``makeTestRequest()``
+
+    Create a fake Zope request.
+
+``addRequestContainer(app, environ=None)``
+
+    Create a fake request and wrap the given object (normally an application root) in a ``RequestContainer`` with this request.
+    This makes acquisition of ``app.REQUEST`` possible.
+    To initialise the request environment with non-default values, pass a dictionary as ``environ``.
+
+    .. note::
+    
+       This method is rarely used, because both the ``zopeApp()``
+       context manager and the layer set-up/tear-down for
+       ``z2.INTEGRATION_TESTING`` and ``z2.FUNCTIONAL_TESTING`` will wrap the
+       ``app`` object before exposing it.
+
+``Browser(app)``
+
+    Obtain a test browser client, for use with `zope.testbrowser`_.
+    You should use this in conjunction with the ``z2.FUNCTIONAL_TESTING`` layer or a derivative.
+    You must pass the app root, usually obtained from the ``app`` resource of the layer, e.g.::
+
+        app = self.layer['app']
+        browser = z2.Browser(app)
+
+    You can then use ``browser`` as described in the `zope.testbrowser`_ documentation.
+
+    Bear in mind that the test browser runs separately from the test fixture.
+    In particular, calls to helpers such as ``login()`` or ``logout()`` do not affect the state that the test browser sees.
+    If you want to set up a persistent fixture (e.g. test content), you can do so before creating the test browser, but you will need to explicitly commit your changes, with::
+
+        import transaction
+        transaction.commit()
+
+.. _zope.testing: http://pypi.python.org/pypi/zope.testing
+.. _zope.testbrowser: http://pypi.python.org/pypi/zope.testbrowser
+.. _zope.component: http://pypi.python.org/pypi/zope.component
+.. _zope.publisher: http://pypi.python.org/pypi/zope.publisher
+.. _plone.app.testing: http://pypi.python.org/pypi/plone.app.testing
+.. _zc.recipe.testrunner: http://pypi.python.org/pypi/zc.recipe.testrunner
+.. _coverage: http://pypi.python.org/pypi/coverage
+.. _Cobertura: http://wiki.hudson-ci.org/display/HUDSON/Cobertura+Plugin
+.. _Hudson: http://www.hudson-labs.org/
+.. _unittest: http://doc.python.org/library/unittest.html
+.. _unittest2: http://pypi.python.org/pypi/unittest2
+.. _doctest: http://docs.python.org/dev/library/doctest.html
+.. _Windmill: http://getwindmill.com/
+.. _Selenium: http://seleniumhq.org/
diff --git a/setup.py b/setup.py
index 6fb36ff..e793f5f 100644
--- a/setup.py
+++ b/setup.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 import os
 import os.path
 import sys
@@ -5,87 +6,91 @@
 
 version = '4.1.0.dev0'
 
-install_requires = ['setuptools',
-                    'zope.testing',
-                    ]
+install_requires = [
+    'setuptools',
+    'zope.testing',
+]
 
 
 if sys.version_info < (2, 7):
     install_requires.append('unittest2')
 
-tests_require = ['zope.component',
-                 'zope.interface',
-                 'zope.publisher',
-                 'zope.security',
-                 'zope.event',
-                 'zope.configuration',
-                 'zope.testbrowser',
-                 'zope.testrunner',
-                 'zope.app.publisher',  # XXX: Can probably go away in Zope 2.13
-                 'ZODB3',
-                 'Zope2',
-                 ]
+tests_require = [
+    'zope.component',
+    'zope.interface',
+    'zope.publisher',
+    'zope.security',
+    'zope.event',
+    'zope.configuration',
+    'zope.testbrowser',
+    'zope.testrunner',
+    'zope.app.publisher',  # XXX: Can probably go away in Zope 2.13
+    'ZODB3',
+    'Zope2',
+]
 
-setup(name='plone.testing',
-      version=version,
-      description="Testing infrastructure for Zope and Plone projects.",
-      long_description=(open(os.path.join("src", "plone", "testing", "README.rst")).read() + "\n\n" +
-                        open("CHANGES.rst").read() + "\n\n" +
-                        "Detailed documentation\n" +
-                        "======================\n\n" +
-                        open(os.path.join("src", "plone", "testing", "layer.txt")).read() + "\n\n" +
-                        open(os.path.join("src", "plone", "testing", "zca.txt")).read() + "\n\n" +
-                        open(os.path.join("src", "plone", "testing", "security.txt")).read() + "\n\n" +
-                        open(os.path.join("src", "plone", "testing", "publisher.txt")).read() + "\n\n" +
-                        open(os.path.join("src", "plone", "testing", "zodb.txt")).read()),
-      classifiers=[
-          "Environment :: Web Environment",
-          "Framework :: Plone",
-          "Framework :: Plone :: 4.2",
-          "Framework :: Plone :: 4.3",
-          "Framework :: Plone :: 5.0",
-          "Operating System :: OS Independent",
-          "Programming Language :: Python",
-          "Programming Language :: Python :: 2.6",
-          "Programming Language :: Python :: 2.7",
-          "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
-          "License :: OSI Approved :: BSD License",
-      ],
-      keywords='plone zope testing',
-      author='Plone Foundation',
-      author_email='plone-developers@lists.sourceforge.net',
-      url='https://github.com/plone/plone.testing',
-      license='BSD',
-      packages=find_packages('src'),
-      package_dir={'': 'src'},
-      namespace_packages=['plone'],
-      include_package_data=True,
-      zip_safe=False,
-      install_requires=install_requires,
-      tests_require=tests_require,
-      extras_require={
-          'test': tests_require,
-          'zodb': [
-                  'ZODB3',
-                  ],
-          'zca': [
-                  'zope.component',
-                  'zope.event',
-                  'zope.configuration',
-                  ],
-          'security': [
-                  'zope.security',
-                  ],
-          'publisher': [
-                  'zope.configuration',
-                  'zope.security',
-                  'zope.app.publisher',  # XXX: Can probably go away in Zope 2.13
-                  ],
-          'z2': [
-                  'Zope2',
-                  'zope.site',
-                  'zope.testbrowser',
-                  'zope.publisher',
-                  ],
-      },
-      )
+setup(
+    name='plone.testing',
+    version=version,
+    description="Testing infrastructure for Zope and Plone projects.",
+    long_description=(u'\n\n'.join([
+        open(os.path.join("docs", "overview.rst")).read(),
+        open("CHANGES.rst").read(),
+        "Detailed documentation\n" +
+        "======================",
+        open(os.path.join("src", "plone", "testing", "layer.rst")).read(),
+        open(os.path.join("src", "plone", "testing", "zca.rst")).read(),
+        open(os.path.join("src", "plone", "testing", "security.rst")).read(),
+        open(os.path.join("src", "plone", "testing", "publisher.rst")).read(),
+        open(os.path.join("src", "plone", "testing", "zodb.rst")).read(),
+        open(os.path.join("src", "plone", "testing", "z2.rst")).read()
+    ])),
+    classifiers=[
+        "Environment :: Web Environment",
+        "Framework :: Plone",
+        "Framework :: Plone :: 4.2",
+        "Framework :: Plone :: 4.3",
+        "Framework :: Plone :: 5.0",
+        "Operating System :: OS Independent",
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 2.6",
+        "Programming Language :: Python :: 2.7",
+        "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
+        "License :: OSI Approved :: BSD License",
+    ],
+    keywords='plone zope testing',
+    author='Plone Foundation',
+    author_email='plone-developers@lists.sourceforge.net',
+    url='https://github.com/plone/plone.testing',
+    license='BSD',
+    packages=find_packages('src'),
+    package_dir={'': 'src'},
+    namespace_packages=['plone'],
+    include_package_data=True,
+    zip_safe=False,
+    install_requires=install_requires,
+    tests_require=tests_require,
+    extras_require={
+        'test': tests_require,
+        'zodb': ['ZODB3'],
+        'zca': [
+            'zope.component',
+            'zope.event',
+            'zope.configuration',
+        ],
+        'security': [
+            'zope.security',
+        ],
+        'publisher': [
+            'zope.configuration',
+            'zope.security',
+            'zope.app.publisher',  # XXX: Can probably go away in Zope 2.13
+        ],
+        'z2': [
+            'Zope2',
+            'zope.site',
+            'zope.testbrowser',
+            'zope.publisher',
+        ],
+    },
+)
diff --git a/src/plone/__init__.py b/src/plone/__init__.py
index de40ea7..68c04af 100644
--- a/src/plone/__init__.py
+++ b/src/plone/__init__.py
@@ -1 +1,2 @@
+# -*- coding: utf-8 -*-
 __import__('pkg_resources').declare_namespace(__name__)
diff --git a/src/plone/testing/README.rst b/src/plone/testing/README.rst
deleted file mode 100644
index c727322..0000000
--- a/src/plone/testing/README.rst
+++ /dev/null
@@ -1,2229 +0,0 @@
-Introduction
-============
-
-.. contents:: Table of contents
-
-``plone.testing`` provides tools for writing unit and integration tests in a
-Zope and Plone environment. It is not tied to Plone, and it does not depend on
-Zope 2 (although it has some optional Zope 2-only features).
-
-``plone.testing`` builds on `zope.testing`_, in particular its layers concept.
-This package also aims to promote some "good practice" for writing tests of
-various types.
-
-.. note::
-
-   If you are working with Plone, there is a complementary package
-   `plone.app.testing`_, which builds on ``plone.testing`` to provide
-   additional layers useful for testing Plone add-ons.
-
-If you are new to automated testing and test driven development, you should
-spend some time learning about those concepts. Some useful references include:
-
-* `The Wikipedia article on unit testing <http://en.wikipedia.org/wiki/Unit_testing>`_
-* `The Dive Into Python chapter on testing <http://diveintopython.net/unit_testing/index.html>`_
-
-Bear in mind that different Python frameworks have slightly different takes on
-how to approach testing. Therefore, you may find examples that are different
-to those shown below. The core concepts should be consistent, however.
-
-Compatibility
--------------
-
-``plone.testing`` 4.x has only been tested with Python 2.6 and 2.7.
-If you're using the
-optional Zope 2 layers, you must use Zope version 2.12 or later.
-Look at ``plone.testing`` 3.x for Zope 2.10 support.
-
-Definitions
------------
-
-In this documentation, we will use a number of testing-related terms. The
-following definitions apply:
-
-Unit test
-    An automated test (i.e. one written in code) that tests a single unit
-    (normally a function) in isolation. A unit test attempts to prove that the
-    given function works as expected and gives the correct output given a
-    particular input. It is common to have a number of unit tests for a single
-    function, testing different inputs, including boundary cases and errors.
-    Unit tests are typically quick to write and run.
-Integration test
-    An automated test that tests how a number of units interact. In a Zope
-    context, this often pertains to how a particular object or view interacts
-    with the Zope framework, the ZODB persistence engine, and so on.
-    Integration tests usually require some setup and can be slower to run than
-    unit tests. It is common to have fewer integration tests than unit test.
-Functional test
-    An automated test that tests a feature in an "end-to-end" fashion. In a
-    Zope context, that normally means that it invokes an action in the same
-    way that a user would, i.e. through a web request. Functional tests are
-    normally slower to run than either unit or integration tests, and can be
-    significantly slower to run. It is therefore common to have only a few
-    functional tests for each major feature, relying on unit and integration
-    tests for the bulk of testing.
-Black box testing
-    Testing which only considers the system's defined inputs and outputs. For
-    example, a functional test is normally a black box test that provides
-    inputs only through the defined interface (e.g. URLs published in a web
-    application), and makes assertions only on end outputs (e.g. the response
-    returned for requests to those URLs).
-White box testing
-    Testing which examines the internal state of a system to make assertions.
-    Authors of unit and integration tests normally have significant knowledge
-    of the implementation of the code under test, and can examine such things
-    as data in a database or changes to the system's environment to determine
-    if the test succeeded or failed.
-Assertion
-    A check that determines whether a test succeeds or fails. For example, if
-    a unit test for the function ``foo()`` expects it to return the value 1,
-    an assertion could be written to verify this fact. A test is said to
-    *fail* if any of its assertions fail. A test always contains one or more
-    assertions.
-Test case
-    A single unit, integration or functional test. Often shortened to just
-    *test*. A test case sets up, executes and makes assertions against a
-    single scenario that bears testing.
-Test fixture
-    The state used as a baseline for one or more tests. The test fixture is
-    *set up* before each test is executed, and *torn down* afterwards. This is
-    a pre-requisite for *test isolation* - the principle that tests should be
-    independent of one another.
-Layer
-    The configuration of a test fixture shared by a number of tests. All test
-    cases that belong to a particular layer will be executed together. The
-    layer is *set up* once before the tests are executed, and *torn down* once
-    after. Layers may depend on one another. Any *base layers* are set up
-    before and torn down after a particular *child layer* is used. The test
-    runner will order test execution to minimise layer setup and tear-down.
-Test suite
-    A collection of test cases (and layers) that are executed together.
-Test runner
-    The program which executes tests. This is responsible for calling layer
-    and test fixture set-up and tear-down methods. It also reports on the test
-    run, usually by printing output to the console.
-Coverage
-    To have confidence in your code, you should ensure it is adequately
-    covered by tests. That is, each line of code, and each possible branching
-    point (loops, ``if`` statements) should be executed by a test. This is
-    known as *coverage*, and is normally measured as a percentage of lines of
-    non-test code covered by tests. Coverage can be measured by the test
-    runner, which keeps track of which lines of code were executed in a given
-    test run.
-Doctest
-    A style of testing where tests are written as examples that could be typed
-    into the interactive Python interpreter. The test runner executes each
-    example and checks the actual output against the expected output. Doctests
-    can either be placed in the docstring of a method, or in a separate file.
-    The use of doctests is largely a personal preference. Some developers like
-    to write documentation as doctests, which has the advantage that code
-    samples can be automatically tested for correctness. You can read more
-    about doctests on `Wikipedia <http://en.wikipedia.org/wiki/Doctest>`_.
-
-Installation and usage
-======================
-
-To use ``plone.testing`` in your own package, you need to add it as a
-dependency. Most people prefer to keep test-only dependencies separate, so
-that they do not need to be installed in scenarios (such as on a production
-server) where the tests will not be run. This can be achieved using a
-``test`` extra.
-
-In ``setup.py``, add or modify the ``extras_require`` option, like so::
-
-    extras_require = {
-        'test': [
-                'plone.testing',
-            ]
-    },
-
-You can add other test-only dependencies to that list as well, of course.
-
-To run tests, you need a test runner. If you are using ``zc.buildout``, you
-can install a test runner using the `zc.recipe.testrunner`_ recipe. For
-example, you could add the following to your ``buildout.cfg``::
-
-    [test]
-    recipe = zc.recipe.testrunner
-    eggs =
-        my.package [test]
-    defaults = ['--auto-color', '--auto-progress']
-
-You'll also need to add this part to the ``parts`` list, of course::
-
-    [buildout]
-    parts =
-        ...
-        test
-
-In this example, have listed a single package to test, called ``my.package``,
-and asked for it to be installed with the ``[test]`` extra. This will install
-any regular dependencies (listed in the ``install_requires`` option in
-``setup.py``), as well as those in the list associated with the ``test`` key
-in the ``extras_require`` option.
-
-Note that it becomes important to properly list your dependencies here,
-because the test runner will only be aware of the packages explicitly listed,
-and their dependencies. For example, if your package depends on Zope 2, you
-need to list ``Zope2`` in the ``install_requires`` list in ``setup.py``; ditto
-for ``Plone``, or indeed any other package you import from.
-
-Once you have re-run buildout, the test runner will be installed as
-``bin/test`` (the executable name is taken from the name of the buildout
-part). You can execute it without arguments to run all tests of each egg
-listed in the ``eggs`` list::
-
-    $ bin/test
-
-If you have listed several eggs, and you want to run the tests for a
-particular one, you can do::
-
-    $ bin/test -s my.package
-
-If you want to run only a particular test within this package, use the ``-t``
-option. This can be passed a regular expression matching either a doctest file
-name or a test method name.
-
-    $ bin/test -s my.package -t test_spaceship
-
-There are other command line options, which you can find by running::
-
-    $ bin/test --help
-
-Also note the ``defaults`` option in the buildout configuration. This can be
-used to set default command line options. Some commonly useful options are
-shown above.
-
-Coverage reporting
-------------------
-
-When writing tests, it is useful to know how well your tests cover your code.
-You can create coverage reports via the excellent `coverage`_ library. In
-order to use it, we need to install it and a reporting script::
-
-    [buildout]
-    parts =
-        ...
-        test
-        coverage
-        report
-
-    [coverage]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    initialization =
-        include = '--source=${buildout:directory}/src'
-        sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all']
-
-    [report]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    scripts = coverage=report
-    initialization =
-        sys.argv = sys.argv[:] + ['html', '-i']
-
-This will run the ``bin/test`` script with arguments like `--all` to run all
-layers. You can also specify no or some other arguments. It will place coverage
-reporting information in a ``.coverage`` file inside your buildout root.
-Via the ``--source`` argument you specify the directories containing code you
-want to cover. The coverage script would otherwise generate coverage
-information for all executed code, including other packages and even the
-standard library.
-
-Running the ``bin/report`` script will generate a human readable HTML
-representation of the run in the `htmlcov` directory. Open the contained
-`index.html` in a browser to see the result.
-
-If you want to generate an XML representation suitable for the `Cobertura`_
-plugin of `Hudson`_, you can add another part::
-
-    [buildout]
-    parts =
-        ...
-        report-xml
-
-    [report-xml]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    scripts = coverage=report-xml
-    initialization =
-        sys.argv = sys.argv[:] + ['xml', '-i']
-
-This will generate a ``coverage.xml`` file in the buildout root.
-
-Optional dependencies
----------------------
-
-``plone.testing`` comes with a core set of tools for managing layers, which
-depends only on `zope.testing`_ and (for Python < 2.7) `unittest2`_. In addition, there are
-several layers and helper functions which can be used in your own tests (or
-as bases for your own layers). Some of these have deeper dependencies.
-However, these dependencies are optional and not installed by default. If you
-don't use the relevant layers, you can safely ignore them.
-
-``plone.testing`` does specify these dependencies, however, using the
-``setuptools`` "extras" feature. You can depend on one or more extras in
-your own ``setup.py`` ``install_requires`` or ``extras_require`` option
-using the same square bracket notation shown for the ``[test]`` buildout part
-above. For example, if you need both the ``zca`` and ``publisher`` extras, you
-can have the following in your ``setup.py``::
-
-    extras_require = {
-        'test': [
-                'plone.testing [zca, publisher]',
-            ]
-    },
-
-The available extras are:
-
-``zodb``
-    ZODB testing. Depends on ``ZODB3``. The relevant layers and helpers are in
-    the module ``plone.testing.zodb``.
-``zca``
-    Zope Component Architecture testing. Depends on core Zope Component
-    Architecture packages such as ``zope.component`` and ``zope.event``. The
-    relevant layers and helpers are in the module ``plone.testing.zca``.
-``security``
-    Security testing. Depends on ``zope.security``. The relevant layers and
-    helpers are in the module ``plone.testing.security``.
-``publisher``
-    Zope Publisher testing. Depends on ``zope.app.publisher`` and sets up
-    ZCML directives. The relevant layers and helpers are in the module
-    ``plone.testing.publisher``.
-``z2``
-    Zope 2 testing. Depends on the ``Zope2`` egg, which includes all the
-    dependencies of the Zope 2 application server. The relevant layers and
-    helpers are in the module ``plone.testing.z2``
-
-Adding a test buildout to your package
---------------------------------------
-
-When creating re-usable, mostly stand-alone packages, it is often useful to be
-able to include a buildout with the package sources itself that can be used to
-create a test runner. This is a popular approach for many Zope packages, for
-example. In fact, ``plone.testing`` itself uses this kind of layout.
-
-To have a self-contained buildout in your package, the following is required:
-
-* You need a ``buildout.cfg`` at the root of the package.
-* In most cases, you always want a ``bootstrap.py`` file to make it easier for
-  people to set up a fresh buildout.
-* Your package sources need to be inside a ``src`` directory. If you're using
-  namespace packages, that means the top level package should be in the
-  ``src`` directory.
-* The ``src`` directory must be referenced in ``setup.py``.
-
-For example, ``plone.testing`` has the following layout::
-
-    plone.testing/
-    plone.testing/setup.py
-    plone.testing/bootstrap.py
-    plone.testing/buildout.cfg
-    plone.testing/README.txt
-    plone.testing/src/
-    plone.testing/src/plone
-    plone.testing/src/plone/__init__.py
-    plone.testing/src/plone/testing/
-    plone.testing/src/plone/testing/*
-
-In ``setup.py``, the following arguments are required::
-
-        packages=find_packages('src'),
-        package_dir={'': 'src'},
-
-This tells ``setuptools`` where to find the source code.
-
-The ``buildout.cfg`` for ``plone.testing`` looks like this::
-
-    [buildout]
-    extends =
-        http://download.zope.org/Zope2/index/2.12.12/versions.cfg
-    parts = coverage test report report-xml
-    develop = .
-
-    [test]
-    recipe = collective.xmltestreport
-    eggs =
-        plone.testing [test]
-    defaults = ['--auto-color', '--auto-progress']
-
-    [coverage]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    initialization =
-        include = '--source=${buildout:directory}/src'
-        sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all', '--xml']
-
-    [report]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    scripts = coverage=report
-    initialization =
-        sys.argv = sys.argv[:] + ['html', '-i']
-
-    [report-xml]
-    recipe = zc.recipe.egg
-    eggs = coverage
-    scripts = coverage=report-xml
-    initialization =
-        sys.argv = sys.argv[:] + ['xml', '-i']
-
-Obviously, you should adjust the package name in the ``eggs`` list and the
-version set in the ``extends`` line as appropriate.
-
-You can of course also add additional buildout parts, for example to include
-some development/debugging tools, or even a running application server for
-testing purposes.
-
-    *Hint:* If you use this package layout, you should avoid checking any
-    files or directories generated by buildout into your version control
-    repository. You want to ignore:
-
-    * ``.coverage``
-    * ``.installed.cfg``
-    * ``bin``
-    * ``coverage.xml``
-    * ``develop-eggs``
-    * ``htmlcov``
-    * ``parts``
-    * ``src/*.egg-info``
-
-Layers
-======
-
-In large part, ``plone.testing`` is about layers. It provides:
-
-* A set of layers (outlined below), which you can use or extend.
-* A set of tools for working with layers
-* A mini-framework to make it easy to write layers and manage shared resources
-  associated with layers.
-
-We'll discuss the last two items here, before showing how to write tests that
-use layers.
-
-Layer basics
-------------
-
-Layers are used to create test fixtures that are shared by multiple test
-cases. For example, if you are writing a set of integration tests, you may
-need to set up a database and configure various components to access that
-database. This type of test fixture setup can be resource-intensive and
-time-consuming. If it is possible to only perform the setup and tear-down once
-for a set of tests without losing isolation between those tests, test runs can
-often be sped up significantly.
-
-Layers also allow re-use of test fixtures and set-up/tear-down code.
-``plone.testing`` provides a number of useful (but optional) layers that
-manage test fixtures for common Zope testing scenarios, letting you focus on
-the actual test authoring.
-
-At the most basic, a layer is an object with the following methods and
-attributes:
-
-``setUp()``
-    Called by the test runner when the layer is to be set up. This is called
-    exactly once for each layer used during a test run.
-``tearDown()``
-    Called by the test runner when the layer is to be torn down. As with
-    ``setUp()``, this is called exactly once for each layer.
-``testSetUp()``
-    Called immediately before each test case that uses the layer is executed.
-    This is useful for setting up aspects of the fixture that are managed on
-    a per-test basis, as opposed to fixture shared among all tests.
-``testTearDown()``
-    Called immediately after each test case that uses the layer is executed.
-    This is a chance to perform any post-test cleanup to ensure the fixture
-    is ready for the next test.
-``__bases__``
-    A tuple of base layers.
-
-Each test case is associated with zero or one layer. (The syntax for
-specifying the layer is shown in the section "Writing tests" below.) All the
-tests associated with a given layer will be executed together.
-
-Layers can depend on one another (as indicated in the ``__bases__`` tuple),
-allowing one layer to build on the fixture created by another. Base layers are
-set up before and torn down after their dependants.
-
-For example, if the test runner is executing some tests that belong to layer
-A, and some other tests that belong to layer B, both of which depend on layer
-C, the order of execution might be::
-
-    1. C.setUp()
-    1.1. A.setUp()
-
-    1.1.1. C.testSetUp()
-    1.1.2. A.testSetUp()
-    1.1.3. [One test using layer A]
-    1.1.4. A.testTearDown()
-    1.1.5. C.testTearDown()
-
-    1.1.6. C.testSetUp()
-    1.1.7. A.testSetUp()
-    1.1.8. [Another test using layer A]
-    1.1.9. A.testTearDown()
-    1.1.10. C.testTearDown()
-
-    1.2. A.tearDown()
-    1.3. B.setUp()
-
-    1.3.1. C.testSetUp()
-    1.3.2. B.testSetUp()
-    1.3.3. [One test using layer B]
-    1.3.4. B.testTearDown()
-    1.3.5. C.testTearDown()
-
-    1.3.6. C.testSetUp()
-    1.3.7. B.testSetUp()
-    1.3.8. [Another test using layer B]
-    1.3.9. B.testTearDown()
-    1.3.10. C.testTearDown()
-
-    1.4. B.tearDown()
-    2. C.tearDown()
-
-A base layer may of course depend on other base layers. In the case of nested
-dependencies like this, the order of set up and tear-down as calculated by the
-test runner is similar to the way in which Python searches for the method to
-invoke in the case of multiple inheritance.
-
-Writing layers
---------------
-
-The easiest way to create a new layer is to use the ``Layer`` base class and
-implement the ``setUp()``, ``tearDown()``, ``testSetUp()`` and
-``testTearDown()`` methods as needed. All four are optional. The default
-implementation of each does nothing.
-
-By convention, layers are created in a module called ``testing.py`` at the top
-level of your package. The idea is that other packages that extend your
-package can re-use your layers for their own testing.
-
-A simple layer may look like this:
-
-    >>> from plone.testing import Layer
-    >>> class SpaceShip(Layer):
-    ...
-    ...     def setUp(self):
-    ...         print "Assembling space ship"
-    ...
-    ...     def tearDown(self):
-    ...         print "Disasembling space ship"
-    ...
-    ...     def testSetUp(self):
-    ...         print "Fuelling space ship in preparation for test"
-    ...
-    ...     def testTearDown(self):
-    ...         print "Emptying the fuel tank"
-
-Before this layer can be used, it must be instantiated. Layers are normally
-instantiated exactly once, since by nature they are shared between tests. This
-becomes important when you start to manage resources (such as persistent data,
-database connections, or other shared resources) in layers.
-
-The layer instance is conventionally also found in ``testing.py``, just after
-the layer class definition.
-
-    >>> SPACE_SHIP = SpaceShip()
-
-.. note::
-
-   Since the layer is instantiated in module scope, it will be
-   created as soon as the ``testing`` module is imported. It is therefore
-   very important that the layer class is inexpensive and safe to create. In
-   general, you should avoid doing anything non-trivial in the ``__init__()``
-   method of your layer class. All setup should happen in the ``setUp()``
-   method. If you *do* implement ``__init__()``, be sure to call the ``super``
-   version as well.
-
-The layer shown above did not have any base layers (dependencies). Here is an
-example of another layer that depends on it:
-
-    >>> class ZIGSpaceShip(Layer):
-    ...     defaultBases = (SPACE_SHIP,)
-    ...
-    ...     def setUp(self):
-    ...         print "Installing main canon"
-
-    >>> ZIG = ZIGSpaceShip()
-
-Here, we have explicitly listed the base layers on which ``ZIGSpaceShip``
-depends, in the ``defaultBases`` attribute. This is used by the ``Layer``
-base class to set the layer bases in a way that can also be overridden: see
-below.
-
-Note that we use the layer *instance* in the ``defaultBases`` tuple, not the
-class. Layer dependencies always pertain to specific layer instances. Above,
-we are really saying that *instances* of ``ZIGSpaceShip`` will, by default,
-require the ``SPACE_SHIP`` layer to be set up first.
-
-.. note::
-
-   You may find it useful to create other layer base/mix-in classes
-   that extend ``plone.testing.Layer`` and provide helper methods for use in
-   your own layers. This is perfectly acceptable, but please do not confuse a
-   layer base class used in this manner with the concept of a *base layer* as
-   described above:
-
-     * A class deriving from ``plone.testing.Layer`` is known as a *layer
-       class*. It defines the behaviour of the layer by implementing the
-       lifecycle methods ``setUp()``, ``tearDown()``, ``testSetUp()`` and/or
-       ``testTearDown()``.
-     * A layer class can be instantiated into an actual layer. When a layer is
-       associated with a test, it is the layer *instance* that is used.
-     * The instance is usually a shared, module-global object, although in
-       some cases it is useful to create copies of layers by instantiating the
-       class more than once.
-     * Subclassing an existing layer class is just straightforward OOP re-use:
-       the test runner is not aware of the subclassing relationship.
-     * A layer *instance* can be associated with any number of layer *bases*,
-       via its ``__bases__`` property (which is usually via the
-       ``defaultBases`` variable in the class body and/or overridden using the
-       ``bases`` argument to the ``Layer`` constructor). These bases are layer
-       *instances*, not classes. The test runner will inspect the ``__bases__``
-       attribute of each layer instance it sets up to calculate layer
-       pre-requisites and dependencies.
-
-   Also note that the `zope.testing`_ documentation contains examples of
-   layers that are "old-style" classes where the ``setUp()`` and
-   ``tearDown()`` methods are ``classmethod`` methods and class inheritance
-   syntax is used to specify base layers. Whilst this pattern works, we
-   discourage its use, because the classes created using this pattern are not
-   really used as classes. The concept of layer bases is slightly different
-   from class inheritance, and using the ``class`` keyword to create layers
-   with base layers leads to a number of "gotchas" that are best avoided.
-
-Advanced - overriding bases
----------------------------
-
-In some cases, it may be useful to create a copy of a layer, but change its
-bases. One reason to do this may if you are re-using a layer from another
-module, and you need to change the order in which layers are set up and torn
-down.
-
-Normally, of course, you would just re-use the layer instance, either directly
-in a test, or in the ``defaultBases`` tuple of another layer, but if you need
-to change the bases, you can pass a new list of bases to the layer instance
-constructor:
-
-    >>> class CATSMessage(Layer):
-    ...
-    ...     def setUp(self):
-    ...         print "All your base are belong to us"
-    ...
-    ...     def tearDown(self):
-    ...         print "For great justice"
-
-    >>> CATS_MESSAGE = CATSMessage()
-
-    >>> ZERO_WING = ZIGSpaceShip(bases=(SPACE_SHIP, CATS_MESSAGE,), name="ZIGSpaceShip:CATSMessage")
-
-Please note that when overriding bases like this, the ``name`` argument is
-required. This is because each layer (using in a given test run) must have
-a unique name. The default is to use the layer class name, but this obviously
-only works for one instantiation. Therefore, ``plone.testing`` requires a
-name when setting ``bases`` explicitly.
-
-Please take great care when changing layer bases like this. The layer
-implementation may make assumptions about the test fixture that was set up
-by its bases. If you change the order in which the bases are listed, or remove
-a base altogether, the layer may fail to set up correctly.
-
-Also, bear in mind that the new layer instance is independent of the original
-layer instance, so any resources defined in the layer are likely to be
-duplicated.
-
-Layer combinations
-------------------
-
-Sometimes, it is useful to be able to combine several layers into one, without
-adding any new fixture. One way to do this is to use the ``Layer`` class
-directly and instantiate it with new bases:
-
-    >>> COMBI_LAYER = Layer(bases=(CATS_MESSAGE, SPACE_SHIP,), name="Combi")
-
-Here, we have created a "no-op" layer with two bases: ``CATS_MESSAGE`` and
-``SPACE_SHIP``, named ``Combi``.
-
-Please note that when using ``Layer`` directly like this, the ``name``
-argument is required. This is to allow the test runner to identify the layer
-correctly. Normally, the class name of the layer is used as a basis for the
-name, but when using the ``Layer`` base class directly, this is unlikely to be
-unique or descriptive.
-
-Layer resources
----------------
-
-Many layers will manage one or more resources that are used either by other
-layers, or by tests themselves. Examples may include database connections,
-thread-local objects, or configuration data.
-
-``plone.testing`` contains a simple resource storage abstraction that makes it
-easy to access resources from dependant layers or tests. The resource storage
-uses dictionary notation:
-
-    >>> class WarpDrive(object):
-    ...     """A shared resource"""
-    ...
-    ...     def __init__(self, maxSpeed):
-    ...         self.maxSpeed = maxSpeed
-    ...         self.running = False
-    ...
-    ...     def start(self, speed):
-    ...         if speed > self.maxSpeed:
-    ...             print "We need more power!"
-    ...         else:
-    ...             print "Going to warp at speed", speed
-    ...             self.running = True
-    ...
-    ...     def stop(self):
-    ...         self.running = False
-
-    >>> class ConstitutionClassSpaceShip(Layer):
-    ...     defaultBases = (SPACE_SHIP,)
-    ...
-    ...     def setUp(self):
-    ...         self['warpDrive'] = WarpDrive(8.0)
-    ...
-    ...     def tearDown(self):
-    ...         del self['warpDrive']
-
-    >>> CONSTITUTION_CLASS_SPACE_SHIP = ConstitutionClassSpaceShip()
-
-    >>> class GalaxyClassSpaceShip(Layer):
-    ...     defaultBases = (CONSTITUTION_CLASS_SPACE_SHIP,)
-    ...
-    ...     def setUp(self):
-    ...         # Upgrade the warp drive
-    ...         self.previousMaxSpeed = self['warpDrive'].maxSpeed
-    ...         self['warpDrive'].maxSpeed = 9.5
-    ...
-    ...     def tearDown(self):
-    ...         # Restore warp drive to its previous speed
-    ...         self['warpDrive'].maxSpeed = self.previousMaxSpeed
-
-    >>> GALAXY_CLASS_SPACE_SHIP = GalaxyClassSpaceShip()
-
-As shown, layers (that derive from ``plone.testing.Layer``) support item
-(dict-like) assignment, access and deletion of arbitrary resources under
-string keys.
-
-    **Important:** If a layer creates a resource (by assigning an object to
-    a key on ``self`` as shown above) during fixture setup-up, it must also
-    delete the resource on tear-down. Set-up and deletion should be symmetric:
-    if the resource is assigned during ``setUp()`` it should be deleted in
-    ``tearDown()``; if it's created in ``testSetUp()`` it should be deleted
-    in ``testTearDown()``.
-
-A resource defined in a base layer is accessible from and through a child
-layer. If a resource is set on a child using a key that also exists in a base
-layer, the child version will shadow the base version until the child layer is
-torn down (presuming it deletes the resource, which it should), but the base
-layer version remains intact.
-
-.. note::
-
-   Accessing a resource is analogous to accessing an instance
-   variable. For example, if a base layer assigns a resource to a given key
-   in its ``setUp()`` method, a child layer shadows that resource with
-   another object under the same key, the shadowed resource will by used
-   during the ``testSetUp()`` and ``testTearDown()`` lifecycle methods if
-   implemented by the *base* layer as well. This will be the case until
-   the child layer "pops" the resource by deleting it, normally in its
-   ``tearDown()``.
-
-Conversely, if (as shown above) the child layer accesses and modifies the
-object, it will modify the original.
-
-.. note::
-
-   It is sometimes necessary (or desirable) to modify a shared
-   resource in a child layer, as shown in the example above. In this case,
-   however, it is very important to restore the original state when the layer
-   is torn down. Otherwise, other layers or tests using the base layer
-   directly may be affected in difficult-to-debug ways.
-
-If the same key is used in multiple base layers, the rules for choosing which
-version to use are similar to those that apply when choosing an attribute or
-method to use in the case of multiple inheritance.
-
-In the example above, we used the resource manager for the ``warpDrive``
-object, but we assigned the ``previousMaxSpeed`` variable to ``self``. This is
-because ``previousMaxSpeed`` is internal to the layer and should not be shared
-with any other layers that happen to use this layer as a base. Nor should it
-be used by any test cases. Conversely, ``warpDrive`` is a shared resource that
-is exposed to other layers and test cases.
-
-The distinction becomes even more important when you consider how a test case
-may access the shared resource. We'll discuss how to write test cases that use
-layers shortly, but consider the following test:
-
-    >>> try:
-    ...     import unittest2 as unittest
-    ... except ImportError: # Python 2.7
-    ...     import unittest
-    >>> class TestFasterThanLightTravel(unittest.TestCase):
-    ...     layer = GALAXY_CLASS_SPACE_SHIP
-    ...
-    ...     def test_hyperdrive(self):
-    ...         warpDrive = self.layer['warpDrive']
-    ...         warpDrive.start(8)
-
-This test needs access to the shared resource. It knows that its layer defines
-one called ``warpDrive``. It does not know or care that the warp drive was
-actually initiated by the ``ConstitutionClassSpaceShip`` base layer.
-
-If, however, the base layer had assigned the resource as an instance variable,
-it would not inherit to child layers (remember: layer bases are not base
-classes!). The syntax to access it would be::
-
-    self.layer.__bases__[0].warpDrive
-
-which is not only ugly, but brittle: if the list of bases is changed, the
-expression above may lead to an attribute error.
-
-Writing tests
-=============
-
-Tests are usually written in one of two ways: As methods on a class that
-derives from ``unittest.TestCase`` (this is sometimes known as "Python tests"
-or "JUnit-style tests"), or using doctest syntax.
-
-You should realise that although the relevant frameworks (``unittest``,
-``unittest2`` and ``doctest``) often talk about unit testing, these tools are
-also used to write integration and functional tests. The distinction between
-unit, integration and functional tests is largely practical: you use the same
-techniques to set up a fixture or write assertions for an integration test as
-you would for a unit test. The difference lies in what that fixture contains,
-and how you invoke the code under test. In general, a true unit test will have
-a minimal or no test fixture, whereas an integration test will have a fixture
-that contains the components your code is integrating with. A functional test
-will have a fixture that contains enough of the full system to execute and
-test an "end-to-end" scenario.
-
-Python tests
-------------
-
-Python tests use the Python `unittest`_ module, or its cousin `unittest2`_
-(see below). They should be placed in a module or package called ``tests``
-for the test runner to pick them up.
-
-For small packages, a single module called ``tests.py`` will normally contain
-all tests. For larger packages, it is common to have a ``tests`` package that
-contains a number of modules with tests. These need to start with the word
-``test``, e.g. ``tests/test_foo.py`` or ``tests/test_bar.py``. Don't forget
-the ``__init__.py`` in the ``tests`` package, too!
-
-unittest2
-~~~~~~~~~
-
-In Python 2.7+, the ``unittest`` module has grown several new and useful
-features. To make use of these in Python 2.4, 2.5 and 2.6, an add-on module
-called `unittest2`_ can be installed. ``plone.testing`` depends on
-``unittest2`` for these versions (and uses it for its own tests), so you will have access to it
-if you depend on ``plone.testing``.
-
-We will use ``unittest2`` for the examples in this document, but try to import it
-with an alias of ``unittest``. This makes the code forward compatible with
-Python 2.7, where the built-in ``unittest`` module will have all the features
-of the ``unittest2`` module.
-
-Please note that the `zope.testing`_ test runner at the time of writing
-(version 3.9.3) does not (yet) support the new ``setUpClass()``,
-``tearDownClass()``, ``setUpModule()`` and ``tearDownModule()`` hooks from
-``unittest2``. This is not normally a problem, since we tend to use layers to
-manage complex fixtures, but it is important to be aware of nonetheless.
-
-Test modules, classes and functions
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Python tests are written with classes that derive from the base class
-``TestCase``. Each test is written as a method that takes no arguments and
-has a name starting with ``test``. Other methods can be added and called from
-test methods as appropriate, e.g. to share some test logic.
-
-Two special methods, ``setUp()`` and ``tearDown()``, can also be added. These
-will be called before or after each test, respectively, and provide a useful
-place to construct and clean up test fixtures without writing a custom layer.
-They are obviously not as re-usable as layers, though.
-
-   *Hint:* Somewhat confusingly, the ``setUp()`` and ``tearDown()`` methods in
-   a test case class are the equivalent of the ``testSetUp()`` and
-   ``testTearDown()`` methods of a layer class.
-
-A layer can be specified by setting the ``layer`` class attribute to a layer
-instance. If layers are used in conjunction with ``setUp()`` and
-``tearDown()`` methods in the test class itself, the class' ``setUp()`` method
-will be called after the layer's ``testSetUp()`` method, and the class'
-``tearDown()`` method will be called before the layer's ``testTearDown()``
-method.
-
-The ``TestCase`` base class contains a number of methods which can be used to
-write assertions. They all take the form ``self.assertSomething()``, e.g.
-``self.assertEqual(result, expectedValue)``. See the `unittest`_ and/or
-`unittest2`_ documentation for details.
-
-Putting this together, let's expand on our previous example unit test:
-
-    >>> try:
-    ...     import unittest2 as unittest
-    ... except ImportError: # Python 2.7
-    ...     import unittest
-
-    >>> class TestFasterThanLightTravel(unittest.TestCase):
-    ...     layer = GALAXY_CLASS_SPACE_SHIP
-    ...
-    ...     def setUp(self):
-    ...         self.warpDrive = self.layer['warpDrive']
-    ...         self.warpDrive.stop()
-    ...
-    ...     def tearDown(self):
-    ...         self.warpDrive.stop()
-    ...
-    ...     def test_warp8(self):
-    ...         self.warpDrive.start(8)
-    ...         self.assertEqual(self.warpDrive.running, True)
-    ...
-    ...     def test_max_speed(self):
-    ...         tooFast = self.warpDrive.maxSpeed + 0.1
-    ...         self.warpDrive.start(tooFast)
-    ...         self.assertEqual(self.warpDrive.running, False)
-
-A few things to note:
-
-* The class derives from ``unittest.TestCase``.
-* The ``layer`` class attribute is set to a layer instance (not a layer
-  class!) defined previously. This would typically be imported from a
-  ``testing`` module.
-* There are two tests here: ``test_warp8()`` and ``test_max_speed()``.
-* We have used the ``self.assertEqual()`` assertion in both tests to check the
-  result of executing the ``start()`` method on the warp drive.
-* We have used the ``setUp()`` method to fetch the ``warpDrive`` resource and
-  ensure that it is stopped before each test is executed. Assigning a variable
-  to ``self`` is a useful way to provide some state to each test method,
-  though be careful about data leaking between tests: in general, you cannot
-  predict the order in which tests will run, and tests should always be
-  independent.
-* We have used the ``tearDown()`` method to make sure the warp
-  drive is really stopped after each test.
-
-Test suites
-~~~~~~~~~~~
-
-If you are using version 3.8.0 or later of `zope.testing`_, a class like the
-one above is all you need: any class deriving from ``TestCase`` in a module
-with a name starting with ``test`` will be examined for test methods. Those
-tests are then collected into a test suite and executed.
-
-With older versions of `zope.testing`_, you need to add a ``test_suite()``
-function in each module that returns the tests in the test suite. The
-`unittest`_ module contains several tools to construct suites, but one of the
-simplest is to use the default test loader to load all tests in the current
-module:
-
-    >>> def test_suite():
-    ...     return unittest.defaultTestLoader.loadTestsFromName(__name__)
-
-If you need to load tests explicitly, you can use the ``TestSuite`` API from
-the `unittest`_ module. For example:
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         unittest.makeSuite(TestFasterThanLightTravel)
-    ...     ])
-    ...     return suite
-
-The ``makeSuite()`` function creates a test suite from the test methods in
-the given class (which must derive from ``TestCase``). This suite is then
-appended to an overall suite, which is returned from the ``test_suite()``
-method. Note that ``addTests()`` takes a list of suites (which are coalesced
-into a single suite). We'll add additional suites later.
-
-See the `unittest`_ documentation for other options.
-
-.. note::
-
-   Adding a ``test_suite()`` method to a module disables automatic
-   test discovery, even when using a recent version of ``zope.testing``.
-
-Doctests
---------
-
-Doctests can be written in two ways: as the contents of a docstring (usually,
-but not always, as a means of illustrating and testing the functionality of
-the method or class where the docstring appears), or as a separate text file.
-In both cases, the standard `doctest`_ module is used. See its documentation
-for details about doctest syntax and conventions.
-
-Doctests are used in two different ways:
-
-* To test documentation. That is, to ensure that code examples contained in
-  documentation are valid and continue to work as the software is updated.
-* As a convenient syntax for writing tests.
-
-These two approaches use the same testing APIs and techniques. The difference
-is mostly about mindset. However, it is important to avoid falling into the
-trap that tests can substitute for good documentation or vice-a-versa. Tests
-usually need to systematically go through inputs and outputs and cover off a
-number of corner cases. Documentation should tell a compelling narrative and
-usually focus on the main usage scenarios. Trying to kill these two birds with
-one stone normally leaves you with an unappealing pile of stones and feathers.
-
-Docstring doctests
-~~~~~~~~~~~~~~~~~~
-
-Doctests can be added to any module, class or function docstring::
-
-    def canOutrunKlingons(warpDrive):
-        """Find out of the given warp drive can outrun Klingons.
-
-        Klingons travel at warp 8
-
-        >>> drive = WarpDrive(5)
-        >>> canOutrunKlingons(drive)
-        False
-
-        We have to be faster than that to outrun them.
-
-        >>> drive = WarpDrive(8.1)
-        >>> canOutrunKlingons(drive)
-        True
-
-        We can't outrun them if we're travelling exactly the same speed
-
-        >>> drive = WarpDrive(8.0)
-        >>> canOutrunKlingons(drive)
-        False
-
-        """
-        return warpDrive.maxSpeed > 8.0
-
-To add the doctests from a particular module to a test suite, you need to
-use the ``test_suite()`` function hook:
-
-    >>> import doctest
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         unittest.makeSuite(TestFasterThanLightTravel), # our previous test
-    ...         doctest.DocTestSuite('spaceship.utils'),
-    ...     ])
-    ...     return suite
-
-Here, we have given the name of the module to check as a string dotted name.
-It is also possible to import a module and pass it as an object. The code
-above passes a list to ``addTests()``, making it easy to add several sets of
-tests to the suite: the list can be constructed from calls to
-``DocTestSuite()``, ``DocFileSuite()`` (shown below) and ``makeSuite()``
-(shown above).
-
-    Remember that if you add a ``test_suite()`` function to a module that
-    also has ``TestCase``-derived python tests, those tests will no longer
-    be automatically picked up by ``zope.testing``, so you need to add them
-    to the test suite explicitly.
-
-The example above illustrates a documentation-oriented doctest, where the
-doctest forms part of the docstring of a public module. The same syntax can
-be used for more systematic unit tests. For example, we could have a module
-``spaceship.tests.test_spaceship`` with a set of methods like::
-
-    # It's often better to put the import into each method, but here we've
-    # imported the code under test at module level
-    from spaceship.utils import WarpDrive, canOutrunKlingons
-
-    def test_canOutrunKlingons_too_small():
-        """Klingons travel at warp 8.0
-
-        >>> drive = WarpDrive(7.9)
-        >>> canOutrunKlingons(drive)
-        False
-
-        """
-
-    def test_canOutrunKlingons_big():
-        """Klingons travel at warp 8.0
-
-        >>> drive = WarpDrive(8.1)
-        >>> canOutrunKlingons(drive)
-        True
-
-        """
-
-    def test_canOutrunKlingons_must_be_greater():
-        """Klingons travel at warp 8.0
-
-        >>> drive = WarpDrive(8.0)
-        >>> canOutrunKlingons(drive)
-        False
-
-        """
-
-Here, we have created a number of small methods that have no body. They merely
-serve as a container for docstrings with doctests. Since the module has no
-globals, each test must import the code under test, which helps make import
-errors more explicit.
-
-File doctests
-~~~~~~~~~~~~~
-
-Doctests contained in a file are similar to those contained in docstrings.
-File doctests are better suited to narrative documentation covering the usage
-of an entire module or package.
-
-For example, if we had a file called ``spaceship.txt`` with doctests, we could
-add it to the test suite above with:
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         unittest.makeSuite(TestFasterThanLightTravel),
-    ...         doctest.DocTestSuite('spaceship.utils'),
-    ...         doctest.DocFileSuite('spaceship.txt'),
-    ...     ])
-    ...     return suite
-
-By default, the file is located relative to the module where the test
-suite is defined. You can use ``../`` (even on Windows) to reference the
-parent directory, which is sometimes useful if the doctest is inside a module
-in a ``tests`` package.
-
-.. note::
-
-   If you put the doctest ``test_suite()`` method in a module
-   inside a ``tests`` package, that module must have a name starting with
-   ``test``. It is common to have ``tests/test_doctests.py`` that contains a
-   single ``test_suite()`` method that returns a suite of multiple doctests.
-
-It is possible to pass several tests to the suite, e.g.::
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         unittest.makeSuite(TestFasterThanLightTravel),
-    ...         doctest.DocTestSuite('spaceship.utils'),
-    ...         doctest.DocFileSuite('spaceship.txt', 'warpdrive.txt',),
-    ...     ])
-    ...     return suite
-
-The test runner will report each file as a separate test, i.e. the
-``DocFileSuite()`` above would add two tests to the overall suite. Conversely,
-a ``DocTestSuite()`` using a module with more than one docstring containing
-doctests will report one test for each eligible docstring.
-
-Doctest fixtures and layers
-~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-A docstring doctest will by default have access to any global symbol available
-in the module where the docstring is found (e.g. anything defined or imported
-in the module). The global namespace can be overridden by passing a ``globs``
-keyword argument to the ``DocTestSuite()`` constructor, or augmented by
-passing an ``extraglobs`` argument. Both should be given dictionaries.
-
-A file doctest has an empty globals namespace by default. Globals may be
-provided via the ``globs`` argument to ``DocFileSuite()``.
-
-To manage a simple test fixture for a doctest, you can define set-up and
-tear-down functions and pass them as the ``setUp`` and ``tearDown``
-arguments respectively. These are both passed a single argument, a ``DocTest``
-object. The most useful attribute of this object is ``globs``, which is a
-mutable dictionary of globals available in the test.
-
-For example:
-
-    >>> def setUpKlingons(doctest):
-    ...     doctest.globs['oldStyleKlingons'] = True
-
-    >>> def tearDownKlingons(doctest):
-    ...     doctest.globs['oldStyleKlingons'] = False
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         doctest.DocTestSuite('spaceship.utils', setUp=setUpKlingons, tearDown=tearDownKlingons),
-    ...     ])
-    ...     return suite
-
-The same arguments are available on the ``DocFileSuite()`` constructor. The
-set up method is called before each docstring in the given module for a
-``DocTestSuite``, and before each file given in a ``DocFileSuite``.
-
-Of course, we often want to use layers with doctests too. Unfortunately,
-the ``unittest`` API is not aware of layers, so you can't just pass a layer
-to the ``DocTestSuite()`` and ``DocFileSuite()`` constructors. Instead,
-you have to set a ``layer`` attribute on the suite after it has been
-constructed.
-
-Furthermore, to use layer resources in a doctest, we need access to the layer
-instance. The easiest way to do this is to pass it as a glob, conventionally
-called 'layer'. This makes a global name 'layer' available in the doctest
-itself, giving access to the test's layer instance.
-
-To make it easier to do this, ``plone.testing`` comes with a helper function
-called ``layered()``. Its first argument is a test suite. The second argument
-is the layer.
-
-For example:
-
-    >>> from plone.testing import layered
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         layered(doctest.DocTestSuite('spaceship.utils'), layer=CONSTITUTION_CLASS_SPACE_SHIP),
-    ...     ])
-    ...     return suite
-
-This is equivalent to:
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...
-    ...     spaceshipUtilTests = doctest.DocTestSuite('spaceship.utils', globs={'layer': CONSTITUTION_CLASS_SPACE_SHIP})
-    ...     spaceshipUtilTests.layer = CONSTITUTION_CLASS_SPACE_SHIP
-    ...     suite.addTest(spaceshipUtilTests)
-    ...
-    ...     return suite
-
-(In this example, we've opted to use ``addTest()`` to add a single suite,
-instead of using ``addTests()`` to add multiple suites in one go).
-
-Zope testing tools
-==================
-
-Everything described so far in this document relies only on the standard
-`unittest`_/`unittest2`_ and `doctest`_ modules and `zope.testing`_, and you
-can use this package without any other dependencies.
-
-However, there are also some tools (and layers) available in this package, as
-well as in other packages, that are specifically useful for testing
-applications that use various Zope-related frameworks.
-
-Test cleanup
-------------
-
-If a test uses a global registry, it may be necessary to clean that registry
-on set up and tear down of each test fixture. ``zope.testing`` provides a
-mechanism to register cleanup handlers - methods that are called to clean
-up global state. This can then be invoked in the ``setUp()`` and
-``tearDown()`` fixture lifecycle methods of a test case.
-
-    >>> from zope.testing import cleanup
-
-Let's say we had a global registry, implemented as a dictionary
-
-    >>> SOME_GLOBAL_REGISTRY = {}
-
-If we wanted to clean this up on each test run, we could call ``clear()``
-on the dict. Since that's a no-argument method, it is perfect as a cleanup
-handler.
-
-    >>> cleanup.addCleanUp(SOME_GLOBAL_REGISTRY.clear)
-
-We can now use the ``cleanUp()`` method to execute all registered
-cleanups:
-
-    >>> cleanup.cleanUp()
-
-This call could be placed in a ``setUp()`` and/or ``tearDown()`` method in a
-test class, for example.
-
-Event testing
--------------
-
-You may wish to test some code that uses ``zope.event`` to fire specific
-events. `zope.component`_ provides some helpers to capture and analyse
-events.
-
-    >>> from zope.component import eventtesting
-
-To use this, you first need to set up event testing. Some of the layers
-shown below will do this for you, but you can do it yourself by calling
-the ``eventtesting.setUp()`` method, e.g. from your own ``setUp()`` method:
-
-    >>> eventtesting.setUp()
-
-This simply registers a few catch-all event handlers. Once you have
-executed the code that is expected to fire events, you can use the
-``getEvents()`` helper function to obtain a list of the event instances
-caught:
-
-    >>> events = eventtesting.getEvents()
-
-You can now examine ``events`` to see what events have been caught since the
-last cleanup.
-
-``getEvents()`` takes two optional arguments that can be used to filter the
-returned list of events. The first (``event_type``) is an interface. If given,
-only events providing this interface are returned. The second (``filter``) is
-a callable taking one argument. If given, it will be called with each captured
-event. Only those events where the filter function returns ``True`` will be
-included.
-
-The ``eventtesting`` module registers a cleanup action as outlined above. When
-you call ``cleanup.cleanUp()`` (or ``eventtesting.clearEvents()``, which is
-the handler it registers), the events list will be cleared, ready for the
-next test. Here, we'll do it manually:
-
-    >>> eventtesting.clearEvents()
-
-Mock requests
--------------
-
-Many tests require a request object, often with particular request/form
-variables set. `zope.publisher`_ contains a useful class for this purpose.
-
-    >>> from zope.publisher.browser import TestRequest
-
-A simple test request can be constructed with no arguments:
-
-    >>> request = TestRequest()
-
-To add a body input stream, pass a ``StringIO`` or file as the first
-parameter. To set the environment (request headers), use the ``environ``
-keyword argument. To simulate a submitted form, use the ``form`` keyword
-argument:
-
-    >>> request = TestRequest(form=dict(field1='foo', field2=1))
-
-Note that the ``form`` dict contains marshalled form fields, so modifiers like
-``:int`` or ``:boolean`` should not be included in the field names, and
-values should be converted to the appropriate type.
-
-Registering components
-----------------------
-
-Many test fixtures will depend on having a minimum of Zope Component
-Architecture (ZCA) components registered. In normal operation, these would
-probably be registered via ZCML, but in a unit test, you should avoid loading
-the full ZCML configuration of your package (and its dependencies).
-
-Instead, you can use the Python API in `zope.component`_ to register
-global components instantly. The three most commonly used functions are:
-
-    >>> from zope.component import provideAdapter
-    >>> from zope.component import provideUtility
-    >>> from zope.component import provideHandler
-
-See the `zope.component`_ documentation for details about how to use these.
-
-When registering global components like this, it is important to avoid test
-leakage. The ``cleanup`` mechanism outlined above can be used to tear down the
-component registry between each test. See also the
-``plone.testing.zca.UNIT_TESTING`` layer, described below, which performs this
-cleanup automatically via the ``testSetUp()``/``testTearDown()`` mechanism.
-
-Alternatively, you can "stack" a new global component registry using the
-``plone.testing.zca.pushGlobalRegistry()`` and
-``plone.testing.zca.popGlobalRegistry()`` helpers. This makes it possible to
-set up and tear down components that are specific to a given layer, and even
-allow tests to safely call the global component API (or load ZCML - see below)
-with proper tear-down. See the layer reference below for details.
-
-Loading ZCML
-------------
-
-Integration tests often need to load ZCML configuration. This can be achieved
-using the ``zope.configuration`` API.
-
-    >>> from zope.configuration import xmlconfig
-
-The ``xmlconfig`` module contains two methods for loading ZCML.
-
-``xmlconfig.string()`` can be used to load a literal string of ZCML:
-
-    >>> xmlconfig.string("""\
-    ... <configure xmlns="http://namespaces.zope.org/zope" package="plone.testing">
-    ...     <include package="zope.component" file="meta.zcml" />
-    ... </configure>
-    ... """)
-    <zope.configuration.config.ConfigurationMachine object at ...>
-
-Note that we need to set a package (used for relative imports and file
-locations) explicitly here, using the ``package`` attribute of the
-``<configure />`` element.
-
-Also note that unless the optional second argument (``context``) is passed,
-a new configuration machine will be created every time ``string()`` is called.
-It therefore becomes necessary to explicitly ``<include />`` the files that
-contain the directives you want to use (the one in ``zope.component`` is a
-common example). Layers that set up ZCML configuration may expose a resource
-which can be passed as the ``context`` parameter, usually called
-``configurationContext`` - see below.
-
-To load the configuration for a particular package, use ``xmlconfig.file()``:
-
-    >>> import zope.component
-    >>> context = xmlconfig.file('meta.zcml', zope.component)
-    >>> xmlconfig.file('configure.zcml', zope.component, context=context)
-    <zope.configuration.config.ConfigurationMachine object at ...>
-
-This takes two required arguments: the file name and the module relative to
-which it is to be found. Here, we have loaded two files: ``meta.zcml`` and
-``configure.zcml``. The first call to ``xmlconfig.file()`` creates and
-returns a configuration context. We re-use that for the subsequent invocation,
-so that the directives configured are available.
-
-Installing a Zope 2 product
----------------------------
-
-Some packages (including all those in the ``Products.*`` namespace) have the
-special status of being Zope 2 "products". These are recorded in a special
-registry, and may have an ``initialize()`` hook in their top-level
-``__init__.py`` that needs to be called for the package to be fully configured.
-
-Zope 2 will find and execute any products during startup. For testing, we
-need to explicitly list the products to install. Provided you are using
-``plone.testing`` with Zope 2, you can use the following::
-
-    from plone.testing import z2
-
-    with z2.zopeApp() as app:
-        z2.installProduct(app, 'Products.ZCatalog')
-
-This would normally be used during layer ``setUp()``. Note that the basic
-Zope 2 application context must have been set up before doing this. The usual
-way to ensure this, is to use a layer that is based on ``z2.STARTUP`` - see
-below.
-
-To tear down such a layer, you should do::
-
-    from plone.testing import z2
-
-    with z2.zopeApp() as app:
-        z2.uninstallProduct(app, 'Products.ZCatalog')
-
-Note:
-
-* Unlike the similarly-named function from ``ZopeTestCase``, these helpers
-  will work with any type of product. There is no distinction between a
-  "product" and a "package" (and no ``installPackage()``). However, you must
-  use the full name (``Products.*``) when registering a product.
-* Installing a product in this manner is independent of ZCML configuration.
-  However, it is almost always necessary to install the package's ZCML
-  configuration first.
-
-Functional testing
-------------------
-
-For functional tests that aim to simulate the browser, you can use
-`zope.testbrowser`_ in a Python test or doctest::
-
-    >>> from zope.testbrowser.browser import Browser
-    >>> browser = Browser()
-
-This provides a simple API to simulate browser input, without actually running
-a web server thread or scripting a live browser (as tools such as Windmill
-and Selenium do). The downside is that it is not possible to test JavaScript-
-dependent behaviour.
-
-If you are testing a Zope 2 application, you need to change the import
-location slightly, and pass the application root to the method::
-
-    from plone.testing.z2 import Browser
-    browser = Browser(app)
-
-You can get the application root from the ``app`` resource in any of the
-Zope 2 layers in this package.
-
-Beyond that, the `zope.testbrowser`_ documentation should cover how to use
-the test browser.
-
-    **Hint:** The test browser will usually commit at the end of a request. To
-    avoid test fixture contamination, you should use a layer that fully
-    isolates each test, such as the ``z2.INTEGRATION_TESTING`` layer described
-    below.
-
-Layer reference
-===============
-
-``plone.testing`` comes with several layers that are available to use directly
-or extend. These are outlined below.
-
-Zope Component Architecture
----------------------------
-
-The Zope Component Architecture layers are found in the module
-``plone.testing.zca``. If you depend on this, you can use the ``[zca]`` extra
-when depending on ``plone.testing``.
-
-Unit testing
-~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.zca.UNIT_TESTING``               |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zca.UnitTesting``                |
-+------------+--------------------------------------------------+
-| Bases:     | None                                             |
-+------------+--------------------------------------------------+
-| Resources: | None                                             |
-+------------+--------------------------------------------------+
-
-This layer does not set up a fixture per se, but cleans up global state
-before and after each test, using ``zope.testing.cleanup`` as described
-above.
-
-The net result is that each test has a clean global component registry. Thus,
-it is safe to use the `zope.component`_ Python API (``provideAdapter()``,
-``provideUtility()``, ``provideHandler()`` and so on) to register components.
-
-Be careful with using this layer in combination with other layers. Because
-it tears down the component registry between each test, it will clobber any
-layer that sets up more permanent test fixture in the component registry.
-
-Event testing
-~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.zca.EVENT_TESTING``              |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zca.EventTesting``               |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.zca.UNIT_TESTING``               |
-+------------+--------------------------------------------------+
-| Resources: | None                                             |
-+------------+--------------------------------------------------+
-
-This layer extends the ``zca.UNIT_TESTING`` layer to enable the
-``eventtesting`` support from ``zope.component``. Using this layer, you can
-import and use ``zope.component.eventtesting.getEvent`` to inspect events
-fired by the code under test.
-
-See above for details.
-
-Layer cleanup
-~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.zca.LAYER_CLEANUP``              |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zca.LayerCleanup``               |
-+------------+--------------------------------------------------+
-| Bases:     | None                                             |
-+------------+--------------------------------------------------+
-| Resources: | None                                             |
-+------------+--------------------------------------------------+
-
-This layer calls the cleanup functions from ``zope.testing.cleanup`` on setup
-and tear-down (but not between each test). It is useful as a base layer for
-other layers that need an environment as pristine as possible.
-
-Basic ZCML directives
-~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.zca.ZCML_DIRECTIVES``            |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zca.ZCMLDirectives``             |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |
-+------------+--------------------------------------------------+
-| Resources: | ``configurationContext``                         |
-+------------+--------------------------------------------------+
-
-This registers a minimal set of ZCML directives, principally those found in
-the ``zope.component`` package, and makes available a configuration context.
-This allows custom ZCML to be loaded as described above.
-
-The ``configurationContext`` resource should be used when loading custom ZCML.
-To ensure isolation, you should stack this using the
-``stackConfigurationContext()`` helper. For example, if you were writing a
-``setUp()`` method in a layer that had ``zca.ZCML_DIRECTIVES`` as a base, you
-could do::
-
-    self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
-    xmlconfig.string(someZCMLString, context=context)
-
-This will create a new configuration context with the state of the base
-layer's context. On tear-down, you should delete the layer-specific resource::
-
-    del self['configurationContext']
-
-.. note::
-
-   If you fail to do this, you may get problems if your layer is torn
-   down and then needs to be set up again later.
-
-See above for more details about loading custom ZCML in a layer or test.
-
-ZCML files helper class
-~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zca.ZCMLSandbox``                |
-+------------+--------------------------------------------------+
-| Resources: | ``configurationContext``                         |
-+------------+--------------------------------------------------+
-
-The ``ZCMLSandbox`` can be instantiated with a ``filename`` and ``package``
-arguments::
-
-    ZCML_SANDBOX = zca.ZCMLSandbox(filename="configure.zcml",
-        package=my.package)
-
-
-That layer ``setUp`` loads the ZCML file. It avoids the need to
-using (and understand) ``configurationContext`` and ``globalRegistry`` until you
-need more flexibility or modularity for your layer and tests.
-
-See above for more details about loading custom ZCML in a layer or test.
-
-Helper functions
-~~~~~~~~~~~~~~~~
-
-The following helper functions are available in the ``plone.testing.zca``
-module.
-
-``stackConfigurationContext(context=None)``
-    Create and return a copy of the passed-in ZCML configuration context, or a
-    brand new context if it is ``None``.
-
-    The purpose of this is to ensure that if a layer loads some ZCML files
-    (using the ``zope.configuration`` API during) during its ``setUp()``, the state
-    of the configuration registry (which includes registered directives as
-    well as a list of already imported files, which will not be loaded again
-    even if explicitly included) can be torn down during ``tearDown()``.
-
-    The usual pattern is to keep the configuration context in a layer resource
-    called ``configurationContext``. In ``setUp()``, you would then use::
-
-        self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
-
-        # use 'context' to load some ZCML
-
-    In ``tearDown()``, you can then simply do::
-
-        del self['configurationContext']
-
-``pushGlobalRegistry(new=None)``
-    Create or obtain a stack of global component registries, and push a new
-    registry to the top of the stack. The net result is that
-    ``zope.component.getGlobalSiteManager()`` and (an un-hooked)
-    ``getSiteManager()`` will return the new registry instead of the default,
-    module-scope one. From this point onwards, calls to ``provideAdapter()``,
-    ``provideUtility()`` and other functions that modify the global registry
-    will use the new registry.
-
-    If ``new`` is not given, a new registry is created that has the previous
-    global registry (site manager) as its sole base. This has the effect that
-    registrations in the previous default global registry are still available,
-    but new registrations are confined to the new registry.
-
-    **Warning**: If you call this function, you *must* reciprocally call
-    ``popGlobalRegistry()``. That is, if you "push" a registry during layer
-    ``setUp()``, you must "pop" it during ``tearDown()``. If you "push" during
-    ``testSetUp()``, you must "pop" during ``testTearDown()``. If the calls
-    to push and pop are not balanced, you will leave your global registry in
-    a mess, which is not pretty.
-
-    Returns the new default global site manager. Also causes the site manager
-    hook from ``zope.site`` to be reset, clearing any local site managers as
-    appropriate.
-
-``popGlobalRegistry()``
-    Pop the global site registry, restoring the previous registry to be the
-    default.
-
-    Please heed the warning above: push and pop must be balanced.
-
-    Returns the new default global site manager. Also causes the site manager
-    hook from ``zope.site`` to be reset, clearing any local site managers as
-    appropriate.
-
-Zope Security
--------------
-
-The Zope Security layers build can be found in the module
-``plone.testing.security``.
-
-If you depend on this, you can use the ``[security]`` extra when depending on
-``plone.testing``.
-
-Security checker isolation
-~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.security.CHECKERS``              |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.security.Checkers``              |
-+------------+--------------------------------------------------+
-| Bases:     | None                                             |
-+------------+--------------------------------------------------+
-| Resources: | None                                             |
-+------------+--------------------------------------------------+
-
-This layer ensures that security checkers used by ``zope.security`` are
-isolated. Any checkers set up in a child layer will be removed cleanly during
-tear-down.
-
-Helper functions
-~~~~~~~~~~~~~~~~
-
-The security checker isolation outlined above is managed using two helper
-functions found in the module ``plone.testing.security``:
-
-``pushCheckers()``
-    Copy the current set of security checkers for later tear-down.
-``popCheckers()``
-    Restore the set of security checkers to the state of the most recent
-    call to ``pushCheckers()``.
-
-You *must* keep calls to ``pushCheckers()`` and ``popCheckers()`` in balance.
-That usually means that if you call the former during layer setup, you should
-call the latter during layer tear-down. Ditto for calls during test
-setup/tear-down or within tests themselves.
-
-Zope Publisher
---------------
-
-The Zope Publisher layers build on the Zope Component Architecture layers.
-They can be found in the module ``plone.testing.publisher``.
-
-If you depend on this, you can use the ``[publisher]`` extra when depending on
-``plone.testing``.
-
-Publisher directives
-~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.publisher.PUBLISHER_DIRECTIVES`` |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.publisher.PublisherDirectives``  |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.zca.ZCML_DIRECTIVES``            |
-+------------+--------------------------------------------------+
-| Resources: | None                                             |
-+------------+--------------------------------------------------+
-
-This layer extends the ``zca.ZCML_DIRECTIVES`` layer to install additional
-ZCML directives in the ``browser`` namespace (from
-``zope.app.publisher.browser``) as well as those from ``zope.security``.
-This allows browser views, browser pages and other UI components to be
-registered, as well as the definition of new permissions.
-
-As with ``zca.ZCML_DIRECTIVES``, you should use the ``configurationContext``
-resource when loading ZCML strings or files, and the
-``stackConfigurationRegistry()`` helper to create a layer-specific version
-of this resource resource. See above.
-
-ZODB
-----
-
-The ZODB layers set up a test fixture with a persistent ZODB. The ZODB
-instance uses ``DemoStorage``, so it will not interfere with any "live"
-data.
-
-ZODB layers can be found in the module ``plone.testing.zodb``. If you depend
-on this, you can use the ``[zodb]`` extra when depending on ``plone.testing``.
-
-Empty ZODB sandbox
-~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.zodb.EMPTY_ZODB``                |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.zodb.EmptyZODB``                 |
-+------------+--------------------------------------------------+
-| Bases:     |  None                                            |
-+------------+--------------------------------------------------+
-| Resources: | ``zodbRoot``                                     |
-|            +--------------------------------------------------+
-|            | ``zodbDB`` (test set-up only)                    |
-|            +--------------------------------------------------+
-|            | ``zodbConnection`` (test set-up only)            |
-+------------+--------------------------------------------------+
-
-This layer sets up a simple ZODB sandbox using ``DemoStorage``. The ZODB root
-object is a simple persistent mapping, available as the resource ``zodbRoot``.
-The ZODB database object is available as the resource ``zodbDB``. The
-connection used in the test is available as ``zodbConnection``.
-
-Note that the ``zodbConnection`` and ``zodbRoot`` resources are created and
-destroyed for each test. You can use ``zodbDB`` (and the ``open()`` method)
-if you are writing a layer based on this one and need to set up a fixture
-during layer set up. Don't forget to close the connection before concluding
-the test setup!
-
-A new transaction is begun for each test, and rolled back (aborted) on test
-tear-down. This means that so long as you don't use ``transaction.commit()``
-explicitly in your code, it should be safe to add or modify items in the
-ZODB root.
-
-If you want to create a test fixture with persistent data in your own layer
-based on ``EMPTY_ZODB``, you can use the following pattern::
-
-    from plone.layer import Layer
-    from plone.layer import zodb
-
-    class MyLayer(Layer):
-        defaultBases = (zodb.EMPTY_ZODB,)
-
-        def setUp(self):
-
-            import transaction
-            self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
-
-            conn = db.open()
-            root = conn.root()
-
-            # modify the root object here
-
-            transaction.commit()
-            conn.close()
-
-        def tearDown(self):
-
-            self['zodbDB'].close()
-            del self['zodbDB']
-
-This shadows the ``zodbDB`` resource with a new database that uses a new
-``DemoStorage`` stacked on top of the underlying database storage. The fixture
-is added to this storage and committed during layer setup. (The base layer
-test set-up/tear-down will still begin and abort a new transaction for each
-*test*). On layer tear-down, the database is closed and the resource popped,
-leaving the original ``zodbDB`` database with the original, pristine storage.
-
-Helper functions
-~~~~~~~~~~~~~~~~
-
-One helper function is available in the ``plone.testing.zodb`` module.
-
-``stackDemoStorage(db=None, name=None)``
-    Create a new ``DemoStorage`` using the storage from the passed-in database
-    as a base. If ``db`` is None, a brand new storage is created.
-
-    A ``name`` can be given to uniquely identify the storage. It is optional,
-    but it is often useful for debugging purposes to pass the name of the
-    layer.
-
-    The usual pattern is::
-
-        def setUp(self):
-            self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
-
-        def tearDown(self):
-            self['zodbDB'].close()
-            del self['zodbDB']
-
-    This will shadow the ``zodbDB`` resource with an isolated
-    ``DemoStorage``, creating a new one if that resource does not already
-    exist. All existing data continues to be available, but new changes are
-    written to the stacked storage. On tear-down, the stacked database is
-    closed and the resource removed, leaving the original data.
-
-Zope 2
-------
-
-The Zope 2 layers provide test fixtures suitable for testing Zope 2
-applications. They set up a Zope 2 application root, install core Zope 2
-products, and manage security.
-
-Zope 2 layers can be found in the module ``plone.testing.z2``. If you depend
-on this, you can use the ``[z2]`` extra when depending on ``plone.testing``.
-
-Startup
-~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.STARTUP``                     |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.Startup``                     |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |
-+------------+--------------------------------------------------+
-| Resources: | ``zodbDB``                                       |
-|            +--------------------------------------------------+
-|            | ``configurationContext``                         |
-|            +--------------------------------------------------+
-|            | ``host``                                         |
-|            +--------------------------------------------------+
-|            | ``port``                                         |
-+------------+--------------------------------------------------+
-
-This layer sets up a Zope 2 environment, and is a required base for all other
-Zope 2 layers. You cannot run two instances of this layer in parallel, since
-Zope 2 depends on some module-global state to run, which is managed by this
-layer.
-
-On set-up, the layer will configure a Zope environment with:
-
-.. note::
-
-   The ``STARTUP`` layer is a useful base layer for your own fixtures,
-   but should not be used directly, since it provides no test lifecycle or
-   transaction management. See the "Integration test" and "Functional" test
-   sections below for examples of how to create your own layers.
-
-* Debug mode enabled.
-* ZEO client cache disabled.
-* Some patches installed, which speed up Zope startup by disabling the help
-  system and some other superfluous aspects of Zope.
-* One thread (this only really affects the ``ZSERVER`` and ``FTP_SERVER``
-  layers).
-* A pristine database using ``DemoStorage``, exposed as the resource
-  ``zodbDB``. Zope is configured to use this database in a way that will
-  also work if the ``zodbDB`` resource is shadowed using the pattern shown
-  above in the description of the ``zodb.EMPTY_ZODB`` layer.
-* A fake hostname and port, exposed as the ``host`` and ``port`` resource,
-  respectively.
-* A minimal set of products installed (``Products.OFSP`` and
-  ``Products.PluginIndexes``, both required for Zope to start up).
-* A stacked ZCML configuration context, exposed as the resource
-  ``configurationContext``. As illustrated above, you should use the
-  ``zca.stackConfigurationContext()`` helper to stack your own configuration
-  context if you use this.
-* A minimal set of global Zope components configured.
-
-Note that unlike a "real" Zope site, products in the ``Products.*`` namespace
-are not automatically loaded, nor is any ZCML.
-
-Integration test
-~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.INTEGRATION_TESTING``         |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.IntegrationTesting``          |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.STARTUP``                     |
-+------------+--------------------------------------------------+
-| Resources: | ``app``                                          |
-|            +--------------------------------------------------+
-|            | ``request``                                      |
-+------------+--------------------------------------------------+
-
-This layer is intended for integration testing against the simple ``STARTUP``
-fixture. If you want to create your own layer with a more advanced, shared
-fixture, see "Integration and functional testing with custom fixtures" below.
-
-For each test, it exposes the Zope application root as the resource ``app``.
-This is wrapped in the request container, so you can do ``app.REQUEST`` to
-acquire a fake request, but the request is also available as the resource
-``request``.
-
-A new transaction is begun for each test and rolled back on test tear-down,
-meaning that so long as the code under test does not explicitly commit any
-changes, the test may modify the ZODB.
-
-    *Hint:* If you want to set up a persistent test fixture in a layer based
-    on this one (or ``z2.FUNCTIONAL_TESTING``), you can stack a new
-    ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern
-    described above for the ``zodb.EMPTY_ZODB`` layer.
-
-    Once you've shadowed the ``zodbDB`` resource, you can do (e.g. in your
-    layer's ``setUp()`` method)::
-
-        ...
-        with z2.zopeApp() as app:
-            # modify the Zope application root
-
-    The ``zopeApp()`` context manager will open a new connection to the Zope
-    application root, accessible here as ``app``. Provided the code within
-    the ``with`` block does not raise an exception, the transaction will be
-    committed and the database closed properly upon exiting the block.
-
-Functional testing
-~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.FUNCTIONAL_TESTING``          |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.FunctionalTesting``           |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.STARTUP``                     |
-+------------+--------------------------------------------------+
-| Resources: | ``app``                                          |
-|            +--------------------------------------------------+
-|            | ``request``                                      |
-+------------+--------------------------------------------------+
-
-This layer is intended for functional testing against the simple ``STARTUP``
-fixture. If you want to create your own layer with a more advanced, shared
-fixture, see "Integration and functional testing with custom fixtures" below.
-
-As its name implies, this layer is intended mainly for functional end-to-end
-testing using tools like `zope.testbrowser`_. See also the ``Browser`` object
-as described under "Helper functions" below.
-
-This layer is very similar to ``INTEGRATION_TESTING``, but is not based on it.
-It sets up the same fixture and exposes the same resources. However, instead
-of using a simple transaction abort to isolate the ZODB between tests, it uses
-a stacked ``DemoStorage`` for each test. This is slower, but allows test code
-to perform and explicit commit, as will usually happen in a functional test.
-
-Integration and functional testing with custom fixtures
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-If you want to extend the ``STARTUP`` fixture for use with integration or
-functional testing, you should use the following pattern:
-
-* Create a layer class and a "fixture" base layer instance that has
-  ``z2.STARTUP`` (or some intermediary layer, such as ``z2.ZSERVER_FIXTURE``
-  or ``z2.FTP_SERVER_FIXTURE``, shown below) as a base.
-* Create "end user" layers by instantiating the ``z2.IntegrationTesting``
-  and/or ``FunctionalTesting`` classes with this new "fixture" layer as a
-  base.
-
-This allows the same fixture to be used regardless of the "style" of testing,
-minimising the amount of set-up and tear-down. The "fixture" layers manage the
-fixture as part of the *layer* lifecycle. The layer class
-(``IntegrationTesting`` or ``FunctionalTesting``), manages the *test*
-lifecycle, and the test lifecycle only.
-
-For example::
-
-    from plone.testing import Layer, z2, zodb
-
-    class MyLayer(Layer):
-        defaultBases = (z2.STARTUP,)
-
-        def setUp(self):
-            # Set up the fixture here
-            ...
-
-        def tearDown(self):
-            # Tear down the fixture here
-            ...
-
-    MY_FIXTURE = MyLayer()
-
-    MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")
-    MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")
-
-(Note that we need to give an explicit, unique name to the two layers that
-re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)
-
-In this example, other layers could extend the "MyLayer" fixture by using
-``MY_FIXTURE`` as a base. Tests would use either ``MY_INTEGRATION_TESTING``
-or ``MY_FUNCTIONAL_TESTING`` as appropriate. However, even if both these two
-layers were used, the fixture in ``MY_FIXTURE`` would only be set up once.
-
-.. note::
-
-   If you implement the ``testSetUp()`` and ``testTearDown()`` test
-   lifecycle methods in your "fixture" layer (e.g. in the the ``MyLayer``
-   class above), they will execute before the corresponding methods from
-   ``IntegrationTesting`` and ``FunctionalTesting``. Hence, they cannot use
-   those layers' resources (``app`` and ``request``).
-
-It may be preferable, therefore, to have your own "test lifecycle" layer
-classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and
-call base class methods as appropriate. ``plone.app.testing`` takes this
-approach, for example.
-
-HTTP ZServer thread (fixture only)
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.ZServer``                     |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.STARTUP``                     |
-+------------+--------------------------------------------------+
-| Resources: | ``host``                                         |
-|            +--------------------------------------------------+
-|            | ``port``                                         |
-+------------+--------------------------------------------------+
-
-This layer extends the ``z2.STARTUP`` layer to start the Zope HTTP server in
-a separate thread. This means the test site can be accessed through a web
-browser, and can thus be used with tools like `Windmill`_ or `Selenium`_.
-
-.. note::
-
-   This layer is useful as a fixture base layer only, because it does
-   not manage the test lifecycle. Use the ``ZSERVER`` layer if you want to
-   execute functional tests against this fixture.
-
-The ZServer's hostname (normally ``localhost``) is available through the
-resource ``host``, whilst the port it is running on is available through the
-resource ``port``.
-
-  *Hint:* Whilst the layer is set up, you can actually access the test Zope
-  site through a web browser. The default URL will be
-  ``http://localhost:55001``.
-
-HTTP ZServer functional testing
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.ZSERVER``                     |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.FunctionalTesting``           |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |
-+------------+--------------------------------------------------+
-| Resources: |                                                  |
-+------------+--------------------------------------------------+
-
-This layer provides the functional testing lifecycle against the fixture set
-up by the ``z2.ZSERVER_FIXTURE`` layer.
-
-You can use this to run "live" functional tests against a basic Zope site.
-You should **not** use it as a base. Instead, create your own "fixture"
-layer that extends ``z2.ZSERVER_FIXTURE``, and then instantiate the
-``FunctionalTesting`` class with this extended fixture layer as a base,
-as outlined above.
-
-FTP server thread (fixture only)
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.FTPServer``                   |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.STARTUP``                     |
-+------------+--------------------------------------------------+
-| Resources: | ``host``                                         |
-|            +--------------------------------------------------+
-|            | ``port``                                         |
-+------------+--------------------------------------------------+
-
-This layer is the FTP server equivalent of the ``ZSERVER_FIXTURE`` layer. It
-can be used to functionally test Zope servers.
-
-.. note::
-
-   This layer is useful as a fixture base layer only, because it does
-   not manage the test lifecycle. Use the ``FTP_SERVER`` layer if you want to
-   execute functional tests against this fixture.
-
-   *Hint:* Whilst the layer is set up, you can actually access the test Zope
-   site through an FTP client. The default URL will be
-   ``ftp://localhost:55002``.
-
-.. warning::
-
-   Do not run the ``FTP_SERVER`` and ``ZSERVER`` layers concurrently in the same process.
-
-If you need both ZServer and FTPServer running together, you can subclass the
-``ZServer`` layer class (like the ``FTPServer`` layer class does) and
-implement the ``setUpServer()`` and ``tearDownServer()`` methods to set up
-and close down two servers on different ports. They will then share a main
-loop.
-
-FTP server functional testing
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-+------------+--------------------------------------------------+
-| Layer:     | ``plone.testing.z2.FTP_SERVER``                  |
-+------------+--------------------------------------------------+
-| Class:     | ``plone.testing.z2.FunctionalTesting``           |
-+------------+--------------------------------------------------+
-| Bases:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |
-+------------+--------------------------------------------------+
-| Resources: |                                                  |
-+------------+--------------------------------------------------+
-
-This layer provides the functional testing lifecycle against the fixture set
-up by the ``z2.FTP_SERVER_FIXTURE`` layer.
-
-You can use this to run "live" functional tests against a basic Zope site.
-You should **not** use it as a base. Instead, create your own "fixture"
-layer that extends ``z2.FTP_SERVER_FIXTURE``, and then instantiate the
-``FunctionalTesting`` class with this extended fixture layer as a base,
-as outlined above.
-
-Helper functions
-~~~~~~~~~~~~~~~~
-
-Several helper functions are available in the ``plone.testing.z2`` module.
-
-``zopeApp(db=None, conn=Non, environ=None)``
-    This function can be used as a context manager for any code that requires
-    access to the Zope application root. By using it in a ``with`` block,
-    the database will be opened, and the application root will be obtained and
-    request-wrapped. When exiting the ``with`` block, the transaction will be
-    committed and the database properly closed, unless an exception was
-    raised::
-
-        with z2.zopeApp() as app:
-            # do something with app
-
-    If you want to use a specific database or database connection, pass either
-    the ``db`` or ``conn`` arguments. If the context manager opened a new
-    connection, it will close it, but it will not close a connection passed
-    with ``conn``.
-
-    To set keys in the (fake) request environment, pass a dictionary of
-    environment values as ``environ``.
-
-    Note that ``zopeApp()`` should *not* normally be used in tests or test
-    set-up/tear-down, because the ``INTEGRATOIN_TEST`` and
-    ``FUNCTIONAL_TESTING`` layers both manage the application root (as the
-    ``app`` resource) and close it for you. It is very useful in layer setup,
-    however.
-``installProduct(app, product, quiet=False)``
-    Install a Zope 2 style product, ensuring that its ``initialize()``
-    function is called. The product name must be the full dotted name, e.g.
-    ``plone.app.portlets`` or ``Products.CMFCore``. If ``quiet`` is true,
-    duplicate registrations will be ignored silently, otherwise a message is
-    logged.
-
-    To get hold of the application root, passed as the ``app`` argument, you
-    would normally use the ``zopeApp()`` context manager outlined above.
-``uninstallProduct(app, product, quiet=False)``
-    This is the reciprocal of ``installProduct()``, normally used during layer
-    tear-down. Again, you should use ``zopeApp()`` to obtain the application
-    root.
-``login(userFolder, userName)``
-    Create a new security manager that simulates being logged in as the given
-    user. ``userFolder`` is an ``acl_users`` object, e.g.
-    ``app['acl_users']`` for the root user folder.
-``logout()``
-    Simulate being the anonymous user by unsetting the security manager.
-``setRoles(userFolder, userName, roles)``
-    Set the roles of the given user in the given user folder to the given
-    list of roles.
-``makeTestRequest()``
-    Create a fake Zope request.
-``addRequestContainer(app, environ=None)``
-    Create a fake request and wrap the given object (normally an application
-    root) in a ``RequestContainer`` with this request. This makes acquisition
-    of ``app.REQUEST`` possible. To initialise the request environment with
-    non-default values, pass a dictionary as ``environ``.
-
-    .. note::
-    
-       This method is rarely used, because both the ``zopeApp()``
-       context manager and the layer set-up/tear-down for
-       ``z2.INTEGRATION_TESTING`` and ``z2.FUNCTIONAL_TESTING`` will wrap the
-       ``app`` object before exposing it.
-``Browser(app)``
-    Obtain a test browser client, for use with `zope.testbrowser`_. You should
-    use this in conjunction with the ``z2.FUNCTIONAL_TESTING`` layer or a
-    derivative. You must pass the app root, usually obtained from the ``app``
-    resource of the layer, e.g.::
-
-        app = self.layer['app']
-        browser = z2.Browser(app)
-
-    You can then use ``browser`` as described in the `zope.testbrowser`_
-    documentation.
-
-    Bear in mind that the test browser runs separately from the test fixture.
-    In particular, calls to helpers such as ``login()`` or ``logout()`` do
-    not affect the state that the test browser sees. If you want to set up
-    a persistent fixture (e.g. test content), you can do so before creating
-    the test browser, but you will need to explicitly commit your changes,
-    with::
-
-        import transaction
-        transaction.commit()
-
-.. _zope.testing: http://pypi.python.org/pypi/zope.testing
-.. _zope.testbrowser: http://pypi.python.org/pypi/zope.testbrowser
-.. _zope.component: http://pypi.python.org/pypi/zope.component
-.. _zope.publisher: http://pypi.python.org/pypi/zope.publisher
-.. _plone.app.testing: http://pypi.python.org/pypi/plone.app.testing
-.. _zc.recipe.testrunner: http://pypi.python.org/pypi/zc.recipe.testrunner
-.. _coverage: http://pypi.python.org/pypi/coverage
-.. _Cobertura: http://wiki.hudson-ci.org/display/HUDSON/Cobertura+Plugin
-.. _Hudson: http://www.hudson-labs.org/
-.. _unittest: http://doc.python.org/library/unittest.html
-.. _unittest2: http://pypi.python.org/pypi/unittest2
-.. _doctest: http://docs.python.org/dev/library/doctest.html
-.. _Windmill: http://getwindmill.com/
-.. _Selenium: http://seleniumhq.org/
diff --git a/src/plone/testing/__init__.py b/src/plone/testing/__init__.py
index c879a5d..a39d736 100644
--- a/src/plone/testing/__init__.py
+++ b/src/plone/testing/__init__.py
@@ -1,6 +1,4 @@
+# -*- coding: utf-8 -*-
 # Convenience imports
-
-from plone.testing.layer import (
-        Layer,
-        layered
-    )
+from plone.testing.layer import Layer    # noqa
+from plone.testing.layer import layered  # noqa
diff --git a/src/plone/testing/_z2_testbrowser.py b/src/plone/testing/_z2_testbrowser.py
index 14cce2c..8a230ee 100644
--- a/src/plone/testing/_z2_testbrowser.py
+++ b/src/plone/testing/_z2_testbrowser.py
@@ -1,15 +1,14 @@
-import sys
-import re
+# -*- coding: utf-8 -*-
+from cStringIO import StringIO
 import base64
+import mechanize
+import pkg_resources
+import re
 import rfc822
+import sys
 import urllib
 import urllib2
 
-from cStringIO import StringIO
-
-import mechanize
-import pkg_resources
-
 # Using a from-import here to avoid an AttributeError below when using
 # zope.testbrowser 4.x without zope.app.testing:
 from zope.testbrowser.testing import PublisherConnection, PublisherResponse
@@ -18,6 +17,7 @@
 
 try:
     pkg_resources.get_distribution('Zope2>=2.13')
+
     def get_cookies(request):
         return request.response._cookie_list()
 except (pkg_resources.VersionConflict, pkg_resources.DistributionNotFound):
@@ -31,15 +31,30 @@ class Browser(zope.testbrowser.browser.Browser):
     """
 
     def __init__(self, app, url=None):
-        super(Browser, self).__init__(url=url, mech_browser=Zope2MechanizeBrowser(app))
+        super(
+            Browser,
+            self).__init__(
+            url=url,
+            mech_browser=Zope2MechanizeBrowser(app))
+
 
 class Zope2MechanizeBrowser(mechanize.Browser):
     """A mechanize browser class that uses the Zope 2 publisher to talk HTTP
     """
 
-    default_schemes    = ['http']
-    default_others     = ['_http_error', '_http_request_upgrade', '_http_default_error']
-    default_features   = ['_redirect', '_cookies', '_referer', '_refresh','_equiv', '_basicauth', '_digestauth' ]
+    default_schemes = ['http']
+    default_others = [
+        '_http_error',
+        '_http_request_upgrade',
+        '_http_default_error']
+    default_features = [
+        '_redirect',
+        '_cookies',
+        '_referer',
+        '_refresh',
+        '_equiv',
+        '_basicauth',
+        '_digestauth']
 
     def __init__(self, app, *args, **kws):
 
@@ -52,6 +67,7 @@ def httpHandlerFactory():
                                if cls in mechanize.Browser.handler_classes]
         mechanize.Browser.__init__(self, *args, **kws)
 
+
 class Zope2HTTPHandler(urllib2.HTTPHandler):
     """A protocol handler that uses the Zope 2 publisher to talk HTTP
     """
@@ -65,6 +81,7 @@ def connectionFactory(host, timeout=None):
             return Zope2Connection(self.app, host, timeout=timeout)
         return self.do_open(connectionFactory, req)
 
+
 class Zope2Connection(PublisherConnection):
     """A urllib2-compatible connection that can talk to the Zope 2 publisher.
     """
@@ -92,9 +109,11 @@ def getresponse(self):
                 # only change non-literal header names
                 key = "%s%s" % (key[:1].upper(), key[1:])
                 start = 0
-                l = key.find('-',start)
+                l = key.find('-', start)
                 while l >= start:
-                    key = "%s-%s%s" % (key[:l],key[l+1:l+2].upper(),key[l+2:])
+                    key = "%s-%s%s" % (key[:l],
+                                       key[l + 1:l + 2].upper(),
+                                       key[l + 2:])
                     start = l + 1
                     l = key.find('-', start)
             headers.append((key, val))
@@ -109,6 +128,7 @@ def getresponse(self):
 
         return PublisherResponse(content, headers, status, reason)
 
+
 def saveState(func):
     """Save threadlocal state (security manager, local component site) before
     exectuting a decorated function, and restore it after.
@@ -128,10 +148,14 @@ def wrapped_func(*args, **kw):
     return wrapped_func
 
 HEADER_RE = re.compile('(\S+): (.+)$')
+
+
 def splitHeader(header):
     return HEADER_RE.match(header).group(1, 2)
 
 BASIC_RE = re.compile('Basic (.+)?:(.+)?$')
+
+
 def authHeader(header):
     match = BASIC_RE.match(header)
     if match:
@@ -144,6 +168,7 @@ def authHeader(header):
         return 'Basic %s' % auth[:-1]
     return header
 
+
 class Zope2Caller(object):
     """Functional testing caller that can execute HTTP requests via the
     Zope 2 publisher.
@@ -172,7 +197,7 @@ def setBody(self, body, title='', is_error=0, **kw):
         # Split off and parse the command line
         l = requestString.find('\n')
         commandLine = requestString[:l].rstrip()
-        requestString = requestString[l+1:]
+        requestString = requestString[l + 1:]
         method, url, protocol = commandLine.split()
 
         instream = StringIO(requestString)
@@ -189,14 +214,15 @@ def setBody(self, body, title='', is_error=0, **kw):
         elif len(p) == 2:
             [env['PATH_INFO'], env['QUERY_STRING']] = p
         else:
-            raise TypeError, ''
+            raise TypeError('')
 
         # If you followed closely, you notice that one part of the url
         # gets unquoted (PATH_INFO) while the other (QUERY_STRING)
         # doesn't That complies with what the ZSERVER does.
         env['PATH_INFO'] = urllib.unquote(env['PATH_INFO'])
 
-        headers = [splitHeader(header) for header in rfc822.Message(instream).headers]
+        headers = [splitHeader(header)
+                   for header in rfc822.Message(instream).headers]
 
         # Store request body without headers
         instream = StringIO(instream.read())
@@ -207,7 +233,7 @@ def setBody(self, body, title='', is_error=0, **kw):
                 name = 'HTTP_' + name
             env[name] = value.rstrip()
 
-        if env.has_key('HTTP_AUTHORIZATION'):
+        if 'HTTP_AUTHORIZATION' in env:
             env['HTTP_AUTHORIZATION'] = authHeader(env['HTTP_AUTHORIZATION'])
 
         outstream = StringIO()
@@ -218,7 +244,7 @@ def setBody(self, body, title='', is_error=0, **kw):
                        stdin=instream,
                        environ=env,
                        debug=not handle_errors,
-                      )
+                       )
 
         self.app._p_jar.sync()
 
diff --git a/src/plone/testing/layer.py b/src/plone/testing/layer.py
index a14592a..8d8d76d 100644
--- a/src/plone/testing/layer.py
+++ b/src/plone/testing/layer.py
@@ -1,11 +1,13 @@
+# -*- coding: utf-8 -*-
 import sys
 _marker = object()
 
+
 class ResourceManager(object):
     """Mixin class for resource managers.
     """
 
-    __bases__ = () # must be set as an instance variable by subclass
+    __bases__ = ()  # must be set as an instance variable by subclass
 
     def __init__(self):
         self._resources = {}
@@ -38,7 +40,7 @@ def __setitem__(self, key, value):
                 foundStack = True
 
                 foundStackItem = False
-                for idx in range(len(stack)-1, -1, -1):
+                for idx in range(len(stack) - 1, -1, -1):
                     if stack[idx][1] is self:
 
                         # This layer instance has already added an item to
@@ -52,7 +54,7 @@ def __setitem__(self, key, value):
                 # This layer instance does not have a stack item yet. Create
                 # a new one.
                 if not foundStackItem:
-                    stack.append([value, self,])
+                    stack.append([value, self, ])
 
                 # Note: We do not break here on purpose: it's possible
                 # that there is resource stack in another branch of the base
@@ -67,7 +69,7 @@ def __delitem__(self, key):
         for resourceManager in self.baseResolutionOrder:
             if key in getattr(resourceManager, '_resources', {}):
                 stack = resourceManager._resources[key]
-                for idx in range(len(stack)-1, -1, -1):
+                for idx in range(len(stack) - 1, -1, -1):
                     if stack[idx][1] is self:
                         del stack[idx]
 
@@ -101,11 +103,11 @@ def _mergeResourceManagers(self, seqs):
 
             i += 1
 
-            for seq in nonemptyseqs: # find merge candidates among seq heads
+            for seq in nonemptyseqs:  # find merge candidates among seq heads
                 cand = seq[0]
-                nothead=[s for s in nonemptyseqs if cand in s[1:]]
+                nothead = [s for s in nonemptyseqs if cand in s[1:]]
                 if nothead:
-                    cand=None #reject candidate
+                    cand = None  # reject candidate
                 else:
                     break
 
@@ -113,16 +115,17 @@ def _mergeResourceManagers(self, seqs):
                 raise TypeError(u"Inconsistent layer hierarchy!")
 
             res.append(cand)
-            for seq in nonemptyseqs: # remove cand
+            for seq in nonemptyseqs:  # remove cand
                 if seq[0] == cand:
                     del seq[0]
 
     def _resourceResolutionOrder(self, instance):
         return self._mergeResourceManagers(
-                [ [instance] ] +
-                map(self._resourceResolutionOrder, instance.__bases__) +
-                [ list(instance.__bases__) ]
-            )
+            [[instance]] +
+            map(self._resourceResolutionOrder, instance.__bases__) +
+            [list(instance.__bases__)]
+        )
+
 
 class Layer(ResourceManager):
     """A base class for layers.
@@ -151,10 +154,10 @@ def __init__(self, bases=None, name=None, module=None):
         """
 
         if self.__class__ is Layer and name is None:
-            raise ValueError('The `name` argument is required when instantiating `Layer` directly')
+            raise ValueError('The `name` argument is required when instantiating `Layer` directly')  # noqa
 
         if name is None and bases is not None:
-            raise ValueError('The `name`` argument is required when overriding bases with the `bases` argument')
+            raise ValueError('The `name`` argument is required when overriding bases with the `bases` argument')  # noqa
 
         super(Layer, self).__init__()
 
@@ -201,6 +204,7 @@ def testSetUp(self):
     def testTearDown(self):
         pass
 
+
 def layered(suite, layer, addLayerToDoctestGlobs=True):
     """Add the given layer to the given suite and return the suite.
 
@@ -214,7 +218,7 @@ def layered(suite, layer, addLayerToDoctestGlobs=True):
         for test in suite:
             if hasattr(test, '_dt_test'):
                 globs = test._dt_test.globs
-                if not 'layer' in globs:
+                if 'layer' not in globs:
                     globs['layer'] = layer
 
     return suite
diff --git a/src/plone/testing/layer.rst b/src/plone/testing/layer.rst
new file mode 100644
index 0000000..f3f856b
--- /dev/null
+++ b/src/plone/testing/layer.rst
@@ -0,0 +1,509 @@
+Layer base class
+----------------
+
+This package provides a layer base class which can be used by the test runner.
+It is available as a convenience import from the package root.::
+
+    >>> from plone.testing import Layer
+
+A layer may be instantiated directly, though in this case the ``name`` argument is required (see below).::
+
+    >>> NULL_LAYER = Layer(name="Null layer")
+
+This is not very useful on its own.
+It has an empty list of bases, and each of the layer lifecycle methods does nothing.::
+
+    >>> NULL_LAYER.__bases__
+    ()
+    >>> NULL_LAYER.__name__
+    'Null layer'
+    >>> NULL_LAYER.__module__
+    'plone.testing.layer'
+
+    >>> NULL_LAYER.setUp()
+    >>> NULL_LAYER.testSetUp()
+    >>> NULL_LAYER.tearDown()
+    >>> NULL_LAYER.testTearDown()
+
+Just about the only reason to use this directly (i.e. not as a base class) is to group together other layers.::
+
+    >>> SIMPLE_LAYER = Layer(bases=(NULL_LAYER,), name="Simple layer", module='plone.testing.tests')
+
+Here, we've also set the module name directly.
+The default for all layers is to take the module name from the stack frame where the layer was instantiated.
+In doctests, that doesn't work, though, so we fall back on the module name of the layer class.
+The two are often the same, of course.
+
+This layer now has the bases, name and module we set:::
+
+    >>> SIMPLE_LAYER.__bases__
+    (<Layer 'plone.testing.layer.Null layer'>,)
+
+    >>> SIMPLE_LAYER.__name__
+    'Simple layer'
+
+    >>> SIMPLE_LAYER.__module__
+    'plone.testing.tests'
+
+The ``name`` argument is required when using ``Layer`` directly (but not when using a subclass):::
+
+    >>> Layer((SIMPLE_LAYER,))
+    Traceback (most recent call last):
+    ...
+    ValueError: The `name` argument is required when instantiating `Layer` directly
+
+    >>> class NullLayer(Layer):
+    ...     pass
+    >>> NullLayer()
+    <Layer '__builtin__.NullLayer'>
+
+Using ``Layer`` as a base class
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The usual pattern is to use ``Layer`` as a base class for a custom layer.
+This can then override the lifecycle methods as appropriate, as well as set a default list of bases.::
+
+    >>> class BaseLayer(Layer):
+    ...
+    ...     def setUp(self):
+    ...         print "Setting up base layer"
+    ...
+    ...     def tearDown(self):
+    ...         print "Tearing down base layer"
+
+    >>> BASE_LAYER = BaseLayer()
+
+The layer name and module are taken from the class.::
+
+    >>> BASE_LAYER.__bases__
+    ()
+    >>> BASE_LAYER.__name__
+    'BaseLayer'
+    >>> BASE_LAYER.__module__
+    '__builtin__'
+
+We can now create a new layer that has this one as a base.
+We can do this in the instance constructor, as shown above, but the most common pattern is to set the default bases in the class body, using the variable ``defaultBases``.
+
+We'll also set the default name explicitly here by passing a name to the the super-constructor.
+This is mostly cosmetic, but may be desirable if the class name would be misleading in the test runner output.::
+
+    >>> class ChildLayer(Layer):
+    ...     defaultBases = (BASE_LAYER,)
+    ...
+    ...     def __init__(self, bases=None, name='Child layer', module=None):
+    ...         super(ChildLayer, self).__init__(bases, name, module)
+    ...
+    ...     def setUp(self):
+    ...         print "Setting up child layer"
+    ...
+    ...     def tearDown(self):
+    ...         print "Tearing down child layer"
+
+    >>> CHILD_LAYER = ChildLayer()
+
+Notice how the bases have now been set using the value in ``defaultBases``.::
+
+    >>> CHILD_LAYER.__bases__
+    (<Layer '__builtin__.BaseLayer'>,)
+    >>> CHILD_LAYER.__name__
+    'Child layer'
+    >>> CHILD_LAYER.__module__
+    '__builtin__'
+
+Overriding the default list of bases
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+We can override the list of bases on a per-instance basis.
+This may be dangerous, i.e.
+the layer is likely to expect that its bases are set up.
+Sometimes, it may be useful to inject a new base, however, especially when re-using layers from other packages.
+
+The new list of bases is passed to the constructor.
+When creating a second instance of a layer (most layers are global singletons created only once), it's useful to give the new instance a unique name, too.::
+
+    >>> NEW_CHILD_LAYER = ChildLayer(bases=(SIMPLE_LAYER, BASE_LAYER,), name='New child')
+
+    >>> NEW_CHILD_LAYER.__bases__
+    (<Layer 'plone.testing.tests.Simple layer'>, <Layer '__builtin__.BaseLayer'>)
+    >>> NEW_CHILD_LAYER.__name__
+    'New child'
+    >>> NEW_CHILD_LAYER.__module__
+    '__builtin__'
+
+Inconsistent bases
+~~~~~~~~~~~~~~~~~~
+
+Layer bases are maintained in an order that is semantically equivalent to the "method resolution order" Python maintains for base classes.
+We can get this from the ``baseResolutionOrder`` attribute:::
+
+    >>> CHILD_LAYER.baseResolutionOrder
+    (<Layer '__builtin__.Child layer'>, <Layer '__builtin__.BaseLayer'>)
+
+    >>> NEW_CHILD_LAYER.baseResolutionOrder
+    (<Layer '__builtin__.New child'>, <Layer 'plone.testing.tests.Simple layer'>,
+     <Layer 'plone.testing.layer.Null layer'>,
+     <Layer '__builtin__.BaseLayer'>)
+
+As with Python classes, it is possible to construct an invalid set of bases.
+In this case, layer instantiation will fail.::
+
+    >>> INCONSISTENT_BASE1 = Layer(name="Inconsistent 1")
+    >>> INCONSISTENT_BASE2 = Layer((INCONSISTENT_BASE1,), name="Inconsistent 1")
+    >>> INCONSISTENT_BASE3 = Layer((INCONSISTENT_BASE1, INCONSISTENT_BASE2,), name="Inconsistent 1")
+    Traceback (most recent call last):
+    ...
+    TypeError: Inconsistent layer hierarchy!
+
+Using the resource manager
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Layers are also resource managers.
+Resources can be set, retrieved and deleted using dictionary syntax.
+Resources in base layers are available in child layers.
+When an item is set on a child layer, it shadows any items with the same key in any base layer (until it is deleted), but the original item still exists.
+
+Let's create a somewhat complex hierarchy of layers that all set resources under a key ``'foo'`` in their ``setUp()`` methods.::
+
+    >>> class Layer1(Layer):
+    ...     def setUp(self):
+    ...         self['foo'] = 1
+    ...     def tearDown(self):
+    ...         del self['foo']
+    >>> LAYER1 = Layer1()
+
+    >>> class Layer2(Layer):
+    ...     defaultBases = (LAYER1,)
+    ...     def setUp(self):
+    ...         self['foo'] = 2
+    ...     def tearDown(self):
+    ...         del self['foo']
+    >>> LAYER2 = Layer2()
+
+    >>> class Layer3(Layer):
+    ...     def setUp(self):
+    ...         self['foo'] = 3
+    ...     def tearDown(self):
+    ...         del self['foo']
+    >>> LAYER3 = Layer3()
+
+    >>> class Layer4(Layer):
+    ...     defaultBases = (LAYER2, LAYER3,)
+    ...     def setUp(self):
+    ...         self['foo'] = 4
+    ...     def tearDown(self):
+    ...         del self['foo']
+    >>> LAYER4 = Layer4()
+
+    **Important:** Resources that are created in ``setUp()`` must be deleted in ``tearDown()``.
+    Similarly, resources created in ``testSetUp()`` must be deleted in ``testTearDown()``.
+    This ensures resources are properly stacked and do not leak between layers.
+
+If a test was using ``LAYER4``, the test runner would call each setup step in turn, starting with the "deepest" layer.
+We'll simulate that here, so that each of the resources is created.::
+
+    >>> LAYER1.setUp()
+    >>> LAYER2.setUp()
+    >>> LAYER3.setUp()
+    >>> LAYER4.setUp()
+
+The layers are ordered in a known "resource resolution order", which is used to determine in which order the layers shadow one another.
+This is based on the same algorithm as Python's method resolution order.::
+
+    >>> LAYER4.baseResolutionOrder
+    (<Layer '__builtin__.Layer4'>,
+     <Layer '__builtin__.Layer2'>,
+     <Layer '__builtin__.Layer1'>,
+     <Layer '__builtin__.Layer3'>)
+
+When fetching and item from a layer, it will be obtained according to the resource resolution order.::
+
+    >>> LAYER4['foo']
+    4
+
+This is not terribly interesting, since ``LAYER4`` has the resource ``'foo'`` set directly.
+Let's tear down the layer (which deletes the resource) and see what happens.::
+
+    >>> LAYER4.tearDown()
+    >>> LAYER4['foo']
+    2
+
+We can continue up the chain:::
+
+    >>> LAYER2.tearDown()
+    >>> LAYER4['foo']
+    1
+
+    >>> LAYER1.tearDown()
+    >>> LAYER4['foo']
+    3
+
+Once we've deleted the last key, we'll get a ``KeyError``:::
+
+    >>> LAYER3.tearDown()
+    >>> LAYER4['foo']
+    Traceback (most recent call last):
+    ...
+    KeyError: 'foo'
+
+To guard against this, we can use the ``get()`` method.::
+
+    >>> LAYER4.get('foo', -1)
+    -1
+
+We can also test with 'in':::
+
+    >>> 'foo' in LAYER4
+    False
+
+To illustrate that this indeed works, let's set the resource back on one of the bases.::
+
+    >>> LAYER3['foo'] = 10
+    >>> LAYER4.get('foo', -1)
+    10
+
+Let's now consider a special case: a base layer sets up a resource in layer setup, and uses it in test setup.
+A child layer then shadows this resource in its own layer setup method.
+In this case, we want the base layer's ``testSetUp()`` to use the shadowed version that the child provided.
+
+(This is similar to how instance variables work: a base class may set an attribute on ``self`` and use it in a method.
+If a subclass then sets the same attribute to a different value and the base class method is called on an instance of the subclass, the base class attribute is used).
+
+    *Hint:* If you definitely need to access the "original" resource in your ``testSetUp()``/``testTearDown()`` methods, you can store a reference to the resource as a layer instance variable::
+
+        self.someResource = self['someResource'] = SomeResource()
+
+    ``self.someResource`` will now be the exact resource created here, whereas ``self['someResource']`` will retain the layer shadowing semantics.
+    In most cases, you probably *don't* want to do this, allowing child layers to supply overridden versions of resources as appropriate.
+
+First, we'll create some base layers.
+We want to demonstrate having two "branches" of bases that both happen to define the same resource.::
+
+    >>> class ResourceBaseLayer1(Layer):
+    ...     def setUp(self):
+    ...         self['resource'] = "Base 1"
+    ...     def testSetUp(self):
+    ...         print self['resource']
+    ...     def tearDown(self):
+    ...         del self['resource']
+
+    >>> RESOURCE_BASE_LAYER1 = ResourceBaseLayer1()
+
+    >>> class ResourceBaseLayer2(Layer):
+    ...     defaultBases = (RESOURCE_BASE_LAYER1,)
+    ...     def testSetUp(self):
+    ...         print self['resource']
+
+    >>> RESOURCE_BASE_LAYER2 = ResourceBaseLayer2()
+
+    >>> class ResourceBaseLayer3(Layer):
+    ...     def setUp(self):
+    ...         self['resource'] = "Base 3"
+    ...     def testSetUp(self):
+    ...         print self['resource']
+    ...     def tearDown(self):
+    ...         del self['resource']
+
+    >>> RESOURCE_BASE_LAYER3 = ResourceBaseLayer3()
+
+We'll then create the child layer that overrides this resource.::
+
+    >>> class ResourceChildLayer(Layer):
+    ...     defaultBases = (RESOURCE_BASE_LAYER2, RESOURCE_BASE_LAYER3)
+    ...     def setUp(self):
+    ...         self['resource'] = "Child"
+    ...     def testSetUp(self):
+    ...         print self['resource']
+    ...     def tearDown(self):
+    ...         del self['resource']
+
+    >>> RESOURCE_CHILD_LAYER = ResourceChildLayer()
+
+We'll first set up the base layers on their own and simulate two tests.
+
+A test with RESOURCE_BASE_LAYER1 only would look like this:::
+
+    >>> RESOURCE_BASE_LAYER1.setUp()
+
+    >>> RESOURCE_BASE_LAYER1.testSetUp()
+    Base 1
+    >>> RESOURCE_BASE_LAYER1.testTearDown()
+
+    >>> RESOURCE_BASE_LAYER1.tearDown()
+
+A test with RESOURCE_BASE_LAYER2 would look like this:::
+
+    >>> RESOURCE_BASE_LAYER1.setUp()
+    >>> RESOURCE_BASE_LAYER2.setUp()
+
+    >>> RESOURCE_BASE_LAYER1.testSetUp()
+    Base 1
+    >>> RESOURCE_BASE_LAYER2.testSetUp()
+    Base 1
+    >>> RESOURCE_BASE_LAYER2.testTearDown()
+    >>> RESOURCE_BASE_LAYER1.testTearDown()
+
+    >>> RESOURCE_BASE_LAYER2.tearDown()
+    >>> RESOURCE_BASE_LAYER1.tearDown()
+
+A test with RESOURCE_BASE_LAYER3 only would look like this:::
+
+    >>> RESOURCE_BASE_LAYER3.setUp()
+
+    >>> RESOURCE_BASE_LAYER3.testSetUp()
+    Base 3
+    >>> RESOURCE_BASE_LAYER3.testTearDown()
+
+    >>> RESOURCE_BASE_LAYER3.tearDown()
+
+Now let's set up the child layer and simulate another test.
+We should now be using the shadowed resource.::
+
+    >>> RESOURCE_BASE_LAYER1.setUp()
+    >>> RESOURCE_BASE_LAYER2.setUp()
+    >>> RESOURCE_BASE_LAYER3.setUp()
+    >>> RESOURCE_CHILD_LAYER.setUp()
+
+    >>> RESOURCE_BASE_LAYER1.testSetUp()
+    Child
+    >>> RESOURCE_BASE_LAYER2.testSetUp()
+    Child
+    >>> RESOURCE_BASE_LAYER3.testSetUp()
+    Child
+    >>> RESOURCE_CHILD_LAYER.testSetUp()
+    Child
+
+    >>> RESOURCE_CHILD_LAYER.testTearDown()
+    >>> RESOURCE_BASE_LAYER3.testTearDown()
+    >>> RESOURCE_BASE_LAYER2.testTearDown()
+    >>> RESOURCE_BASE_LAYER1.testTearDown()
+
+Finally, we'll tear down the child layer again and simulate another test.
+we should have the original resources back.
+Note that the first and third layers no longer share a resource, since they don't have a common ancestor.::
+
+    >>> RESOURCE_CHILD_LAYER.tearDown()
+
+    >>> RESOURCE_BASE_LAYER1.testSetUp()
+    Base 1
+    >>> RESOURCE_BASE_LAYER2.testSetUp()
+    Base 1
+    >>> RESOURCE_BASE_LAYER2.testTearDown()
+    >>> RESOURCE_BASE_LAYER1.testTearDown()
+
+    >>> RESOURCE_BASE_LAYER3.testSetUp()
+    Base 3
+    >>> RESOURCE_BASE_LAYER3.testTearDown()
+
+Finally, we'll tear down the remaining layers..::
+
+    >>> RESOURCE_BASE_LAYER3.tearDown()
+    >>> RESOURCE_BASE_LAYER2.tearDown()
+    >>> RESOURCE_BASE_LAYER1.tearDown()
+
+Asymmetric deletion
++++++++++++++++++++
+
+It is an error to create or shadow a resource in a set-up lifecycle method and not delete it again in the tear-down.
+It is also an error to delete a resource that was not explicitly created.
+These two layers break those roles:::
+
+    >>> class BadLayer1(Layer):
+    ...     def setUp(self):
+    ...         pass
+    ...     def tearDown(self):
+    ...         del self['foo']
+    >>> BAD_LAYER1 = BadLayer1()
+
+    >>> class BadLayer2(Layer):
+    ...     defaultBases = (BAD_LAYER1,)
+    ...     def setUp(self):
+    ...         self['foo'] = 1
+    ...         self['bar'] = 2
+    >>> BAD_LAYER2 = BadLayer2()
+
+Let's simulate a test that uses ``BAD_LAYER2``:::
+
+    >>> BAD_LAYER1.setUp()
+    >>> BAD_LAYER2.setUp()
+
+    >>> BAD_LAYER1.testSetUp()
+    >>> BAD_LAYER2.testSetUp()
+
+    >>> BAD_LAYER2.testTearDown()
+    >>> BAD_LAYER1.testTearDown()
+
+    >>> BAD_LAYER2.tearDown()
+    >>> BAD_LAYER1.tearDown()
+    Traceback (most recent call last):
+    ...
+    KeyError: 'foo'
+
+Here, we've got an error in the base layer.
+This is because the resource is actually associated with the layer that first created it, in this case ``BASE_LAYER2``.
+This one remains intact and orphaned:::
+
+    >>> 'foo' in BAD_LAYER2._resources
+    True
+    >>> 'bar' in BAD_LAYER2._resources
+    True
+
+Doctest layer helper
+~~~~~~~~~~~~~~~~~~~~
+
+The ``doctest`` module is not aware of ``zope.testing``'s layers concept.
+Therefore, the syntax for creating a doctest with a layer and adding it to a test suite is somewhat contrived: the test suite has to be created first, and then the layer attribute set on it:::
+
+    >>> class DoctestLayer(Layer):
+    ...     pass
+    >>> DOCTEST_LAYER = DoctestLayer()
+
+    >>> try:
+    ...     import unittest2 as unittest
+    ... except ImportError: # Python 2.7
+    ...     import unittest
+    >>> import doctest
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     layerDoctest = doctest.DocFileSuite('layer.rst', package='plone.testing')
+    ...     layerDoctest.layer = DOCTEST_LAYER
+    ...     suite.addTest(layerDoctest)
+    ...     return suite
+
+    >>> suite = test_suite()
+    >>> tests = list(suite)
+    >>> len(tests)
+    1
+    >>> tests[0].layer is DOCTEST_LAYER
+    True
+
+
+To make this a little easier - especially when setting up multiple tests - a helper function called ``layered`` is provided:::
+
+    >>> from plone.testing import layered
+
+    >>> def test_suite():
+    ...     suite = unittest.TestSuite()
+    ...     suite.addTests([
+    ...         layered(doctest.DocFileSuite('layer.rst', package='plone.testing'), layer=DOCTEST_LAYER),
+    ...         # repeat with more suites if necessary
+    ...     ])
+    ...     return suite
+
+This does the same as the sample above.::
+
+    >>> suite = test_suite()
+    >>> tests = list(suite)
+    >>> len(tests)
+    1
+    >>> tests[0].layer is DOCTEST_LAYER
+    True
+
+In addition, a 'layer' glob is added to each test in the suite.
+This allows the test to access layer resources.::
+
+    >>> len(list(tests[0]))
+    1
+    >>> list(tests[0])[0]._dt_test.globs['layer'] is DOCTEST_LAYER
+    True
diff --git a/src/plone/testing/layer.txt b/src/plone/testing/layer.txt
deleted file mode 100644
index 43aeee2..0000000
--- a/src/plone/testing/layer.txt
+++ /dev/null
@@ -1,535 +0,0 @@
-Layer base class
-----------------
-
-This package provides a layer base class which can be used by the test
-runner. It is available as a convenience import from the package root.
-
-    >>> from plone.testing import Layer
-
-A layer may be instantiated directly, though in this case the ``name``
-argument is required (see below).
-
-    >>> NULL_LAYER = Layer(name="Null layer")
-
-This is not very useful on its own. It has an empty list of bases, and each of
-the layer lifecycle methods does nothing.
-
-    >>> NULL_LAYER.__bases__
-    ()
-    >>> NULL_LAYER.__name__
-    'Null layer'
-    >>> NULL_LAYER.__module__
-    'plone.testing.layer'
-
-    >>> NULL_LAYER.setUp()
-    >>> NULL_LAYER.testSetUp()
-    >>> NULL_LAYER.tearDown()
-    >>> NULL_LAYER.testTearDown()
-
-Just about the only reason to use this directly (i.e. not as a base class) is
-to group together other layers.
-
-    >>> SIMPLE_LAYER = Layer(bases=(NULL_LAYER,), name="Simple layer", module='plone.testing.tests')
-
-Here, we've also set the module name directly. The default for all layers is
-to take the module name from the stack frame where the layer was instantiated.
-In doctests, that doesn't work, though, so we fall back on the module name of
-the layer class. The two are often the same, of course.
-
-This layer now has the bases, name and module we set:
-
-    >>> SIMPLE_LAYER.__bases__
-    (<Layer 'plone.testing.layer.Null layer'>,)
-
-    >>> SIMPLE_LAYER.__name__
-    'Simple layer'
-
-    >>> SIMPLE_LAYER.__module__
-    'plone.testing.tests'
-
-The ``name`` argument is required when using ``Layer`` directly (but not
-when using a subclass):
-
-    >>> Layer((SIMPLE_LAYER,))
-    Traceback (most recent call last):
-    ...
-    ValueError: The `name` argument is required when instantiating `Layer` directly
-
-    >>> class NullLayer(Layer):
-    ...     pass
-    >>> NullLayer()
-    <Layer '__builtin__.NullLayer'>
-
-Using ``Layer`` as a base class
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-The usual pattern is to use ``Layer`` as a base class for a custom layer.
-This can then override the lifecycle methods as appropriate, as well as
-set a default list of bases.
-
-    >>> class BaseLayer(Layer):
-    ...
-    ...     def setUp(self):
-    ...         print "Setting up base layer"
-    ...
-    ...     def tearDown(self):
-    ...         print "Tearing down base layer"
-
-    >>> BASE_LAYER = BaseLayer()
-
-The layer name and module are taken from the class.
-
-    >>> BASE_LAYER.__bases__
-    ()
-    >>> BASE_LAYER.__name__
-    'BaseLayer'
-    >>> BASE_LAYER.__module__
-    '__builtin__'
-
-We can now create a new layer that has this one as a base. We can do this in
-the instance constructor, as shown above, but the most common pattern is to
-set the default bases in the class body, using the variable ``defaultBases``.
-
-We'll also set the default name explicitly here by passing a name to the the
-super-constructor. This is mostly cosmetic, but may be desirable if the class
-name would be misleading in the test runner output.
-
-    >>> class ChildLayer(Layer):
-    ...     defaultBases = (BASE_LAYER,)
-    ...
-    ...     def __init__(self, bases=None, name='Child layer', module=None):
-    ...         super(ChildLayer, self).__init__(bases, name, module)
-    ...
-    ...     def setUp(self):
-    ...         print "Setting up child layer"
-    ...
-    ...     def tearDown(self):
-    ...         print "Tearing down child layer"
-
-    >>> CHILD_LAYER = ChildLayer()
-
-Notice how the bases have now been set using the value in ``defaultBases``.
-
-    >>> CHILD_LAYER.__bases__
-    (<Layer '__builtin__.BaseLayer'>,)
-    >>> CHILD_LAYER.__name__
-    'Child layer'
-    >>> CHILD_LAYER.__module__
-    '__builtin__'
-
-Overriding the default list of bases
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-We can override the list of bases on a per-instance basis. This may be
-dangerous, i.e. the layer is likely to expect that its bases are set up.
-Sometimes, it may be useful to inject a new base, however, especially when
-re-using layers from other packages.
-
-The new list of bases is passed to the constructor. When creating a second
-instance of a layer (most layers are global singletons created only once),
-it's useful to give the new instance a unique name, too.
-
-    >>> NEW_CHILD_LAYER = ChildLayer(bases=(SIMPLE_LAYER, BASE_LAYER,), name='New child')
-
-    >>> NEW_CHILD_LAYER.__bases__
-    (<Layer 'plone.testing.tests.Simple layer'>, <Layer '__builtin__.BaseLayer'>)
-    >>> NEW_CHILD_LAYER.__name__
-    'New child'
-    >>> NEW_CHILD_LAYER.__module__
-    '__builtin__'
-
-Inconsistent bases
-~~~~~~~~~~~~~~~~~~
-
-Layer bases are maintained in an order that is semantically equivalent to the
-"method resolution order" Python maintains for base classes. We can get this
-from the ``baseResolutionOrder`` attribute:
-
-    >>> CHILD_LAYER.baseResolutionOrder
-    (<Layer '__builtin__.Child layer'>, <Layer '__builtin__.BaseLayer'>)
-
-    >>> NEW_CHILD_LAYER.baseResolutionOrder
-    (<Layer '__builtin__.New child'>, <Layer 'plone.testing.tests.Simple layer'>,
-     <Layer 'plone.testing.layer.Null layer'>,
-     <Layer '__builtin__.BaseLayer'>)
-
-As with Python classes, it is possible to construct an invalid set of bases.
-In this case, layer instantiation will fail.
-
-    >>> INCONSISTENT_BASE1 = Layer(name="Inconsistent 1")
-    >>> INCONSISTENT_BASE2 = Layer((INCONSISTENT_BASE1,), name="Inconsistent 1")
-    >>> INCONSISTENT_BASE3 = Layer((INCONSISTENT_BASE1, INCONSISTENT_BASE2,), name="Inconsistent 1")
-    Traceback (most recent call last):
-    ...
-    TypeError: Inconsistent layer hierarchy!
-
-Using the resource manager
-~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Layers are also resource managers. Resources can be set, retrieved and
-deleted using dictionary syntax. Resources in base layers are available in
-child layers. When an item is set on a child layer, it shadows any items with
-the same key in any base layer (until it is deleted), but the original item
-still exists.
-
-Let's create a somewhat complex hierarchy of layers that all set resources
-under a key ``'foo'`` in their ``setUp()`` methods.
-
-    >>> class Layer1(Layer):
-    ...     def setUp(self):
-    ...         self['foo'] = 1
-    ...     def tearDown(self):
-    ...         del self['foo']
-    >>> LAYER1 = Layer1()
-
-    >>> class Layer2(Layer):
-    ...     defaultBases = (LAYER1,)
-    ...     def setUp(self):
-    ...         self['foo'] = 2
-    ...     def tearDown(self):
-    ...         del self['foo']
-    >>> LAYER2 = Layer2()
-
-    >>> class Layer3(Layer):
-    ...     def setUp(self):
-    ...         self['foo'] = 3
-    ...     def tearDown(self):
-    ...         del self['foo']
-    >>> LAYER3 = Layer3()
-
-    >>> class Layer4(Layer):
-    ...     defaultBases = (LAYER2, LAYER3,)
-    ...     def setUp(self):
-    ...         self['foo'] = 4
-    ...     def tearDown(self):
-    ...         del self['foo']
-    >>> LAYER4 = Layer4()
-
-    **Important:** Resources that are created in ``setUp()`` must be deleted
-    in ``tearDown()``. Similarly, resources created in ``testSetUp()`` must
-    be deleted in ``testTearDown()``. This ensures resources are properly
-    stacked and do not leak between layers.
-
-If a test was using ``LAYER4``, the test runner would call each setup step in
-turn, starting with the "deepest" layer. We'll simulate that here, so that
-each of the resources is created.
-
-    >>> LAYER1.setUp()
-    >>> LAYER2.setUp()
-    >>> LAYER3.setUp()
-    >>> LAYER4.setUp()
-
-The layers are ordered in a known "resource resolution order", which is used
-to determine in which order the layers shadow one another. This is based on
-the same algorithm as Python's method resolution order.
-
-    >>> LAYER4.baseResolutionOrder
-    (<Layer '__builtin__.Layer4'>,
-     <Layer '__builtin__.Layer2'>,
-     <Layer '__builtin__.Layer1'>,
-     <Layer '__builtin__.Layer3'>)
-
-When fetching and item from a layer, it will be obtained according to the
-resource resolution order.
-
-    >>> LAYER4['foo']
-    4
-
-This is not terribly interesting, since ``LAYER4`` has the resource ``'foo'``
-set directly. Let's tear down the layer (which deletes the resource) and see
-what happens.
-
-    >>> LAYER4.tearDown()
-    >>> LAYER4['foo']
-    2
-
-We can continue up the chain:
-
-    >>> LAYER2.tearDown()
-    >>> LAYER4['foo']
-    1
-
-    >>> LAYER1.tearDown()
-    >>> LAYER4['foo']
-    3
-
-Once we've deleted the last key, we'll get a ``KeyError``:
-
-    >>> LAYER3.tearDown()
-    >>> LAYER4['foo']
-    Traceback (most recent call last):
-    ...
-    KeyError: 'foo'
-
-To guard against this, we can use the ``get()`` method.
-
-    >>> LAYER4.get('foo', -1)
-    -1
-
-We can also test with 'in':
-
-    >>> 'foo' in LAYER4
-    False
-
-To illustrate that this indeed works, let's set the resource back on one
-of the bases.
-
-    >>> LAYER3['foo'] = 10
-    >>> LAYER4.get('foo', -1)
-    10
-
-Let's now consider a special case: a base layer sets up a resource in layer
-setup, and uses it in test setup. A child layer then shadows this resource in
-its own layer setup method. In this case, we want the base layer's
-``testSetUp()`` to use the shadowed version that the child provided.
-
-(This is similar to how instance variables work: a base class may set an
-attribute on ``self`` and use it in a method. If a subclass then sets the same
-attribute to a different value and the base class method is called on an
-instance of the subclass, the base class attribute is used).
-
-    *Hint:* If you definitely need to access the "original" resource in your
-    ``testSetUp()``/``testTearDown()`` methods, you can store a reference to
-    the resource as a layer instance variable::
-
-        self.someResource = self['someResource'] = SomeResource()
-
-    ``self.someResource`` will now be the exact resource created here, whereas
-    ``self['someResource']`` will retain the layer shadowing semantics. In
-    most cases, you probably *don't* want to do this, allowing child layers to
-    supply overridden versions of resources as appropriate.
-
-First, we'll create some base layers. We want to demonstrate having two
-"branches" of bases that both happen to define the same resource.
-
-    >>> class ResourceBaseLayer1(Layer):
-    ...     def setUp(self):
-    ...         self['resource'] = "Base 1"
-    ...     def testSetUp(self):
-    ...         print self['resource']
-    ...     def tearDown(self):
-    ...         del self['resource']
-
-    >>> RESOURCE_BASE_LAYER1 = ResourceBaseLayer1()
-
-    >>> class ResourceBaseLayer2(Layer):
-    ...     defaultBases = (RESOURCE_BASE_LAYER1,)
-    ...     def testSetUp(self):
-    ...         print self['resource']
-
-    >>> RESOURCE_BASE_LAYER2 = ResourceBaseLayer2()
-
-    >>> class ResourceBaseLayer3(Layer):
-    ...     def setUp(self):
-    ...         self['resource'] = "Base 3"
-    ...     def testSetUp(self):
-    ...         print self['resource']
-    ...     def tearDown(self):
-    ...         del self['resource']
-
-    >>> RESOURCE_BASE_LAYER3 = ResourceBaseLayer3()
-
-We'll then create the child layer that overrides this resource.
-
-    >>> class ResourceChildLayer(Layer):
-    ...     defaultBases = (RESOURCE_BASE_LAYER2, RESOURCE_BASE_LAYER3)
-    ...     def setUp(self):
-    ...         self['resource'] = "Child"
-    ...     def testSetUp(self):
-    ...         print self['resource']
-    ...     def tearDown(self):
-    ...         del self['resource']
-
-    >>> RESOURCE_CHILD_LAYER = ResourceChildLayer()
-
-We'll first set up the base layers on their own and simulate two tests.
-
-A test with RESOURCE_BASE_LAYER1 only would look like this:
-
-    >>> RESOURCE_BASE_LAYER1.setUp()
-
-    >>> RESOURCE_BASE_LAYER1.testSetUp()
-    Base 1
-    >>> RESOURCE_BASE_LAYER1.testTearDown()
-
-    >>> RESOURCE_BASE_LAYER1.tearDown()
-
-A test with RESOURCE_BASE_LAYER2 would look like this:
-
-    >>> RESOURCE_BASE_LAYER1.setUp()
-    >>> RESOURCE_BASE_LAYER2.setUp()
-
-    >>> RESOURCE_BASE_LAYER1.testSetUp()
-    Base 1
-    >>> RESOURCE_BASE_LAYER2.testSetUp()
-    Base 1
-    >>> RESOURCE_BASE_LAYER2.testTearDown()
-    >>> RESOURCE_BASE_LAYER1.testTearDown()
-
-    >>> RESOURCE_BASE_LAYER2.tearDown()
-    >>> RESOURCE_BASE_LAYER1.tearDown()
-
-A test with RESOURCE_BASE_LAYER3 only would look like this:
-
-    >>> RESOURCE_BASE_LAYER3.setUp()
-
-    >>> RESOURCE_BASE_LAYER3.testSetUp()
-    Base 3
-    >>> RESOURCE_BASE_LAYER3.testTearDown()
-
-    >>> RESOURCE_BASE_LAYER3.tearDown()
-
-Now let's set up the child layer and simulate another test. We should now be
-using the shadowed resource.
-
-    >>> RESOURCE_BASE_LAYER1.setUp()
-    >>> RESOURCE_BASE_LAYER2.setUp()
-    >>> RESOURCE_BASE_LAYER3.setUp()
-    >>> RESOURCE_CHILD_LAYER.setUp()
-
-    >>> RESOURCE_BASE_LAYER1.testSetUp()
-    Child
-    >>> RESOURCE_BASE_LAYER2.testSetUp()
-    Child
-    >>> RESOURCE_BASE_LAYER3.testSetUp()
-    Child
-    >>> RESOURCE_CHILD_LAYER.testSetUp()
-    Child
-
-    >>> RESOURCE_CHILD_LAYER.testTearDown()
-    >>> RESOURCE_BASE_LAYER3.testTearDown()
-    >>> RESOURCE_BASE_LAYER2.testTearDown()
-    >>> RESOURCE_BASE_LAYER1.testTearDown()
-
-Finally, we'll tear down the child layer again and simulate another test.
-we should have the original resources back. Note that the first and third
-layers no longer share a resource, since they don't have a common ancestor.
-
-    >>> RESOURCE_CHILD_LAYER.tearDown()
-
-    >>> RESOURCE_BASE_LAYER1.testSetUp()
-    Base 1
-    >>> RESOURCE_BASE_LAYER2.testSetUp()
-    Base 1
-    >>> RESOURCE_BASE_LAYER2.testTearDown()
-    >>> RESOURCE_BASE_LAYER1.testTearDown()
-
-    >>> RESOURCE_BASE_LAYER3.testSetUp()
-    Base 3
-    >>> RESOURCE_BASE_LAYER3.testTearDown()
-
-Finally, we'll tear down the remaining layers..
-
-    >>> RESOURCE_BASE_LAYER3.tearDown()
-    >>> RESOURCE_BASE_LAYER2.tearDown()
-    >>> RESOURCE_BASE_LAYER1.tearDown()
-
-Asymmetric deletion
-+++++++++++++++++++
-
-It is an error to create or shadow a resource in a set-up lifecycle method and
-not delete it again in the tear-down. It is also an error to delete a resource
-that was not explicitly created. These two layers break those roles:
-
-    >>> class BadLayer1(Layer):
-    ...     def setUp(self):
-    ...         pass
-    ...     def tearDown(self):
-    ...         del self['foo']
-    >>> BAD_LAYER1 = BadLayer1()
-
-    >>> class BadLayer2(Layer):
-    ...     defaultBases = (BAD_LAYER1,)
-    ...     def setUp(self):
-    ...         self['foo'] = 1
-    ...         self['bar'] = 2
-    >>> BAD_LAYER2 = BadLayer2()
-
-Let's simulate a test that uses ``BAD_LAYER2``:
-
-    >>> BAD_LAYER1.setUp()
-    >>> BAD_LAYER2.setUp()
-
-    >>> BAD_LAYER1.testSetUp()
-    >>> BAD_LAYER2.testSetUp()
-
-    >>> BAD_LAYER2.testTearDown()
-    >>> BAD_LAYER1.testTearDown()
-
-    >>> BAD_LAYER2.tearDown()
-    >>> BAD_LAYER1.tearDown()
-    Traceback (most recent call last):
-    ...
-    KeyError: 'foo'
-
-Here, we've got an error in the base layer. This is because the resource
-is actually associated with the layer that first created it, in this case
-``BASE_LAYER2``. This one remains intact and orphaned:
-
-    >>> 'foo' in BAD_LAYER2._resources
-    True
-    >>> 'bar' in BAD_LAYER2._resources
-    True
-
-Doctest layer helper
-~~~~~~~~~~~~~~~~~~~~
-
-The ``doctest`` module is not aware of ``zope.testing``'s layers concept.
-Therefore, the syntax for creating a doctest with a layer and adding it to
-a test suite is somewhat contrived: the test suite has to be created first,
-and then the layer attribute set on it:
-
-    >>> class DoctestLayer(Layer):
-    ...     pass
-    >>> DOCTEST_LAYER = DoctestLayer()
-
-    >>> try:
-    ...     import unittest2 as unittest
-    ... except ImportError: # Python 2.7
-    ...     import unittest
-    >>> import doctest
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     layerDoctest = doctest.DocFileSuite('layer.txt', package='plone.testing')
-    ...     layerDoctest.layer = DOCTEST_LAYER
-    ...     suite.addTest(layerDoctest)
-    ...     return suite
-
-    >>> suite = test_suite()
-    >>> tests = list(suite)
-    >>> len(tests)
-    1
-    >>> tests[0].layer is DOCTEST_LAYER
-    True
-
-
-To make this a little easier - especially when setting up multiple tests -
-a helper function called ``layered`` is provided:
-
-    >>> from plone.testing import layered
-
-    >>> def test_suite():
-    ...     suite = unittest.TestSuite()
-    ...     suite.addTests([
-    ...         layered(doctest.DocFileSuite('layer.txt', package='plone.testing'), layer=DOCTEST_LAYER),
-    ...         # repeat with more suites if necessary
-    ...     ])
-    ...     return suite
-
-This does the same as the sample above.
-
-    >>> suite = test_suite()
-    >>> tests = list(suite)
-    >>> len(tests)
-    1
-    >>> tests[0].layer is DOCTEST_LAYER
-    True
-
-In addition, a 'layer' glob is added to each test in the suite. This allows
-the test to access layer resources.
-
-    >>> len(list(tests[0]))
-    1
-    >>> list(tests[0])[0]._dt_test.globs['layer'] is DOCTEST_LAYER
-    True
diff --git a/src/plone/testing/publisher.py b/src/plone/testing/publisher.py
index 26de1df..555e035 100644
--- a/src/plone/testing/publisher.py
+++ b/src/plone/testing/publisher.py
@@ -1,8 +1,10 @@
+# -*- coding: utf-8 -*-
 """Helpers for working with common Zope publisher operations
 """
-
 from plone.testing import Layer
-from plone.testing import zca, security
+from plone.testing import security
+from plone.testing import zca
+
 
 class PublisherDirectives(Layer):
     """Enables the use of the ZCML directives from ``zope.app.publisher``
@@ -19,7 +21,8 @@ def setUp(self):
         from zope.configuration import xmlconfig
 
         # Stack a new configuration context
-        self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
+        self['configurationContext'] = context = zca.stackConfigurationContext(
+            self.get('configurationContext'))
 
         import zope.security
         xmlconfig.file('meta.zcml', zope.security, context=context)
diff --git a/src/plone/testing/publisher.rst b/src/plone/testing/publisher.rst
new file mode 100644
index 0000000..921ebc9
--- /dev/null
+++ b/src/plone/testing/publisher.rst
@@ -0,0 +1,120 @@
+Zope Publisher layers
+---------------------
+
+The Zope Publisher layers are found in the module ``plone.testing.publisher``::
+
+    >>> from plone.testing import publisher
+
+For testing, we need a testrunner:::
+
+    >>> from zope.testrunner import runner
+
+ZCML directives
+~~~~~~~~~~~~~~~
+
+The ``publisher.PUBLISHER_DIRECTIVES`` layer extends the ``zca.ZCML_DIRECTIVES`` layer to extend its ZCML configuration context with the ``zope.app.publisher`` and ``zope.security`` directives available.
+It also extends ``security.CHECKERS``.::
+
+    >>> from plone.testing import zca, security
+
+    >>> "%s.%s" % (publisher.PUBLISHER_DIRECTIVES.__module__, publisher.PUBLISHER_DIRECTIVES.__name__,)
+    'plone.testing.publisher.PublisherDirectives'
+
+    >>> publisher.PUBLISHER_DIRECTIVES.__bases__
+    (<Layer 'plone.testing.zca.ZCMLDirectives'>, <Layer 'plone.testing.security.Checkers'>)
+
+Before the test, we cannot use e.g.
+the ``<permission />`` or ``<browser:view />`` directives without loading the necessary ``meta.zcml`` files.::
+
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.string("""\
+    ... <configure package="plone.testing"
+    ...     xmlns="http://namespaces.zope.org/zope"
+    ...     xmlns:browser="http://namespaces.zope.org/browser"
+    ...     i18n_domain="plone.testing.tests">
+    ...     <permission id="plone.testing.Test" title="plone.testing: Test" />
+    ...     <browser:view
+    ...         for="*"
+    ...         name="plone.testing-test"
+    ...         class="plone.testing.tests.DummyView"
+    ...         permission="zope.Public"
+    ...         />
+    ... </configure>""")
+    Traceback (most recent call last):
+    ...
+    ZopeXMLConfigurationError: File "<string>", line 5.4
+        ConfigurationError: ('Unknown directive', u'http://namespaces.zope.org/zope', u'permission')
+
+Layer setup creates a configuration context we can use to load further configuration.::
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, publisher.PUBLISHER_DIRECTIVES, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.zca.ZCMLDirectives in ... seconds.
+    Set up plone.testing.security.Checkers in ... seconds.
+    Set up plone.testing.publisher.PublisherDirectives in ... seconds.
+
+
+Let's now simulate a test that uses this configuration context to load the same ZCML string.::
+
+    >>> zca.ZCML_DIRECTIVES.testSetUp()
+    >>> security.CHECKERS.testSetUp()
+    >>> publisher.PUBLISHER_DIRECTIVES.testSetUp()
+
+    >>> context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']
+    >>> xmlconfig.string("""\
+    ... <configure package="plone.testing"
+    ...     xmlns="http://namespaces.zope.org/zope"
+    ...     xmlns:browser="http://namespaces.zope.org/browser"
+    ...     i18n_domain="plone.testing.tests">
+    ...     <permission id="plone.testing.Test" title="plone.testing: Test" />
+    ...     <browser:view
+    ...         for="*"
+    ...         name="plone.testing-test"
+    ...         class="plone.testing.tests.DummyView"
+    ...         permission="zope.Public"
+    ...         />
+    ... </configure>""", context=context) is context
+    True
+
+The permission and view are now registered:::
+
+    >>> from zope.component import queryUtility
+    >>> from zope.security.interfaces import IPermission
+
+    >>> queryUtility(IPermission, name=u"plone.testing.Test")
+    <zope.security.permission.Permission object at ...>
+
+    >>> from zope.interface import Interface
+    >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer
+    >>> from zope.component import getSiteManager
+    >>> siteManager = getSiteManager()
+
+    >>> [x.factory for x in siteManager.registeredAdapters()
+    ...  if x.provided==Interface and x.required==(Interface, IDefaultBrowserLayer)
+    ...   and x.name==u"plone.testing-test"]
+    [<class '....plone.testing-test'>]
+
+We can then simulate test tear-down:::
+
+    >>> publisher.PUBLISHER_DIRECTIVES.testTearDown()
+    >>> security.CHECKERS.testTearDown()
+    >>> zca.ZCML_DIRECTIVES.testTearDown()
+
+Note that you'd normally combine this layer with the ``zca.UNIT_TESTING`` or a similar layer to automatically tear down the component architecture between each test.
+Here, we need to do it manually.::
+
+    >>> from zope.component.testing import tearDown
+    >>> tearDown()
+
+Layer tear-down does nothing.::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.publisher.PublisherDirectives in ... seconds.
+    Tear down plone.testing.zca.ZCMLDirectives in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+    Tear down plone.testing.security.Checkers in ... seconds.
+
+    >>> zca.ZCML_DIRECTIVES.get('configurationContext', None) is None
+    True
diff --git a/src/plone/testing/publisher.txt b/src/plone/testing/publisher.txt
deleted file mode 100644
index 5f35948..0000000
--- a/src/plone/testing/publisher.txt
+++ /dev/null
@@ -1,126 +0,0 @@
-Zope Publisher layers
----------------------
-
-The Zope Publisher layers are found in the module ``plone.testing.publisher``:
-
-    >>> from plone.testing import publisher
-
-For testing, we need a testrunner
-
-    >>> from zope.testrunner import runner
-
-ZCML directives
-~~~~~~~~~~~~~~~
-
-The ``publisher.PUBLISHER_DIRECTIVES`` layer extends the
-``zca.ZCML_DIRECTIVES`` layer to extend its ZCML configuration context with
-the ``zope.app.publisher`` and ``zope.security`` directives available. It
-also extends ``security.CHECKERS``.
-
-    >>> from plone.testing import zca, security
-
-    >>> "%s.%s" % (publisher.PUBLISHER_DIRECTIVES.__module__, publisher.PUBLISHER_DIRECTIVES.__name__,)
-    'plone.testing.publisher.PublisherDirectives'
-
-    >>> publisher.PUBLISHER_DIRECTIVES.__bases__
-    (<Layer 'plone.testing.zca.ZCMLDirectives'>, <Layer 'plone.testing.security.Checkers'>)
-
-Before the test, we cannot use e.g. the ``<permission />`` or
-``<browser:view />`` directives without loading the necessary ``meta.zcml``
-files.
-
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.string("""\
-    ... <configure package="plone.testing"
-    ...     xmlns="http://namespaces.zope.org/zope"
-    ...     xmlns:browser="http://namespaces.zope.org/browser"
-    ...     i18n_domain="plone.testing.tests">
-    ...     <permission id="plone.testing.Test" title="plone.testing: Test" />
-    ...     <browser:view
-    ...         for="*"
-    ...         name="plone.testing-test"
-    ...         class="plone.testing.tests.DummyView"
-    ...         permission="zope.Public"
-    ...         />
-    ... </configure>""")
-    Traceback (most recent call last):
-    ...
-    ZopeXMLConfigurationError: File "<string>", line 5.4
-        ConfigurationError: ('Unknown directive', u'http://namespaces.zope.org/zope', u'permission')
-
-Layer setup creates a configuration context we can use to load further
-configuration.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, publisher.PUBLISHER_DIRECTIVES, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.zca.ZCMLDirectives in ... seconds.
-    Set up plone.testing.security.Checkers in ... seconds.
-    Set up plone.testing.publisher.PublisherDirectives in ... seconds.
-
-
-Let's now simulate a test that uses this configuration context to load the
-same ZCML string.
-
-    >>> zca.ZCML_DIRECTIVES.testSetUp()
-    >>> security.CHECKERS.testSetUp()
-    >>> publisher.PUBLISHER_DIRECTIVES.testSetUp()
-
-    >>> context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']
-    >>> xmlconfig.string("""\
-    ... <configure package="plone.testing"
-    ...     xmlns="http://namespaces.zope.org/zope"
-    ...     xmlns:browser="http://namespaces.zope.org/browser"
-    ...     i18n_domain="plone.testing.tests">
-    ...     <permission id="plone.testing.Test" title="plone.testing: Test" />
-    ...     <browser:view
-    ...         for="*"
-    ...         name="plone.testing-test"
-    ...         class="plone.testing.tests.DummyView"
-    ...         permission="zope.Public"
-    ...         />
-    ... </configure>""", context=context) is context
-    True
-
-The permission and view are now registered:
-
-    >>> from zope.component import queryUtility
-    >>> from zope.security.interfaces import IPermission
-
-    >>> queryUtility(IPermission, name=u"plone.testing.Test")
-    <zope.security.permission.Permission object at ...>
-
-    >>> from zope.interface import Interface
-    >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer
-    >>> from zope.component import getSiteManager
-    >>> siteManager = getSiteManager()
-
-    >>> [x.factory for x in siteManager.registeredAdapters()
-    ...  if x.provided==Interface and x.required==(Interface, IDefaultBrowserLayer)
-    ...   and x.name==u"plone.testing-test"]
-    [<class '....plone.testing-test'>]
-
-We can then simulate test tear-down:
-
-    >>> publisher.PUBLISHER_DIRECTIVES.testTearDown()
-    >>> security.CHECKERS.testTearDown()
-    >>> zca.ZCML_DIRECTIVES.testTearDown()
-
-Note that you'd normally combine this layer with the ``zca.UNIT_TESTING`` or a
-similar layer to automatically tear down the component architecture between
-each test. Here, we need to do it manually.
-
-    >>> from zope.component.testing import tearDown
-    >>> tearDown()
-
-Layer tear-down does nothing.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.publisher.PublisherDirectives in ... seconds.
-    Tear down plone.testing.zca.ZCMLDirectives in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-    Tear down plone.testing.security.Checkers in ... seconds.
-
-    >>> zca.ZCML_DIRECTIVES.get('configurationContext', None) is None
-    True
diff --git a/src/plone/testing/security.py b/src/plone/testing/security.py
index 2cfbb72..28516e7 100644
--- a/src/plone/testing/security.py
+++ b/src/plone/testing/security.py
@@ -1,10 +1,11 @@
+# -*- coding: utf-8 -*-
 """Security helpers and layers
 """
-
 from plone.testing import Layer
 
 _checkersStack = []
 
+
 def pushCheckers():
     """Push the current set of security checkers onto a stack. You should
     normally do this during layer set-up, before loading any ZCML files that
@@ -17,6 +18,7 @@ def pushCheckers():
 
     _checkersStack.append(checker._checkers.copy())
 
+
 def popCheckers():
     """Pop the most recently pushed set of security checkers from the stack.
     You should normally do this during layer tear-down. You *must* keep calls
@@ -29,6 +31,7 @@ def popCheckers():
 
     checker._checkers = _checkersStack.pop()
 
+
 class Checkers(Layer):
     """Ensures correct isolation of security checkers in zope.security.
     """
diff --git a/src/plone/testing/security.rst b/src/plone/testing/security.rst
new file mode 100644
index 0000000..3423bd3
--- /dev/null
+++ b/src/plone/testing/security.rst
@@ -0,0 +1,73 @@
+Security
+--------
+
+The Zope Security layers are found in the module ``plone.testing.security``:::
+
+    >>> from plone.testing import security
+
+For testing, we need a testrunner:::
+
+    >>> from zope.testrunner import runner
+
+Layers
+~~~~~~
+
+The ``security.CHECKERS`` layer makes sure that ``zope.security`` checkers are correctly set up and torn down.::
+
+    >>> "%s.%s" % (security.CHECKERS.__module__, security.CHECKERS.__name__,)
+    'plone.testing.security.Checkers'
+
+    >>> security.CHECKERS.__bases__
+    ()
+
+Before the test, our custom checker is not in the registry.::
+
+    >>> class DummyObject(object):
+    ...     pass
+
+    >>> from zope.security.interfaces import IChecker
+    >>> from zope.interface import implements
+    >>> class FauxChecker(object):
+    ...     implements(IChecker)
+    ...     # we should really implement the interface here, but oh well
+
+    >>> from zope.security.checker import getCheckerForInstancesOf
+    >>> getCheckerForInstancesOf(DummyObject) is None
+    True
+
+Layer setup stacks the current checkers.::
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, security.CHECKERS, setupLayers)
+    Set up plone.testing.security.Checkers in ... seconds.
+
+We can now set up a checker.
+In real life, this may happen during ZCML configuration, but here will just call the API directlyMost likely, we'd do this in a child layer:::
+
+    >>> from zope.security.checker import defineChecker
+    >>> fauxChecker = FauxChecker()
+    >>> defineChecker(DummyObject, fauxChecker)
+
+    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
+    True
+
+Let's now simulate a test that may use the checker.::
+
+    >>> security.CHECKERS.testSetUp()
+    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
+    True
+    >>> security.CHECKERS.testTearDown()
+
+We still have the checker after test tear-down:::
+
+    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
+    True
+
+However, when we tear down the layer, the checker is gone:::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.security.Checkers in ... seconds.
+
+    >>> getCheckerForInstancesOf(DummyObject) is None
+    True
diff --git a/src/plone/testing/security.txt b/src/plone/testing/security.txt
deleted file mode 100644
index 2cd34ca..0000000
--- a/src/plone/testing/security.txt
+++ /dev/null
@@ -1,75 +0,0 @@
-Security
---------
-
-The Zope Security layers are found in the module ``plone.testing.security``:
-
-    >>> from plone.testing import security
-
-For testing, we need a testrunner
-
-    >>> from zope.testrunner import runner
-
-Layers
-~~~~~~
-
-The ``security.CHECKERS`` layer makes sure that ``zope.security`` checkers are
-correctly set up and torn down.
-
-    >>> "%s.%s" % (security.CHECKERS.__module__, security.CHECKERS.__name__,)
-    'plone.testing.security.Checkers'
-
-    >>> security.CHECKERS.__bases__
-    ()
-
-Before the test, our custom checker is not in the registry.
-
-    >>> class DummyObject(object):
-    ...     pass
-
-    >>> from zope.security.interfaces import IChecker
-    >>> from zope.interface import implements
-    >>> class FauxChecker(object):
-    ...     implements(IChecker)
-    ...     # we should really implement the interface here, but oh well
-
-    >>> from zope.security.checker import getCheckerForInstancesOf
-    >>> getCheckerForInstancesOf(DummyObject) is None
-    True
-
-Layer setup stacks the current checkers.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, security.CHECKERS, setupLayers)
-    Set up plone.testing.security.Checkers in ... seconds.
-
-We can now set up a checker. In real life, this may happen during ZCML
-configuration, but here will just call the API directlyMost likely, we'd do
-this in a child layer:
-
-    >>> from zope.security.checker import defineChecker
-    >>> fauxChecker = FauxChecker()
-    >>> defineChecker(DummyObject, fauxChecker)
-
-    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
-    True
-
-Let's now simulate a test that may use the checker.
-
-    >>> security.CHECKERS.testSetUp()
-    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
-    True
-    >>> security.CHECKERS.testTearDown()
-
-We still have the checker after test tear-down:
-
-    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker
-    True
-
-However, when we tear down the layer, the checker is gone:
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.security.Checkers in ... seconds.
-
-    >>> getCheckerForInstancesOf(DummyObject) is None
-    True
diff --git a/src/plone/testing/testing_zca.zcml b/src/plone/testing/testing_zca.zcml
index b5c5170..417804c 100644
--- a/src/plone/testing/testing_zca.zcml
+++ b/src/plone/testing/testing_zca.zcml
@@ -1,6 +1,13 @@
-<configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
-    <include package="zope.component" file="meta.zcml" />
-    <utility factory=".tests.DummyUtility"
-             provides="zope.interface.Interface"
-             name="layer" />
+<configure
+    package="plone.testing"
+    xmlns="http://namespaces.zope.org/zope">
+
+  <include package="zope.component" file="meta.zcml" />
+
+  <utility
+      factory=".tests.DummyUtility"
+      provides="zope.interface.Interface"
+      name="layer"
+      />
+
 </configure>
diff --git a/src/plone/testing/testing_zca_more_specific.zcml b/src/plone/testing/testing_zca_more_specific.zcml
index 43ec7d5..a6f0692 100644
--- a/src/plone/testing/testing_zca_more_specific.zcml
+++ b/src/plone/testing/testing_zca_more_specific.zcml
@@ -1,5 +1,11 @@
-<configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
-    <utility factory=".tests.DummyUtility"
-             provides="zope.interface.Interface"
-             name="more_specific_layer" />
+<configure
+    package="plone.testing"
+    xmlns="http://namespaces.zope.org/zope">
+
+  <utility
+      factory=".tests.DummyUtility"
+      provides="zope.interface.Interface"
+      name="more_specific_layer"
+      />
+
 </configure>
diff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py
index 47f1876..ca99bd9 100644
--- a/src/plone/testing/tests.py
+++ b/src/plone/testing/tests.py
@@ -1,6 +1,7 @@
+# -*- coding: utf-8 -*-
 try:
     import unittest2 as unittest
-except ImportError: # Python 2.7
+except ImportError:  # Python 2.7
     import unittest
 import doctest
 
@@ -12,7 +13,7 @@
 from OFS.SimpleItem import SimpleItem
 from ZPublisher.Iterators import filestream_iterator
 
-# This is somewhat retarted. We execute README.txt as a doctest, mainly just
+# This is somewhat retarted. We execute README.rst as a doctest, mainly just
 # to test that the code samples import cleanly and are valid Python. However,
 # in there we also have a code sample of a doctest, which gets executed by the
 # doctest runner. Since the method inside the example code block is not yet
@@ -20,23 +21,32 @@
 #
 # To get around this, we define a fake method and stick it into the globs for
 # the doctest.
+
+
 def _canOutrunKlingons(warpDrive):
     return warpDrive.maxSpeed > 8.0
 
+
 class DummyUtility(object):
+
     def __repr__(self):
         return "<Dummy utility>"
 
+
 class DummyView(object):
+
     def __init__(self, context, request):
         pass
+
     def __call__(self):
         return u""
 
+
 class DummyFile(SimpleItem):
+
     def __call__(self):
         path = get_distribution('plone.testing').location
-        path = os.path.join(path, 'plone', 'testing', 'z2.txt')
+        path = os.path.join(path, 'plone', 'testing', 'z2.rst')
 
         request = self.REQUEST
         response = request.response
@@ -44,29 +54,32 @@ def __call__(self):
         response.setHeader('Content-Length', os.path.getsize(path))
         return filestream_iterator(path)
 
+
 def setUp(self):
     zope.component.testing.setUp()
 
+
 def tearDown(self):
     zope.component.testing.tearDown()
 
+
 def test_suite():
     suite = unittest.TestSuite()
     suite.addTests([
         doctest.DocFileSuite(
-            'layer.txt',
-            'zca.txt',
-            'security.txt',
-            'publisher.txt',
-            'zodb.txt',
-            'z2.txt',
+            'layer.rst',
+            'zca.rst',
+            'security.rst',
+            'publisher.rst',
+            'zodb.rst',
+            'z2.rst',
             setUp=setUp,
             tearDown=tearDown,
             optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,
         ),
         doctest.DocFileSuite(
-            'README.rst',
-            globs={'canOutrunKlingons': _canOutrunKlingons,},
+            '../../../docs/overview.rst',
+            globs={'canOutrunKlingons': _canOutrunKlingons, },
             setUp=setUp,
             tearDown=tearDown,
             optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,
diff --git a/src/plone/testing/z2.py b/src/plone/testing/z2.py
index 316f236..bb9e11c 100644
--- a/src/plone/testing/z2.py
+++ b/src/plone/testing/z2.py
@@ -1,12 +1,14 @@
+# -*- coding: utf-8 -*-
 """Zope2-specific helpers and layers
 """
-
-import contextlib
-import os
-
 from plone.testing import Layer
-from plone.testing import zodb
 from plone.testing import zca
+from plone.testing import zodb
+from zope.schema.vocabulary import getVocabularyRegistry
+from zope.schema.vocabulary import setVocabularyRegistry
+from Zope2.App.schema import Zope2VocabularyRegistry
+import contextlib
+import os
 
 try:
     from plone.testing._z2_testbrowser import Browser
@@ -14,10 +16,6 @@
     # Just in case zope.testbrowser causes an import error, don't break
     pass
 
-from zope.schema.vocabulary import getVocabularyRegistry
-from zope.schema.vocabulary import setVocabularyRegistry
-from Zope2.App.schema import Zope2VocabularyRegistry
-
 try:
     from OFS.metaconfigure import get_packages_to_initialize
     HAS_ZOPE213 = True
@@ -26,6 +24,7 @@
 
 _INSTALLED_PRODUCTS = {}
 
+
 def installProduct(app, productName, quiet=False, multiinit=False):
     """Install the Zope 2 product with the given name, so that it will show
     up in the Zope 2 control panel and have its ``initialize()`` hook called.
@@ -38,17 +37,14 @@ def installProduct(app, productName, quiet=False, multiinit=False):
     Note that products' ZCML is *not* loaded automatically, even if the
     product is in the Products namespace.
     """
-
-    import sys
-
-
-    from OFS.Folder import Folder
-    from OFS.Application import get_folder_permissions, get_products
-    from OFS.Application import install_product, install_package
-
     from App.class_init import InitializeClass
-
+    from OFS.Application import get_folder_permissions
+    from OFS.Application import get_products
+    from OFS.Application import install_package
+    from OFS.Application import install_product
+    from OFS.Folder import Folder
     import Products
+    import sys
 
     found = False
 
@@ -59,10 +55,21 @@ def installProduct(app, productName, quiet=False, multiinit=False):
         for priority, name, index, productDir in get_products():
             if ('Products.' + name) == productName:
 
-                install_product(app, productDir, name, [], get_folder_permissions(), raise_exc=1)
+                install_product(
+                    app,
+                    productDir,
+                    name,
+                    [],
+                    get_folder_permissions(),
+                    raise_exc=1)
                 InitializeClass(Folder)
 
-                _INSTALLED_PRODUCTS[productName] = (priority, name, index, productDir,)
+                _INSTALLED_PRODUCTS[productName] = (
+                    priority,
+                    name,
+                    index,
+                    productDir,
+                )
 
                 found = True
                 break
@@ -76,7 +83,8 @@ def installProduct(app, productName, quiet=False, multiinit=False):
             if module.__name__ == productName:
                 install_package(app, module, init_func, raise_exc=1)
                 if not HAS_ZOPE213:
-                    Products._packages_to_initialize.remove((module, init_func))
+                    Products._packages_to_initialize.remove(
+                        (module, init_func))
 
                 _INSTALLED_PRODUCTS[productName] = (module, init_func,)
 
@@ -88,6 +96,7 @@ def installProduct(app, productName, quiet=False, multiinit=False):
         sys.stderr.write("Could not install product %s\n" % productName)
         sys.stderr.flush()
 
+
 def uninstallProduct(app, productName, quiet=False):
     """Uninstall the given Zope 2 product. This is the inverse of
     ``installProduct()`` above.
@@ -130,12 +139,13 @@ def uninstallProduct(app, productName, quiet=False):
                         del cp[name]
 
                 # TODO: Also remove permissions from get_folder_permissions?
-                # Difficult to know if this would stomp on any other permissions
+                # Difficult to know if this would stomp on any other
+                # permissions
                 # InitializeClass(Folder)
 
                 found = True
                 break
-    elif productName in _INSTALLED_PRODUCTS: # must be a package
+    elif productName in _INSTALLED_PRODUCTS:  # must be a package
 
         module, init_func = _INSTALLED_PRODUCTS[productName]
         name = module.__name__
@@ -168,6 +178,7 @@ def uninstallProduct(app, productName, quiet=False):
         sys.stderr.write("Could not install product %s\n" % productName)
         sys.stderr.flush()
 
+
 def login(userFolder, userName):
     """Log in as the given user in the given user folder.
     """
@@ -181,6 +192,7 @@ def login(userFolder, userName):
         user = user.__of__(userFolder)
     newSecurityManager(None, user)
 
+
 def logout():
     """Log out, i.e. become anonymous
     """
@@ -188,6 +200,7 @@ def logout():
     from AccessControl.SecurityManagement import noSecurityManager
     noSecurityManager()
 
+
 def setRoles(userFolder, userId, roles):
     """Set the given user's roles to a tuple of roles.
     """
@@ -203,9 +216,9 @@ def setRoles(userFolder, userId, roles):
 def makeTestRequest(environ=None):
     """Return an HTTPRequest object suitable for testing views."""
     from sys import stdin, stdout
+    from zope.publisher.browser import setDefaultSkin
     from ZPublisher.HTTPRequest import HTTPRequest
     from ZPublisher.HTTPResponse import HTTPResponse
-    from zope.publisher.browser import setDefaultSkin
 
     if environ is None:
         environ = {}
@@ -272,18 +285,18 @@ def zopeApp(db=None, connection=None, environ=None):
     inner_exception = None
     try:
         yield app
-    except Exception, e:
+    except Exception as e:
         inner_exception = e
         try:
             transaction.abort()
-        except Exception, e:
+        except Exception as e:
             inner_exception = e
             raise
         raise
     else:
         try:
             transaction.commit()
-        except Exception, e:
+        except Exception as e:
             inner_exception = e
     finally:
         try:
@@ -297,6 +310,7 @@ def zopeApp(db=None, connection=None, environ=None):
             else:
                 raise
 
+
 # Startup layer - you probably don't want to use this one directly
 
 class Startup(Layer):
@@ -414,36 +428,48 @@ def setUpPatches(self):
         import Zope2.App.startup
 
         # Avoid expensive product import
-        def null_import_products(): pass
+        def null_import_products():
+            pass
         self._OFS_Application_import_products = OFS.Application.import_products
         OFS.Application.import_products = null_import_products
 
         # Avoid expensive product installation
-        def null_initialize(app): pass
+        def null_initialize(app):
+            pass
         self._OFS_Application_initialize = OFS.Application.initialize
         OFS.Application.initialize = null_initialize
 
         # Avoid expensive help registration
         try:
-            self._App_ProductContext_ProductContext_registerHelpTopic = App.ProductContext.ProductContext.registerHelpTopic
+            self._App_ProductContext_ProductContext_registerHelpTopic = App.ProductContext.ProductContext.registerHelpTopic  # noqa
         except AttributeError:
             # Zope 4
             pass
         else:
-            def null_register_topic(self,id,topic): pass
-            App.ProductContext.ProductContext.registerHelpTopic = null_register_topic
+            def null_register_topic(self, id, topic):
+                pass
+            App.ProductContext.ProductContext.registerHelpTopic = null_register_topic  # noqa
+
+            self._App_ProductContext_ProductContext_registerHelpTitle = App.ProductContext.ProductContext.registerHelpTitle  # noqa
 
-            self._App_ProductContext_ProductContext_registerHelpTitle = App.ProductContext.ProductContext.registerHelpTitle
-            def null_register_title(self,title): pass
-            App.ProductContext.ProductContext.registerHelpTitle = null_register_title
+            def null_register_title(self, title):
+                pass
+            App.ProductContext.ProductContext.registerHelpTitle = null_register_title  # noqa
 
-            self._App_ProductContext_ProductContext_registerHelp = App.ProductContext.ProductContext.registerHelp
-            def null_register_help(self,directory='',clear=1,title_re=None): pass
+            self._App_ProductContext_ProductContext_registerHelp = App.ProductContext.ProductContext.registerHelp  # noqa
+
+            def null_register_help(
+                    self,
+                    directory='',
+                    clear=1,
+                    title_re=None):
+                pass
             App.ProductContext.ProductContext.registerHelp = null_register_help
 
         # in Zope 2.13, prevent ZCML from loading during App startup
         if hasattr(Zope2.App.startup, 'load_zcml'):
-            def null_load_zcml(): pass
+            def null_load_zcml():
+                pass
             self._Zope2_App_startup_load_zcml = Zope2.App.startup.load_zcml
             Zope2.App.startup.load_zcml = null_load_zcml
 
@@ -461,17 +487,17 @@ def tearDownPatches(self):
         del self._OFS_Application_initialize
 
         try:
-            App.ProductContext.ProductContext.registerHelpTopic = self._App_ProductContext_ProductContext_registerHelpTopic
+            App.ProductContext.ProductContext.registerHelpTopic = self._App_ProductContext_ProductContext_registerHelpTopic  # noqa
         except AttributeError:
             # Zope 4
             pass
         else:
             del self._App_ProductContext_ProductContext_registerHelpTopic
 
-            App.ProductContext.ProductContext.registerHelpTitle = self._App_ProductContext_ProductContext_registerHelpTitle
+            App.ProductContext.ProductContext.registerHelpTitle = self._App_ProductContext_ProductContext_registerHelpTitle  # noqa
             del self._App_ProductContext_ProductContext_registerHelpTitle
 
-            App.ProductContext.ProductContext.registerHelp = self._App_ProductContext_ProductContext_registerHelp
+            App.ProductContext.ProductContext.registerHelp = self._App_ProductContext_ProductContext_registerHelp  # noqa
             del self._App_ProductContext_ProductContext_registerHelp
 
     def setUpThreads(self):
@@ -524,7 +550,9 @@ def setUpDatabase(self):
         # Layer a new storage for Zope 2 on top of the one from the base
         # layer, if there is one.
 
-        self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='Startup')
+        self['zodbDB'] = zodb.stackDemoStorage(
+            self.get('zodbDB'),
+            name='Startup')
 
         # Create a facade for the database object that will delegate to the
         # correct underlying database. This allows resource shadowing to work
@@ -551,7 +579,8 @@ class DBTab(Zope2.Startup.datatypes.DBTab):
             """
 
             def __init__(self, db):
-                self.db_factories = {'testing': None} # value is never used when we have an open db
+                # value is never used when we have an open db
+                self.db_factories = {'testing': None}
                 self.mount_paths = {'/': 'testing'}
                 self.databases = {'testing': db}
 
@@ -658,8 +687,10 @@ def tearDownBasicProducts(self):
         except ImportError:
             # Zope <= 2.12
             from Products.Five import fiveconfigure as metaconfigure
-        metaconfigure._register_monkies = list(set(metaconfigure._register_monkies))
-        metaconfigure._meta_type_regs = list(set(metaconfigure._meta_type_regs))
+        metaconfigure._register_monkies = list(
+            set(metaconfigure._register_monkies))
+        metaconfigure._meta_type_regs = list(
+            set(metaconfigure._meta_type_regs))
 
     def setUpZCML(self):
         """Load the basic ZCML configuration from Five. Exposes a resource
@@ -673,7 +704,8 @@ def setUpZCML(self):
         # Load something akin to the default site.zcml without actually auto-
         # loading products
 
-        self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))
+        self['configurationContext'] = context = zca.stackConfigurationContext(
+            self.get('configurationContext'))
 
         from zope.configuration import xmlconfig
         xmlconfig.string("""\
@@ -720,6 +752,7 @@ def tearDownFive(self):
 
 STARTUP = Startup()
 
+
 # Basic integration and functional test and layers. These are the simplest
 # Zope 2 layers that are generally useful
 
@@ -744,7 +777,7 @@ class MyFixture(Layer):
             ...
 
         MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name='MyFixture')
-        MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name='MyFixture:Integration')
+        MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name='MyFixture:Integration')  # noqa
     """
 
     defaultBases = (STARTUP,)
@@ -804,6 +837,7 @@ def testTearDown(self):
 
 INTEGRATION_TESTING = IntegrationTesting()
 
+
 class FunctionalTesting(Layer):
     """An alternative to ``INTEGRATION_TESTING`` suitable for functional testing.
     This one pushes and pops a ``DemoStorage`` layer for each test. The
@@ -825,7 +859,7 @@ class MyFixture(Layer):
             ...
 
         MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name='MyFixture')
-        MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name='MyFixture:Functional')
+        MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name='MyFixture:Functional')  # noqa
     """
 
     defaultBases = (STARTUP,)
@@ -840,7 +874,9 @@ def testSetUp(self):
         # this layer, we can't just assign a new shadow. We therefore keep
         # track of the original so that we can restore it on tear-down.
 
-        self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='FunctionalTest')
+        self['zodbDB'] = zodb.stackDemoStorage(
+            self.get('zodbDB'),
+            name='FunctionalTest')
 
         # Save the app
 
@@ -894,6 +930,7 @@ def testTearDown(self):
 
 FUNCTIONAL_TESTING = FunctionalTesting()
 
+
 # More advanced functional testing - running ZServer and FTP server
 
 class ZServer(Layer):
@@ -931,9 +968,9 @@ def setUp(self):
         self.setUpServer()
 
         self.thread = Thread(
-                name="%s server" % self.__name__,
-                target=self.runner,
-            )
+            name="%s server" % self.__name__,
+            target=self.runner,
+        )
 
         self.thread.start()
         time.sleep(0.5)
@@ -963,7 +1000,11 @@ def setUpServer(self):
 
         zopeLog = logger.file_logger(log)
 
-        server = zhttp_server(ip=self.host, port=self.port, resolver=None, logger_object=zopeLog)
+        server = zhttp_server(
+            ip=self.host,
+            port=self.port,
+            resolver=None,
+            logger_object=zopeLog)
         zhttpHandler = zhttp_handler(module='Zope2', uri_base='')
         server.install_handler(zhttpHandler)
 
@@ -993,7 +1034,12 @@ def runner(self):
 ZSERVER_FIXTURE = ZServer()
 
 # Functional testing layer that uses the ZSERVER_FIXTURE
-ZSERVER = FunctionalTesting(bases=(ZSERVER_FIXTURE,), name="ZServer:Functional")
+ZSERVER = FunctionalTesting(
+    bases=(
+        ZSERVER_FIXTURE,
+    ),
+    name="ZServer:Functional")
+
 
 class FTPServer(ZServer):
     """FTP variant of the ZServer layer.
@@ -1031,7 +1077,11 @@ def setUpServer(self):
 
         zopeLog = logger.file_logger(log)
 
-        self.ftpServer = FTPServer('Zope2', ip=self.host, port=self.port, logger_object=zopeLog)
+        self.ftpServer = FTPServer(
+            'Zope2',
+            ip=self.host,
+            port=self.port,
+            logger_object=zopeLog)
 
     def tearDownServer(self):
         """Close the FTPServer socket
@@ -1043,4 +1093,8 @@ def tearDownServer(self):
 FTP_SERVER_FIXTURE = FTPServer()
 
 # Functional testing layer that uses the FTP_SERVER_FIXTURE
-FTP_SERVER = FunctionalTesting(bases=(FTP_SERVER_FIXTURE,), name="FTPServer:Functional")
+FTP_SERVER = FunctionalTesting(
+    bases=(
+        FTP_SERVER_FIXTURE,
+    ),
+    name="FTPServer:Functional")
diff --git a/src/plone/testing/z2.rst b/src/plone/testing/z2.rst
new file mode 100644
index 0000000..b16280a
--- /dev/null
+++ b/src/plone/testing/z2.rst
@@ -0,0 +1,649 @@
+Zope 2 layers
+-------------
+
+The Zope 2 layers are found in the module ``plone.testing.z2``:::
+
+    >>> from plone.testing import z2
+
+For testing, we need a testrunner:::
+
+    >>> from zope.testrunner import runner
+
+Startup
+~~~~~~~
+
+``STARTUP`` is the base layer for all Zope 2 testing.
+It sets up a Zope 2 sandbox environment that is suitable for testing.
+It extends the ``zca.LAYER_CLEANUP`` layer to maximise the chances of having and leaving a pristine environment.
+
+**Note**: You should probably use at least ``INTEGRATION_TESTING`` for any real test, although ``STARTUP`` is a useful base layer if you are setting up your own fixture.
+See the description of ``INTEGRATION_TESTING`` below.::
+
+    >>> "%s.%s" % (z2.STARTUP.__module__, z2.STARTUP.__name__,)
+    'plone.testing.z2.Startup'
+
+    >>> z2.STARTUP.__bases__
+    (<Layer 'plone.testing.zca.LayerCleanup'>,)
+
+On layer setup, Zope is initialised in a lightweight manner.
+This involves certain patches to global modules that Zope manages, to reduce setup time, a database based on ``DemoStorage``, and a minimal set of products that must be installed for Zope 2 to work.
+A minimal set of ZCML is loaded, but packages in the ``Products`` namespace are not automatically configured.
+
+Let's just verify that we have an empty component registry before the test:::
+
+    >>> from zope.component import getSiteManager
+    >>> list(getSiteManager().registeredAdapters())
+    []
+
+Five sets a special vocabulary registry upon the layer setup, but there's a default one set before:::
+
+    >>> from zope.schema.vocabulary import getVocabularyRegistry
+    >>> getVocabularyRegistry()
+    <zope.schema.vocabulary.VocabularyRegistry object ...>
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.STARTUP, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+
+After layer setup, the ``zodbDB`` resource is available, pointing to the default ZODB.::
+
+    >>> z2.STARTUP['zodbDB']
+    <ZODB.DB.DB object at ...>
+
+    >>> z2.STARTUP['zodbDB'].storage
+    Startup
+
+In addition, the resources ``host`` and ``port`` are set to the default hostname and port that are used for URLs generated from Zope.
+These are hardcoded, but shadowed by layers that provide actual running Zope instances.::
+
+    >>> z2.STARTUP['host']
+    'nohost'
+    >>> z2.STARTUP['port']
+    80
+
+At this point, it is also possible to get hold of a Zope application root.
+If you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the ``zopeApp()`` context manager.::
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+If you want to use a specific database, you can pass that to ``zopeApp()`` as the ``db`` parameter.
+A new connection will be opened and closed.::
+
+    >>> with z2.zopeApp(db=z2.STARTUP['zodbDB']) as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+If you want to re-use an existing connection, you can pass one to ``zopeApp()`` as the ``connection`` argument.
+In this case, you will need to close the connection yourself.::
+
+    >>> conn = z2.STARTUP['zodbDB'].open()
+    >>> with z2.zopeApp(connection=conn) as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+    >>> conn.opened is not None
+    True
+
+    >>> conn.close()
+
+If an exception is raised within the ``with`` block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager):::
+
+    >>> with z2.zopeApp() as app:
+    ...     raise Exception("Test error")
+    Traceback (most recent call last):
+    ...
+    Exception: Test error
+
+It is common to combine the ``zopeApp()`` context manager with a stacked ``DemoStorage`` to set up a layer-specific fixture.
+As a sketch:::
+
+    from plone.testing import Layer, z2, zodb
+
+    class MyLayer(Layer):
+        defaultBases = (z2.STARTUP,)
+
+        def setUp(self):
+            self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
+            with z2.zopeApp() as app:
+
+                # Set up a fixture, e.g.:
+                app.manage_addFolder('folder1')
+                folder = app['folder1']
+                folder._addRole('role1')
+                folder.manage_addUserFolder()
+
+                userFolder = folder['acl_users']
+                ignore = userFolder.userFolderAddUser('user1', 'secret', ['role1'], [])
+                folder.manage_role('role1', ('Access contents information',))
+
+        def tearDown(self):
+            self['zodbDB'].close()
+            del self['zodbDB']
+
+Note that you would normally *not* use the ``z2.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.
+The ``IntegrationTesting`` and ``FunctionalTesting`` layer classes manage the application object for you, exposing them as the resource ``app`` (see below).
+
+After layer setup, the global component registry contains a number of components needed by Zope.::
+
+    >>> len(list(getSiteManager().registeredAdapters())) > 1 # in fact, > a lot
+    True
+
+And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:::
+
+    >>> getVocabularyRegistry()
+    <....Zope2VocabularyRegistry object at ...>
+
+To load additional ZCML, you can use the ``configurationContext`` resource:::
+
+    >>> z2.STARTUP['configurationContext']
+    <zope.configuration.config.ConfigurationMachine object ...>
+
+See ``zca.rst`` for details about how to use ``zope.configuration`` for this purpose.
+
+The ``STARTUP`` layer does not perform any specific test setup or tear-down.
+That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING`` layers, or other layers using their layer classes - ``IntegrationTesting`` and ``FunctionalTesting``.::
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.STARTUP.testTearDown()
+
+Layer tear-down resets the environment.::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+    >>> import Zope2
+    >>> Zope2._began_startup
+    0
+    >>> Zope2.DB is None
+    True
+    >>> Zope2.bobo_application is None
+    True
+
+    >>> list(getSiteManager().registeredAdapters())
+    []
+
+    >>> getVocabularyRegistry()
+    <zope.schema.vocabulary.VocabularyRegistry object at ...>
+
+Integration test
+~~~~~~~~~~~~~~~~
+
+``INTEGRATION_TESTING`` is intended for simple Zope 2 integration testing.
+It extends ``STARTUP`` to ensure that a transaction is begun before and rolled back after each test.
+Two resources, ``app`` and ``request``, are available during testing as well.
+It does not manage any layer state - it implements the test lifecycle methods only.
+
+**Note:** You would normally *not* use ``INTEGRATION_TESTING`` as a base layer.
+Instead, you'd use the ``IntegrationTesting`` class to create your own layer with the testing lifecycle semantics of ``INTEGRATION_TESTING``.
+See the ``plone.testing`` ``README`` file for an example.
+
+``app`` is the application root.
+In a test, you should use this instead of the ``zopeApp`` context manager (which remains the weapon of choice for setting up persistent fixtures), because the ``app`` resource is part of the transaction managed by the layer.
+
+``request`` is a test request. It is the same as ``app.REQUEST``.::
+
+    >>> "%s.%s" % (z2.INTEGRATION_TESTING.__module__, z2.INTEGRATION_TESTING.__name__,)
+    'plone.testing.z2.IntegrationTesting'
+
+    >>> z2.INTEGRATION_TESTING.__bases__
+    (<Layer 'plone.testing.z2.Startup'>,)
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.INTEGRATION_TESTING, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+    Set up plone.testing.z2.IntegrationTesting in ... seconds.
+
+Let's now simulate a test.
+On test setup, the ``app`` resource is made available.
+In a test, you should always use this to access the application root.::
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.INTEGRATION_TESTING.testSetUp()
+
+The test may now inspect and modify the environment.::
+
+    >>> app = z2.INTEGRATION_TESTING['app'] # would normally be self.layer['app']
+    >>> app.manage_addFolder('folder1')
+    >>> app.objectIds()
+    ['acl_users', 'Control_Panel', 'folder1']
+
+The request is also available:::
+
+    >>> z2.INTEGRATION_TESTING['request'] # would normally be self.layer['request']
+    <HTTPRequest, URL=http://nohost>
+
+We can create a user and simulate logging in as that user, using the ``z2.login()`` helper:::
+
+    >>> app._addRole('role1')
+    >>> ignore = app['acl_users'].userFolderAddUser('user1', 'secret', ['role1'], [])
+    >>> z2.login(app['acl_users'], 'user1')
+
+The first argument to ``z2.login()`` is the user folder that contains the relevant user.
+The second argument is the user's name.
+There is no need to give the password.::
+
+    >>> from AccessControl import getSecurityManager
+    >>> getSecurityManager().getUser()
+    <User 'user1'>
+
+You can change the roles of a user using the ``z2.setRoles()`` helper:::
+
+    >>> sorted(getSecurityManager().getUser().getRolesInContext(app))
+    ['Authenticated', 'role1']
+
+    >>> z2.setRoles(app['acl_users'], 'user1', [])
+    >>> getSecurityManager().getUser().getRolesInContext(app)
+    ['Authenticated']
+
+To become the anonymous user again, use ``z2.logout()``:::
+
+    >>> z2.logout()
+    >>> getSecurityManager().getUser()
+    <SpecialUser 'Anonymous User'>
+
+On tear-down, the transaction is rolled back:::
+
+    >>> z2.INTEGRATION_TESTING.testTearDown()
+    >>> z2.STARTUP.testTearDown()
+
+    >>> 'app' in z2.INTEGRATION_TESTING
+    False
+
+    >>> 'request' in z2.INTEGRATION_TESTING
+    False
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+Let's tear down the layers:::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.IntegrationTesting in ... seconds.
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+Functional testing
+~~~~~~~~~~~~~~~~~~
+
+The ``FUNCTIONAL_TESTING`` layer is very similar to ``INTEGRATION_TESTING``, and exposes the same fixture and resources.
+However, it has different transaction semantics.
+``INTEGRATION_TESTING`` creates a single database storage, and rolls back the transaction after each test.
+``FUNCTIONAL_TESTING`` creates a whole new database storage (stacked on top of the basic fixture) for each test.
+This allows testing of code that performs an explicit commit, which is usually required for end-to-end testing.
+The downside is that the set-up and tear-down of each test takes longer.
+
+**Note:** Again, you would normally *not* use ``FUNCTIONAL_TESTING`` as a base layer.
+Instead, you'd use the ``FunctionalTesting`` class to create your own layer with the testing lifecycle semantics of ``FUNCTIONAL_TESTING``.
+See the ``plone.testing`` ``README`` file for an example.
+
+Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.::
+
+    >>> "%s.%s" % (z2.FUNCTIONAL_TESTING.__module__, z2.FUNCTIONAL_TESTING.__name__,)
+    'plone.testing.z2.FunctionalTesting'
+
+    >>> z2.FUNCTIONAL_TESTING.__bases__
+    (<Layer 'plone.testing.z2.Startup'>,)
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+    Set up plone.testing.z2.FunctionalTesting in ... seconds.
+
+Let's now simulate a test.
+On test setup, the ``app`` resource is made available.
+In a test, you should always use this to access the application root.
+The ``request`` resource can be used to access the test request.::
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.FUNCTIONAL_TESTING.testSetUp()
+
+The test may now inspect and modify the environment.
+It may also commit things.::
+
+    >>> app = z2.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']
+    >>> app.manage_addFolder('folder1')
+    >>> app.objectIds()
+    ['acl_users', 'Control_Panel', 'folder1']
+
+    >>> import transaction
+    >>> transaction.commit()
+
+On tear-down, the database is torn down.::
+
+    >>> z2.FUNCTIONAL_TESTING.testTearDown()
+    >>> z2.STARTUP.testTearDown()
+
+    >>> 'app' in z2.FUNCTIONAL_TESTING
+    False
+
+    >>> 'request' in z2.FUNCTIONAL_TESTING
+    False
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+Let's tear down the layer:::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.FunctionalTesting in ... seconds.
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+The test browser
+~~~~~~~~~~~~~~~~
+
+The ``FUNCTIONAL_TESTING`` layer and ``FunctionalTesting`` layer class are the basis for functional testing using ``zope.testbrowser``.
+This simulates a web browser, allowing an application to be tested "end-to-end" via its user-facing interface.
+
+To use the test browser with a ``FunctionalTesting`` layer (such as the default ``FUNCTIONAL_TESTING`` layer instance), we need to use a custom browser client, which ensures that the test browser uses the correct ZODB and is appropriately isolated from the test code.::
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+    Set up plone.testing.z2.FunctionalTesting in ... seconds.
+
+Let's simulate a test:::
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.FUNCTIONAL_TESTING.testSetUp()
+
+In the test, we can create a test browser client like so:::
+
+    >>> app = z2.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']
+    >>> browser = z2.Browser(app)
+
+It is usually best to let Zope errors be shown with full tracebacks:::
+
+    >>> browser.handleErrors = False
+
+We can add to the test fixture in the test.
+For those changes to be visible to the test browser, however, we need to commit the transaction.::
+
+    >>> app.manage_addFolder('folder1')
+    >>> import transaction; transaction.commit()
+
+We can now view this via the test browser:::
+
+    >>> browser.open(app.absolute_url() + '/folder1')
+
+    >>> 'folder1' in browser.contents
+    True
+
+The test browser integration converts the URL into a request and passes control to Zope's publisher.
+Let's check that query strings are available for input processing:::
+
+    >>> import urllib
+    >>> qs = urllib.urlencode({'foo': 'boo, bar & baz'})  # sic: the ampersand.
+    >>> _ = app['folder1'].addDTMLMethod('index_html', file='<dtml-var foo>')
+    >>> import transaction; transaction.commit()
+    >>> browser.open(app.absolute_url() + '/folder1?' + qs)
+    >>> browser.contents
+    'boo, bar & baz'
+
+The test browser also works with iterators.
+Let's test that with a simple file implementation that uses an iterator.::
+
+    >>> from plone.testing.tests import DummyFile
+    >>> app._setObject('file1', DummyFile('file1'))
+    'file1'
+
+    >>> import transaction; transaction.commit()
+
+    >>> browser.open(app.absolute_url() + '/file1')
+    >>> 'The test browser also works with iterators' in browser.contents
+    True
+
+See the ``zope.testbrowser`` documentation for more information about how to use the browser client.
+
+On tear-down, the database is torn down.::
+
+    >>> z2.FUNCTIONAL_TESTING.testTearDown()
+    >>> z2.STARTUP.testTearDown()
+
+    >>> 'app' in z2.FUNCTIONAL_TESTING
+    False
+
+    >>> 'request' in z2.FUNCTIONAL_TESTING
+    False
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+Let's tear down the layer:::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.FunctionalTesting in ... seconds.
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+HTTP server
+~~~~~~~~~~~
+
+The ``ZSERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded Zope server in a separate thread.
+This makes it possible to connect to the test instance using a web browser or a testing tool like Selenium or Windmill.
+
+The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has ``ZSERVER_FIXTURE`` as its base.::
+
+    >>> "%s.%s" % (z2.ZSERVER_FIXTURE.__module__, z2.ZSERVER_FIXTURE.__name__,)
+    'plone.testing.z2.ZServer'
+
+    >>> z2.ZSERVER_FIXTURE.__bases__
+    (<Layer 'plone.testing.z2.Startup'>,)
+
+
+    >>> "%s.%s" % (z2.ZSERVER.__module__, z2.ZSERVER.__name__,)
+    'plone.testing.z2.ZServer:Functional'
+
+    >>> z2.ZSERVER.__bases__
+    (<Layer 'plone.testing.z2.ZServer'>,)
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.ZSERVER, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+    Set up plone.testing.z2.ZServer in ... seconds.
+    Set up plone.testing.z2.ZServer:Functional in ... seconds.
+
+After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::
+
+    >>> host = z2.ZSERVER['host']
+    >>> host
+    'localhost'
+
+    >>> port = z2.ZSERVER['port']
+    >>> import os
+    >>> port == int(os.environ.get('ZSERVER_PORT', 55001))
+    True
+
+Let's now simulate a test.
+Test setup does nothing beyond what the base layers do.::
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.FUNCTIONAL_TESTING.testSetUp()
+    >>> z2.ZSERVER.testSetUp()
+
+It is common in a test to use the Python API to change the state of the server (e.g.
+create some content or change a setting) and then use the HTTP protocol to look at the results.
+Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``z2.login()`` and ``z2.logout()``, for instance, do not affect the server thread.::
+
+    >>> app = z2.ZSERVER['app'] # would normally be self.layer['app']
+    >>> app.manage_addFolder('folder1')
+
+Note that we need to commit the transaction before it will show up in the other thread.::
+
+    >>> import transaction; transaction.commit()
+
+We can now look for this new object through the server.::
+
+    >>> app_url = app.absolute_url()
+    >>> app_url.split(':')[:-1]
+    ['http', '//localhost']
+
+    >>> import urllib2
+    >>> conn = urllib2.urlopen(app_url + '/folder1', timeout=5)
+    >>> print conn.read()
+    <Folder at folder1>
+    >>> conn.close()
+
+Test tear-down does nothing beyond what the base layers do.::
+
+    >>> z2.ZSERVER.testTearDown()
+    >>> z2.FUNCTIONAL_TESTING.testTearDown()
+    >>> z2.STARTUP.testTearDown()
+
+    >>> 'app' in z2.ZSERVER
+    False
+
+    >>> 'request' in z2.ZSERVER
+    False
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+When the server is torn down, the ZServer thread is stopped.::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.ZServer:Functional in ... seconds.
+    Tear down plone.testing.z2.ZServer in ... seconds.
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+    >>> conn = urllib2.urlopen(app_url + '/folder1', timeout=5)
+    Traceback (most recent call last):
+    ...
+    URLError: <urlopen error [Errno ...] Connection refused>
+
+FTP server
+~~~~~~~~~~
+
+The ``FTP_SERVER`` layer is identical similar to ``ZSERVER``, except that it starts an FTP server instead of an HTTP server.
+The fixture is contained in the ``FTP_SERVER_FIXTURE`` layer.
+
+    **Warning:** It is generally not safe to run the ``ZSERVER`` and ``FTP_SERVER`` layers concurrently, because they both start up the same ``asyncore`` loop.
+    If you need concurrent HTTP and FTP servers in a test, you can create your own layer by subclassing the ``ZServer`` layer class, and overriding the ``setUpServer()`` and ``tearDownServer()`` hooks to set up and close both servers.
+    See the code for an example.
+
+The ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.::
+
+    >>> "%s.%s" % (z2.FTP_SERVER_FIXTURE.__module__, z2.FTP_SERVER_FIXTURE.__name__,)
+    'plone.testing.z2.FTPServer'
+
+    >>> z2.FTP_SERVER_FIXTURE.__bases__
+    (<Layer 'plone.testing.z2.Startup'>,)
+
+The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the ``FunctionalTesting`` layer class.::
+
+    >>> "%s.%s" % (z2.FTP_SERVER.__module__, z2.FTP_SERVER.__name__,)
+    'plone.testing.z2.FTPServer:Functional'
+
+    >>> z2.FTP_SERVER.__bases__
+    (<Layer 'plone.testing.z2.FTPServer'>,)
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, z2.FTP_SERVER, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.z2.Startup in ... seconds.
+    Set up plone.testing.z2.FTPServer in ... seconds.
+    Set up plone.testing.z2.FTPServer:Functional in ... seconds.
+
+After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::
+
+    >>> host = z2.FTP_SERVER['host']
+    >>> host
+    'localhost'
+
+    >>> port = z2.FTP_SERVER['port']
+    >>> import os
+    >>> port == int(os.environ.get('FTPSERVER_PORT', 55002))
+    True
+
+Let's now simulate a test.
+Test setup does nothing beyond what the base layers do.::
+
+    >>> z2.STARTUP.testSetUp()
+    >>> z2.FUNCTIONAL_TESTING.testSetUp()
+    >>> z2.FTP_SERVER.testSetUp()
+
+As with ``ZSERVER``, we will set up some content for the test and then access it over the FTP port.::
+
+    >>> app = z2.FTP_SERVER['app'] # would normally be self.layer['app']
+    >>> app.manage_addFolder('folder1')
+
+We'll also create a user in the root user folder to make FTP access easier.::
+
+    >>> ignore = app['acl_users'].userFolderAddUser('admin', 'secret', ['Manager'], ())
+
+Note that we need to commit the transaction before it will show up in the other thread.::
+
+    >>> import transaction; transaction.commit()
+
+We can now look for this new object through the server.::
+
+    >>> app_path = app.absolute_url_path()
+
+    >>> import ftplib
+    >>> ftpClient = ftplib.FTP()
+    >>> ftpClient.connect(host, port, timeout=5)
+    '220 ... FTP server (...) ready.'
+
+    >>> ftpClient.login('admin', 'secret')
+    '230 Login successful.'
+
+    >>> ftpClient.cwd(app_path)
+    '250 CWD command successful.'
+
+    >>> ftpClient.retrlines('LIST')
+    drwxrwx---   1 Zope     Zope            0 ... .
+    drwxrwx---   1 Zope     Zope            0 ... Control_Panel
+    --w--w----   1 Zope     Zope            0 ... acl_users
+    drwxrwx---   1 Zope     Zope            0 ... folder1
+    '226 Transfer complete'
+
+    >>> ftpClient.quit()
+    '221 Goodbye.'
+
+Test tear-down does nothing beyond what the base layers do.::
+
+    >>> z2.FTP_SERVER.testTearDown()
+    >>> z2.FUNCTIONAL_TESTING.testTearDown()
+    >>> z2.STARTUP.testTearDown()
+
+    >>> 'app' in z2.ZSERVER
+    False
+
+    >>> 'request' in z2.ZSERVER
+    False
+
+    >>> with z2.zopeApp() as app:
+    ...     print app.objectIds()
+    ['acl_users', 'Control_Panel']
+
+When the server is torn down, the FTP thread is stopped.::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.z2.FTPServer:Functional in ... seconds.
+    Tear down plone.testing.z2.FTPServer in ... seconds.
+    Tear down plone.testing.z2.Startup in ... seconds.
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+    >>> ftpClient.connect(host, port, timeout=5)
+    Traceback (most recent call last):
+    ...
+    error: [Errno ...] Connection refused
diff --git a/src/plone/testing/z2.txt b/src/plone/testing/z2.txt
deleted file mode 100644
index 9b2f471..0000000
--- a/src/plone/testing/z2.txt
+++ /dev/null
@@ -1,696 +0,0 @@
-Zope 2 layers
--------------
-
-The Zope 2 layers are found in the module ``plone.testing.z2``:
-
-    >>> from plone.testing import z2
-
-For testing, we need a testrunner
-
-    >>> from zope.testrunner import runner
-
-Startup
-~~~~~~~
-
-``STARTUP`` is the base layer for all Zope 2 testing. It sets up a Zope 2
-sandbox environment that is suitable for testing. It extends the
-``zca.LAYER_CLEANUP`` layer to maximise the chances of having and leaving a
-pristine environment.
-
-**Note**: You should probably use at least ``INTEGRATION_TESTING`` for any
-real test, although ``STARTUP`` is a useful base layer if you are setting up
-your own fixture. See the description of ``INTEGRATION_TESTING`` below.
-
-    >>> "%s.%s" % (z2.STARTUP.__module__, z2.STARTUP.__name__,)
-    'plone.testing.z2.Startup'
-
-    >>> z2.STARTUP.__bases__
-    (<Layer 'plone.testing.zca.LayerCleanup'>,)
-
-On layer setup, Zope is initialised in a lightweight manner. This involves
-certain patches to global modules that Zope manages, to reduce setup time,
-a database based on ``DemoStorage``, and a minimal set of products that must
-be installed for Zope 2 to work. A minimal set of ZCML is loaded, but packages
-in the ``Products`` namespace are not automatically configured.
-
-Let's just verify that we have an empty component registry before the test:
-
-    >>> from zope.component import getSiteManager
-    >>> list(getSiteManager().registeredAdapters())
-    []
-
-Five sets a special vocabulary registry upon the layer setup, but
-there's a default one set before:
-
-    >>> from zope.schema.vocabulary import getVocabularyRegistry
-    >>> getVocabularyRegistry()
-    <zope.schema.vocabulary.VocabularyRegistry object ...>
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.STARTUP, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-
-After layer setup, the ``zodbDB`` resource is available, pointing to the
-default ZODB.
-
-    >>> z2.STARTUP['zodbDB']
-    <ZODB.DB.DB object at ...>
-
-    >>> z2.STARTUP['zodbDB'].storage
-    Startup
-
-In addition, the resources ``host`` and ``port`` are set to the default
-hostname and port that are used for URLs generated from Zope. These are
-hardcoded, but shadowed by layers that provide actual running Zope
-instances.
-
-    >>> z2.STARTUP['host']
-    'nohost'
-    >>> z2.STARTUP['port']
-    80
-
-At this point, it is also possible to get hold of a Zope application root.
-If you are setting up a layer fixture, you can obtain an application root
-with the correct database that is properly closed by using the ``zopeApp()``
-context manager.
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-If you want to use a specific database, you can pass that to ``zopeApp()`` as
-the ``db`` parameter. A new connection will be opened and closed.
-
-    >>> with z2.zopeApp(db=z2.STARTUP['zodbDB']) as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-If you want to re-use an existing connection, you can pass one to
-``zopeApp()`` as the ``connection`` argument. In this case, you will need to
-close the connection yourself.
-
-    >>> conn = z2.STARTUP['zodbDB'].open()
-    >>> with z2.zopeApp(connection=conn) as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-    >>> conn.opened is not None
-    True
-
-    >>> conn.close()
-
-If an exception is raised within the ``with`` block, the transaction is
-aborted, but the connection is still closed (if it was opened by the context
-manager):
-
-    >>> with z2.zopeApp() as app:
-    ...     raise Exception("Test error")
-    Traceback (most recent call last):
-    ...
-    Exception: Test error
-
-It is common to combine the ``zopeApp()`` context manager with a stacked
-``DemoStorage`` to set up a layer-specific fixture. As a sketch::
-
-    from plone.testing import Layer, z2, zodb
-
-    class MyLayer(Layer):
-        defaultBases = (z2.STARTUP,)
-
-        def setUp(self):
-            self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')
-            with z2.zopeApp() as app:
-
-                # Set up a fixture, e.g.:
-                app.manage_addFolder('folder1')
-                folder = app['folder1']
-                folder._addRole('role1')
-                folder.manage_addUserFolder()
-
-                userFolder = folder['acl_users']
-                ignore = userFolder.userFolderAddUser('user1', 'secret', ['role1'], [])
-                folder.manage_role('role1', ('Access contents information',))
-
-        def tearDown(self):
-            self['zodbDB'].close()
-            del self['zodbDB']
-
-Note that you would normally *not* use the ``z2.zopeApp()`` in a test or in a
-``testSetUp()`` or ``testTearDown()`` method. The ``IntegrationTesting`` and
-``FunctionalTesting`` layer classes manage the application object for you,
-exposing them as the resource ``app`` (see below).
-
-After layer setup, the global component registry contains a number of
-components needed by Zope.
-
-    >>> len(list(getSiteManager().registeredAdapters())) > 1 # in fact, > a lot
-    True
-
-And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:
-
-    >>> getVocabularyRegistry()
-    <....Zope2VocabularyRegistry object at ...>
-
-To load additional ZCML, you can use the ``configurationContext`` resource:
-
-    >>> z2.STARTUP['configurationContext']
-    <zope.configuration.config.ConfigurationMachine object ...>
-
-See ``zca.txt`` for details about how to use ``zope.configuration`` for this
-purpose.
-
-The ``STARTUP`` layer does not perform any specific test setup or tear-down.
-That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING``
-layers, or other layers using their layer classes - ``IntegrationTesting``
-and ``FunctionalTesting``.
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.STARTUP.testTearDown()
-
-Layer tear-down resets the environment.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-    >>> import Zope2
-    >>> Zope2._began_startup
-    0
-    >>> Zope2.DB is None
-    True
-    >>> Zope2.bobo_application is None
-    True
-
-    >>> list(getSiteManager().registeredAdapters())
-    []
-
-    >>> getVocabularyRegistry()
-    <zope.schema.vocabulary.VocabularyRegistry object at ...>
-
-Integration test
-~~~~~~~~~~~~~~~~
-
-``INTEGRATION_TESTING`` is intended for simple Zope 2 integration testing. It
-extends ``STARTUP`` to ensure that a transaction is begun before and rolled
-back after each test. Two resources, ``app`` and ``request``, are available
-during testing as well. It does not manage any layer state - it implements
-the test lifecycle methods only.
-
-**Note:** You would normally *not* use ``INTEGRATION_TESTING`` as a base
-layer. Instead, you'd use the ``IntegrationTesting`` class to create your
-own layer with the testing lifecycle semantics of ``INTEGRATION_TESTING``.
-See the ``plone.testing`` ``README`` file for an example.
-
-``app`` is the application root. In a test, you should use this instead of
-the ``zopeApp`` context manager (which remains the weapon of choice for
-setting up persistent fixtures), because the ``app`` resource is part of the
-transaction managed by the layer.
-
-``request`` is a test request. It is the same as ``app.REQUEST``.
-
-    >>> "%s.%s" % (z2.INTEGRATION_TESTING.__module__, z2.INTEGRATION_TESTING.__name__,)
-    'plone.testing.z2.IntegrationTesting'
-
-    >>> z2.INTEGRATION_TESTING.__bases__
-    (<Layer 'plone.testing.z2.Startup'>,)
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.INTEGRATION_TESTING, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-    Set up plone.testing.z2.IntegrationTesting in ... seconds.
-
-Let's now simulate a test. On test setup, the ``app`` resource is made
-available. In a test, you should always use this to access the application
-root.
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.INTEGRATION_TESTING.testSetUp()
-
-The test may now inspect and modify the environment.
-
-    >>> app = z2.INTEGRATION_TESTING['app'] # would normally be self.layer['app']
-    >>> app.manage_addFolder('folder1')
-    >>> app.objectIds()
-    ['acl_users', 'Control_Panel', 'folder1']
-
-The request is also available:
-
-    >>> z2.INTEGRATION_TESTING['request'] # would normally be self.layer['request']
-    <HTTPRequest, URL=http://nohost>
-
-We can create a user and simulate logging in as that user, using the
-``z2.login()`` helper:
-
-    >>> app._addRole('role1')
-    >>> ignore = app['acl_users'].userFolderAddUser('user1', 'secret', ['role1'], [])
-    >>> z2.login(app['acl_users'], 'user1')
-
-The first argument to ``z2.login()`` is the user folder that contains the
-relevant user. The second argument is the user's name. There is no need to
-give the password.
-
-    >>> from AccessControl import getSecurityManager
-    >>> getSecurityManager().getUser()
-    <User 'user1'>
-
-You can change the roles of a user using the ``z2.setRoles()`` helper:
-
-    >>> sorted(getSecurityManager().getUser().getRolesInContext(app))
-    ['Authenticated', 'role1']
-
-    >>> z2.setRoles(app['acl_users'], 'user1', [])
-    >>> getSecurityManager().getUser().getRolesInContext(app)
-    ['Authenticated']
-
-To become the anonymous user again, use ``z2.logout()``:
-
-    >>> z2.logout()
-    >>> getSecurityManager().getUser()
-    <SpecialUser 'Anonymous User'>
-
-On tear-down, the transaction is rolled back:
-
-    >>> z2.INTEGRATION_TESTING.testTearDown()
-    >>> z2.STARTUP.testTearDown()
-
-    >>> 'app' in z2.INTEGRATION_TESTING
-    False
-
-    >>> 'request' in z2.INTEGRATION_TESTING
-    False
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-Let's tear down the layers
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.IntegrationTesting in ... seconds.
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-Functional testing
-~~~~~~~~~~~~~~~~~~
-
-The ``FUNCTIONAL_TESTING`` layer is very similar to ``INTEGRATION_TESTING``,
-and exposes the same fixture and resources. However, it has different
-transaction semantics. ``INTEGRATION_TESTING`` creates a single database
-storage, and rolls back the transaction after each test.
-``FUNCTIONAL_TESTING`` creates a whole new database storage (stacked on top of
-the basic fixture) for each test. This allows testing of code that performs an
-explicit commit, which is usually required for end-to-end testing. The
-downside is that the set-up and tear-down of each test takes longer.
-
-**Note:** Again, you would normally *not* use ``FUNCTIONAL_TESTING`` as a base
-layer. Instead, you'd use the ``FunctionalTesting`` class to create your own
-layer with the testing lifecycle semantics of ``FUNCTIONAL_TESTING``. See
-the ``plone.testing`` ``README`` file for an example.
-
-Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.
-
-    >>> "%s.%s" % (z2.FUNCTIONAL_TESTING.__module__, z2.FUNCTIONAL_TESTING.__name__,)
-    'plone.testing.z2.FunctionalTesting'
-
-    >>> z2.FUNCTIONAL_TESTING.__bases__
-    (<Layer 'plone.testing.z2.Startup'>,)
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-    Set up plone.testing.z2.FunctionalTesting in ... seconds.
-
-Let's now simulate a test. On test setup, the ``app`` resource is made
-available. In a test, you should always use this to access the application
-root. The ``request`` resource can be used to access the test request.
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.FUNCTIONAL_TESTING.testSetUp()
-
-The test may now inspect and modify the environment. It may also
-commit things.
-
-    >>> app = z2.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']
-    >>> app.manage_addFolder('folder1')
-    >>> app.objectIds()
-    ['acl_users', 'Control_Panel', 'folder1']
-
-    >>> import transaction
-    >>> transaction.commit()
-
-On tear-down, the database is torn down.
-
-    >>> z2.FUNCTIONAL_TESTING.testTearDown()
-    >>> z2.STARTUP.testTearDown()
-
-    >>> 'app' in z2.FUNCTIONAL_TESTING
-    False
-
-    >>> 'request' in z2.FUNCTIONAL_TESTING
-    False
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-Let's tear down the layer:
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.FunctionalTesting in ... seconds.
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-The test browser
-~~~~~~~~~~~~~~~~
-
-The ``FUNCTIONAL_TESTING`` layer and ``FunctionalTesting`` layer class are
-the basis for functional testing using ``zope.testbrowser``. This simulates a
-web browser, allowing an application to be tested "end-to-end" via its
-user-facing interface.
-
-To use the test browser with a ``FunctionalTesting`` layer (such as the
-default ``FUNCTIONAL_TESTING`` layer instance), we need to use a custom
-browser client, which ensures that the test browser uses the correct ZODB and
-is appropriately isolated from the test code.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-    Set up plone.testing.z2.FunctionalTesting in ... seconds.
-
-Let's simulate a test:
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.FUNCTIONAL_TESTING.testSetUp()
-
-In the test, we can create a test browser client like so::
-
-    >>> app = z2.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']
-    >>> browser = z2.Browser(app)
-
-It is usually best to let Zope errors be shown with full tracebacks:
-
-    >>> browser.handleErrors = False
-
-We can add to the test fixture in the test. For those changes to be visible to
-the test browser, however, we need to commit the transaction.
-
-    >>> app.manage_addFolder('folder1')
-    >>> import transaction; transaction.commit()
-
-We can now view this via the test browser:
-
-    >>> browser.open(app.absolute_url() + '/folder1')
-
-    >>> 'folder1' in browser.contents
-    True
-
-The test browser integration converts the URL into a request and
-passes control to Zope's publisher. Let's check that query strings are
-available for input processing:
-
-    >>> import urllib
-    >>> qs = urllib.urlencode({'foo': 'boo, bar & baz'})  # sic: the ampersand.
-    >>> _ = app['folder1'].addDTMLMethod('index_html', file='<dtml-var foo>')
-    >>> import transaction; transaction.commit()
-    >>> browser.open(app.absolute_url() + '/folder1?' + qs)
-    >>> browser.contents
-    'boo, bar & baz'
-
-The test browser also works with iterators. Let's test that with a simple
-file implementation that uses an iterator.
-
-    >>> from plone.testing.tests import DummyFile
-    >>> app._setObject('file1', DummyFile('file1'))
-    'file1'
-
-    >>> import transaction; transaction.commit()
-
-    >>> browser.open(app.absolute_url() + '/file1')
-    >>> 'The test browser also works with iterators' in browser.contents
-    True
-
-See the ``zope.testbrowser`` documentation for more information about how to
-use the browser client.
-
-On tear-down, the database is torn down.
-
-    >>> z2.FUNCTIONAL_TESTING.testTearDown()
-    >>> z2.STARTUP.testTearDown()
-
-    >>> 'app' in z2.FUNCTIONAL_TESTING
-    False
-
-    >>> 'request' in z2.FUNCTIONAL_TESTING
-    False
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-Let's tear down the layer:
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.FunctionalTesting in ... seconds.
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-HTTP server
-~~~~~~~~~~~
-
-The ``ZSERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded
-Zope server in a separate thread. This makes it possible to connect to the
-test instance using a web browser or a testing tool like Selenium or Windmill.
-
-The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has
-``ZSERVER_FIXTURE`` as its base.
-
-    >>> "%s.%s" % (z2.ZSERVER_FIXTURE.__module__, z2.ZSERVER_FIXTURE.__name__,)
-    'plone.testing.z2.ZServer'
-
-    >>> z2.ZSERVER_FIXTURE.__bases__
-    (<Layer 'plone.testing.z2.Startup'>,)
-
-
-    >>> "%s.%s" % (z2.ZSERVER.__module__, z2.ZSERVER.__name__,)
-    'plone.testing.z2.ZServer:Functional'
-
-    >>> z2.ZSERVER.__bases__
-    (<Layer 'plone.testing.z2.ZServer'>,)
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.ZSERVER, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-    Set up plone.testing.z2.ZServer in ... seconds.
-    Set up plone.testing.z2.ZServer:Functional in ... seconds.
-
-After layer setup, the resources ``host`` and ``port`` are available, and
-indicate where Zope is running.
-
-    >>> host = z2.ZSERVER['host']
-    >>> host
-    'localhost'
-
-    >>> port = z2.ZSERVER['port']
-    >>> import os
-    >>> port == int(os.environ.get('ZSERVER_PORT', 55001))
-    True
-
-Let's now simulate a test. Test setup does nothing beyond what the base layers
-do.
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.FUNCTIONAL_TESTING.testSetUp()
-    >>> z2.ZSERVER.testSetUp()
-
-It is common in a test to use the Python API to change the state of the server
-(e.g. create some content or change a setting) and then use the HTTP protocol
-to look at the results. Bear in mind that the server is running in a separate
-thread, with a separate security manager, so calls to ``z2.login()`` and
-``z2.logout()``, for instance, do not affect the server thread.
-
-    >>> app = z2.ZSERVER['app'] # would normally be self.layer['app']
-    >>> app.manage_addFolder('folder1')
-
-Note that we need to commit the transaction before it will show up in the
-other thread.
-
-    >>> import transaction; transaction.commit()
-
-We can now look for this new object through the server.
-
-    >>> app_url = app.absolute_url()
-    >>> app_url.split(':')[:-1]
-    ['http', '//localhost']
-
-    >>> import urllib2
-    >>> conn = urllib2.urlopen(app_url + '/folder1', timeout=5)
-    >>> print conn.read()
-    <Folder at folder1>
-    >>> conn.close()
-
-Test tear-down does nothing beyond what the base layers do.
-
-    >>> z2.ZSERVER.testTearDown()
-    >>> z2.FUNCTIONAL_TESTING.testTearDown()
-    >>> z2.STARTUP.testTearDown()
-
-    >>> 'app' in z2.ZSERVER
-    False
-
-    >>> 'request' in z2.ZSERVER
-    False
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-When the server is torn down, the ZServer thread is stopped.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.ZServer:Functional in ... seconds.
-    Tear down plone.testing.z2.ZServer in ... seconds.
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-    >>> conn = urllib2.urlopen(app_url + '/folder1', timeout=5)
-    Traceback (most recent call last):
-    ...
-    URLError: <urlopen error [Errno ...] Connection refused>
-
-FTP server
-~~~~~~~~~~
-
-The ``FTP_SERVER`` layer is identical similar to ``ZSERVER``, except that it
-starts an FTP server instead of an HTTP server. The fixture is contained in
-the ``FTP_SERVER_FIXTURE`` layer.
-
-    **Warning:** It is generally not safe to run the ``ZSERVER`` and
-    ``FTP_SERVER`` layers concurrently, because they both start up the same
-    ``asyncore`` loop. If you need concurrent HTTP and FTP servers in a test,
-    you can create your own layer by subclassing the ``ZServer`` layer class,
-    and overriding the ``setUpServer()`` and ``tearDownServer()`` hooks to set
-    up and close both servers. See the code for an example.
-
-The ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.
-
-    >>> "%s.%s" % (z2.FTP_SERVER_FIXTURE.__module__, z2.FTP_SERVER_FIXTURE.__name__,)
-    'plone.testing.z2.FTPServer'
-
-    >>> z2.FTP_SERVER_FIXTURE.__bases__
-    (<Layer 'plone.testing.z2.Startup'>,)
-
-The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the
-``FunctionalTesting`` layer class.
-
-    >>> "%s.%s" % (z2.FTP_SERVER.__module__, z2.FTP_SERVER.__name__,)
-    'plone.testing.z2.FTPServer:Functional'
-
-    >>> z2.FTP_SERVER.__bases__
-    (<Layer 'plone.testing.z2.FTPServer'>,)
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, z2.FTP_SERVER, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.z2.Startup in ... seconds.
-    Set up plone.testing.z2.FTPServer in ... seconds.
-    Set up plone.testing.z2.FTPServer:Functional in ... seconds.
-
-After layer setup, the resources ``host`` and ``port`` are available, and
-indicate where Zope is running.
-
-    >>> host = z2.FTP_SERVER['host']
-    >>> host
-    'localhost'
-
-    >>> port = z2.FTP_SERVER['port']
-    >>> import os
-    >>> port == int(os.environ.get('FTPSERVER_PORT', 55002))
-    True
-
-Let's now simulate a test. Test setup does nothing beyond what the base layers
-do.
-
-    >>> z2.STARTUP.testSetUp()
-    >>> z2.FUNCTIONAL_TESTING.testSetUp()
-    >>> z2.FTP_SERVER.testSetUp()
-
-As with ``ZSERVER``, we will set up some content for the test and then access
-it over the FTP port.
-
-    >>> app = z2.FTP_SERVER['app'] # would normally be self.layer['app']
-    >>> app.manage_addFolder('folder1')
-
-We'll also create a user in the root user folder to make FTP access easier.
-
-    >>> ignore = app['acl_users'].userFolderAddUser('admin', 'secret', ['Manager'], ())
-
-Note that we need to commit the transaction before it will show up in the
-other thread.
-
-    >>> import transaction; transaction.commit()
-
-We can now look for this new object through the server.
-
-    >>> app_path = app.absolute_url_path()
-
-    >>> import ftplib
-    >>> ftpClient = ftplib.FTP()
-    >>> ftpClient.connect(host, port, timeout=5)
-    '220 ... FTP server (...) ready.'
-
-    >>> ftpClient.login('admin', 'secret')
-    '230 Login successful.'
-
-    >>> ftpClient.cwd(app_path)
-    '250 CWD command successful.'
-
-    >>> ftpClient.retrlines('LIST')
-    drwxrwx---   1 Zope     Zope            0 ... .
-    drwxrwx---   1 Zope     Zope            0 ... Control_Panel
-    --w--w----   1 Zope     Zope            0 ... acl_users
-    drwxrwx---   1 Zope     Zope            0 ... folder1
-    '226 Transfer complete'
-
-    >>> ftpClient.quit()
-    '221 Goodbye.'
-
-Test tear-down does nothing beyond what the base layers do.
-
-    >>> z2.FTP_SERVER.testTearDown()
-    >>> z2.FUNCTIONAL_TESTING.testTearDown()
-    >>> z2.STARTUP.testTearDown()
-
-    >>> 'app' in z2.ZSERVER
-    False
-
-    >>> 'request' in z2.ZSERVER
-    False
-
-    >>> with z2.zopeApp() as app:
-    ...     print app.objectIds()
-    ['acl_users', 'Control_Panel']
-
-When the server is torn down, the FTP thread is stopped.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.z2.FTPServer:Functional in ... seconds.
-    Tear down plone.testing.z2.FTPServer in ... seconds.
-    Tear down plone.testing.z2.Startup in ... seconds.
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-    >>> ftpClient.connect(host, port, timeout=5)
-    Traceback (most recent call last):
-    ...
-    error: [Errno ...] Connection refused
diff --git a/src/plone/testing/zca.py b/src/plone/testing/zca.py
index 9ef7731..fb4f598 100644
--- a/src/plone/testing/zca.py
+++ b/src/plone/testing/zca.py
@@ -1,11 +1,12 @@
+# -*- coding: utf-8 -*-
 """Core Zope Component Architecture helpers and layers
 """
+from plone.testing import Layer
+from zope.configuration.config import ConfigurationMachine
 import logging
 
-logger = logging.getLogger('plone.testing.zca')
 
-from zope.configuration.config import ConfigurationMachine
-from plone.testing import Layer
+logger = logging.getLogger('plone.testing.zca')
 
 # Contains a stack of installed global registries (but not the default one)
 _REGISTRIES = []
@@ -48,8 +49,8 @@ def _hookRegistry(reg):
     else:
         localsitemanager.base = reg
 
-# Helper functions
 
+# Helper functions
 
 def pushGlobalRegistry(new=None):
     """Set a new global component registry that uses the current registry as
@@ -83,11 +84,13 @@ def pushGlobalRegistry(new=None):
     if new is None:
         name = 'test-stack-%d' % len(_REGISTRIES)
         new = globalregistry.BaseGlobalComponents(name=name, bases=(current,))
-        logger.debug("New component registry: %s based on %s", name, current.__name__)
+        logger.debug(
+            "New component registry: %s based on %s",
+            name,
+            current.__name__)
     else:
         logger.debug("Push component registry: %s", new.__name__)
 
-
     _REGISTRIES.append(new)
 
     # Monkey patch this into the three (!) places where zope.component
@@ -119,7 +122,7 @@ def popGlobalRegistry():
 
     if not _REGISTRIES or not _REGISTRIES[-1] is globalregistry.base:
         msg = ("popGlobalRegistry() called out of sync with "
-            "pushGlobalRegistry()")
+               "pushGlobalRegistry()")
         raise ValueError(msg)
 
     current = _REGISTRIES.pop()
@@ -159,7 +162,7 @@ def __init__(self, name):
 
     def __str__(self):
         return ('<zope.configuration.config.ConfigurationMachine object %s>'
-            % self.__name__)
+                % self.__name__)
 
     def __repr__(self):
         return self.__str__()
@@ -217,13 +220,13 @@ def stackConfigurationContext(context=None, name="not named"):
                     if Interface in info:
                         factory = info[Interface][u'']
                         newRegistry.register([interface], Interface, '',
-                            factory)
+                                             factory)
 
     logger.debug('Configuration context %s cloned from %s', clone, context)
     return clone
 
-# Layers
 
+# Layers
 
 class UnitTesting(Layer):
     """Zope Component Architecture unit testing sandbox: The ZCA is cleared
@@ -308,7 +311,7 @@ class ZCMLSandbox(Layer):
     defaultBases = (LAYER_CLEANUP,)
 
     def __init__(self, bases=None, name=None, module=None, filename=None,
-        package=None):
+                 package=None):
         super(ZCMLSandbox, self).__init__(bases, name, module)
         self.filename = filename
         self.package = package
@@ -327,7 +330,7 @@ def setUpZCMLFiles(self):
             raise ValueError("ZCML file name has not been provided.")
         if self.package is None:
             raise ValueError("The package that contains the ZCML file "
-                "has not been provided.")
+                             "has not been provided.")
         self.loadZCMLFile(self.filename, self.package)
 
     def loadZCMLFile(self, filename, package):
diff --git a/src/plone/testing/zca.rst b/src/plone/testing/zca.rst
new file mode 100644
index 0000000..5a5e7bb
--- /dev/null
+++ b/src/plone/testing/zca.rst
@@ -0,0 +1,471 @@
+Zope Component Architecture layers
+----------------------------------
+
+The ZCA layers are found in the module ``plone.testing.zca``:::
+
+    >>> from plone.testing import zca
+
+For testing, we need a testrunner:::
+
+    >>> from zope.testrunner import runner
+
+Unit testing
+~~~~~~~~~~~~
+
+The ``UNIT_TESTING`` layer is used to set up a clean component registry between each test.
+It uses ``zope.testing.cleanup`` to clean up all global state.
+
+It has no bases:::
+
+    >>> "%s.%s" % (zca.UNIT_TESTING.__module__, zca.UNIT_TESTING.__name__,)
+    'plone.testing.zca.UnitTesting'
+
+    >>> zca.UNIT_TESTING.__bases__
+    ()
+
+The component registry is cleaned up between each test.::
+
+    >>> from zope.interface import Interface
+    >>> from zope.component import provideUtility
+
+    >>> class DummyUtility(object):
+    ...     def __init__(self, name):
+    ...         self.name = name
+    ...     def __repr__(self):
+    ...         return "<%s>" % self.name
+
+    >>> provideUtility(DummyUtility("Dummy"), provides=Interface, name="test-dummy")
+
+    >>> from zope.component import queryUtility
+    >>> queryUtility(Interface, name="test-dummy")
+    <Dummy>
+
+Layer setup does nothing.::
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, zca.UNIT_TESTING, setupLayers)
+    Set up plone.testing.zca.UnitTesting in ... seconds.
+
+Let's now simulate a test.
+Before any test setup has happened, our previously registered utility is still there.::
+
+    >>> queryUtility(Interface, name="test-dummy")
+    <Dummy>
+
+On test setup, it disappears.::
+
+    >>> zca.UNIT_TESTING.testSetUp()
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+
+The test would now execute. It may register some components.::
+
+    >>> provideUtility(DummyUtility("Dummy2"), provides=Interface, name="test-dummy")
+    >>> queryUtility(Interface, name="test-dummy")
+    <Dummy2>
+
+On test tear-down, this disappears.::
+
+    >>> zca.UNIT_TESTING.testTearDown()
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+
+Layer tear-down does nothing.::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.zca.UnitTesting in ... seconds.
+
+Event testing
+~~~~~~~~~~~~~
+
+The ``EVENT_TESTING`` layer extends the ``UNIT_TESTING`` layer to add the necessary registrations for ``zope.component.eventtesting`` to work.::
+
+    >>> "%s.%s" % (zca.EVENT_TESTING.__module__, zca.EVENT_TESTING.__name__,)
+    'plone.testing.zca.EventTesting'
+
+    >>> zca.EVENT_TESTING.__bases__
+    (<Layer 'plone.testing.zca.UnitTesting'>,)
+
+Before the test, the component registry is empty and ``getEvents()`` returns nothing, even if an event is fired.::
+
+    >>> from zope.component.eventtesting import getEvents
+
+    >>> class DummyEvent(object):
+    ...     def __repr__(self):
+    ...         return "<Dummy event>"
+
+    >>> from zope.event import notify
+    >>> notify(DummyEvent())
+
+    >>> getEvents()
+    []
+
+Layer setup does nothing.::
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, zca.EVENT_TESTING, setupLayers)
+    Set up plone.testing.zca.UnitTesting in ... seconds.
+    Set up plone.testing.zca.EventTesting in ... seconds.
+
+Let's now simulate a test. On test setup, the event testing list is emptied.::
+
+    >>> zca.UNIT_TESTING.testSetUp()
+    >>> zca.EVENT_TESTING.testSetUp()
+
+    >>> getEvents()
+    []
+
+The test would now execute.
+It may fire some events, which would show up in the event testing list.::
+
+    >>> notify(DummyEvent())
+    >>> getEvents()
+    [<Dummy event>]
+
+On test tear-down, the list is emptied again:::
+
+    >>> zca.EVENT_TESTING.testTearDown()
+    >>> zca.UNIT_TESTING.testTearDown()
+
+    >>> getEvents()
+    []
+
+Layer tear-down does nothing.::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.zca.EventTesting in ... seconds.
+    Tear down plone.testing.zca.UnitTesting in ... seconds.
+
+Layer cleanup
+~~~~~~~~~~~~~
+
+The ``LAYER_CLEANUP`` layer is used to set up a clean component registry at the set-up and tear-down of a layer.
+It uses ``zope.testing.cleanup`` to clean up all global state.
+
+It has no bases:::
+
+    >>> "%s.%s" % (zca.LAYER_CLEANUP.__module__, zca.LAYER_CLEANUP.__name__,)
+    'plone.testing.zca.LayerCleanup'
+
+    >>> zca.LAYER_CLEANUP.__bases__
+    ()
+
+The component registry is cleaned up on layer set-up and tear-down (but not between tests).::
+
+    >>> from zope.interface import Interface
+    >>> from zope.component import provideUtility
+
+    >>> class DummyUtility(object):
+    ...     def __init__(self, name):
+    ...         self.name = name
+    ...     def __repr__(self):
+    ...         return "<%s>" % self.name
+
+    >>> provideUtility(DummyUtility("Dummy"), provides=Interface, name="test-dummy")
+
+    >>> from zope.component import queryUtility
+    >>> queryUtility(Interface, name="test-dummy")
+    <Dummy>
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, zca.LAYER_CLEANUP, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+
+A sub-layer may register additional components:::
+
+    >>> provideUtility(DummyUtility("Dummy2"), provides=Interface, name="test-dummy2")
+
+Let's now simulate a test. Test setup and tear-down does nothing.::
+
+    >>> zca.LAYER_CLEANUP.testSetUp()
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+    >>> queryUtility(Interface, name="test-dummy2")
+    <Dummy2>
+
+    >>> zca.LAYER_CLEANUP.testTearDown()
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+    >>> queryUtility(Interface, name="test-dummy2")
+    <Dummy2>
+
+On tear-down, the registry is cleaned again.::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.zca.LayerCleanup in ... seconds.
+
+    >>> queryUtility(Interface, name="test-dummy") is None
+    True
+    >>> queryUtility(Interface, name="test-dummy2") is None
+    True
+
+Basic ZCML directives
+~~~~~~~~~~~~~~~~~~~~~
+
+The ``ZCML_DIRECTIVES`` layer creates a ZCML configuration context with the basic ``zope.component`` directives available.
+It extends the ``LAYER_CLEANUP`` layer.::
+
+    >>> "%s.%s" % (zca.ZCML_DIRECTIVES.__module__, zca.ZCML_DIRECTIVES.__name__,)
+    'plone.testing.zca.ZCMLDirectives'
+
+    >>> zca.ZCML_DIRECTIVES.__bases__
+    (<Layer 'plone.testing.zca.LayerCleanup'>,)
+
+Before the test, we cannot use e.g. a ``<utility />`` directive without loading the necessary ``meta.zcml`` files.::
+
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.string("""\
+    ... <configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
+    ...     <utility factory=".tests.DummyUtility" provides="zope.interface.Interface" name="test-dummy" />
+    ... </configure>""")
+    Traceback (most recent call last):
+    ...
+    ZopeXMLConfigurationError: File "<string>", line 2.4
+        ConfigurationError: ('Unknown directive', u'http://namespaces.zope.org/zope', u'utility')
+
+Layer setup creates a configuration context we can use to load further configuration.::
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, zca.ZCML_DIRECTIVES, setupLayers)
+    Set up plone.testing.zca.LayerCleanup in ... seconds.
+    Set up plone.testing.zca.ZCMLDirectives in ... seconds.
+
+Let's now simulate a test that uses this configuration context to load the same ZCML string.::
+
+    >>> zca.ZCML_DIRECTIVES.testSetUp()
+
+    >>> context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']
+    >>> xmlconfig.string("""\
+    ... <configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
+    ...     <utility factory=".tests.DummyUtility" provides="zope.interface.Interface" name="test-dummy" />
+    ... </configure>""", context=context) is context
+    True
+
+The utility is now registered:::
+
+    >>> queryUtility(Interface, name="test-dummy")
+    <Dummy utility>
+
+    >>> zca.UNIT_TESTING.testTearDown()
+
+Note that normally, we'd combine this with the ``UNIT_TESTING`` layer to tear down the component architecture as well.
+
+Layer tear-down deletes the configuration context.::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.zca.ZCMLDirectives in ... seconds.
+
+    >>> zca.ZCML_DIRECTIVES.get('configurationContext', None) is None
+    True
+
+Configuration registry sandboxing
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+For simple unit tests, the full cleanup performed between each test using the ``UNIT_TESTING`` layer is undoubtedly the safest and most convenient way to ensure proper isolation of tests using the global component architecture.
+However, if you are writing a complex layer that sets up a lot of components, you may wish to keep some components registered at the layer level, whilst still allowing tests and sub-layers to register their own components in isolation.
+
+This is a tricky problem, because the default ZCML directives and APIs (``provideAdapter()``, ``provideUtility()`` and so on) explicitly work on a single global adapter registry object.
+To get around this, you can use two helper methods in the ``zca`` module to push a new global component registry before registering components, and pop the registry after.
+Registries are stacked, so the components registered in a "lower" registry are automatically available in a "higher" registry.
+
+Let's illustrate this with a layer that stacks two new global registries.
+The first registry is specific to the layer, and is used to house the components registered at the layer level.
+The second registry is set up and torn down for each test, allowing tests to register their own components freely.
+
+First, we'll create a simple dummy utility to illustrate registrations.::
+
+    >>> from zope.interface import Interface, implements
+
+    >>> class IDummyUtility(Interface):
+    ...     pass
+    >>> class DummyUtility(object):
+    ...     implements(IDummyUtility)
+    ...     def __init__(self, name):
+    ...         self.name = name
+    ...     def __repr__(self):
+    ...         return "<DummyUtility %s>" % self.name
+
+The two key methods are:
+
+* ``zca.pushGlobalRegistry()``, which creates a new global registry.
+* ``zca.popGlobalRegistry()``, which restores the previous global registry.
+
+  **Warning:** You *must* balance your calls to these methods.
+  If you call ``pushGlobalRegistry()`` in ``setUp()``, call ``popGlobalRegistry()`` in ``tearDown()``.
+  Ditto for ``testSetUp()`` and ``testTearDown()``.
+
+Let's now create our layer.::
+
+    >>> from zope.component import provideUtility
+    >>> from plone.testing import Layer
+    >>> from plone.testing import zca
+
+    >>> class ComponentSandbox(Layer):
+    ...     def setUp(self):
+    ...         zca.pushGlobalRegistry()
+    ...         provideUtility(DummyUtility("layer"), name="layer")
+    ...     def tearDown(self):
+    ...         zca.popGlobalRegistry()
+    ...     def testSetUp(self):
+    ...         zca.pushGlobalRegistry()
+    ...     def testTearDown(self):
+    ...         zca.popGlobalRegistry()
+    >>> COMPONENT_SANDBOX = ComponentSandbox()
+
+Let's now simulate a test using this layer.
+
+To begin with, we have the default registry.::
+
+    >>> from zope.component import getGlobalSiteManager, getSiteManager
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+
+    >>> defaultGlobalSiteManager = getGlobalSiteManager()
+
+    >>> from zope.component import queryUtility
+    >>> queryUtility(IDummyUtility, name="layer") is None
+    True
+
+We'll now simulate layer setup. This will push a new registry onto the stack:::
+
+    >>> COMPONENT_SANDBOX.setUp()
+
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+    >>> getGlobalSiteManager() is defaultGlobalSiteManager
+    False
+    >>> layerGlobalSiteManager = getGlobalSiteManager()
+
+    >>> queryUtility(IDummyUtility, name="layer")
+    <DummyUtility layer>
+
+We'll then simulate a test that registers a global component:::
+
+    >>> COMPONENT_SANDBOX.testSetUp()
+
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+    >>> getGlobalSiteManager() is defaultGlobalSiteManager
+    False
+    >>> getGlobalSiteManager() is layerGlobalSiteManager
+    False
+
+Our previously registered component is still here.::
+
+    >>> queryUtility(IDummyUtility, name="layer")
+    <DummyUtility layer>
+
+We can also register a new one.::
+
+    >>> provideUtility(DummyUtility("test"), name="test")
+    >>> queryUtility(IDummyUtility, name="layer")
+    <DummyUtility layer>
+    >>> queryUtility(IDummyUtility, name="test")
+    <DummyUtility test>
+
+On test tear-down, only the second utility disappears:::
+
+    >>> COMPONENT_SANDBOX.testTearDown()
+
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+    >>> getGlobalSiteManager() is defaultGlobalSiteManager
+    False
+    >>> getGlobalSiteManager() is layerGlobalSiteManager
+    True
+
+    >>> queryUtility(IDummyUtility, name="layer")
+    <DummyUtility layer>
+    >>> queryUtility(IDummyUtility, name="test") is None
+    True
+
+If we tear down the layer too, we're back where we started:::
+
+    >>> COMPONENT_SANDBOX.tearDown()
+
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+    >>> getGlobalSiteManager() is defaultGlobalSiteManager
+    True
+
+    >>> queryUtility(IDummyUtility, name="layer") is None
+    True
+    >>> queryUtility(IDummyUtility, name="test") is None
+    True
+
+ZCML files helper class
+~~~~~~~~~~~~~~~~~~~~~~~
+
+One of the frequent use cases is a layer that loads a ZCML file and sandbox the resulting registry.
+
+The ``ZCMLSandbox`` can be instantiated with a `filename`` and ``package`` arguments.::
+
+    >>> import plone.testing
+    >>> ZCML_SANDBOX = zca.ZCMLSandbox(filename="testing_zca.zcml",
+    ...     package=plone.testing)
+
+Before layer setup, the utility is not registered.::
+
+    >>> queryUtility(Interface, name="layer") is None
+    True
+
+We'll now simulate layer setup.
+This pushes a new registry onto the stack:::
+
+    >>> ZCML_SANDBOX.setUp()
+
+    >>> getSiteManager() is getGlobalSiteManager()
+    True
+    >>> getGlobalSiteManager() is defaultGlobalSiteManager
+    False
+    >>> queryUtility(Interface, name="layer")
+    <Dummy utility>
+
+The ``ZCMLSandbox`` class can also be used as ancestor for your own classes when you need to load more than a single ZCML file.
+
+Your class then needs to override the ``setUpZCMLFiles()`` method.
+It is in charge of calling ``loadZCMLFile()``, once for each ZCML file that the class needs to load.::
+
+    >>> class OtherZCML(zca.ZCMLSandbox):
+    ...     def setUpZCMLFiles(self):
+    ...         self.loadZCMLFile("testing_zca.zcml", package=plone.testing)
+    ...         self.loadZCMLFile("testing_zca_more_specific.zcml",
+    ...             package=plone.testing)
+    >>> OTHER_ZCML_SANDBOX = OtherZCML()
+
+Before layer setup, a second utility is not registered.::
+
+    >>> queryUtility(Interface, name="more_specific_layer") is None
+    True
+
+We'll now simulate the setup of the more specific layer.::
+
+    >>> OTHER_ZCML_SANDBOX.setUp()
+
+After setUp, the second utility is registered:::
+
+    >>> queryUtility(Interface, name="more_specific_layer")
+    <Dummy utility>
+
+After layer teardown, the second utility is not registered anymore.::
+
+    >>> OTHER_ZCML_SANDBOX.tearDown()
+    >>> queryUtility(Interface, name="more_specific_layer") is None
+    True
+
+After teardown of the first layer, the first utility is not registered anymore.::
+
+    >>> ZCML_SANDBOX.tearDown()
+    >>> queryUtility(Interface, name="layer") is None
+    True
diff --git a/src/plone/testing/zca.txt b/src/plone/testing/zca.txt
deleted file mode 100644
index 134fc10..0000000
--- a/src/plone/testing/zca.txt
+++ /dev/null
@@ -1,494 +0,0 @@
-Zope Component Architecture layers
-----------------------------------
-
-The ZCA layers are found in the module ``plone.testing.zca``:
-
-    >>> from plone.testing import zca
-
-For testing, we need a testrunner
-
-    >>> from zope.testrunner import runner
-
-Unit testing
-~~~~~~~~~~~~
-
-The ``UNIT_TESTING`` layer is used to set up a clean component registry
-between each test. It uses ``zope.testing.cleanup`` to clean up all global
-state.
-
-It has no bases:
-
-    >>> "%s.%s" % (zca.UNIT_TESTING.__module__, zca.UNIT_TESTING.__name__,)
-    'plone.testing.zca.UnitTesting'
-
-    >>> zca.UNIT_TESTING.__bases__
-    ()
-
-The component registry is cleaned up between each test.
-
-    >>> from zope.interface import Interface
-    >>> from zope.component import provideUtility
-
-    >>> class DummyUtility(object):
-    ...     def __init__(self, name):
-    ...         self.name = name
-    ...     def __repr__(self):
-    ...         return "<%s>" % self.name
-
-    >>> provideUtility(DummyUtility("Dummy"), provides=Interface, name="test-dummy")
-
-    >>> from zope.component import queryUtility
-    >>> queryUtility(Interface, name="test-dummy")
-    <Dummy>
-
-Layer setup does nothing.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, zca.UNIT_TESTING, setupLayers)
-    Set up plone.testing.zca.UnitTesting in ... seconds.
-
-Let's now simulate a test. Before any test setup has happened, our previously
-registered utility is still there.
-
-    >>> queryUtility(Interface, name="test-dummy")
-    <Dummy>
-
-On test setup, it disappears.
-
-    >>> zca.UNIT_TESTING.testSetUp()
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-
-The test would now execute. It may register some components.
-
-    >>> provideUtility(DummyUtility("Dummy2"), provides=Interface, name="test-dummy")
-    >>> queryUtility(Interface, name="test-dummy")
-    <Dummy2>
-
-On test tear-down, this disappears.
-
-    >>> zca.UNIT_TESTING.testTearDown()
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-
-Layer tear-down does nothing.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.zca.UnitTesting in ... seconds.
-
-Event testing
-~~~~~~~~~~~~~
-
-The ``EVENT_TESTING`` layer extends the ``UNIT_TESTING`` layer to add the
-necessary registrations for ``zope.component.eventtesting`` to work.
-
-    >>> "%s.%s" % (zca.EVENT_TESTING.__module__, zca.EVENT_TESTING.__name__,)
-    'plone.testing.zca.EventTesting'
-
-    >>> zca.EVENT_TESTING.__bases__
-    (<Layer 'plone.testing.zca.UnitTesting'>,)
-
-Before the test, the component registry is empty and ``getEvents()`` returns
-nothing, even if an event is fired.
-
-    >>> from zope.component.eventtesting import getEvents
-
-    >>> class DummyEvent(object):
-    ...     def __repr__(self):
-    ...         return "<Dummy event>"
-
-    >>> from zope.event import notify
-    >>> notify(DummyEvent())
-
-    >>> getEvents()
-    []
-
-Layer setup does nothing.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, zca.EVENT_TESTING, setupLayers)
-    Set up plone.testing.zca.UnitTesting in ... seconds.
-    Set up plone.testing.zca.EventTesting in ... seconds.
-
-Let's now simulate a test. On test setup, the event testing list is emptied.
-
-    >>> zca.UNIT_TESTING.testSetUp()
-    >>> zca.EVENT_TESTING.testSetUp()
-
-    >>> getEvents()
-    []
-
-The test would now execute. It may fire some events, which would show up in
-the event testing list.
-
-    >>> notify(DummyEvent())
-    >>> getEvents()
-    [<Dummy event>]
-
-On test tear-down, the list is emptied again
-
-    >>> zca.EVENT_TESTING.testTearDown()
-    >>> zca.UNIT_TESTING.testTearDown()
-
-    >>> getEvents()
-    []
-
-Layer tear-down does nothing.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.zca.EventTesting in ... seconds.
-    Tear down plone.testing.zca.UnitTesting in ... seconds.
-
-Layer cleanup
-~~~~~~~~~~~~~
-
-The ``LAYER_CLEANUP`` layer is used to set up a clean component registry
-at the set-up and tear-down of a layer. It uses ``zope.testing.cleanup`` to
-clean up all global state.
-
-It has no bases:
-
-    >>> "%s.%s" % (zca.LAYER_CLEANUP.__module__, zca.LAYER_CLEANUP.__name__,)
-    'plone.testing.zca.LayerCleanup'
-
-    >>> zca.LAYER_CLEANUP.__bases__
-    ()
-
-The component registry is cleaned up on layer set-up and tear-down (but not
-between tests).
-
-    >>> from zope.interface import Interface
-    >>> from zope.component import provideUtility
-
-    >>> class DummyUtility(object):
-    ...     def __init__(self, name):
-    ...         self.name = name
-    ...     def __repr__(self):
-    ...         return "<%s>" % self.name
-
-    >>> provideUtility(DummyUtility("Dummy"), provides=Interface, name="test-dummy")
-
-    >>> from zope.component import queryUtility
-    >>> queryUtility(Interface, name="test-dummy")
-    <Dummy>
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, zca.LAYER_CLEANUP, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-
-A sub-layer may register additional components:
-
-    >>> provideUtility(DummyUtility("Dummy2"), provides=Interface, name="test-dummy2")
-
-Let's now simulate a test. Test setup and tear-down does nothing.
-
-    >>> zca.LAYER_CLEANUP.testSetUp()
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-    >>> queryUtility(Interface, name="test-dummy2")
-    <Dummy2>
-
-    >>> zca.LAYER_CLEANUP.testTearDown()
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-    >>> queryUtility(Interface, name="test-dummy2")
-    <Dummy2>
-
-On tear-down, the registry is cleaned again.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.zca.LayerCleanup in ... seconds.
-
-    >>> queryUtility(Interface, name="test-dummy") is None
-    True
-    >>> queryUtility(Interface, name="test-dummy2") is None
-    True
-
-Basic ZCML directives
-~~~~~~~~~~~~~~~~~~~~~
-
-The ``ZCML_DIRECTIVES`` layer creates a ZCML configuration context with the
-basic ``zope.component`` directives available. It extends the
-``LAYER_CLEANUP`` layer.
-
-    >>> "%s.%s" % (zca.ZCML_DIRECTIVES.__module__, zca.ZCML_DIRECTIVES.__name__,)
-    'plone.testing.zca.ZCMLDirectives'
-
-    >>> zca.ZCML_DIRECTIVES.__bases__
-    (<Layer 'plone.testing.zca.LayerCleanup'>,)
-
-Before the test, we cannot use e.g. a ``<utility />`` directive without
-loading the necessary ``meta.zcml`` files.
-
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.string("""\
-    ... <configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
-    ...     <utility factory=".tests.DummyUtility" provides="zope.interface.Interface" name="test-dummy" />
-    ... </configure>""")
-    Traceback (most recent call last):
-    ...
-    ZopeXMLConfigurationError: File "<string>", line 2.4
-        ConfigurationError: ('Unknown directive', u'http://namespaces.zope.org/zope', u'utility')
-
-Layer setup creates a configuration context we can use to load further
-configuration.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, zca.ZCML_DIRECTIVES, setupLayers)
-    Set up plone.testing.zca.LayerCleanup in ... seconds.
-    Set up plone.testing.zca.ZCMLDirectives in ... seconds.
-
-Let's now simulate a test that uses this configuration context to load the
-same ZCML string.
-
-    >>> zca.ZCML_DIRECTIVES.testSetUp()
-
-    >>> context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']
-    >>> xmlconfig.string("""\
-    ... <configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">
-    ...     <utility factory=".tests.DummyUtility" provides="zope.interface.Interface" name="test-dummy" />
-    ... </configure>""", context=context) is context
-    True
-
-The utility is now registered:
-
-    >>> queryUtility(Interface, name="test-dummy")
-    <Dummy utility>
-
-    >>> zca.UNIT_TESTING.testTearDown()
-
-Note that normally, we'd combine this with the ``UNIT_TESTING`` layer to tear
-down the component architecture as well.
-
-Layer tear-down deletes the configuration context.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.zca.ZCMLDirectives in ... seconds.
-
-    >>> zca.ZCML_DIRECTIVES.get('configurationContext', None) is None
-    True
-
-Configuration registry sandboxing
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-For simple unit tests, the full cleanup performed between each test using the
-``UNIT_TESTING`` layer is undoubtedly the safest and most convenient way to
-ensure proper isolation of tests using the global component architecture.
-However, if you are writing a complex layer that sets up a lot of components,
-you may wish to keep some components registered at the layer level, whilst
-still allowing tests and sub-layers to register their own components in
-isolation.
-
-This is a tricky problem, because the default ZCML directives and APIs
-(``provideAdapter()``, ``provideUtility()`` and so on) explicitly work on
-a single global adapter registry object. To get around this, you can use two
-helper methods in the ``zca`` module to push a new global component registry
-before registering components, and pop the registry after. Registries are
-stacked, so the components registered in a "lower" registry are automatically
-available in a "higher" registry.
-
-Let's illustrate this with a layer that stacks two new global registries. The
-first registry is specific to the layer, and is used to house the components
-registered at the layer level. The second registry is set up and torn down for
-each test, allowing tests to register their own components freely.
-
-First, we'll create a simple dummy utility to illustrate registrations.
-
-    >>> from zope.interface import Interface, implements
-
-    >>> class IDummyUtility(Interface):
-    ...     pass
-    >>> class DummyUtility(object):
-    ...     implements(IDummyUtility)
-    ...     def __init__(self, name):
-    ...         self.name = name
-    ...     def __repr__(self):
-    ...         return "<DummyUtility %s>" % self.name
-
-The two key methods are:
-
-* ``zca.pushGlobalRegistry()``, which creates a new global registry.
-* ``zca.popGlobalRegistry()``, which restores the previous global registry.
-
-  **Warning:** You *must* balance your calls to these methods. If you call
-  ``pushGlobalRegistry()`` in ``setUp()``, call ``popGlobalRegistry()`` in
-  ``tearDown()``. Ditto for ``testSetUp()`` and ``testTearDown()``.
-
-Let's now create our layer.
-
-    >>> from zope.component import provideUtility
-    >>> from plone.testing import Layer
-    >>> from plone.testing import zca
-
-    >>> class ComponentSandbox(Layer):
-    ...     def setUp(self):
-    ...         zca.pushGlobalRegistry()
-    ...         provideUtility(DummyUtility("layer"), name="layer")
-    ...     def tearDown(self):
-    ...         zca.popGlobalRegistry()
-    ...     def testSetUp(self):
-    ...         zca.pushGlobalRegistry()
-    ...     def testTearDown(self):
-    ...         zca.popGlobalRegistry()
-    >>> COMPONENT_SANDBOX = ComponentSandbox()
-
-Let's now simulate a test using this layer.
-
-To begin with, we have the default registry.
-
-    >>> from zope.component import getGlobalSiteManager, getSiteManager
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-
-    >>> defaultGlobalSiteManager = getGlobalSiteManager()
-
-    >>> from zope.component import queryUtility
-    >>> queryUtility(IDummyUtility, name="layer") is None
-    True
-
-We'll now simulate layer setup. This will push a new registry onto the stack:
-
-    >>> COMPONENT_SANDBOX.setUp()
-
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-    >>> getGlobalSiteManager() is defaultGlobalSiteManager
-    False
-    >>> layerGlobalSiteManager = getGlobalSiteManager()
-
-    >>> queryUtility(IDummyUtility, name="layer")
-    <DummyUtility layer>
-
-We'll then simulate a test that registers a global component:
-
-    >>> COMPONENT_SANDBOX.testSetUp()
-
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-    >>> getGlobalSiteManager() is defaultGlobalSiteManager
-    False
-    >>> getGlobalSiteManager() is layerGlobalSiteManager
-    False
-
-Our previously registered component is still here.
-
-    >>> queryUtility(IDummyUtility, name="layer")
-    <DummyUtility layer>
-
-We can also register a new one.
-
-    >>> provideUtility(DummyUtility("test"), name="test")
-    >>> queryUtility(IDummyUtility, name="layer")
-    <DummyUtility layer>
-    >>> queryUtility(IDummyUtility, name="test")
-    <DummyUtility test>
-
-On test tear-down, only the second utility disappears:
-
-    >>> COMPONENT_SANDBOX.testTearDown()
-
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-    >>> getGlobalSiteManager() is defaultGlobalSiteManager
-    False
-    >>> getGlobalSiteManager() is layerGlobalSiteManager
-    True
-
-    >>> queryUtility(IDummyUtility, name="layer")
-    <DummyUtility layer>
-    >>> queryUtility(IDummyUtility, name="test") is None
-    True
-
-If we tear down the layer too, we're back where we started:
-
-    >>> COMPONENT_SANDBOX.tearDown()
-
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-    >>> getGlobalSiteManager() is defaultGlobalSiteManager
-    True
-
-    >>> queryUtility(IDummyUtility, name="layer") is None
-    True
-    >>> queryUtility(IDummyUtility, name="test") is None
-    True
-
-ZCML files helper class
-~~~~~~~~~~~~~~~~~~~~~~~
-
-One of the frequent use cases is a layer that loads a ZCML file and sandbox the
-resulting registry.
-
-The ``ZCMLSandbox`` can be instantiated with a `filename`` and ``package``
-arguments.
-
-    >>> import plone.testing
-    >>> ZCML_SANDBOX = zca.ZCMLSandbox(filename="testing_zca.zcml",
-    ...     package=plone.testing)
-
-Before layer setup, the utility is not registered.
-
-    >>> queryUtility(Interface, name="layer") is None
-    True
-
-We'll now simulate layer setup. This pushes a new registry onto the stack:
-
-    >>> ZCML_SANDBOX.setUp()
-
-    >>> getSiteManager() is getGlobalSiteManager()
-    True
-    >>> getGlobalSiteManager() is defaultGlobalSiteManager
-    False
-    >>> queryUtility(Interface, name="layer")
-    <Dummy utility>
-
-The ``ZCMLSandbox`` class can also be used as ancestor
-for your own classes when you need to load more than a single ZCML file.
-
-Your class then needs to override the ``setUpZCMLFiles()`` method. It is in
-charge of calling ``loadZCMLFile()``, once for each ZCML file that the class
-needs to load.
-
-    >>> class OtherZCML(zca.ZCMLSandbox):
-    ...     def setUpZCMLFiles(self):
-    ...         self.loadZCMLFile("testing_zca.zcml", package=plone.testing)
-    ...         self.loadZCMLFile("testing_zca_more_specific.zcml",
-    ...             package=plone.testing)
-    >>> OTHER_ZCML_SANDBOX = OtherZCML()
-
-Before layer setup, a second utility is not registered.
-
-    >>> queryUtility(Interface, name="more_specific_layer") is None
-    True
-
-We'll now simulate the setup of the more specific layer.
-
-    >>> OTHER_ZCML_SANDBOX.setUp()
-
-After setUp, the second utility is registered :
-
-    >>> queryUtility(Interface, name="more_specific_layer")
-    <Dummy utility>
-
-After layer teardown, the second utility is not registered anymore.
-
-    >>> OTHER_ZCML_SANDBOX.tearDown()
-    >>> queryUtility(Interface, name="more_specific_layer") is None
-    True
-
-After teardown of the first layer, the first utility is not registered anymore.
-
-    >>> ZCML_SANDBOX.tearDown()
-    >>> queryUtility(Interface, name="layer") is None
-    True
diff --git a/src/plone/testing/zodb.py b/src/plone/testing/zodb.py
index fd98cf3..6c041ce 100644
--- a/src/plone/testing/zodb.py
+++ b/src/plone/testing/zodb.py
@@ -1,8 +1,9 @@
+# -*- coding: utf-8 -*-
 """ZODB-specific helpers and layers
 """
-
 from plone.testing import Layer
 
+
 def stackDemoStorage(db=None, name=None):
     """Create a new DemoStorage that has the given database as a base.
     ``db`` may be none, in which case a base demo storage will be created.
@@ -11,7 +12,7 @@ def stackDemoStorage(db=None, name=None):
     The usual pattern in a layer is::
 
         def setUp(self):
-            self['zodbDB'] = stackDemoStorage(self.get('zodbDB'), name='mylayer')
+            self['zodbDB'] = stackDemoStorage(self.get('zodbDB'), name='mylayer')  # noqa
 
         def tearDown(self):
             self['zodbDB'].close()
@@ -28,6 +29,7 @@ def tearDown(self):
 
     return DB(storage)
 
+
 class EmptyZODB(Layer):
     """Set up a new ZODB database using ``DemoStorage``. The database object
     is available as the resource ``zodbDB``.
@@ -55,7 +57,7 @@ def tearDown(self):
 
     def testSetUp(self):
         self['zodbConnection'] = connection = self['zodbDB'].open()
-        self['zodbRoot']       = connection.root()
+        self['zodbRoot'] = connection.root()
 
         import transaction
         transaction.begin()
diff --git a/src/plone/testing/zodb.rst b/src/plone/testing/zodb.rst
new file mode 100644
index 0000000..9cc436e
--- /dev/null
+++ b/src/plone/testing/zodb.rst
@@ -0,0 +1,278 @@
+Zope Object Database layers
+---------------------------
+
+The ZODB layers are found in the module ``plone.testing.zodb``:::
+
+    >>> from plone.testing import zodb
+
+For testing, we need a testrunner:::
+
+    >>> from zope.testrunner import runner
+
+Empty ZODB layer
+~~~~~~~~~~~~~~~~
+
+The ``EMPTY_ZODB`` layer is used to set up an empty ZODB using ``DemoStorage``.
+
+The storage and database are set up as layer fixtures.
+The database is exposed as the resource ``zodbDB``.
+
+A connection is opened for each test and exposed as ``zodbConnection``.
+The ZODB root is also exposed, as ``zodbRoot``.
+A new transaction is begun for each test.
+On test tear-down, the transaction is aborted, the connection is closed, and the two test-specific resources are deleted.
+
+The layer has no bases.::
+
+    >>> "%s.%s" % (zodb.EMPTY_ZODB.__module__, zodb.EMPTY_ZODB.__name__,)
+    'plone.testing.zodb.EmptyZODB'
+
+    >>> zodb.EMPTY_ZODB.__bases__
+    ()
+
+Layer setup creates the database, but not a connection.::
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, zodb.EMPTY_ZODB, setupLayers)
+    Set up plone.testing.zodb.EmptyZODB in ... seconds.
+
+    >>> db = zodb.EMPTY_ZODB['zodbDB']
+    >>> db.storage
+    EmptyZODB
+
+    >>> zodb.EMPTY_ZODB.get('zodbConnection', None) is None
+    True
+    >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None
+    True
+
+Let's now simulate a test.::
+
+    >>> zodb.EMPTY_ZODB.testSetUp()
+
+The test would then execute. It may use the ZODB root.::
+
+    >>> zodb.EMPTY_ZODB['zodbConnection']
+    <Connection at ...>
+
+    >>> zodb.EMPTY_ZODB['zodbRoot']
+    {}
+
+    >>> zodb.EMPTY_ZODB['zodbRoot']['foo'] = 'bar'
+
+On test tear-down, the transaction is aborted and the connection is closed.::
+
+    >>> zodb.EMPTY_ZODB.testTearDown()
+
+    >>> zodb.EMPTY_ZODB.get('zodbConnection', None) is None
+    True
+
+    >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None
+    True
+
+The transaction has been rolled back.::
+
+    >>> conn = zodb.EMPTY_ZODB['zodbDB'].open()
+    >>> conn.root()
+    {}
+    >>> conn.close()
+
+Layer tear-down closes and deletes the database.::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down plone.testing.zodb.EmptyZODB in ... seconds.
+
+    >>> zodb.EMPTY_ZODB.get('zodbDB', None) is None
+    True
+
+Extending the ZODB layer
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+When creating a test fixture, it is often desirable to add some initial data to the database.
+If you want to do that once on layer setup, you can create your own layer class based on ``EmptyZODB`` and override its ``createStorage()`` and/or ``createDatabase()`` methods to return a pre-populated database.::
+
+    >>> import transaction
+    >>> from ZODB.DemoStorage import DemoStorage
+    >>> from ZODB.DB import DB
+
+    >>> class PopulatedZODB(zodb.EmptyZODB):
+    ...
+    ...     def createStorage(self):
+    ...         return DemoStorage("My storage")
+    ...
+    ...     def createDatabase(self, storage):
+    ...         db = DB(storage)
+    ...         conn = db.open()
+    ...
+    ...         conn.root()['someData'] = 'a string'
+    ...
+    ...         transaction.commit()
+    ...         conn.close()
+    ...
+    ...         return db
+
+    >>> POPULATED_ZODB = PopulatedZODB()
+
+We'll use this new layer in a similar manner to the test above, showing that the data is there for each test, but that other changes are rolled back.::
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, POPULATED_ZODB, setupLayers)
+    Set up PopulatedZODB in ... seconds.
+
+    >>> db = POPULATED_ZODB['zodbDB']
+    >>> db.storage
+    My storage
+
+    >>> POPULATED_ZODB.get('zodbConnection', None) is None
+    True
+    >>> POPULATED_ZODB.get('zodbRoot', None) is None
+    True
+
+Let's now simulate a test.::
+
+    >>> POPULATED_ZODB.testSetUp()
+
+The test would then execute. It may use the ZODB root.::
+
+    >>> POPULATED_ZODB['zodbConnection']
+    <Connection at ...>
+
+    >>> POPULATED_ZODB['zodbRoot']
+    {'someData': 'a string'}
+
+    >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'
+
+On test tear-down, the transaction is aborted and the connection is closed.::
+
+    >>> POPULATED_ZODB.testTearDown()
+
+    >>> POPULATED_ZODB.get('zodbConnection', None) is None
+    True
+
+    >>> POPULATED_ZODB.get('zodbRoot', None) is None
+    True
+
+The transaction has been rolled back.::
+
+    >>> conn = POPULATED_ZODB['zodbDB'].open()
+    >>> conn.root()
+    {'someData': 'a string'}
+    >>> conn.close()
+
+Layer tear-down closes and deletes the database.::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down PopulatedZODB in ... seconds.
+
+    >>> POPULATED_ZODB.get('zodbDB', None) is None
+    True
+
+Stacking ``DemoStorage`` storages
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The example above shows how to create a simple test fixture with a custom database.
+It is sometimes useful to be able to stack these fixtures, so that a base layer sets up some data for one set of tests, and a child layer extends this, temporarily, with more data.
+
+This can be achieved using layer bases and resource shadowing, combined with ZODB's stackable DemoStorage.
+There is even a helper function available:::
+
+    >>> from plone.testing import Layer
+    >>> from plone.testing import zodb
+    >>> import transaction
+
+    >>> class ExpandedZODB(Layer):
+    ...     defaultBases = (POPULATED_ZODB,)
+    ...
+    ...     def setUp(self):
+    ...         # Get the database from the base layer
+    ...
+    ...         self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='ExpandedZODB')
+    ...
+    ...         conn = db.open()
+    ...         conn.root()['additionalData'] = "Some new data"
+    ...         transaction.commit()
+    ...         conn.close()
+    ...
+    ...     def tearDown(self):
+    ...         # Close the database and delete the shadowed copy
+    ...
+    ...         self['zodbDB'].close()
+    ...         del self['zodbDB']
+
+    >>> EXPANDED_ZODB = ExpandedZODB()
+
+Notice that we are using plain ``Layer`` as a base class here.
+We obtain the underlying database from our bases using the resource manager, and then create a shadow copy using a stacked storage.
+Stacked storages contain the data of the original storage, but save changes in a separate (and, in this case, temporary) storage.
+
+Let's simulate a test run again to show how this would work.::
+
+    >>> options = runner.get_options([], [])
+    >>> setupLayers = {}
+    >>> runner.setup_layer(options, EXPANDED_ZODB, setupLayers)
+    Set up PopulatedZODB in ... seconds.
+    Set up ExpandedZODB in ... seconds.
+
+    >>> db = EXPANDED_ZODB['zodbDB']
+    >>> db.storage
+    ExpandedZODB
+
+    >>> EXPANDED_ZODB.get('zodbConnection', None) is None
+    True
+    >>> EXPANDED_ZODB.get('zodbRoot', None) is None
+    True
+
+Let's now simulate a test.::
+
+    >>> POPULATED_ZODB.testSetUp()
+    >>> EXPANDED_ZODB.testSetUp()
+
+The test would then execute. It may use the ZODB root.::
+
+    >>> EXPANDED_ZODB['zodbConnection']
+    <Connection at ...>
+
+    >>> EXPANDED_ZODB['zodbRoot'] == dict(someData='a string', additionalData='Some new data')
+    True
+
+    >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'
+
+On test tear-down, the transaction is aborted and the connection is closed.::
+
+    >>> EXPANDED_ZODB.testTearDown()
+    >>> POPULATED_ZODB.testTearDown()
+
+    >>> EXPANDED_ZODB.get('zodbConnection', None) is None
+    True
+
+    >>> EXPANDED_ZODB.get('zodbRoot', None) is None
+    True
+
+The transaction has been rolled back.::
+
+    >>> conn = EXPANDED_ZODB['zodbDB'].open()
+    >>> conn.root() == dict(someData='a string', additionalData='Some new data')
+    True
+    >>> conn.close()
+
+We'll now tear down the expanded layer and inspect the database again.::
+
+    >>> runner.tear_down_unneeded(options, [POPULATED_ZODB], setupLayers)
+    Tear down ExpandedZODB in ... seconds.
+
+    >>> conn = EXPANDED_ZODB['zodbDB'].open()
+    >>> conn.root()
+    {'someData': 'a string'}
+
+    >>> conn.close()
+
+Finally, we'll tear down the rest of the layers.::
+
+    >>> runner.tear_down_unneeded(options, [], setupLayers)
+    Tear down PopulatedZODB in ... seconds.
+
+    >>> EXPANDED_ZODB.get('zodbDB', None) is None
+    True
+    >>> POPULATED_ZODB.get('zodbDB', None) is None
+    True
diff --git a/src/plone/testing/zodb.txt b/src/plone/testing/zodb.txt
deleted file mode 100644
index 79ff465..0000000
--- a/src/plone/testing/zodb.txt
+++ /dev/null
@@ -1,288 +0,0 @@
-Zope Object Database layers
----------------------------
-
-The ZODB layers are found in the module ``plone.testing.zodb``:
-
-    >>> from plone.testing import zodb
-
-For testing, we need a testrunner
-
-    >>> from zope.testrunner import runner
-
-Empty ZODB layer
-~~~~~~~~~~~~~~~~
-
-The ``EMPTY_ZODB`` layer is used to set up an empty ZODB using
-``DemoStorage``.
-
-The storage and database are set up as layer fixtures. The database is exposed
-as the resource ``zodbDB``.
-
-A connection is opened for each test and exposed as ``zodbConnection``. The
-ZODB root is also exposed, as ``zodbRoot``. A new transaction is begun for
-each test. On test tear-down, the transaction is aborted, the connection is
-closed, and the two test-specific resources are deleted.
-
-The layer has no bases.
-
-    >>> "%s.%s" % (zodb.EMPTY_ZODB.__module__, zodb.EMPTY_ZODB.__name__,)
-    'plone.testing.zodb.EmptyZODB'
-
-    >>> zodb.EMPTY_ZODB.__bases__
-    ()
-
-Layer setup creates the database, but not a connection.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, zodb.EMPTY_ZODB, setupLayers)
-    Set up plone.testing.zodb.EmptyZODB in ... seconds.
-
-    >>> db = zodb.EMPTY_ZODB['zodbDB']
-    >>> db.storage
-    EmptyZODB
-
-    >>> zodb.EMPTY_ZODB.get('zodbConnection', None) is None
-    True
-    >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None
-    True
-
-Let's now simulate a test.
-
-    >>> zodb.EMPTY_ZODB.testSetUp()
-
-The test would then execute. It may use the ZODB root.
-
-    >>> zodb.EMPTY_ZODB['zodbConnection']
-    <Connection at ...>
-
-    >>> zodb.EMPTY_ZODB['zodbRoot']
-    {}
-
-    >>> zodb.EMPTY_ZODB['zodbRoot']['foo'] = 'bar'
-
-On test tear-down, the transaction is aborted and the connection is closed.
-
-    >>> zodb.EMPTY_ZODB.testTearDown()
-
-    >>> zodb.EMPTY_ZODB.get('zodbConnection', None) is None
-    True
-
-    >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None
-    True
-
-The transaction has been rolled back.
-
-    >>> conn = zodb.EMPTY_ZODB['zodbDB'].open()
-    >>> conn.root()
-    {}
-    >>> conn.close()
-
-Layer tear-down closes and deletes the database.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down plone.testing.zodb.EmptyZODB in ... seconds.
-
-    >>> zodb.EMPTY_ZODB.get('zodbDB', None) is None
-    True
-
-Extending the ZODB layer
-~~~~~~~~~~~~~~~~~~~~~~~~
-
-When creating a test fixture, it is often desirable to add some initial data
-to the database. If you want to do that once on layer setup, you can create
-your own layer class based on ``EmptyZODB`` and override its
-``createStorage()`` and/or ``createDatabase()`` methods to return a
-pre-populated database.
-
-
-    >>> import transaction
-    >>> from ZODB.DemoStorage import DemoStorage
-    >>> from ZODB.DB import DB
-
-    >>> class PopulatedZODB(zodb.EmptyZODB):
-    ...
-    ...     def createStorage(self):
-    ...         return DemoStorage("My storage")
-    ...
-    ...     def createDatabase(self, storage):
-    ...         db = DB(storage)
-    ...         conn = db.open()
-    ...
-    ...         conn.root()['someData'] = 'a string'
-    ...
-    ...         transaction.commit()
-    ...         conn.close()
-    ...
-    ...         return db
-
-    >>> POPULATED_ZODB = PopulatedZODB()
-
-We'll use this new layer in a similar manner to the test above, showing that
-the data is there for each test, but that other changes are rolled back.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, POPULATED_ZODB, setupLayers)
-    Set up PopulatedZODB in ... seconds.
-
-    >>> db = POPULATED_ZODB['zodbDB']
-    >>> db.storage
-    My storage
-
-    >>> POPULATED_ZODB.get('zodbConnection', None) is None
-    True
-    >>> POPULATED_ZODB.get('zodbRoot', None) is None
-    True
-
-Let's now simulate a test.
-
-    >>> POPULATED_ZODB.testSetUp()
-
-The test would then execute. It may use the ZODB root.
-
-    >>> POPULATED_ZODB['zodbConnection']
-    <Connection at ...>
-
-    >>> POPULATED_ZODB['zodbRoot']
-    {'someData': 'a string'}
-
-    >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'
-
-On test tear-down, the transaction is aborted and the connection is closed.
-
-    >>> POPULATED_ZODB.testTearDown()
-
-    >>> POPULATED_ZODB.get('zodbConnection', None) is None
-    True
-
-    >>> POPULATED_ZODB.get('zodbRoot', None) is None
-    True
-
-The transaction has been rolled back.
-
-    >>> conn = POPULATED_ZODB['zodbDB'].open()
-    >>> conn.root()
-    {'someData': 'a string'}
-    >>> conn.close()
-
-Layer tear-down closes and deletes the database.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down PopulatedZODB in ... seconds.
-
-    >>> POPULATED_ZODB.get('zodbDB', None) is None
-    True
-
-Stacking ``DemoStorage`` storages
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-The example above shows how to create a simple test fixture with a custom
-database. It is sometimes useful to be able to stack these fixtures, so that
-a base layer sets up some data for one set of tests, and a child layer
-extends this, temporarily, with more data.
-
-This can be achieved using layer bases and resource shadowing, combined with
-ZODB's stackable DemoStorage. There is even a helper function available:
-
-    >>> from plone.testing import Layer
-    >>> from plone.testing import zodb
-    >>> import transaction
-
-    >>> class ExpandedZODB(Layer):
-    ...     defaultBases = (POPULATED_ZODB,)
-    ...
-    ...     def setUp(self):
-    ...         # Get the database from the base layer
-    ...
-    ...         self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='ExpandedZODB')
-    ...
-    ...         conn = db.open()
-    ...         conn.root()['additionalData'] = "Some new data"
-    ...         transaction.commit()
-    ...         conn.close()
-    ...
-    ...     def tearDown(self):
-    ...         # Close the database and delete the shadowed copy
-    ...
-    ...         self['zodbDB'].close()
-    ...         del self['zodbDB']
-
-    >>> EXPANDED_ZODB = ExpandedZODB()
-
-Notice that we are using plain ``Layer`` as a base class here. We obtain the
-underlying database from our bases using the resource manager, and then
-create a shadow copy using a stacked storage. Stacked storages contain the
-data of the original storage, but save changes in a separate (and, in this
-case, temporary) storage.
-
-Let's simulate a test run again to show how this would work.
-
-    >>> options = runner.get_options([], [])
-    >>> setupLayers = {}
-    >>> runner.setup_layer(options, EXPANDED_ZODB, setupLayers)
-    Set up PopulatedZODB in ... seconds.
-    Set up ExpandedZODB in ... seconds.
-
-    >>> db = EXPANDED_ZODB['zodbDB']
-    >>> db.storage
-    ExpandedZODB
-
-    >>> EXPANDED_ZODB.get('zodbConnection', None) is None
-    True
-    >>> EXPANDED_ZODB.get('zodbRoot', None) is None
-    True
-
-Let's now simulate a test.
-
-    >>> POPULATED_ZODB.testSetUp()
-    >>> EXPANDED_ZODB.testSetUp()
-
-The test would then execute. It may use the ZODB root.
-
-    >>> EXPANDED_ZODB['zodbConnection']
-    <Connection at ...>
-
-    >>> EXPANDED_ZODB['zodbRoot'] == dict(someData='a string', additionalData='Some new data')
-    True
-
-    >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'
-
-On test tear-down, the transaction is aborted and the connection is closed.
-
-    >>> EXPANDED_ZODB.testTearDown()
-    >>> POPULATED_ZODB.testTearDown()
-
-    >>> EXPANDED_ZODB.get('zodbConnection', None) is None
-    True
-
-    >>> EXPANDED_ZODB.get('zodbRoot', None) is None
-    True
-
-The transaction has been rolled back.
-
-    >>> conn = EXPANDED_ZODB['zodbDB'].open()
-    >>> conn.root() == dict(someData='a string', additionalData='Some new data')
-    True
-    >>> conn.close()
-
-We'll now tear down the expanded layer and inspect the database again.
-
-    >>> runner.tear_down_unneeded(options, [POPULATED_ZODB], setupLayers)
-    Tear down ExpandedZODB in ... seconds.
-
-    >>> conn = EXPANDED_ZODB['zodbDB'].open()
-    >>> conn.root()
-    {'someData': 'a string'}
-
-    >>> conn.close()
-
-Finally, we'll tear down the rest of the layers.
-
-    >>> runner.tear_down_unneeded(options, [], setupLayers)
-    Tear down PopulatedZODB in ... seconds.
-
-    >>> EXPANDED_ZODB.get('zodbDB', None) is None
-    True
-    >>> POPULATED_ZODB.get('zodbDB', None) is None
-    True


