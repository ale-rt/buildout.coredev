Repository: plone.reload


Branch: refs/heads/master
Date: 2017-10-31T12:48:50+01:00
Author: Hanno Schlichting (hannosch) <hanno@hannosch.eu>
Commit: https://github.com/plone/plone.reload/commit/c04088c9e47868b647faf1494315d376cfc505dc

Update bootstrap.py

Files changed:
M bootstrap.py

diff --git a/bootstrap.py b/bootstrap.py
index 5f2cb08..ed57894 100644
--- a/bootstrap.py
+++ b/bootstrap.py
@@ -18,74 +18,14 @@
 use the -c option to specify an alternate configuration file.
 """
 
-import os, shutil, sys, tempfile, textwrap, urllib, urllib2, subprocess
-from optparse import OptionParser
-
-if sys.platform == 'win32':
-    def quote(c):
-        if ' ' in c:
-            return '"%s"' % c # work around spawn lamosity on windows
-        else:
-            return c
-else:
-    quote = str
-
-# See zc.buildout.easy_install._has_broken_dash_S for motivation and comments.
-stdout, stderr = subprocess.Popen(
-    [sys.executable, '-Sc',
-     'try:\n'
-     '    import ConfigParser\n'
-     'except ImportError:\n'
-     '    print 1\n'
-     'else:\n'
-     '    print 0\n'],
-    stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
-has_broken_dash_S = bool(int(stdout.strip()))
+import os
+import shutil
+import sys
+import tempfile
 
-# In order to be more robust in the face of system Pythons, we want to
-# run without site-packages loaded.  This is somewhat tricky, in
-# particular because Python 2.6's distutils imports site, so starting
-# with the -S flag is not sufficient.  However, we'll start with that:
-if not has_broken_dash_S and 'site' in sys.modules:
-    # We will restart with python -S.
-    args = sys.argv[:]
-    args[0:0] = [sys.executable, '-S']
-    args = map(quote, args)
-    os.execv(sys.executable, args)
-# Now we are running with -S.  We'll get the clean sys.path, import site
-# because distutils will do it later, and then reset the path and clean
-# out any namespace packages from site-packages that might have been
-# loaded by .pth files.
-clean_path = sys.path[:]
-import site
-sys.path[:] = clean_path
-for k, v in sys.modules.items():
-    if k in ('setuptools', 'pkg_resources') or (
-        hasattr(v, '__path__') and
-        len(v.__path__)==1 and
-        not os.path.exists(os.path.join(v.__path__[0],'__init__.py'))):
-        # This is a namespace package.  Remove it.
-        sys.modules.pop(k)
-
-is_jython = sys.platform.startswith('java')
-
-setuptools_source = 'http://peak.telecommunity.com/dist/ez_setup.py'
-distribute_source = 'http://python-distribute.org/distribute_setup.py'
+from optparse import OptionParser
 
-# parsing arguments
-def normalize_to_url(option, opt_str, value, parser):
-    if value:
-        if '://' not in value: # It doesn't smell like a URL.
-            value = 'file://%s' % (
-                urllib.pathname2url(
-                    os.path.abspath(os.path.expanduser(value))),)
-        if opt_str == '--download-base' and not value.endswith('/'):
-            # Download base needs a trailing slash to make the world happy.
-            value += '/'
-    else:
-        value = None
-    name = opt_str[2:].replace('-', '_')
-    setattr(parser.values, name, value)
+tmpeggs = tempfile.mkdtemp()
 
 usage = '''\
 [DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]
@@ -95,31 +35,13 @@ def normalize_to_url(option, opt_str, value, parser):
 Simply run this script in a directory containing a buildout.cfg, using the
 Python that you want bin/buildout to use.
 
-Note that by using --setup-source and --download-base to point to
-local resources, you can keep this script from going over the network.
+Note that by using --find-links to point to local resources, you can keep 
+this script from going over the network.
 '''
 
 parser = OptionParser(usage=usage)
-parser.add_option("-v", "--version", dest="version",
-                          help="use a specific zc.buildout version")
-parser.add_option("-d", "--distribute",
-                   action="store_true", dest="use_distribute", default=False,
-                   help="Use Distribute rather than Setuptools.")
-parser.add_option("--setup-source", action="callback", dest="setup_source",
-                  callback=normalize_to_url, nargs=1, type="string",
-                  help=("Specify a URL or file location for the setup file. "
-                        "If you use Setuptools, this will default to " +
-                        setuptools_source + "; if you use Distribute, this "
-                        "will default to " + distribute_source +"."))
-parser.add_option("--download-base", action="callback", dest="download_base",
-                  callback=normalize_to_url, nargs=1, type="string",
-                  help=("Specify a URL or directory for downloading "
-                        "zc.buildout and either Setuptools or Distribute. "
-                        "Defaults to PyPI."))
-parser.add_option("--eggs",
-                  help=("Specify a directory for storing eggs.  Defaults to "
-                        "a temporary directory that is deleted when the "
-                        "bootstrap script completes."))
+parser.add_option("-v", "--version", help="use a specific zc.buildout version")
+
 parser.add_option("-t", "--accept-buildout-test-releases",
                   dest='accept_buildout_test_releases',
                   action="store_true", default=False,
@@ -129,81 +51,74 @@ def normalize_to_url(option, opt_str, value, parser):
                         "extensions for you.  If you use this flag, "
                         "bootstrap and buildout will get the newest releases "
                         "even if they are alphas or betas."))
-parser.add_option("-c", None, action="store", dest="config_file",
-                   help=("Specify the path to the buildout configuration "
-                         "file to be used."))
-
-options, args = parser.parse_args()
-
-# if -c was provided, we push it back into args for buildout's main function
-if options.config_file is not None:
-    args += ['-c', options.config_file]
+parser.add_option("-c", "--config-file",
+                  help=("Specify the path to the buildout configuration "
+                        "file to be used."))
+parser.add_option("-f", "--find-links",
+                  help=("Specify a URL to search for buildout releases"))
+parser.add_option("--allow-site-packages",
+                  action="store_true", default=False,
+                  help=("Let bootstrap.py use existing site packages"))
 
-if options.eggs:
-    eggs_dir = os.path.abspath(os.path.expanduser(options.eggs))
-else:
-    eggs_dir = tempfile.mkdtemp()
 
-if options.setup_source is None:
-    if options.use_distribute:
-        options.setup_source = distribute_source
-    else:
-        options.setup_source = setuptools_source
+options, args = parser.parse_args()
 
-if options.accept_buildout_test_releases:
-    args.append('buildout:accept-buildout-test-releases=true')
-args.append('bootstrap')
+######################################################################
+# load/install setuptools
 
 try:
-    import pkg_resources
-    import setuptools # A flag.  Sometimes pkg_resources is installed alone.
-    if not hasattr(pkg_resources, '_distribute'):
-        raise ImportError
+    if options.allow_site_packages:
+        import setuptools
+        import pkg_resources
+    from urllib.request import urlopen
 except ImportError:
-    ez_code = urllib2.urlopen(
-        options.setup_source).read().replace('\r\n', '\n')
-    ez = {}
-    exec ez_code in ez
-    setup_args = dict(to_dir=eggs_dir, download_delay=0)
-    if options.download_base:
-        setup_args['download_base'] = options.download_base
-    if options.use_distribute:
-        setup_args['no_fake'] = True
-    ez['use_setuptools'](**setup_args)
-    if 'pkg_resources' in sys.modules:
-        reload(sys.modules['pkg_resources'])
-    import pkg_resources
-    # This does not (always?) update the default working set.  We will
-    # do it.
-    for path in sys.path:
-        if path not in pkg_resources.working_set.entries:
-            pkg_resources.working_set.add_entry(path)
+    from urllib2 import urlopen
+
+ez = {}
+exec(urlopen('https://bootstrap.pypa.io/ez_setup.py').read(), ez)
+
+if not options.allow_site_packages:
+    # ez_setup imports site, which adds site packages
+    # this will remove them from the path to ensure that incompatible versions 
+    # of setuptools are not in the path
+    import site
+    # inside a virtualenv, there is no 'getsitepackages'. 
+    # We can't remove these reliably
+    if hasattr(site, 'getsitepackages'):
+        for sitepackage_path in site.getsitepackages():
+            sys.path[:] = [x for x in sys.path if sitepackage_path not in x]
+
+setup_args = dict(to_dir=tmpeggs, download_delay=0)
+ez['use_setuptools'](**setup_args)
+import setuptools
+import pkg_resources
+
+# This does not (always?) update the default working set.  We will
+# do it.
+for path in sys.path:
+    if path not in pkg_resources.working_set.entries:
+        pkg_resources.working_set.add_entry(path)
+
+######################################################################
+# Install buildout
 
-cmd = [quote(sys.executable),
-       '-c',
-       quote('from setuptools.command.easy_install import main; main()'),
-       '-mqNxd',
-       quote(eggs_dir)]
+ws = pkg_resources.working_set
 
-if not has_broken_dash_S:
-    cmd.insert(1, '-S')
+cmd = [sys.executable, '-c',
+       'from setuptools.command.easy_install import main; main()',
+       '-mZqNxd', tmpeggs]
 
-find_links = options.download_base
-if not find_links:
-    find_links = os.environ.get('bootstrap-testing-find-links')
+find_links = os.environ.get(
+    'bootstrap-testing-find-links',
+    options.find_links or
+    ('http://downloads.buildout.org/'
+     if options.accept_buildout_test_releases else None)
+    )
 if find_links:
-    cmd.extend(['-f', quote(find_links)])
+    cmd.extend(['-f', find_links])
 
-if options.use_distribute:
-    setup_requirement = 'distribute'
-else:
-    setup_requirement = 'setuptools'
-ws = pkg_resources.working_set
-setup_requirement_path = ws.find(
-    pkg_resources.Requirement.parse(setup_requirement)).location
-env = dict(
-    os.environ,
-    PYTHONPATH=setup_requirement_path)
+setuptools_path = ws.find(
+    pkg_resources.Requirement.parse('setuptools')).location
 
 requirement = 'zc.buildout'
 version = options.version
@@ -211,13 +126,14 @@ def normalize_to_url(option, opt_str, value, parser):
     # Figure out the most recent final version of zc.buildout.
     import setuptools.package_index
     _final_parts = '*final-', '*final'
+
     def _final_version(parsed_version):
         for part in parsed_version:
             if (part[:1] == '*') and (part not in _final_parts):
                 return False
         return True
     index = setuptools.package_index.PackageIndex(
-        search_path=[setup_requirement_path])
+        search_path=[setuptools_path])
     if find_links:
         index.add_find_links((find_links,))
     req = pkg_resources.Requirement.parse(requirement)
@@ -239,22 +155,24 @@ def _final_version(parsed_version):
     requirement = '=='.join((requirement, version))
 cmd.append(requirement)
 
-if is_jython:
-    import subprocess
-    exitcode = subprocess.Popen(cmd, env=env).wait()
-else: # Windows prefers this, apparently; otherwise we would prefer subprocess
-    exitcode = os.spawnle(*([os.P_WAIT, sys.executable] + cmd + [env]))
-if exitcode != 0:
-    sys.stdout.flush()
-    sys.stderr.flush()
-    print ("An error occurred when trying to install zc.buildout. "
-           "Look above this message for any errors that "
-           "were output by easy_install.")
-    sys.exit(exitcode)
+import subprocess
+if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:
+    raise Exception(
+        "Failed to execute command:\n%s" % repr(cmd)[1:-1])
 
-ws.add_entry(eggs_dir)
+######################################################################
+# Import and run buildout
+
+ws.add_entry(tmpeggs)
 ws.require(requirement)
 import zc.buildout.buildout
+
+if not [a for a in args if '=' not in a]:
+    args.append('bootstrap')
+
+# if -c was provided, we push it back into args for buildout' main function
+if options.config_file is not None:
+    args[0:0] = ['-c', options.config_file]
+
 zc.buildout.buildout.main(args)
-if not options.eggs: # clean up temporary egg directory
-    shutil.rmtree(eggs_dir)
+shutil.rmtree(tmpeggs)


Repository: plone.reload


Branch: refs/heads/master
Date: 2017-10-31T12:59:20+01:00
Author: Hanno Schlichting (hannosch) <hanno@hannosch.eu>
Commit: https://github.com/plone/plone.reload/commit/26561878d21098470e806ca2d1ffd76043cc4945

Test against Zope 4, while keeping compatibility with Zope 2.13.

Files changed:
M CHANGES.rst
M buildout.cfg
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 82c50a5..0076761 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,39 +1,22 @@
 Changelog
 =========
 
-2.0.3 (unreleased)
+3.0.0 (unreleased)
 ------------------
 
-Breaking changes:
-
-- *add item here*
-
-New features:
-
-- *add item here*
-
-Bug fixes:
-
-- *add item here*
-
+- Test against Zope 4, while keeping compatibility with Zope 2.13.
 
 2.0.2 (2016-08-18)
 ------------------
 
-Fixes:
-
 - Use zope.interface decorator.
   [gforcada]
 
-
 2.0.1 (2016-02-11)
 ------------------
 
-Fixes:
-
 - Minor packaging fixes.  [gforcada, maurits]
 
-
 2.0 (2011-06-04)
 ----------------
 
diff --git a/buildout.cfg b/buildout.cfg
index e7bc121..a950e10 100644
--- a/buildout.cfg
+++ b/buildout.cfg
@@ -1,12 +1,17 @@
 [buildout]
+extends = https://zopefoundation.github.io/Zope/releases/master/versions.cfg
+
 parts =
     test
     test-cmf
     coverage
-    report-html
+    report
 
 develop = .
 
+[versions]
+Products.CMFCore = >=2.4.0.dev0
+
 [test]
 recipe = zc.recipe.testrunner
 eggs = plone.reload
@@ -24,9 +29,9 @@ initialization =
     source = '--source=${buildout:directory}/plone'
     sys.argv = sys.argv[:] + ['run', source, 'bin/test-cmf', '--all']
 
-[report-html]
+[report]
 recipe = zc.recipe.egg
 eggs = coverage
-scripts = coverage=report-html
+scripts = coverage=report
 initialization =
-    sys.argv = sys.argv[:] + ['html', '-i']
+    sys.argv = sys.argv[:] + ['report', '-i']
diff --git a/setup.py b/setup.py
index 8f33874..8105c5c 100644
--- a/setup.py
+++ b/setup.py
@@ -1,6 +1,6 @@
 from setuptools import setup
 
-version = '2.0.3.dev0'
+version = '3.0.0.dev0'
 
 setup(
     name='plone.reload',
@@ -18,9 +18,8 @@
         "License :: OSI Approved :: BSD License",
         "Operating System :: OS Independent",
         "Programming Language :: Python",
-        "Programming Language :: Python :: 2.6",
         "Programming Language :: Python :: 2.7",
-      ],
+    ],
     keywords='zope plone reload',
     author='Hanno Schlichting',
     author_email='hanno@hannosch.eu',
@@ -38,13 +37,13 @@
         'zope.publisher',
         'zope.site',
         'zope.testing',
-        'Zope2 >= 2.12',
+        'Zope2 >= 2.13',
     ],
     extras_require=dict(
-      cmf=['Products.CMFCore'],
+        cmf=['Products.CMFCore'],
     ),
     entry_points="""
     [z3c.autoinclude.plugin]
     target = plone
     """,
-    )
+)


Repository: plone.reload


Branch: refs/heads/master
Date: 2017-10-31T14:15:51+01:00
Author: Hanno Schlichting (hannosch) <hanno@hannosch.eu>
Commit: https://github.com/plone/plone.reload/commit/5f60666644a6410dffd056068d77dfd89a560d1a

Add Python 3.4, 3.5 and 3.6 support. Drop Python 2.6 support.

Files changed:
A tox.ini
M CHANGES.rst
M buildout.cfg
M docs/LICENSE.txt
M plone/reload/code.py
M plone/reload/tests/test_code.py
M plone/reload/tests/test_reload.py
M plone/reload/xreload.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 0076761..81d4042 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,6 +4,8 @@ Changelog
 3.0.0 (unreleased)
 ------------------
 
+- Add Python 3.4, 3.5 and 3.6 support. Drop Python 2.6 support.
+
 - Test against Zope 4, while keeping compatibility with Zope 2.13.
 
 2.0.2 (2016-08-18)
diff --git a/buildout.cfg b/buildout.cfg
index a950e10..a69fbf8 100644
--- a/buildout.cfg
+++ b/buildout.cfg
@@ -4,6 +4,7 @@ extends = https://zopefoundation.github.io/Zope/releases/master/versions.cfg
 parts =
     test
     test-cmf
+    tox
     coverage
     report
 
@@ -22,12 +23,16 @@ recipe = zc.recipe.testrunner
 eggs = plone.reload [cmf]
 defaults = ['-s', 'plone.reload']
 
+[tox]
+recipe = zc.recipe.egg
+eggs = tox
+
 [coverage]
 recipe = zc.recipe.egg
 eggs = coverage
 initialization =
     source = '--source=${buildout:directory}/plone'
-    sys.argv = sys.argv[:] + ['run', source, 'bin/test-cmf', '--all']
+    sys.argv = sys.argv[:] + ['run', source, 'bin/test', '--all']
 
 [report]
 recipe = zc.recipe.egg
diff --git a/docs/LICENSE.txt b/docs/LICENSE.txt
index 26dd3d9..c59c538 100644
--- a/docs/LICENSE.txt
+++ b/docs/LICENSE.txt
@@ -1,5 +1,5 @@
 plone.reload
-Copyright (C) 2008-2011 Hanno Schlichting
+Copyright (C) 2008-2017 Hanno Schlichting
 
 All rights reserved.
 
diff --git a/plone/reload/code.py b/plone/reload/code.py
index 63572bd..14ee521 100644
--- a/plone/reload/code.py
+++ b/plone/reload/code.py
@@ -11,6 +11,40 @@
 MOD_TIMES = dict()
 
 
+try:
+    # Py3
+    from imp import cache_from_source, source_from_cache
+
+    def _cache_from_source(path):
+        if '__pycache__' in path:
+            return path
+        return cache_from_source(path)
+
+    def _source_from_cache(path):
+        if '__pycache__' in path:
+            return source_from_cache(path)
+        return path
+
+except ImportError:
+    # Py2
+    def _cache_from_source(path):
+        if path.endswith('pyc') or path.endswith('pyo'):
+            cache = path
+        else:
+            cache = path + 'c'
+        if os.path.isfile(cache):
+            path = cache
+        return path
+
+    def _source_from_cache(path):
+        source = path
+        if path.endswith('pyc') or path.endswith('pyo'):
+            source = path[:-1]
+        if os.path.isfile(source):
+            path = source
+        return path
+
+
 def in_search_path(path):
     if 'site-packages' in path:
         return False
@@ -27,7 +61,7 @@ def search_modules():
             # Standard library modules don't have a __file__
             if f is None:
                 continue
-            f = abspath(f)
+            f = abspath(_source_from_cache(f))
             if config.EXCLUDE_SITE_PACKAGES:
                 if in_search_path(f):
                     modules.append((f, module))
@@ -39,10 +73,7 @@ def search_modules():
 def get_mod_time(path):
     mtime = 0
     # If we have the compiled source, look for the source code change date
-    if path.endswith('pyc') or path.endswith('pyo'):
-        source = path[:-1]
-        if os.path.isfile(source):
-            path = source
+    path = _source_from_cache(path)
     # protect against missing and unaccessible files
     if isfile(path):
         mtime = os.stat(path)[8]
diff --git a/plone/reload/tests/test_code.py b/plone/reload/tests/test_code.py
index 00e1211..087d840 100644
--- a/plone/reload/tests/test_code.py
+++ b/plone/reload/tests/test_code.py
@@ -56,16 +56,16 @@ def test_get_mod_time(self):
         self.assertEqual(our_time, os.stat(tests)[8])
 
     def test_get_mod_time_compiled(self):
-        from plone.reload.code import get_mod_time
+        from plone.reload.code import get_mod_time, _cache_from_source
         tests = os.path.join(TESTS, '__init__.py')
-        tests_c = os.path.join(TESTS, '__init__.pyc')
+        tests_c = _cache_from_source(tests)
         our_time = get_mod_time(tests_c)
         self.assertEqual(our_time, os.stat(tests)[8])
 
     def test_get_mod_times(self):
         from plone.reload.code import get_mod_times
         our_package = os.path.abspath(
-            os.path.join(TESTS, os.pardir, '__init__.pyc'))
+            os.path.join(TESTS, os.pardir, '__init__.py'))
         times = get_mod_times()
         self.assertTrue(our_package in times)
         self.assertTrue(isinstance(times[our_package][1], types.ModuleType))
@@ -76,15 +76,16 @@ def test_check_mod_times(self):
 
     def test_check_mod_times_change(self):
         from plone.reload.code import check_mod_times
-        from plone.reload.code import MOD_TIMES
+        from plone.reload.code import get_mod_times
         our_package = os.path.abspath(
-            os.path.join(TESTS, os.pardir, '__init__.pyc'))
-        our_entry = MOD_TIMES[our_package]
+            os.path.join(TESTS, os.pardir, '__init__.py'))
+        times = get_mod_times()
+        our_entry = times[our_package]
         try:
-            MOD_TIMES[our_package] = (our_entry[0] - 10, our_entry[1])
+            times[our_package] = (our_entry[0] - 10, our_entry[1])
             self.assertEqual(len(check_mod_times()), 1)
         finally:
-            MOD_TIMES[our_package] = our_entry
+            times[our_package] = our_entry
 
     def test_reload_code(self):
         from plone.reload.code import reload_code
@@ -92,12 +93,13 @@ def test_reload_code(self):
 
     def test_reload_code_change(self):
         from plone.reload.code import reload_code
-        from plone.reload.code import MOD_TIMES
+        from plone.reload.code import get_mod_times
         our_package = os.path.abspath(
-            os.path.join(TESTS, os.pardir, '__init__.pyc'))
-        our_entry = MOD_TIMES[our_package]
+            os.path.join(TESTS, os.pardir, '__init__.py'))
+        times = get_mod_times()
+        our_entry = times[our_package]
         try:
-            MOD_TIMES[our_package] = (our_entry[0] - 10, our_entry[1])
+            times[our_package] = (our_entry[0] - 10, our_entry[1])
             self.assertEqual(len(reload_code()), 1)
         finally:
-            MOD_TIMES[our_package] = our_entry
+            times[our_package] = our_entry
diff --git a/plone/reload/tests/test_reload.py b/plone/reload/tests/test_reload.py
index 9dd0ead..1707c82 100644
--- a/plone/reload/tests/test_reload.py
+++ b/plone/reload/tests/test_reload.py
@@ -297,7 +297,7 @@ def bar():
 
     def test_interface_method_added(self):
         self.reload(self.base)
-        self.reload(self.base + '\tdef baz():\n\t\t"""Maybe a baz?"""')
+        self.reload(self.base + '    def baz():\n        """Maybe a baz?"""')
         self.assertTrue('bar' in self.module.IFoo.names())
         # Reloading interfaces doesn't work yet at all
         self.assertFalse('baz' in self.module.IFoo.names())
diff --git a/plone/reload/xreload.py b/plone/reload/xreload.py
index fa25c4f..4b5a56c 100644
--- a/plone/reload/xreload.py
+++ b/plone/reload/xreload.py
@@ -18,6 +18,8 @@
 import types
 import inspect
 
+import six
+from six.moves import reload_module
 import zope.component
 
 
@@ -72,7 +74,7 @@ def reload(self):
             # XXX Could handle frozen modules, zip-import modules
             if kind not in (imp.PY_COMPILED, imp.PY_SOURCE):
                 # Fall back to built-in reload()
-                return reload(self.mod)
+                return reload_module(self.mod)
             if kind == imp.PY_SOURCE:
                 source = stream.read()
                 # PeterB: if we don't strip the source code and add newline we
@@ -166,11 +168,13 @@ def _update_scope(oldscope, newscope):
 
 def _update_function(oldfunc, newfunc):
     """Update a function object."""
-    if _closure_changed(oldfunc.func_closure, newfunc.func_closure):
-        raise ClosureChanged
-    oldfunc.func_code = newfunc.func_code
-    oldfunc.func_defaults = newfunc.func_defaults
-    _update_scope(oldfunc.func_globals, newfunc.func_globals)
+    if _closure_changed(six.get_function_closure(oldfunc),
+                        six.get_function_closure(newfunc)):
+        raise ClosureChanged()
+    setattr(oldfunc, six._func_code, six.get_function_code(newfunc))
+    setattr(oldfunc, six._func_defaults, six.get_function_defaults(newfunc))
+    _update_scope(six.get_function_globals(oldfunc),
+                  six.get_function_globals(newfunc))
     # XXX What else?
     return oldfunc
 
@@ -178,7 +182,8 @@ def _update_function(oldfunc, newfunc):
 def _update_method(oldmeth, newmeth):
     """Update a method object."""
     # XXX What if im_func is not a function?
-    _update_function(oldmeth.im_func, newmeth.im_func)
+    _update_function(six.get_unbound_function(oldmeth),
+                     six.get_unbound_function(newmeth))
     return oldmeth
 
 
@@ -204,15 +209,16 @@ def _update_class(oldclass, newclass):
         try:
             new = getattr(newclass, name)
             old = getattr(oldclass, name, None)
-            if isinstance(new, types.MethodType):
+            if isinstance(new, (types.FunctionType, types.MethodType)):
                 if isinstance(old, property) and not isinstance(new, property):
                     # Removing a decorator
-                    setattr(oldclass, name, new.im_func)
-                else:
+                    setattr(oldclass, name, six.get_unbound_function(new))
+                elif isinstance(new, types.FunctionType):
+                    # Under Py3 there are only functions
+                    _update_function(old, new)
+                elif isinstance(new, types.MethodType):
+                    # Py2-only
                     _update_method(old, new)
-            elif isinstance(new, types.FunctionType):
-                # __init__ is a function
-                _update_function(old, new)
             else:
                 new2 = newdict.get(name)
                 if new is not new2:
@@ -224,6 +230,6 @@ def _update_class(oldclass, newclass):
                     setattr(oldclass, name, new)
         except ClosureChanged:
             # If the closure changed, we need to replace the entire function
-            setattr(oldclass, name, new.im_func)
+            setattr(oldclass, name, six.get_unbound_function(new))
 
     return oldclass
diff --git a/setup.py b/setup.py
index 8105c5c..310efd4 100644
--- a/setup.py
+++ b/setup.py
@@ -18,7 +18,13 @@
         "License :: OSI Approved :: BSD License",
         "Operating System :: OS Independent",
         "Programming Language :: Python",
+        "Programming Language :: Python :: 2",
         "Programming Language :: Python :: 2.7",
+        "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: 3.4",
+        "Programming Language :: Python :: 3.5",
+        "Programming Language :: Python :: 3.6",
+        "Programming Language :: Python :: Implementation :: CPython",
     ],
     keywords='zope plone reload',
     author='Hanno Schlichting',
@@ -31,6 +37,7 @@
     zip_safe=False,
     install_requires=[
         'setuptools',
+        'six',
         'zope.component',
         'zope.interface',
         'zope.processlifetime',
diff --git a/tox.ini b/tox.ini
new file mode 100644
index 0000000..dedef13
--- /dev/null
+++ b/tox.ini
@@ -0,0 +1,12 @@
+[tox]
+envlist = py27,py34,py35,py36
+
+[testenv]
+commands =
+    {envbindir}/buildout -c {toxinidir}/buildout.cfg buildout:directory={envdir} buildout:develop={toxinidir} bootstrap
+    {envbindir}/buildout -c {toxinidir}/buildout.cfg buildout:directory={envdir} buildout:develop={toxinidir}
+    {envbindir}/coverage []
+skip_install = true
+deps =
+    setuptools==33.1.1
+    zc.buildout


