Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-01-31T22:01:24+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/226074314a62e893ebfb58a4c6197a971fb03c50

Python 3 compatibility

Files changed:
A .gitignore
A bootstrap-buildout.py
A buildout.cfg
M plone/memoize/compress.py
M plone/memoize/compress.rst
M plone/memoize/forever.rst
M plone/memoize/instance.rst
M plone/memoize/ram.py
M plone/memoize/ram.rst
M plone/memoize/request.py
M plone/memoize/request.rst
M plone/memoize/view.rst
M plone/memoize/volatile.py
M plone/memoize/volatile.rst
M setup.py

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..fc4a60c
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,6 @@
+.installed.cfg
+/bin
+__pycache__
+*.bak
+*.egg-info
+/develop-eggs
diff --git a/bootstrap-buildout.py b/bootstrap-buildout.py
new file mode 100644
index 0000000..a459921
--- /dev/null
+++ b/bootstrap-buildout.py
@@ -0,0 +1,210 @@
+##############################################################################
+#
+# Copyright (c) 2006 Zope Foundation and Contributors.
+# All Rights Reserved.
+#
+# This software is subject to the provisions of the Zope Public License,
+# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
+# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
+# FOR A PARTICULAR PURPOSE.
+#
+##############################################################################
+"""Bootstrap a buildout-based project
+
+Simply run this script in a directory containing a buildout.cfg.
+The script accepts buildout command-line options, so you can
+use the -c option to specify an alternate configuration file.
+"""
+
+import os
+import shutil
+import sys
+import tempfile
+
+from optparse import OptionParser
+
+__version__ = '2015-07-01'
+# See zc.buildout's changelog if this version is up to date.
+
+tmpeggs = tempfile.mkdtemp(prefix='bootstrap-')
+
+usage = '''\
+[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]
+
+Bootstraps a buildout-based project.
+
+Simply run this script in a directory containing a buildout.cfg, using the
+Python that you want bin/buildout to use.
+
+Note that by using --find-links to point to local resources, you can keep
+this script from going over the network.
+'''
+
+parser = OptionParser(usage=usage)
+parser.add_option("--version",
+                  action="store_true", default=False,
+                  help=("Return bootstrap.py version."))
+parser.add_option("-t", "--accept-buildout-test-releases",
+                  dest='accept_buildout_test_releases',
+                  action="store_true", default=False,
+                  help=("Normally, if you do not specify a --version, the "
+                        "bootstrap script and buildout gets the newest "
+                        "*final* versions of zc.buildout and its recipes and "
+                        "extensions for you.  If you use this flag, "
+                        "bootstrap and buildout will get the newest releases "
+                        "even if they are alphas or betas."))
+parser.add_option("-c", "--config-file",
+                  help=("Specify the path to the buildout configuration "
+                        "file to be used."))
+parser.add_option("-f", "--find-links",
+                  help=("Specify a URL to search for buildout releases"))
+parser.add_option("--allow-site-packages",
+                  action="store_true", default=False,
+                  help=("Let bootstrap.py use existing site packages"))
+parser.add_option("--buildout-version",
+                  help="Use a specific zc.buildout version")
+parser.add_option("--setuptools-version",
+                  help="Use a specific setuptools version")
+parser.add_option("--setuptools-to-dir",
+                  help=("Allow for re-use of existing directory of "
+                        "setuptools versions"))
+
+options, args = parser.parse_args()
+if options.version:
+    print("bootstrap.py version %s" % __version__)
+    sys.exit(0)
+
+
+######################################################################
+# load/install setuptools
+
+try:
+    from urllib.request import urlopen
+except ImportError:
+    from urllib2 import urlopen
+
+ez = {}
+if os.path.exists('ez_setup.py'):
+    exec(open('ez_setup.py').read(), ez)
+else:
+    exec(urlopen('https://bootstrap.pypa.io/ez_setup.py').read(), ez)
+
+if not options.allow_site_packages:
+    # ez_setup imports site, which adds site packages
+    # this will remove them from the path to ensure that incompatible versions
+    # of setuptools are not in the path
+    import site
+    # inside a virtualenv, there is no 'getsitepackages'.
+    # We can't remove these reliably
+    if hasattr(site, 'getsitepackages'):
+        for sitepackage_path in site.getsitepackages():
+            # Strip all site-packages directories from sys.path that
+            # are not sys.prefix; this is because on Windows
+            # sys.prefix is a site-package directory.
+            if sitepackage_path != sys.prefix:
+                sys.path[:] = [x for x in sys.path
+                               if sitepackage_path not in x]
+
+setup_args = dict(to_dir=tmpeggs, download_delay=0)
+
+if options.setuptools_version is not None:
+    setup_args['version'] = options.setuptools_version
+if options.setuptools_to_dir is not None:
+    setup_args['to_dir'] = options.setuptools_to_dir
+
+ez['use_setuptools'](**setup_args)
+import setuptools
+import pkg_resources
+
+# This does not (always?) update the default working set.  We will
+# do it.
+for path in sys.path:
+    if path not in pkg_resources.working_set.entries:
+        pkg_resources.working_set.add_entry(path)
+
+######################################################################
+# Install buildout
+
+ws = pkg_resources.working_set
+
+setuptools_path = ws.find(
+    pkg_resources.Requirement.parse('setuptools')).location
+
+# Fix sys.path here as easy_install.pth added before PYTHONPATH
+cmd = [sys.executable, '-c',
+       'import sys; sys.path[0:0] = [%r]; ' % setuptools_path +
+       'from setuptools.command.easy_install import main; main()',
+       '-mZqNxd', tmpeggs]
+
+find_links = os.environ.get(
+    'bootstrap-testing-find-links',
+    options.find_links or
+    ('http://downloads.buildout.org/'
+     if options.accept_buildout_test_releases else None)
+    )
+if find_links:
+    cmd.extend(['-f', find_links])
+
+requirement = 'zc.buildout'
+version = options.buildout_version
+if version is None and not options.accept_buildout_test_releases:
+    # Figure out the most recent final version of zc.buildout.
+    import setuptools.package_index
+    _final_parts = '*final-', '*final'
+
+    def _final_version(parsed_version):
+        try:
+            return not parsed_version.is_prerelease
+        except AttributeError:
+            # Older setuptools
+            for part in parsed_version:
+                if (part[:1] == '*') and (part not in _final_parts):
+                    return False
+            return True
+
+    index = setuptools.package_index.PackageIndex(
+        search_path=[setuptools_path])
+    if find_links:
+        index.add_find_links((find_links,))
+    req = pkg_resources.Requirement.parse(requirement)
+    if index.obtain(req) is not None:
+        best = []
+        bestv = None
+        for dist in index[req.project_name]:
+            distv = dist.parsed_version
+            if _final_version(distv):
+                if bestv is None or distv > bestv:
+                    best = [dist]
+                    bestv = distv
+                elif distv == bestv:
+                    best.append(dist)
+        if best:
+            best.sort()
+            version = best[-1].version
+if version:
+    requirement = '=='.join((requirement, version))
+cmd.append(requirement)
+
+import subprocess
+if subprocess.call(cmd) != 0:
+    raise Exception(
+        "Failed to execute command:\n%s" % repr(cmd)[1:-1])
+
+######################################################################
+# Import and run buildout
+
+ws.add_entry(tmpeggs)
+ws.require(requirement)
+import zc.buildout.buildout
+
+if not [a for a in args if '=' not in a]:
+    args.append('bootstrap')
+
+# if -c was provided, we push it back into args for buildout' main function
+if options.config_file is not None:
+    args[0:0] = ['-c', options.config_file]
+
+zc.buildout.buildout.main(args)
+shutil.rmtree(tmpeggs)
diff --git a/buildout.cfg b/buildout.cfg
new file mode 100644
index 0000000..10c37a2
--- /dev/null
+++ b/buildout.cfg
@@ -0,0 +1,8 @@
+[buildout]
+develop = .
+parts = test
+
+[test]
+recipe = zc.recipe.testrunner
+eggs =
+   plone.memoize [test]
diff --git a/plone/memoize/compress.py b/plone/memoize/compress.py
index 569bd3a..bbb62a9 100644
--- a/plone/memoize/compress.py
+++ b/plone/memoize/compress.py
@@ -4,7 +4,7 @@
 
 from plone.memoize.interfaces import IXHTMLCompressor
 from zope.component import queryUtility
-from zope.interface import implements
+from zope.interface import implementer
 
 SLIMMER = True
 try:
@@ -19,11 +19,9 @@ def xhtml_compress(string):
         return util.compress(string)
     return string
 
-
+@implementer(IXHTMLCompressor)
 class XHTMLSlimmer(object):
 
-    implements(IXHTMLCompressor)
-
     def compress(self, string):
         if SLIMMER:
             return xhtml_slimmer(string)
diff --git a/plone/memoize/compress.rst b/plone/memoize/compress.rst
index 017a527..5247931 100644
--- a/plone/memoize/compress.rst
+++ b/plone/memoize/compress.rst
@@ -10,8 +10,7 @@ Make necessary imports::
 
     >>> from plone.memoize.compress import xhtml_compress
     >>> from plone.memoize.interfaces import IXHTMLCompressor
-    >>> from zope.interface import implements
-
+    >>> from zope.interface import implementer
 
 
 You can register other XHTML-whitespace removal libraries as well.
@@ -25,8 +24,8 @@ Per default there is no compressor available and we get the same string back::
 Make a stupid lowercasing compressor.
 This is not safe as it would lowercase all text outside of tags as well::
 
-    >>> class LowerCaser(object):
-    ...     implements(IXHTMLCompressor)
+    >>> @implementer(IXHTMLCompressor)
+    ... class LowerCaser(object):
     ...
     ...     def compress(self, string):
     ...         return string.lower()
@@ -39,6 +38,6 @@ Register our new compressor::
     >>> sm = getSiteManager()
     >>> sm.registerUtility(lower)
 
-    >>> xhtml_compress(html_string)
-    u'<html><body><span>hello.</span></body><html>'
+    >>> str(xhtml_compress(html_string))
+    '<html><body><span>hello.</span></body><html>'
 
diff --git a/plone/memoize/forever.rst b/plone/memoize/forever.rst
index 0362399..7598079 100644
--- a/plone/memoize/forever.rst
+++ b/plone/memoize/forever.rst
@@ -14,7 +14,7 @@ They work on both global functions and class functions.::
 
     >>> @forever.memoize
     ... def remember(arg1, arg2):
-    ...     print "Calculating"
+    ...     print("Calculating")
     ...     return arg1 + arg2
 
 No matter how many times we call this function with a particular set of arguments, it will only perform its calculation once::
@@ -36,7 +36,7 @@ This also works for methods in classes::
     ...
     ...     @forever.memoize
     ...     def remember(self, arg1, arg2):
-    ...         print "Calculating"
+    ...         print("Calculating")
     ...         return arg1 + arg2
 
     >>> t = Test()
diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index bb35599..ad09032 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -87,63 +87,63 @@ Now we can test the clear before, which does the opposite from the clear after,
 
 memojito supports memoization of multiple signatures as long as all signature values are hashable::
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
 We can alter data underneath, but nothing changes::
 
     >>> msg.txt1 = 'sound and fury'
-    >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
 If we alter the signature, our msg is recalculated, but since mst.txt2 is a memo, only the values passed in change::
 
     >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
-    >>> print msg.getMsg('Bill F.', **ins)
+    >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: goodbye cruel world! tale--told by idiot signify--nothing
 
-    >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: goodbye cruel world! catcher--rye
 
 If change the bang, the memo remains the same::
 
     >>> msg.bang='#!'
-    >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: goodbye cruel world! catcher--rye
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
 clearing works the same as for properties::
 
-    >>> print msg.clearafter()
+    >>> print(msg.clearafter())
     goodbye cruel world
 
 Our shebang appears::
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: sound and fury world#!
 
 Our message to faulkner now is semantically correct::
 
     >>> ins = dict(tale='told by idiot', signify='nothing')
-    >>> print msg.getMsg('Bill F.', **ins)
+    >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world#! tale--told by idiot signify--nothing
 
 Let's make sure that memoized properties which call OTHER memoized properties do the right thing::
 
     >>> msg = MyMsg('hello')
-    >>> print msg.recurse
+    >>> print(msg.recurse)
     recursive: hello world
 
 Now we make sure that both the txt2 and the recurse values are in the cache::
 
-    >>> print len(msg._memojito_.keys())
+    >>> print(len(msg._memojito_.keys()))
     2
 
diff --git a/plone/memoize/ram.py b/plone/memoize/ram.py
index d07825d..e9bb967 100644
--- a/plone/memoize/ram.py
+++ b/plone/memoize/ram.py
@@ -8,7 +8,11 @@
 from zope import interface
 from zope.ramcache import ram
 from zope.ramcache.interfaces.ram import IRAMCache
-import cPickle
+
+try:
+    import pickle  # Python 3
+except ImportError:
+    import cPickle as pickle  # Python 2
 
 try:
     from hashlib import md5
@@ -39,7 +43,7 @@ def __init__(self, client, globalkey=''):
         self.globalkey = globalkey and '%s:' % globalkey
 
     def _make_key(self, source):
-        if isinstance(source, unicode):
+        if isinstance(source, str):
             source = source.encode('utf-8')
         return md5(source).hexdigest()
 
@@ -48,10 +52,10 @@ def __getitem__(self, key):
         if cached_value is None:
             raise KeyError(key)
         else:
-            return cPickle.loads(cached_value)
+            return pickle.loads(cached_value)
 
     def __setitem__(self, key, value):
-        cached_value = cPickle.dumps(value)
+        cached_value = pickle.dumps(value)
         self.client.set(self.globalkey + self._make_key(key), cached_value)
 
 
@@ -62,7 +66,7 @@ def __init__(self, ramcache, globalkey=''):
         self.globalkey = globalkey
 
     def _make_key(self, source):
-        if isinstance(source, unicode):
+        if isinstance(source, str):
             source = source.encode('utf-8')
         return md5(source).digest()
 
diff --git a/plone/memoize/ram.rst b/plone/memoize/ram.rst
index 674fdeb..ff47cec 100644
--- a/plone/memoize/ram.rst
+++ b/plone/memoize/ram.rst
@@ -20,7 +20,7 @@ Make necessary imports::
     ...     return (first, second)
     >>> @cache(cache_key)
     ... def pow(first, second):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return first ** second
 
     >>> pow(3, 2)
@@ -33,7 +33,7 @@ Let's cache another function::
 
     >>> @cache(cache_key)
     ... def add(first, second):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return first + second
 
     >>> add(3, 2)
diff --git a/plone/memoize/request.py b/plone/memoize/request.py
index e987ade..e8c4a3f 100644
--- a/plone/memoize/request.py
+++ b/plone/memoize/request.py
@@ -34,7 +34,7 @@ def memogetter(*args, **kwargs):
                 cache = annotations[self.key] = dict()
 
             key = (func.__module__, func.__name__,
-                   args, frozenset(kwargs.items()))
+                   args, frozenset(list(kwargs.items())))
             value = cache.get(key, _marker)
             if value is _marker:
                 value = cache[key] = func(*args, **kwargs)
@@ -59,7 +59,7 @@ def _store_in_annotation(fun, *args, **kwargs):
             expected_num_args = len(spec[0]) - len(spec[3])
         if num_args != expected_num_args:
             raise TypeError("%s() takes exactly %s arguments (%s given)"
-                            % (fun.func_name, expected_num_args, num_args))
+                            % (fun.__name__, expected_num_args, num_args))
 
         for index, name in enumerate(spec[0]):
             if index < num_args:
diff --git a/plone/memoize/request.rst b/plone/memoize/request.rst
index 7bca946..db73285 100644
--- a/plone/memoize/request.rst
+++ b/plone/memoize/request.rst
@@ -11,7 +11,7 @@ Make necessary imports::
 ::
 
     >>> def increment(a):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return a + 1
 
 Now we need to define this `a`.
@@ -42,14 +42,14 @@ We'll tell the decorator to use `args_hash` for generating the key.
     2
     >>> cached_increment(A(1))
     2
-    >>> IAnnotations(A.request)
-    {'None.increment:1': 2}
+    >>> list(IAnnotations(A.request).items())
+    [('None.increment:1', 2)]
 
 If `request` is already part of the function's argument list, we don't need to specify any expression::
 
     >>> @cache(get_key=get_key)
     ... def increment_plus(a, request):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return a + 1
 
     >>> increment_plus(42, A.request)
@@ -65,13 +65,13 @@ For the sake of convenience pass the request explicitly.
 get_key must be modified to take kwargs into account::
 
     >>> def get_key(fun, a, request, **kwargs):
-    ...     li = kwargs.items()
+    ...     li = list(kwargs.items())
     ...     li.sort()
     ...     return "%s,%s" % (a, li)
 
     >>> @cache(get_key=get_key)
     ... def increment_kwargs(a, request, kwarg1=1, kwarg2=2):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return a + 1
 
     >>> increment_kwargs(42, A.request, kwarg1='kwarg1', kwarg2='kwarg2')
diff --git a/plone/memoize/view.rst b/plone/memoize/view.rst
index 827e214..edaac2a 100644
--- a/plone/memoize/view.rst
+++ b/plone/memoize/view.rst
@@ -9,15 +9,15 @@ This means that the same view can be looked up multiple times and the same memos
 
     >>> from plone.memoize import view
     >>> from zope.component import adapts
-    >>> from zope.interface import implements
+    >>> from zope.interface import implementer
     >>> from zope.interface import Interface
     >>> from zope.publisher.interfaces.browser import IBrowserRequest
     >>> from zope.publisher.interfaces.browser import IBrowserView
 
 First we set up a dummy view::
 
-    >>> class MyView(object):
-    ...     implements(IBrowserView)
+    >>> @implementer(IBrowserView)
+    ... class MyView(object):
     ...     adapts(Interface, IBrowserRequest)
     ...
     ...     def __init__(self, context, request):
@@ -50,8 +50,9 @@ First we set up a dummy view::
 
 We also need a dummy context::
 
-    >>> class Dummy(object):
-    ...     implements(Interface)
+    >>> @implementer(Interface)
+    ... class Dummy(object):
+    ...     pass
 
 Let's look up the view::
 
@@ -82,37 +83,37 @@ Even though we've twiddled txt1, txt2 is not recalculated::
 
 We support memoization of multiple signatures as long as all signature values are hashable::
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
 We can alter data underneath, but nothing changes::
 
     >>> msg.txt1 = 'sound and fury'
-    >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
 If we alter the signature, our msg is recalculated::
 
     >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
-    >>> print msg.getMsg('Bill F.', **ins)
+    >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
 
-    >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: sound and fury world! catcher--rye
 
 If change the bang, the memo remains the same::
 
     >>> msg.bang='#!'
-    >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: sound and fury world! catcher--rye
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
 If we look up the view again on the same object, we will get the same memoized properties as before::
@@ -125,17 +126,17 @@ If we look up the view again on the same object, we will get the same memoized p
     >>> msg2.txt2
     'hello world'
 
-    >>> print msg2.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg2.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
-    >>> print msg2.getMsg('Ernest')
+    >>> print(msg2.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
     >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
-    >>> print msg2.getMsg('Bill F.', **ins)
+    >>> print(msg2.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
 
-    >>> print msg2.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg2.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: sound and fury world! catcher--rye
 
 However, if we look up the view on another context object, things change::
@@ -149,25 +150,25 @@ However, if we look up the view on another context object, things change::
     >>> msg3.txt2
     'so long, cruel world'
 
-    >>> print msg3.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg3.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: so long, cruel world& raise--roofbeams
 
-    >>> print msg3.getMsg('Ernest')
+    >>> print(msg3.getMsg('Ernest'))
     Ernest: so long, cruel world&
 
     >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
-    >>> print msg3.getMsg('Bill F.', **ins)
+    >>> print(msg3.getMsg('Bill F.', **ins))
     Bill F.: so long, cruel world& tale--told by idiot signify--nothing
 
-    >>> print msg3.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg3.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: so long, cruel world& catcher--rye
 
 This behaviour does not apply to contextless decorators, which memoize
 based on parameters, but not on context::
 
-    >>> print msg3.getAnotherMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg3.getAnotherMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: so long, cruel world& raise--roofbeams
 
-    >>> print msg2.getAnotherMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg2.getAnotherMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: so long, cruel world& raise--roofbeams
 
diff --git a/plone/memoize/volatile.py b/plone/memoize/volatile.py
index 30d9dcc..e6854b9 100644
--- a/plone/memoize/volatile.py
+++ b/plone/memoize/volatile.py
@@ -33,7 +33,7 @@ def __setitem__(self, key, value):
     def _cleanup(self):
         now = time.time()
         okay = now - self.cleanup_period
-        for key, timestamp in self._last_access.items():
+        for key, timestamp in list(self._last_access.items()):
             if timestamp < okay:
                 del self._last_access[key]
                 super(CleanupDict, self).__delitem__(key)
diff --git a/plone/memoize/volatile.rst b/plone/memoize/volatile.rst
index 844906f..2fd6e74 100644
--- a/plone/memoize/volatile.rst
+++ b/plone/memoize/volatile.rst
@@ -15,7 +15,7 @@ Let's say we have a class with an expensive method `pow` that we want to cache::
 
     >>> class MyClass:
     ...     def pow(self, first, second):
-    ...         print 'Someone or something called me'
+    ...         print('Someone or something called me')
     ...         return first ** second
 
 Okay, we know that if the `first` and `second` arguments are the same, the result is going to be the same, always.
@@ -35,7 +35,7 @@ Let's define our first class again, this time with a cached `pow` method::
     >>> class MyClass:
     ...     @cache(cache_key)
     ...     def pow(self, first, second):
-    ...         print 'Someone or something called me'
+    ...         print('Someone or something called me')
     ...         return first ** second
 
 The results::
@@ -94,7 +94,7 @@ Note how we provide both the cache key generator and the cache storage as argume
 
     >>> @cache(cache_key, cache_storage)
     ... def pow(first, second):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return first ** second
 
 Let's try it out::
@@ -124,7 +124,7 @@ A cache key generator may also raise DontCache to indicate that no caching shoul
     ...         return (first, second)
     >>> @cache(cache_key, cache_storage)
     ... def pow(first, second):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return first ** second
 
     >>> pow(3, 2)
diff --git a/setup.py b/setup.py
index 9e3d131..df680ed 100644
--- a/setup.py
+++ b/setup.py
@@ -46,6 +46,7 @@ def read(*rnames):
     namespace_packages=['plone'],
     include_package_data=True,
     zip_safe=False,
+    test_suite='plone.memoize.tests.test_suite',
     extras_require=dict(
         test=[
             'zope.configuration',


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-01T20:54:25+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/550d84aa8d0ea956f14680893e10d1e502eb4258

ignore *.pyc

Files changed:
M .gitignore

diff --git a/.gitignore b/.gitignore
index fc4a60c..a7511ea 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,3 +4,4 @@ __pycache__
 *.bak
 *.egg-info
 /develop-eggs
+*.py[co]


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-01T20:56:29+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/6fc26564ef7351f2fbfe99997dec542bb82689cc

update trove classifiers with Python 3 support

Files changed:
M setup.py

diff --git a/setup.py b/setup.py
index df680ed..30da9cd 100644
--- a/setup.py
+++ b/setup.py
@@ -36,6 +36,8 @@ def read(*rnames):
         "Programming Language :: Python",
         "Programming Language :: Python :: 2.6",
         "Programming Language :: Python :: 2.7",
+        "Programming Language :: Python :: 3.4",
+        "Programming Language :: Python :: 3.5",
     ],
     keywords='plone memoize decorator cache',
     author='Plone Foundation',


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-01T21:01:49+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/9de7f5d672398a7da1896cc1616c321e0c09fd20

use six to handle string/unicode processing (it is a dependency already)

Files changed:
M plone/memoize/ram.py
M setup.py

diff --git a/plone/memoize/ram.py b/plone/memoize/ram.py
index e9bb967..245de3d 100644
--- a/plone/memoize/ram.py
+++ b/plone/memoize/ram.py
@@ -9,6 +9,8 @@
 from zope.ramcache import ram
 from zope.ramcache.interfaces.ram import IRAMCache
 
+import six
+
 try:
     import pickle  # Python 3
 except ImportError:
@@ -43,7 +45,7 @@ def __init__(self, client, globalkey=''):
         self.globalkey = globalkey and '%s:' % globalkey
 
     def _make_key(self, source):
-        if isinstance(source, str):
+        if issubclass(six.text_type)
             source = source.encode('utf-8')
         return md5(source).hexdigest()
 
@@ -66,7 +68,7 @@ def __init__(self, ramcache, globalkey=''):
         self.globalkey = globalkey
 
     def _make_key(self, source):
-        if isinstance(source, str):
+        if issubclass(six.text_type)
             source = source.encode('utf-8')
         return md5(source).digest()
 
diff --git a/setup.py b/setup.py
index 30da9cd..89d6d52 100644
--- a/setup.py
+++ b/setup.py
@@ -57,6 +57,7 @@ def read(*rnames):
     ),
     install_requires=[
         'setuptools',
+        'six',
         'zope.annotation',
         'zope.component',
         'zope.interface',


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-02T09:17:19+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/32aee5fe4fa4f28eea52158652d76ef4f9dc1f3b

fixed text type check

Files changed:
M plone/memoize/ram.py

diff --git a/plone/memoize/ram.py b/plone/memoize/ram.py
index 245de3d..1db6e38 100644
--- a/plone/memoize/ram.py
+++ b/plone/memoize/ram.py
@@ -45,7 +45,7 @@ def __init__(self, client, globalkey=''):
         self.globalkey = globalkey and '%s:' % globalkey
 
     def _make_key(self, source):
-        if issubclass(six.text_type)
+        if issubclass(type(source), six.text_type):
             source = source.encode('utf-8')
         return md5(source).hexdigest()
 
@@ -68,7 +68,7 @@ def __init__(self, ramcache, globalkey=''):
         self.globalkey = globalkey
 
     def _make_key(self, source):
-        if issubclass(six.text_type)
+        if issubclass(type(source), six.text_type):
             source = source.encode('utf-8')
         return md5(source).digest()
 


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-02T18:56:57+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/9d06823d87ffa343760c50df4d02ca1e3faedc10

added travis and tox config

Files changed:
A .travis.yml
A tox.ini

diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 0000000..e06867a
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,20 @@
+language: python
+sudo: false
+matrix:
+  include:
+    - python: 3.5
+      env: TOXENV=py35
+env:
+    - TOXENV=py26
+    - TOXENV=py27
+    - TOXENV=py32
+    - TOXENV=py33
+    - TOXENV=py34
+    - TOXENV=pypy
+    - TOXENV=pypy3
+install:
+    - pip install tox
+script:
+    - tox --develop
+notifications:
+    email: false
diff --git a/tox.ini b/tox.ini
new file mode 100644
index 0000000..300f396
--- /dev/null
+++ b/tox.ini
@@ -0,0 +1,23 @@
+[tox]
+envlist =
+#   py26,py27,py34,py35,pypy3,coverage
+   coverage
+
+[testenv]
+deps =
+    plone.memoize [test]
+    zope.testrunner
+commands =
+    zope-testrunner --test-path=.
+
+[testenv:coverage]
+basepython =
+    python2.7
+usedevelop = true
+commands =
+    coverage run --source=plone.memoize -m zope.testrunner --test-path=.
+    coverage report
+deps =
+    plone.memoize [test]
+    zope.testrunner
+    coverage


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-02T18:57:10+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/805566285d4b940ca88d3dacc7f2fe5aa8a8487f

add coverage script in buildout

Files changed:
M .gitignore
M buildout.cfg
M setup.py

diff --git a/.gitignore b/.gitignore
index a7511ea..496058b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,3 +5,7 @@ __pycache__
 *.egg-info
 /develop-eggs
 *.py[co]
+.tox
+.eggs
+.coverage
+/htmlcov
diff --git a/buildout.cfg b/buildout.cfg
index 10c37a2..392c74e 100644
--- a/buildout.cfg
+++ b/buildout.cfg
@@ -1,8 +1,15 @@
 [buildout]
 develop = .
-parts = test
+parts = test createcoverage
 
 [test]
 recipe = zc.recipe.testrunner
 eggs =
    plone.memoize [test]
+
+[createcoverage]
+recipe = zc.recipe.egg
+dependent-scripts = true
+eggs =
+   createcoverage
+   ${test:eggs}
diff --git a/setup.py b/setup.py
index 89d6d52..0245975 100644
--- a/setup.py
+++ b/setup.py
@@ -53,6 +53,7 @@ def read(*rnames):
         test=[
             'zope.configuration',
             'zope.publisher',
+            'zope.testrunner',
         ]
     ),
     install_requires=[


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-02T18:58:53+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/6cd2f82168bcee7956433af33a6c12154e9566cb

enable all test options in tox.ini

Files changed:
M tox.ini

diff --git a/tox.ini b/tox.ini
index 300f396..d423e86 100644
--- a/tox.ini
+++ b/tox.ini
@@ -1,7 +1,6 @@
 [tox]
 envlist =
-#   py26,py27,py34,py35,pypy3,coverage
-   coverage
+   py26,py27,py34,py35,pypy3,coverage
 
 [testenv]
 deps =


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-04T19:18:29+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/a85eb43e057272cce10d0aecaa80fe85a3752ebd

add travis badge

Files changed:
M README.rst

diff --git a/README.rst b/README.rst
index c2542a0..d1f82a8 100644
--- a/README.rst
+++ b/README.rst
@@ -1,6 +1,9 @@
 plone.memoize
 =============
 
+.. image:: https://travis-ci.org/plone/plone.memoize.svg?branch=master
+       :target: https://travis-ci.org/plone/plone.memoize
+
 plone.memoize provides Python function decorators for caching the
 values of functions and methods.
 


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-04T19:35:00+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/9ed891fa7e17fb4c4239b9d259eeed87797752ab

use ordered dict to make tests safe and remove tests for Python 2.6

Files changed:
M plone/memoize/instance.rst
M tox.ini

diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index ad09032..bd7fb5a 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -132,7 +132,11 @@ Our shebang appears::
 
 Our message to faulkner now is semantically correct::
 
-    >>> ins = dict(tale='told by idiot', signify='nothing')
+    >>> try:
+    ...     from collections import OrderedDict
+    ... except ImportError:
+    ...     OrderedDict = dict    # Python 2.6 but this can fail randomly
+    >>> ins = OrderedDict(tale='told by idiot', signify='nothing')
     >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world#! tale--told by idiot signify--nothing
 
diff --git a/tox.ini b/tox.ini
index d423e86..cda2f7a 100644
--- a/tox.ini
+++ b/tox.ini
@@ -1,6 +1,6 @@
 [tox]
 envlist =
-   py26,py27,py34,py35,pypy3,coverage
+   py27,py34,py35,pypy3,coverage
 
 [testenv]
 deps =


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-04T19:36:28+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/39522d25ec1c7fbed4c3e35df9ea22e2aef55017

remove Python 2.6 from supported (tested versions)

Files changed:
M setup.py

diff --git a/setup.py b/setup.py
index 0245975..a9d7eb9 100644
--- a/setup.py
+++ b/setup.py
@@ -34,7 +34,6 @@ def read(*rnames):
         "License :: OSI Approved :: GNU General Public License (GPL)",
         "Operating System :: OS Independent",
         "Programming Language :: Python",
-        "Programming Language :: Python :: 2.6",
         "Programming Language :: Python :: 2.7",
         "Programming Language :: Python :: 3.4",
         "Programming Language :: Python :: 3.5",


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-04T19:38:23+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/c1eab2270f50c8ed57567c1c24342a4081ff7dd0

only test supported versions in travis

Files changed:
M .travis.yml

diff --git a/.travis.yml b/.travis.yml
index e06867a..5dd4fef 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -5,9 +5,7 @@ matrix:
     - python: 3.5
       env: TOXENV=py35
 env:
-    - TOXENV=py26
     - TOXENV=py27
-    - TOXENV=py32
     - TOXENV=py33
     - TOXENV=py34
     - TOXENV=pypy


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-04T19:56:45+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/3870bb8873e3069cf9ea21ac753c89022a281f2b

use ordered dict in all view and instance tests

Files changed:
M plone/memoize/instance.rst
M plone/memoize/view.rst

diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index bd7fb5a..9cb73c3 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -104,7 +104,11 @@ We can alter data underneath, but nothing changes::
 
 If we alter the signature, our msg is recalculated, but since mst.txt2 is a memo, only the values passed in change::
 
-    >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
+    >>> try:
+    ...     from collections import OrderedDict
+    ... expcept ImportError:
+    ...     OrderedDict = dict
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
     >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: goodbye cruel world! tale--told by idiot signify--nothing
 
@@ -132,10 +136,6 @@ Our shebang appears::
 
 Our message to faulkner now is semantically correct::
 
-    >>> try:
-    ...     from collections import OrderedDict
-    ... except ImportError:
-    ...     OrderedDict = dict    # Python 2.6 but this can fail randomly
     >>> ins = OrderedDict(tale='told by idiot', signify='nothing')
     >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world#! tale--told by idiot signify--nothing
diff --git a/plone/memoize/view.rst b/plone/memoize/view.rst
index edaac2a..4b88910 100644
--- a/plone/memoize/view.rst
+++ b/plone/memoize/view.rst
@@ -100,7 +100,11 @@ We can alter data underneath, but nothing changes::
 
 If we alter the signature, our msg is recalculated::
 
-    >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
+    >>> try:
+    ...     from collections import OrderedDict
+    ... expcept ImportError:
+    ...     OrderedDict = dict
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
     >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
 
@@ -132,7 +136,7 @@ If we look up the view again on the same object, we will get the same memoized p
     >>> print(msg2.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
     >>> print(msg2.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
 
@@ -156,7 +160,7 @@ However, if we look up the view on another context object, things change::
     >>> print(msg3.getMsg('Ernest'))
     Ernest: so long, cruel world&
 
-    >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
     >>> print(msg3.getMsg('Bill F.', **ins))
     Bill F.: so long, cruel world& tale--told by idiot signify--nothing
 


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-04T19:59:23+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/70c895dcda1de459634d7b97c50098b4ce8aabfb

fixed typo

Files changed:
M plone/memoize/instance.rst
M plone/memoize/view.rst

diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index 9cb73c3..75e91c5 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -106,7 +106,7 @@ If we alter the signature, our msg is recalculated, but since mst.txt2 is a memo
 
     >>> try:
     ...     from collections import OrderedDict
-    ... expcept ImportError:
+    ... except ImportError:
     ...     OrderedDict = dict
     >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
     >>> print(msg.getMsg('Bill F.', **ins))
diff --git a/plone/memoize/view.rst b/plone/memoize/view.rst
index 4b88910..c49f5be 100644
--- a/plone/memoize/view.rst
+++ b/plone/memoize/view.rst
@@ -102,7 +102,7 @@ If we alter the signature, our msg is recalculated::
 
     >>> try:
     ...     from collections import OrderedDict
-    ... expcept ImportError:
+    ... except ImportError:
     ...     OrderedDict = dict
     >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
     >>> print(msg.getMsg('Bill F.', **ins))


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-04T20:07:19+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/067edc10a562155ef829a51deab5e9fec90b5fe1

fixed call of OrderedDict

Files changed:
M plone/memoize/instance.rst

diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index 75e91c5..204662e 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -136,7 +136,7 @@ Our shebang appears::
 
 Our message to faulkner now is semantically correct::
 
-    >>> ins = OrderedDict(tale='told by idiot', signify='nothing')
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
     >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world#! tale--told by idiot signify--nothing
 


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-04T20:29:05+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/5b4e27929eaa7b57a8844c348cbd59e504e9d74c

use lists instead of dicts to preserve order

Files changed:
M plone/memoize/instance.rst
M plone/memoize/view.rst

diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index 204662e..4c22b10 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -23,8 +23,8 @@ Let's try it out w/ a dummy class::
     ...         return '%s world' %self.txt1
     ...
     ...     @instance.memoize
-    ...     def getMsg(self, to, **instruction):
-    ...         lst = ['%s--%s' %t for t in instruction.items()]
+    ...     def getMsg(self, to, instruction):
+    ...         lst = ['%s--%s' %t for t in instruction]
     ...         instxt = ' '.join(lst)
     ...         return ("%s: %s%s %s" %(to, self.txt2, self.bang, instxt)).strip()
     ...
@@ -90,13 +90,13 @@ memojito supports memoization of multiple signatures as long as all signature va
     >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
+    >>> print(msg.getMsg('J.D.', [('raise', 'roofbeams')]))
     J.D.: goodbye cruel world! raise--roofbeams
 
 We can alter data underneath, but nothing changes::
 
     >>> msg.txt1 = 'sound and fury'
-    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
+    >>> print(msg.getMsg('J.D.', [('raise', 'roofbeams')]))
     J.D.: goodbye cruel world! raise--roofbeams
 
     >>> print(msg.getMsg('Ernest'))
@@ -104,21 +104,17 @@ We can alter data underneath, but nothing changes::
 
 If we alter the signature, our msg is recalculated, but since mst.txt2 is a memo, only the values passed in change::
 
-    >>> try:
-    ...     from collections import OrderedDict
-    ... except ImportError:
-    ...     OrderedDict = dict
-    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
-    >>> print(msg.getMsg('Bill F.', **ins))
+    >>> print(msg.getMsg('Bill F.',
+    ...       [('tale', 'told by idiot'), ('signify', 'nothing')]))
     Bill F.: goodbye cruel world! tale--told by idiot signify--nothing
 
-    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
+    >>> print(msg.getMsg('J.D.', [('catcher', 'rye')]))
     J.D.: goodbye cruel world! catcher--rye
 
 If change the bang, the memo remains the same::
 
     >>> msg.bang='#!'
-    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
+    >>> print(msg.getMsg('J.D.', [('catcher', 'rye')]))
     J.D.: goodbye cruel world! catcher--rye
 
     >>> print(msg.getMsg('Ernest'))
@@ -136,8 +132,8 @@ Our shebang appears::
 
 Our message to faulkner now is semantically correct::
 
-    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
-    >>> print(msg.getMsg('Bill F.', **ins))
+    >>> print(msg.getMsg('Bill F.',
+    ...       [('tale', 'told by idiot'), ('signify', 'nothing')]))
     Bill F.: sound and fury world#! tale--told by idiot signify--nothing
 
 Let's make sure that memoized properties which call OTHER memoized properties do the right thing::
diff --git a/plone/memoize/view.rst b/plone/memoize/view.rst
index c49f5be..42aadd2 100644
--- a/plone/memoize/view.rst
+++ b/plone/memoize/view.rst
@@ -86,13 +86,13 @@ We support memoization of multiple signatures as long as all signature values ar
     >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
+    >>> print(msg.getMsg('J.D.', [('raise', 'roofbeams')]))
     J.D.: goodbye cruel world! raise--roofbeams
 
 We can alter data underneath, but nothing changes::
 
     >>> msg.txt1 = 'sound and fury'
-    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
+    >>> print(msg.getMsg('J.D.', [('raise', 'roofbeams')]))
     J.D.: goodbye cruel world! raise--roofbeams
 
     >>> print(msg.getMsg('Ernest'))
@@ -100,21 +100,17 @@ We can alter data underneath, but nothing changes::
 
 If we alter the signature, our msg is recalculated::
 
-    >>> try:
-    ...     from collections import OrderedDict
-    ... except ImportError:
-    ...     OrderedDict = dict
-    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
-    >>> print(msg.getMsg('Bill F.', **ins))
+    >>> print(msg.getMsg('Bill F.',
+    ...       [('tale', 'told by idiot'), ('signify', 'nothing')]))
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
 
-    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
+    >>> print(msg.getMsg('J.D.', [('catcher', 'rye')]))
     J.D.: sound and fury world! catcher--rye
 
 If change the bang, the memo remains the same::
 
     >>> msg.bang='#!'
-    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
+    >>> print(msg.getMsg('J.D.', [('catcher', 'rye')]))
     J.D.: sound and fury world! catcher--rye
 
     >>> print(msg.getMsg('Ernest'))
@@ -130,14 +126,14 @@ If we look up the view again on the same object, we will get the same memoized p
     >>> msg2.txt2
     'hello world'
 
-    >>> print(msg2.getMsg('J.D.', **{'raise':'roofbeams'}))
+    >>> print(msg2.getMsg('J.D.', [('raise', 'roofbeams')]))
     J.D.: goodbye cruel world! raise--roofbeams
 
     >>> print(msg2.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
-    >>> print(msg2.getMsg('Bill F.', **ins))
+    >>> print(msg2.getMsg('Bill F.',
+    ...       [('tale', 'told by idiot'), ('signify', 'nothing')]))
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
 
     >>> print(msg2.getMsg('J.D.', **{'catcher':'rye'}))
@@ -154,7 +150,7 @@ However, if we look up the view on another context object, things change::
     >>> msg3.txt2
     'so long, cruel world'
 
-    >>> print(msg3.getMsg('J.D.', **{'raise':'roofbeams'}))
+    >>> print(msg3.getMsg('J.D.', [('raise', 'roofbeams')]))
     J.D.: so long, cruel world& raise--roofbeams
 
     >>> print(msg3.getMsg('Ernest'))
@@ -170,9 +166,9 @@ However, if we look up the view on another context object, things change::
 This behaviour does not apply to contextless decorators, which memoize
 based on parameters, but not on context::
 
-    >>> print(msg3.getAnotherMsg('J.D.', **{'raise':'roofbeams'}))
+    >>> print(msg3.getAnotherMsg('J.D.', [('raise', 'roofbeams')]))
     J.D.: so long, cruel world& raise--roofbeams
 
-    >>> print(msg2.getAnotherMsg('J.D.', **{'raise':'roofbeams'}))
+    >>> print(msg2.getAnotherMsg('J.D.', [('raise', 'roofbeams')]))
     J.D.: so long, cruel world& raise--roofbeams
 


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-04T20:30:03+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/b95f71fceac6e6573562c33d8d7e5a9683af6c48

we can claim an test python 2.6 compatibility again

Files changed:
M .travis.yml
M setup.py
M tox.ini

diff --git a/.travis.yml b/.travis.yml
index 5dd4fef..67d9789 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -5,6 +5,7 @@ matrix:
     - python: 3.5
       env: TOXENV=py35
 env:
+    - TOXENV=py26
     - TOXENV=py27
     - TOXENV=py33
     - TOXENV=py34
diff --git a/setup.py b/setup.py
index a9d7eb9..0245975 100644
--- a/setup.py
+++ b/setup.py
@@ -34,6 +34,7 @@ def read(*rnames):
         "License :: OSI Approved :: GNU General Public License (GPL)",
         "Operating System :: OS Independent",
         "Programming Language :: Python",
+        "Programming Language :: Python :: 2.6",
         "Programming Language :: Python :: 2.7",
         "Programming Language :: Python :: 3.4",
         "Programming Language :: Python :: 3.5",
diff --git a/tox.ini b/tox.ini
index cda2f7a..d423e86 100644
--- a/tox.ini
+++ b/tox.ini
@@ -1,6 +1,6 @@
 [tox]
 envlist =
-   py27,py34,py35,pypy3,coverage
+   py26,py27,py34,py35,pypy3,coverage
 
 [testenv]
 deps =


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-05T15:14:24+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/d0a693951daee18307bb03ac4077e03a75c6141a

Revert "use lists instead of dicts to preserve order"

This reverts commit 5b4e27929eaa7b57a8844c348cbd59e504e9d74c.

Files changed:
M plone/memoize/instance.rst
M plone/memoize/view.rst

diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index 4c22b10..204662e 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -23,8 +23,8 @@ Let's try it out w/ a dummy class::
     ...         return '%s world' %self.txt1
     ...
     ...     @instance.memoize
-    ...     def getMsg(self, to, instruction):
-    ...         lst = ['%s--%s' %t for t in instruction]
+    ...     def getMsg(self, to, **instruction):
+    ...         lst = ['%s--%s' %t for t in instruction.items()]
     ...         instxt = ' '.join(lst)
     ...         return ("%s: %s%s %s" %(to, self.txt2, self.bang, instxt)).strip()
     ...
@@ -90,13 +90,13 @@ memojito supports memoization of multiple signatures as long as all signature va
     >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> print(msg.getMsg('J.D.', [('raise', 'roofbeams')]))
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
 We can alter data underneath, but nothing changes::
 
     >>> msg.txt1 = 'sound and fury'
-    >>> print(msg.getMsg('J.D.', [('raise', 'roofbeams')]))
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
     >>> print(msg.getMsg('Ernest'))
@@ -104,17 +104,21 @@ We can alter data underneath, but nothing changes::
 
 If we alter the signature, our msg is recalculated, but since mst.txt2 is a memo, only the values passed in change::
 
-    >>> print(msg.getMsg('Bill F.',
-    ...       [('tale', 'told by idiot'), ('signify', 'nothing')]))
+    >>> try:
+    ...     from collections import OrderedDict
+    ... except ImportError:
+    ...     OrderedDict = dict
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
+    >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: goodbye cruel world! tale--told by idiot signify--nothing
 
-    >>> print(msg.getMsg('J.D.', [('catcher', 'rye')]))
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: goodbye cruel world! catcher--rye
 
 If change the bang, the memo remains the same::
 
     >>> msg.bang='#!'
-    >>> print(msg.getMsg('J.D.', [('catcher', 'rye')]))
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: goodbye cruel world! catcher--rye
 
     >>> print(msg.getMsg('Ernest'))
@@ -132,8 +136,8 @@ Our shebang appears::
 
 Our message to faulkner now is semantically correct::
 
-    >>> print(msg.getMsg('Bill F.',
-    ...       [('tale', 'told by idiot'), ('signify', 'nothing')]))
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
+    >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world#! tale--told by idiot signify--nothing
 
 Let's make sure that memoized properties which call OTHER memoized properties do the right thing::
diff --git a/plone/memoize/view.rst b/plone/memoize/view.rst
index 42aadd2..c49f5be 100644
--- a/plone/memoize/view.rst
+++ b/plone/memoize/view.rst
@@ -86,13 +86,13 @@ We support memoization of multiple signatures as long as all signature values ar
     >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> print(msg.getMsg('J.D.', [('raise', 'roofbeams')]))
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
 We can alter data underneath, but nothing changes::
 
     >>> msg.txt1 = 'sound and fury'
-    >>> print(msg.getMsg('J.D.', [('raise', 'roofbeams')]))
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
     >>> print(msg.getMsg('Ernest'))
@@ -100,17 +100,21 @@ We can alter data underneath, but nothing changes::
 
 If we alter the signature, our msg is recalculated::
 
-    >>> print(msg.getMsg('Bill F.',
-    ...       [('tale', 'told by idiot'), ('signify', 'nothing')]))
+    >>> try:
+    ...     from collections import OrderedDict
+    ... except ImportError:
+    ...     OrderedDict = dict
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
+    >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
 
-    >>> print(msg.getMsg('J.D.', [('catcher', 'rye')]))
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: sound and fury world! catcher--rye
 
 If change the bang, the memo remains the same::
 
     >>> msg.bang='#!'
-    >>> print(msg.getMsg('J.D.', [('catcher', 'rye')]))
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: sound and fury world! catcher--rye
 
     >>> print(msg.getMsg('Ernest'))
@@ -126,14 +130,14 @@ If we look up the view again on the same object, we will get the same memoized p
     >>> msg2.txt2
     'hello world'
 
-    >>> print(msg2.getMsg('J.D.', [('raise', 'roofbeams')]))
+    >>> print(msg2.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
     >>> print(msg2.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> print(msg2.getMsg('Bill F.',
-    ...       [('tale', 'told by idiot'), ('signify', 'nothing')]))
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
+    >>> print(msg2.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
 
     >>> print(msg2.getMsg('J.D.', **{'catcher':'rye'}))
@@ -150,7 +154,7 @@ However, if we look up the view on another context object, things change::
     >>> msg3.txt2
     'so long, cruel world'
 
-    >>> print(msg3.getMsg('J.D.', [('raise', 'roofbeams')]))
+    >>> print(msg3.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: so long, cruel world& raise--roofbeams
 
     >>> print(msg3.getMsg('Ernest'))
@@ -166,9 +170,9 @@ However, if we look up the view on another context object, things change::
 This behaviour does not apply to contextless decorators, which memoize
 based on parameters, but not on context::
 
-    >>> print(msg3.getAnotherMsg('J.D.', [('raise', 'roofbeams')]))
+    >>> print(msg3.getAnotherMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: so long, cruel world& raise--roofbeams
 
-    >>> print(msg2.getAnotherMsg('J.D.', [('raise', 'roofbeams')]))
+    >>> print(msg2.getAnotherMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: so long, cruel world& raise--roofbeams
 


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-05T15:16:33+01:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/5d512b177c7716edbdadb02d0a796fdc275a9574

sort entries in getMsg method to have stable testing results

Files changed:
M plone/memoize/instance.rst
M plone/memoize/view.rst

diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index 204662e..f05919d 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -24,7 +24,7 @@ Let's try it out w/ a dummy class::
     ...
     ...     @instance.memoize
     ...     def getMsg(self, to, **instruction):
-    ...         lst = ['%s--%s' %t for t in instruction.items()]
+    ...         lst = ['%s--%s' %t for t in sorted(instruction.items(), reverse=True)]
     ...         instxt = ' '.join(lst)
     ...         return ("%s: %s%s %s" %(to, self.txt2, self.bang, instxt)).strip()
     ...
diff --git a/plone/memoize/view.rst b/plone/memoize/view.rst
index c49f5be..75da470 100644
--- a/plone/memoize/view.rst
+++ b/plone/memoize/view.rst
@@ -34,7 +34,7 @@ First we set up a dummy view::
     ...
     ...     @view.memoize
     ...     def getMsg(self, to, **instruction):
-    ...         lst = ['%s--%s' %t for t in instruction.items()]
+    ...         lst = ['%s--%s' %t for t in sorted(instruction.items(), reverse=True)]
     ...         instxt = ' '.join(lst)
     ...         return ("%s: %s world%s %s" %(to, self.txt1, self.bang, instxt)).strip()
     ...


Repository: plone.memoize


Branch: refs/heads/master
Date: 2016-02-08T12:19:55+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/23a70a4aca571b7c25e84675c0dba7115e7408ea

Merge pull request #4 from plone/tomgross-python3

Python 3 compatibility

Files changed:
A .gitignore
A .travis.yml
A bootstrap-buildout.py
A buildout.cfg
A tox.ini
M README.rst
M plone/memoize/compress.py
M plone/memoize/compress.rst
M plone/memoize/forever.rst
M plone/memoize/instance.rst
M plone/memoize/ram.py
M plone/memoize/ram.rst
M plone/memoize/request.py
M plone/memoize/request.rst
M plone/memoize/view.rst
M plone/memoize/volatile.py
M plone/memoize/volatile.rst
M setup.py

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..496058b
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,11 @@
+.installed.cfg
+/bin
+__pycache__
+*.bak
+*.egg-info
+/develop-eggs
+*.py[co]
+.tox
+.eggs
+.coverage
+/htmlcov
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 0000000..67d9789
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,19 @@
+language: python
+sudo: false
+matrix:
+  include:
+    - python: 3.5
+      env: TOXENV=py35
+env:
+    - TOXENV=py26
+    - TOXENV=py27
+    - TOXENV=py33
+    - TOXENV=py34
+    - TOXENV=pypy
+    - TOXENV=pypy3
+install:
+    - pip install tox
+script:
+    - tox --develop
+notifications:
+    email: false
diff --git a/README.rst b/README.rst
index c2542a0..d1f82a8 100644
--- a/README.rst
+++ b/README.rst
@@ -1,6 +1,9 @@
 plone.memoize
 =============
 
+.. image:: https://travis-ci.org/plone/plone.memoize.svg?branch=master
+       :target: https://travis-ci.org/plone/plone.memoize
+
 plone.memoize provides Python function decorators for caching the
 values of functions and methods.
 
diff --git a/bootstrap-buildout.py b/bootstrap-buildout.py
new file mode 100644
index 0000000..a459921
--- /dev/null
+++ b/bootstrap-buildout.py
@@ -0,0 +1,210 @@
+##############################################################################
+#
+# Copyright (c) 2006 Zope Foundation and Contributors.
+# All Rights Reserved.
+#
+# This software is subject to the provisions of the Zope Public License,
+# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
+# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
+# FOR A PARTICULAR PURPOSE.
+#
+##############################################################################
+"""Bootstrap a buildout-based project
+
+Simply run this script in a directory containing a buildout.cfg.
+The script accepts buildout command-line options, so you can
+use the -c option to specify an alternate configuration file.
+"""
+
+import os
+import shutil
+import sys
+import tempfile
+
+from optparse import OptionParser
+
+__version__ = '2015-07-01'
+# See zc.buildout's changelog if this version is up to date.
+
+tmpeggs = tempfile.mkdtemp(prefix='bootstrap-')
+
+usage = '''\
+[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]
+
+Bootstraps a buildout-based project.
+
+Simply run this script in a directory containing a buildout.cfg, using the
+Python that you want bin/buildout to use.
+
+Note that by using --find-links to point to local resources, you can keep
+this script from going over the network.
+'''
+
+parser = OptionParser(usage=usage)
+parser.add_option("--version",
+                  action="store_true", default=False,
+                  help=("Return bootstrap.py version."))
+parser.add_option("-t", "--accept-buildout-test-releases",
+                  dest='accept_buildout_test_releases',
+                  action="store_true", default=False,
+                  help=("Normally, if you do not specify a --version, the "
+                        "bootstrap script and buildout gets the newest "
+                        "*final* versions of zc.buildout and its recipes and "
+                        "extensions for you.  If you use this flag, "
+                        "bootstrap and buildout will get the newest releases "
+                        "even if they are alphas or betas."))
+parser.add_option("-c", "--config-file",
+                  help=("Specify the path to the buildout configuration "
+                        "file to be used."))
+parser.add_option("-f", "--find-links",
+                  help=("Specify a URL to search for buildout releases"))
+parser.add_option("--allow-site-packages",
+                  action="store_true", default=False,
+                  help=("Let bootstrap.py use existing site packages"))
+parser.add_option("--buildout-version",
+                  help="Use a specific zc.buildout version")
+parser.add_option("--setuptools-version",
+                  help="Use a specific setuptools version")
+parser.add_option("--setuptools-to-dir",
+                  help=("Allow for re-use of existing directory of "
+                        "setuptools versions"))
+
+options, args = parser.parse_args()
+if options.version:
+    print("bootstrap.py version %s" % __version__)
+    sys.exit(0)
+
+
+######################################################################
+# load/install setuptools
+
+try:
+    from urllib.request import urlopen
+except ImportError:
+    from urllib2 import urlopen
+
+ez = {}
+if os.path.exists('ez_setup.py'):
+    exec(open('ez_setup.py').read(), ez)
+else:
+    exec(urlopen('https://bootstrap.pypa.io/ez_setup.py').read(), ez)
+
+if not options.allow_site_packages:
+    # ez_setup imports site, which adds site packages
+    # this will remove them from the path to ensure that incompatible versions
+    # of setuptools are not in the path
+    import site
+    # inside a virtualenv, there is no 'getsitepackages'.
+    # We can't remove these reliably
+    if hasattr(site, 'getsitepackages'):
+        for sitepackage_path in site.getsitepackages():
+            # Strip all site-packages directories from sys.path that
+            # are not sys.prefix; this is because on Windows
+            # sys.prefix is a site-package directory.
+            if sitepackage_path != sys.prefix:
+                sys.path[:] = [x for x in sys.path
+                               if sitepackage_path not in x]
+
+setup_args = dict(to_dir=tmpeggs, download_delay=0)
+
+if options.setuptools_version is not None:
+    setup_args['version'] = options.setuptools_version
+if options.setuptools_to_dir is not None:
+    setup_args['to_dir'] = options.setuptools_to_dir
+
+ez['use_setuptools'](**setup_args)
+import setuptools
+import pkg_resources
+
+# This does not (always?) update the default working set.  We will
+# do it.
+for path in sys.path:
+    if path not in pkg_resources.working_set.entries:
+        pkg_resources.working_set.add_entry(path)
+
+######################################################################
+# Install buildout
+
+ws = pkg_resources.working_set
+
+setuptools_path = ws.find(
+    pkg_resources.Requirement.parse('setuptools')).location
+
+# Fix sys.path here as easy_install.pth added before PYTHONPATH
+cmd = [sys.executable, '-c',
+       'import sys; sys.path[0:0] = [%r]; ' % setuptools_path +
+       'from setuptools.command.easy_install import main; main()',
+       '-mZqNxd', tmpeggs]
+
+find_links = os.environ.get(
+    'bootstrap-testing-find-links',
+    options.find_links or
+    ('http://downloads.buildout.org/'
+     if options.accept_buildout_test_releases else None)
+    )
+if find_links:
+    cmd.extend(['-f', find_links])
+
+requirement = 'zc.buildout'
+version = options.buildout_version
+if version is None and not options.accept_buildout_test_releases:
+    # Figure out the most recent final version of zc.buildout.
+    import setuptools.package_index
+    _final_parts = '*final-', '*final'
+
+    def _final_version(parsed_version):
+        try:
+            return not parsed_version.is_prerelease
+        except AttributeError:
+            # Older setuptools
+            for part in parsed_version:
+                if (part[:1] == '*') and (part not in _final_parts):
+                    return False
+            return True
+
+    index = setuptools.package_index.PackageIndex(
+        search_path=[setuptools_path])
+    if find_links:
+        index.add_find_links((find_links,))
+    req = pkg_resources.Requirement.parse(requirement)
+    if index.obtain(req) is not None:
+        best = []
+        bestv = None
+        for dist in index[req.project_name]:
+            distv = dist.parsed_version
+            if _final_version(distv):
+                if bestv is None or distv > bestv:
+                    best = [dist]
+                    bestv = distv
+                elif distv == bestv:
+                    best.append(dist)
+        if best:
+            best.sort()
+            version = best[-1].version
+if version:
+    requirement = '=='.join((requirement, version))
+cmd.append(requirement)
+
+import subprocess
+if subprocess.call(cmd) != 0:
+    raise Exception(
+        "Failed to execute command:\n%s" % repr(cmd)[1:-1])
+
+######################################################################
+# Import and run buildout
+
+ws.add_entry(tmpeggs)
+ws.require(requirement)
+import zc.buildout.buildout
+
+if not [a for a in args if '=' not in a]:
+    args.append('bootstrap')
+
+# if -c was provided, we push it back into args for buildout' main function
+if options.config_file is not None:
+    args[0:0] = ['-c', options.config_file]
+
+zc.buildout.buildout.main(args)
+shutil.rmtree(tmpeggs)
diff --git a/buildout.cfg b/buildout.cfg
new file mode 100644
index 0000000..392c74e
--- /dev/null
+++ b/buildout.cfg
@@ -0,0 +1,15 @@
+[buildout]
+develop = .
+parts = test createcoverage
+
+[test]
+recipe = zc.recipe.testrunner
+eggs =
+   plone.memoize [test]
+
+[createcoverage]
+recipe = zc.recipe.egg
+dependent-scripts = true
+eggs =
+   createcoverage
+   ${test:eggs}
diff --git a/plone/memoize/compress.py b/plone/memoize/compress.py
index 569bd3a..bbb62a9 100644
--- a/plone/memoize/compress.py
+++ b/plone/memoize/compress.py
@@ -4,7 +4,7 @@
 
 from plone.memoize.interfaces import IXHTMLCompressor
 from zope.component import queryUtility
-from zope.interface import implements
+from zope.interface import implementer
 
 SLIMMER = True
 try:
@@ -19,11 +19,9 @@ def xhtml_compress(string):
         return util.compress(string)
     return string
 
-
+@implementer(IXHTMLCompressor)
 class XHTMLSlimmer(object):
 
-    implements(IXHTMLCompressor)
-
     def compress(self, string):
         if SLIMMER:
             return xhtml_slimmer(string)
diff --git a/plone/memoize/compress.rst b/plone/memoize/compress.rst
index 017a527..5247931 100644
--- a/plone/memoize/compress.rst
+++ b/plone/memoize/compress.rst
@@ -10,8 +10,7 @@ Make necessary imports::
 
     >>> from plone.memoize.compress import xhtml_compress
     >>> from plone.memoize.interfaces import IXHTMLCompressor
-    >>> from zope.interface import implements
-
+    >>> from zope.interface import implementer
 
 
 You can register other XHTML-whitespace removal libraries as well.
@@ -25,8 +24,8 @@ Per default there is no compressor available and we get the same string back::
 Make a stupid lowercasing compressor.
 This is not safe as it would lowercase all text outside of tags as well::
 
-    >>> class LowerCaser(object):
-    ...     implements(IXHTMLCompressor)
+    >>> @implementer(IXHTMLCompressor)
+    ... class LowerCaser(object):
     ...
     ...     def compress(self, string):
     ...         return string.lower()
@@ -39,6 +38,6 @@ Register our new compressor::
     >>> sm = getSiteManager()
     >>> sm.registerUtility(lower)
 
-    >>> xhtml_compress(html_string)
-    u'<html><body><span>hello.</span></body><html>'
+    >>> str(xhtml_compress(html_string))
+    '<html><body><span>hello.</span></body><html>'
 
diff --git a/plone/memoize/forever.rst b/plone/memoize/forever.rst
index 0362399..7598079 100644
--- a/plone/memoize/forever.rst
+++ b/plone/memoize/forever.rst
@@ -14,7 +14,7 @@ They work on both global functions and class functions.::
 
     >>> @forever.memoize
     ... def remember(arg1, arg2):
-    ...     print "Calculating"
+    ...     print("Calculating")
     ...     return arg1 + arg2
 
 No matter how many times we call this function with a particular set of arguments, it will only perform its calculation once::
@@ -36,7 +36,7 @@ This also works for methods in classes::
     ...
     ...     @forever.memoize
     ...     def remember(self, arg1, arg2):
-    ...         print "Calculating"
+    ...         print("Calculating")
     ...         return arg1 + arg2
 
     >>> t = Test()
diff --git a/plone/memoize/instance.rst b/plone/memoize/instance.rst
index bb35599..f05919d 100644
--- a/plone/memoize/instance.rst
+++ b/plone/memoize/instance.rst
@@ -24,7 +24,7 @@ Let's try it out w/ a dummy class::
     ...
     ...     @instance.memoize
     ...     def getMsg(self, to, **instruction):
-    ...         lst = ['%s--%s' %t for t in instruction.items()]
+    ...         lst = ['%s--%s' %t for t in sorted(instruction.items(), reverse=True)]
     ...         instxt = ' '.join(lst)
     ...         return ("%s: %s%s %s" %(to, self.txt2, self.bang, instxt)).strip()
     ...
@@ -87,63 +87,67 @@ Now we can test the clear before, which does the opposite from the clear after,
 
 memojito supports memoization of multiple signatures as long as all signature values are hashable::
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
 We can alter data underneath, but nothing changes::
 
     >>> msg.txt1 = 'sound and fury'
-    >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
 If we alter the signature, our msg is recalculated, but since mst.txt2 is a memo, only the values passed in change::
 
-    >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
-    >>> print msg.getMsg('Bill F.', **ins)
+    >>> try:
+    ...     from collections import OrderedDict
+    ... except ImportError:
+    ...     OrderedDict = dict
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
+    >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: goodbye cruel world! tale--told by idiot signify--nothing
 
-    >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: goodbye cruel world! catcher--rye
 
 If change the bang, the memo remains the same::
 
     >>> msg.bang='#!'
-    >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: goodbye cruel world! catcher--rye
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
 clearing works the same as for properties::
 
-    >>> print msg.clearafter()
+    >>> print(msg.clearafter())
     goodbye cruel world
 
 Our shebang appears::
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: sound and fury world#!
 
 Our message to faulkner now is semantically correct::
 
-    >>> ins = dict(tale='told by idiot', signify='nothing')
-    >>> print msg.getMsg('Bill F.', **ins)
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
+    >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world#! tale--told by idiot signify--nothing
 
 Let's make sure that memoized properties which call OTHER memoized properties do the right thing::
 
     >>> msg = MyMsg('hello')
-    >>> print msg.recurse
+    >>> print(msg.recurse)
     recursive: hello world
 
 Now we make sure that both the txt2 and the recurse values are in the cache::
 
-    >>> print len(msg._memojito_.keys())
+    >>> print(len(msg._memojito_.keys()))
     2
 
diff --git a/plone/memoize/ram.py b/plone/memoize/ram.py
index d07825d..1db6e38 100644
--- a/plone/memoize/ram.py
+++ b/plone/memoize/ram.py
@@ -8,7 +8,13 @@
 from zope import interface
 from zope.ramcache import ram
 from zope.ramcache.interfaces.ram import IRAMCache
-import cPickle
+
+import six
+
+try:
+    import pickle  # Python 3
+except ImportError:
+    import cPickle as pickle  # Python 2
 
 try:
     from hashlib import md5
@@ -39,7 +45,7 @@ def __init__(self, client, globalkey=''):
         self.globalkey = globalkey and '%s:' % globalkey
 
     def _make_key(self, source):
-        if isinstance(source, unicode):
+        if issubclass(type(source), six.text_type):
             source = source.encode('utf-8')
         return md5(source).hexdigest()
 
@@ -48,10 +54,10 @@ def __getitem__(self, key):
         if cached_value is None:
             raise KeyError(key)
         else:
-            return cPickle.loads(cached_value)
+            return pickle.loads(cached_value)
 
     def __setitem__(self, key, value):
-        cached_value = cPickle.dumps(value)
+        cached_value = pickle.dumps(value)
         self.client.set(self.globalkey + self._make_key(key), cached_value)
 
 
@@ -62,7 +68,7 @@ def __init__(self, ramcache, globalkey=''):
         self.globalkey = globalkey
 
     def _make_key(self, source):
-        if isinstance(source, unicode):
+        if issubclass(type(source), six.text_type):
             source = source.encode('utf-8')
         return md5(source).digest()
 
diff --git a/plone/memoize/ram.rst b/plone/memoize/ram.rst
index 674fdeb..ff47cec 100644
--- a/plone/memoize/ram.rst
+++ b/plone/memoize/ram.rst
@@ -20,7 +20,7 @@ Make necessary imports::
     ...     return (first, second)
     >>> @cache(cache_key)
     ... def pow(first, second):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return first ** second
 
     >>> pow(3, 2)
@@ -33,7 +33,7 @@ Let's cache another function::
 
     >>> @cache(cache_key)
     ... def add(first, second):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return first + second
 
     >>> add(3, 2)
diff --git a/plone/memoize/request.py b/plone/memoize/request.py
index e987ade..e8c4a3f 100644
--- a/plone/memoize/request.py
+++ b/plone/memoize/request.py
@@ -34,7 +34,7 @@ def memogetter(*args, **kwargs):
                 cache = annotations[self.key] = dict()
 
             key = (func.__module__, func.__name__,
-                   args, frozenset(kwargs.items()))
+                   args, frozenset(list(kwargs.items())))
             value = cache.get(key, _marker)
             if value is _marker:
                 value = cache[key] = func(*args, **kwargs)
@@ -59,7 +59,7 @@ def _store_in_annotation(fun, *args, **kwargs):
             expected_num_args = len(spec[0]) - len(spec[3])
         if num_args != expected_num_args:
             raise TypeError("%s() takes exactly %s arguments (%s given)"
-                            % (fun.func_name, expected_num_args, num_args))
+                            % (fun.__name__, expected_num_args, num_args))
 
         for index, name in enumerate(spec[0]):
             if index < num_args:
diff --git a/plone/memoize/request.rst b/plone/memoize/request.rst
index 7bca946..db73285 100644
--- a/plone/memoize/request.rst
+++ b/plone/memoize/request.rst
@@ -11,7 +11,7 @@ Make necessary imports::
 ::
 
     >>> def increment(a):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return a + 1
 
 Now we need to define this `a`.
@@ -42,14 +42,14 @@ We'll tell the decorator to use `args_hash` for generating the key.
     2
     >>> cached_increment(A(1))
     2
-    >>> IAnnotations(A.request)
-    {'None.increment:1': 2}
+    >>> list(IAnnotations(A.request).items())
+    [('None.increment:1', 2)]
 
 If `request` is already part of the function's argument list, we don't need to specify any expression::
 
     >>> @cache(get_key=get_key)
     ... def increment_plus(a, request):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return a + 1
 
     >>> increment_plus(42, A.request)
@@ -65,13 +65,13 @@ For the sake of convenience pass the request explicitly.
 get_key must be modified to take kwargs into account::
 
     >>> def get_key(fun, a, request, **kwargs):
-    ...     li = kwargs.items()
+    ...     li = list(kwargs.items())
     ...     li.sort()
     ...     return "%s,%s" % (a, li)
 
     >>> @cache(get_key=get_key)
     ... def increment_kwargs(a, request, kwarg1=1, kwarg2=2):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return a + 1
 
     >>> increment_kwargs(42, A.request, kwarg1='kwarg1', kwarg2='kwarg2')
diff --git a/plone/memoize/view.rst b/plone/memoize/view.rst
index 827e214..75da470 100644
--- a/plone/memoize/view.rst
+++ b/plone/memoize/view.rst
@@ -9,15 +9,15 @@ This means that the same view can be looked up multiple times and the same memos
 
     >>> from plone.memoize import view
     >>> from zope.component import adapts
-    >>> from zope.interface import implements
+    >>> from zope.interface import implementer
     >>> from zope.interface import Interface
     >>> from zope.publisher.interfaces.browser import IBrowserRequest
     >>> from zope.publisher.interfaces.browser import IBrowserView
 
 First we set up a dummy view::
 
-    >>> class MyView(object):
-    ...     implements(IBrowserView)
+    >>> @implementer(IBrowserView)
+    ... class MyView(object):
     ...     adapts(Interface, IBrowserRequest)
     ...
     ...     def __init__(self, context, request):
@@ -34,7 +34,7 @@ First we set up a dummy view::
     ...
     ...     @view.memoize
     ...     def getMsg(self, to, **instruction):
-    ...         lst = ['%s--%s' %t for t in instruction.items()]
+    ...         lst = ['%s--%s' %t for t in sorted(instruction.items(), reverse=True)]
     ...         instxt = ' '.join(lst)
     ...         return ("%s: %s world%s %s" %(to, self.txt1, self.bang, instxt)).strip()
     ...
@@ -50,8 +50,9 @@ First we set up a dummy view::
 
 We also need a dummy context::
 
-    >>> class Dummy(object):
-    ...     implements(Interface)
+    >>> @implementer(Interface)
+    ... class Dummy(object):
+    ...     pass
 
 Let's look up the view::
 
@@ -82,37 +83,41 @@ Even though we've twiddled txt1, txt2 is not recalculated::
 
 We support memoization of multiple signatures as long as all signature values are hashable::
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
 We can alter data underneath, but nothing changes::
 
     >>> msg.txt1 = 'sound and fury'
-    >>> print msg.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
 If we alter the signature, our msg is recalculated::
 
-    >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
-    >>> print msg.getMsg('Bill F.', **ins)
+    >>> try:
+    ...     from collections import OrderedDict
+    ... except ImportError:
+    ...     OrderedDict = dict
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
+    >>> print(msg.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
 
-    >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: sound and fury world! catcher--rye
 
 If change the bang, the memo remains the same::
 
     >>> msg.bang='#!'
-    >>> print msg.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: sound and fury world! catcher--rye
 
-    >>> print msg.getMsg('Ernest')
+    >>> print(msg.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
 If we look up the view again on the same object, we will get the same memoized properties as before::
@@ -125,17 +130,17 @@ If we look up the view again on the same object, we will get the same memoized p
     >>> msg2.txt2
     'hello world'
 
-    >>> print msg2.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg2.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: goodbye cruel world! raise--roofbeams
 
-    >>> print msg2.getMsg('Ernest')
+    >>> print(msg2.getMsg('Ernest'))
     Ernest: goodbye cruel world!
 
-    >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
-    >>> print msg2.getMsg('Bill F.', **ins)
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
+    >>> print(msg2.getMsg('Bill F.', **ins))
     Bill F.: sound and fury world! tale--told by idiot signify--nothing
 
-    >>> print msg2.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg2.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: sound and fury world! catcher--rye
 
 However, if we look up the view on another context object, things change::
@@ -149,25 +154,25 @@ However, if we look up the view on another context object, things change::
     >>> msg3.txt2
     'so long, cruel world'
 
-    >>> print msg3.getMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg3.getMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: so long, cruel world& raise--roofbeams
 
-    >>> print msg3.getMsg('Ernest')
+    >>> print(msg3.getMsg('Ernest'))
     Ernest: so long, cruel world&
 
-    >>> ins = {'tale':'told by idiot', 'signify':'nothing'}
-    >>> print msg3.getMsg('Bill F.', **ins)
+    >>> ins = OrderedDict([('tale', 'told by idiot'), ('signify', 'nothing')])
+    >>> print(msg3.getMsg('Bill F.', **ins))
     Bill F.: so long, cruel world& tale--told by idiot signify--nothing
 
-    >>> print msg3.getMsg('J.D.', **{'catcher':'rye'})
+    >>> print(msg3.getMsg('J.D.', **{'catcher':'rye'}))
     J.D.: so long, cruel world& catcher--rye
 
 This behaviour does not apply to contextless decorators, which memoize
 based on parameters, but not on context::
 
-    >>> print msg3.getAnotherMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg3.getAnotherMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: so long, cruel world& raise--roofbeams
 
-    >>> print msg2.getAnotherMsg('J.D.', **{'raise':'roofbeams'})
+    >>> print(msg2.getAnotherMsg('J.D.', **{'raise':'roofbeams'}))
     J.D.: so long, cruel world& raise--roofbeams
 
diff --git a/plone/memoize/volatile.py b/plone/memoize/volatile.py
index 30d9dcc..e6854b9 100644
--- a/plone/memoize/volatile.py
+++ b/plone/memoize/volatile.py
@@ -33,7 +33,7 @@ def __setitem__(self, key, value):
     def _cleanup(self):
         now = time.time()
         okay = now - self.cleanup_period
-        for key, timestamp in self._last_access.items():
+        for key, timestamp in list(self._last_access.items()):
             if timestamp < okay:
                 del self._last_access[key]
                 super(CleanupDict, self).__delitem__(key)
diff --git a/plone/memoize/volatile.rst b/plone/memoize/volatile.rst
index 844906f..2fd6e74 100644
--- a/plone/memoize/volatile.rst
+++ b/plone/memoize/volatile.rst
@@ -15,7 +15,7 @@ Let's say we have a class with an expensive method `pow` that we want to cache::
 
     >>> class MyClass:
     ...     def pow(self, first, second):
-    ...         print 'Someone or something called me'
+    ...         print('Someone or something called me')
     ...         return first ** second
 
 Okay, we know that if the `first` and `second` arguments are the same, the result is going to be the same, always.
@@ -35,7 +35,7 @@ Let's define our first class again, this time with a cached `pow` method::
     >>> class MyClass:
     ...     @cache(cache_key)
     ...     def pow(self, first, second):
-    ...         print 'Someone or something called me'
+    ...         print('Someone or something called me')
     ...         return first ** second
 
 The results::
@@ -94,7 +94,7 @@ Note how we provide both the cache key generator and the cache storage as argume
 
     >>> @cache(cache_key, cache_storage)
     ... def pow(first, second):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return first ** second
 
 Let's try it out::
@@ -124,7 +124,7 @@ A cache key generator may also raise DontCache to indicate that no caching shoul
     ...         return (first, second)
     >>> @cache(cache_key, cache_storage)
     ... def pow(first, second):
-    ...     print 'Someone or something called me'
+    ...     print('Someone or something called me')
     ...     return first ** second
 
     >>> pow(3, 2)
diff --git a/setup.py b/setup.py
index 9e3d131..0245975 100644
--- a/setup.py
+++ b/setup.py
@@ -36,6 +36,8 @@ def read(*rnames):
         "Programming Language :: Python",
         "Programming Language :: Python :: 2.6",
         "Programming Language :: Python :: 2.7",
+        "Programming Language :: Python :: 3.4",
+        "Programming Language :: Python :: 3.5",
     ],
     keywords='plone memoize decorator cache',
     author='Plone Foundation',
@@ -46,14 +48,17 @@ def read(*rnames):
     namespace_packages=['plone'],
     include_package_data=True,
     zip_safe=False,
+    test_suite='plone.memoize.tests.test_suite',
     extras_require=dict(
         test=[
             'zope.configuration',
             'zope.publisher',
+            'zope.testrunner',
         ]
     ),
     install_requires=[
         'setuptools',
+        'six',
         'zope.annotation',
         'zope.component',
         'zope.interface',
diff --git a/tox.ini b/tox.ini
new file mode 100644
index 0000000..d423e86
--- /dev/null
+++ b/tox.ini
@@ -0,0 +1,22 @@
+[tox]
+envlist =
+   py26,py27,py34,py35,pypy3,coverage
+
+[testenv]
+deps =
+    plone.memoize [test]
+    zope.testrunner
+commands =
+    zope-testrunner --test-path=.
+
+[testenv:coverage]
+basepython =
+    python2.7
+usedevelop = true
+commands =
+    coverage run --source=plone.memoize -m zope.testrunner --test-path=.
+    coverage report
+deps =
+    plone.memoize [test]
+    zope.testrunner
+    coverage


