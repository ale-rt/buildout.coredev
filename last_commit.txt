Repository: plone.transformchain


Branch: refs/heads/master
Date: 2016-02-15T16:23:30+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.transformchain/commit/8be2c252d08c92f0a64440d0da37cc413f93be48

pep8, make code-analysis happy, rst fixes, doc-style, removal of Zope2.10 specialities

Files changed:
A .isort.cfg
M CHANGES.rst
M README.rst
M docs/INSTALL.txt
M plone/__init__.py
M plone/transformchain/__init__.py
M plone/transformchain/configure.zcml
M plone/transformchain/interfaces.py
M plone/transformchain/tests.py
M plone/transformchain/transformer.py
M plone/transformchain/zpublisher.py
M setup.py

diff --git a/.isort.cfg b/.isort.cfg
new file mode 100644
index 0000000..fb79921
--- /dev/null
+++ b/.isort.cfg
@@ -0,0 +1,5 @@
+[settings]
+force_alphabetical_sort=True
+force_single_line=True
+lines_after_imports=2
+line_length=200
diff --git a/CHANGES.rst b/CHANGES.rst
index 616a087..0866ed5 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,16 +1,18 @@
 Changelog
 =========
 
-1.0.5 (unreleased)
+1.1.0 (unreleased)
 ------------------
 
 New:
 
-- *add item here*
+- Require Zope2 >= 2.13.23
+  [jensens]
 
 Fixes:
 
-- *add item here*
+- PEP8 et al. use zca decorators, ...
+  [jensens]
 
 
 1.0.4 (2015-05-11)
diff --git a/README.rst b/README.rst
index 788bdd3..9a6f25a 100644
--- a/README.rst
+++ b/README.rst
@@ -1,62 +1,53 @@
 Introduction
 ============
 
-This package provides a means of modifying the response from a page published
-with ``repoze.zope2`` or the "classic" ``ZPublisher`` before it is returned to
-the browser.
+``plone.transformchain`` provides methods to modify the response from a page published with ``repoze.zope2`` or the "classic" ``ZPublisher`` before it is returned to the browser.
 
-Register a uniquely named adapter from ``(published, request)`` providing
-the ``ITransform`` interface. ``published`` is the published object, e.g. a
-view; ``request`` is the current request.
+Register a uniquely named adapter from ``(published, request)`` providing the ``ITransform`` interface.
+``published`` is the published object, e.g. a view; ``request`` is the current request.
 
-The order of the transforms can be maintained using the ``order`` property of
-the adapter.
+The order of the transforms can be maintained using the ``order`` property of the adapter.
 
-One of three methods will be called, depending on what type of input was
-obtained from the publisher and/or the previous method.
+One of three methods will be called, depending on what type of input was obtained from the publisher and/or the previous method.
 
-  * transformBytes() is called if the input is a str (bytes) object
-  * transformUnicode() is called if the input is a unicode object
-  * transformIterable() is called if the input is another type of iterable
+  * ``transformBytes()`` is called if the input is a str (bytes) object
+  * ``transformUnicode()`` is called if the input is a unicode object
+  * ``transformIterable()`` is called if the input is another type of iterable
 
 Each stage can return a byte string, a unicode string, or an iterable.
 
-Most transformers will have a "natural" representation of the result, and will
-implement the respective method to return another value of the same
-representation, e.g. implement transformUnicode() to transform and return a
-unicode object. The other methods may then either be implemented to return
-None (do nothing) or convert the value to the appropriate type.
+Most transformers will have a "natural" representation of the result,
+and will implement the respective method to return another value of the same representation,
+e.g. implement transformUnicode() to transform and return a unicode object.
+The other methods may then either be implemented to return None (do nothing) or convert the value to the appropriate type.
 
 The first transformer in the chain is likely to get:
 
-  * A byte string if the transformer is running under the standard Zope 2
-    ZPublisher.
-  * An iterable if the transformer is running under repoze.zope2 or another
-    WSGI pipeline.
+* A byte string if the transformer is running under the standard Zope 2 ZPublisher.
+* An iterable if the transformer is running under repoze.zope2 or another WSGI pipeline.
 
-Check ``self.request.response.getHeader('content-type')`` to see the type of
-result. The iterable, when unwound, will conform to this type, e.g. for
-text/html, ``''.join(result)`` should be an HTML string.
+Check ``self.request.response.getHeader('content-type')`` to see the type of result.
+The iterable, when unwound, will conform to this type, e.g. for "text/html", ``''.join(result)`` should be an HTML string.
 
-The return value is passed to the next transform in the chain. The final
-transform should return a unicode string, an encoded string, or an iterable.
+The return value is passed to the next transform in the chain.
+The final transform should return a unicode string, an encoded string, or an iterable.
 
-If a byte string or unicode string is returned by the last transform in the
-chain, the ``Content-Length`` header will be automatically updated
+If a byte string or unicode string is returned by the last transform in the chain, the ``Content-Length`` header will be automatically updated.
 
-Return ``None`` to signal that the result should not be changed from the
-previous transform.
+Return ``None`` to signal that the result should not be changed from the previous transform.
 
-Here is an example that uppercases everything::
+Here is an example that uppercases everything:
 
-    from zope.interface import implements, Interface
-    from zope.component import adapts
+.. code_block:: python
 
+    from zope.component import adapter
+    from zope.interface import implementer
+    from zope.interface import Interface
     from plone.transformchain.interfaces import ITransform
 
+    @implementer(ITransform)
+    @adapter(Interface, Interface) # any context, any request
     class UpperTransform(object):
-        implements(ITransform)
-        adapts(Interface, Interface) # any context, any request
 
         order = 1000
 
@@ -73,14 +64,15 @@ Here is an example that uppercases everything::
         def transformIterable(self, result, encoding):
             return [s.upper() for s in result]
 
-You could register this in ZCML like so::
+You could register this in ZCML like so:
+
+.. code_block:: xml
 
     <adapter factory=".transforms.UpperTransform" name="example.uppertransform" />
 
-If you need to turn off transformations for a particular request, you can
-set a key in ``request.environ``::
+If you need to turn off transformations for a particular request,
+you can set a key in ``request.environ``::
 
     request.environ['plone.transformchain.disable'] = True
 
-This will leave the response untouched and will not invoke any
-``ITransform`` adapters at all.
+This will leave the response untouched and will not invoke any ``ITransform`` adapters at all.
diff --git a/docs/INSTALL.txt b/docs/INSTALL.txt
index ff052e8..40fc759 100644
--- a/docs/INSTALL.txt
+++ b/docs/INSTALL.txt
@@ -1,12 +1,11 @@
 plone.transformchain Installation
 ---------------------------------
 
-To install plone.transformchain into the global Python environment (or a workingenv),
+To install plone.transformchain into the global Python environment (or a virtualenv),
 using a traditional Zope 2 instance, you can do this:
 
-* When you're reading this you have probably already run
-  ``easy_install plone.transformchain``. Find out how to install setuptools
-  (and EasyInstall) here:
+* When you're reading this you have probably already run ``easy_install plone.transformchain``.
+  Find out how to install setuptools (and EasyInstall) here:
   http://peak.telecommunity.com/DevCenter/EasyInstall
 
 * Create a file called ``plone.transformchain-configure.zcml`` in the
diff --git a/plone/__init__.py b/plone/__init__.py
index f48ad10..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,6 +1,2 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/transformchain/__init__.py b/plone/transformchain/__init__.py
index e69de29..40a96af 100644
--- a/plone/transformchain/__init__.py
+++ b/plone/transformchain/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/plone/transformchain/configure.zcml b/plone/transformchain/configure.zcml
index 5d9ab7a..0d8d97b 100644
--- a/plone/transformchain/configure.zcml
+++ b/plone/transformchain/configure.zcml
@@ -1,21 +1,15 @@
 <configure
+    i18n_domain="plone.transformchain"
     xmlns="http://namespaces.zope.org/zope"
-    xmlns:zcml="http://namespaces.zope.org/zcml"
-    i18n_domain="plone.transformchain">
-
-    <!-- For Zope 2.10, we need to backport the relevant events -->
-    <include
-        zcml:condition="installed ZPublisherEventsBackport"
-        package="ZPublisherEventsBackport"
-        />
-
-    <!-- Default transformation utility which delegates to ITransform adapters -->
-    <utility
-        factory=".transformer.Transformer"
-        />
-
-    <!-- Hooks for ZPublisher -->
-    <subscriber handler=".zpublisher.applyTransformOnSuccess" />
-    <subscriber handler=".zpublisher.applyTransformOnFailure" />
-
+    xmlns:zcml="http://namespaces.zope.org/zcml">
+  <!-- For Zope 2.10, we need to backport the relevant events -->
+  <include
+      package="ZPublisherEventsBackport"
+      zcml:condition="installed ZPublisherEventsBackport"
+  />
+  <!-- Default transformation utility which delegates to ITransform adapters -->
+  <utility factory=".transformer.Transformer" />
+  <!-- Hooks for ZPublisher -->
+  <subscriber handler=".zpublisher.applyTransformOnSuccess" />
+  <subscriber handler=".zpublisher.applyTransformOnFailure" />
 </configure>
diff --git a/plone/transformchain/interfaces.py b/plone/transformchain/interfaces.py
index dfd4199..ebfad19 100644
--- a/plone/transformchain/interfaces.py
+++ b/plone/transformchain/interfaces.py
@@ -1,5 +1,7 @@
-from zope.interface import Interface
+# -*- coding: utf-8 -*-
 from zope import schema
+from zope.interface import Interface
+
 
 try:
     from repoze.zope2.interfaces import ITransformer as IBaseTransformer
@@ -8,6 +10,7 @@
 
 DISABLE_TRANSFORM_REQUEST_KEY = 'plone.transformchain.disable'
 
+
 class ITransform(Interface):
     """Register a named multi adapter from (published, request,) to
     this interface to change the response.
@@ -50,6 +53,7 @@ def transformIterable(result, encoding):
         Return None to indicate that the response should not be modified.
         """
 
+
 class ITransformer(IBaseTransformer):
     """Low-level hook. This interface is defined in repoze.zope2, but since
     this package can be used with the classic ZPublisher as well, we redefine
diff --git a/plone/transformchain/tests.py b/plone/transformchain/tests.py
index 089e349..cecf9ad 100644
--- a/plone/transformchain/tests.py
+++ b/plone/transformchain/tests.py
@@ -1,39 +1,38 @@
-import unittest2 as unittest
+# -*- coding: utf-8 -*-
 from plone.testing.zca import UNIT_TESTING
-
-import os
-import tempfile
-
-# Load patch for Zope 2.10
-try:
-    from ZPublisher import interfaces
-except ImportError:
-    import ZPublisherEventsBackport
-
-
-from zope.interface import Interface, implements, alsoProvides
-from zope.component import adapts, provideAdapter, provideUtility
-
-from plone.transformchain.interfaces import ITransform, ITransformer
+from plone.transformchain.interfaces import ITransform
+from plone.transformchain.interfaces import ITransformer
 from plone.transformchain.transformer import Transformer
 from plone.transformchain.zpublisher import applyTransformOnSuccess
-
+from zope.component import adapter
+from zope.component import provideAdapter
+from zope.component import provideUtility
+from zope.interface import alsoProvides
+from zope.interface import implementer
+from zope.interface import Interface
 from ZPublisher.HTTPResponse import default_encoding
 from ZPublisher.Iterators import filestream_iterator
 from ZServer.FTPRequest import FTPRequest
 
+import os
+import tempfile
+import unittest2 as unittest
+
 
 class FauxPubEvent(object):
 
     def __init__(self, request):
         self.request = request
 
+
 class IRequestMarker(Interface):
     pass
 
+
 class IPublishedMarker(Interface):
     pass
 
+
 class FauxResponse(object):
 
     def __init__(self, body=''):
@@ -42,9 +41,11 @@ def __init__(self, body=''):
 
     def getBody(self):
         return self._body
+
     def setBody(self, body):
         self._body = body
 
+
 class FauxRequest(dict):
 
     def __init__(self, published, response=None):
@@ -55,12 +56,35 @@ def __init__(self, published, response=None):
         self.response = response
         self.environ = {}
 
+
 class FauxFTPRequest(FauxRequest, FTPRequest):
     pass
 
+
 class FauxPublished(object):
     pass
 
+
+@implementer(ITransform)
+@adapter(Interface, Interface)
+class FauxTransformBase(object):
+
+    order = 0
+
+    def __init__(self, published, request):
+        self.published = published
+        self.request = request
+
+        def transformBytes(self, result, encoding):
+            return None
+
+        def transformUnicode(self, result, encoding):
+            return None
+
+        def transformIterable(self, result, encoding):
+            return None
+
+
 class TestTransformChain(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -70,568 +94,381 @@ def setUp(self):
 
     def test_simple(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
+        class Transform1(FauxTransformBase):
 
             def transformBytes(self, result, encoding):
-                return result + " transformed"
+                return result + ' transformed'
 
             def transformUnicode(self, result, encoding):
-                return result + u" transformed"
+                return result + u' transformed'
 
             def transformIterable(self, result, encoding):
                 return ''.join(result) + ' transformed'
 
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Blah transformed", new_result)
+        self.assertEqual('Blah transformed', new_result)
 
     def test_off_switch(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform1(FauxTransformBase):
 
             order = 0
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " transformed"
+                return result + ' transformed'
 
             def transformUnicode(self, result, encoding):
-                return result + u" transformed"
+                return result + u' transformed'
 
             def transformIterable(self, result, encoding):
                 return ''.join(result) + ' transformed'
 
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
         request.environ['plone.transformchain.disable'] = True
 
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals(None, new_result)
+        self.assertEqual(None, new_result)
 
     def test_ftp_request_not_transformed(self):
         request = FauxFTPRequest(FauxPublished())
-        result = ["Blah"]
+        result = ['Blah']
         new_result = self.t(request, result, 'utf8')
-        self.assertEquals(None, new_result)
+        self.assertEqual(None, new_result)
 
     def test_transform_string(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
+        class Transform1(FauxTransformBase):
 
             def transformBytes(self, result, encoding):
-                return result + " One"
+                return result + ' One'
 
-            def transformUnicode(self, result, encoding):
-                return None
-
-            def transformIterable(self, result, encoding):
-                return None
-
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = "Blah"
+        result = 'Blah'
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Blah One", new_result)
+        self.assertEqual('Blah One', new_result)
 
     def test_transform_unicode(self):
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
 
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
+        class Transform1(FauxTransformBase):
 
             def transformUnicode(self, result, encoding):
-                return result + u" One"
+                return result + u' One'
 
-            def transformIterable(self, result, encoding):
-                return None
-
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = u"Blah"
+        result = u'Blah'
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals(u"Blah One", new_result)
+        self.assertEqual(u'Blah One', new_result)
 
     def test_transform_iterable(self):
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
 
-            def transformUnicode(self, result, encoding):
-                return None
+        class Transform1(FauxTransformBase):
 
             def transformIterable(self, result, encoding):
-                return result + [" One"]
+                return result + [' One']
 
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals(["Blah", " One"], new_result)
+        self.assertEqual(['Blah', ' One'], new_result)
 
     def test_transform_mixed(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
-
-            def transformUnicode(self, result, encoding):
-                return None
+        class Transform1(FauxTransformBase):
 
             def transformIterable(self, result, encoding):
-                return u''.join(result) + u" One"
+                return u''.join(result) + u' One'
 
-        class Transform2(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform2(FauxTransformBase):
 
             order = 1
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
-
             def transformUnicode(self, result, encoding):
                 return result.encode(encoding) + ' Two'
 
-            def transformIterable(self, result, encoding):
-                return None
-
-        class Transform3(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform3(FauxTransformBase):
 
             order = 2
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result.decode(encoding) + u" Three"
+                return result.decode(encoding) + u' Three'
 
-            def transformUnicode(self, result, encoding):
-                None
-
-            def transformIterable(self, result, encoding):
-                return None
-
-        provideAdapter(Transform1, name=u"test.one")
-        provideAdapter(Transform2, name=u"test.two")
-        provideAdapter(Transform3, name=u"test.three")
+        provideAdapter(Transform1, name=u'test.one')
+        provideAdapter(Transform2, name=u'test.two')
+        provideAdapter(Transform3, name=u'test.three')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals(u"Blah One Two Three", new_result)
+        self.assertEqual(u'Blah One Two Three', new_result)
 
     def test_abort(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform1(FauxTransformBase):
+            pass
 
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
-
-            def transformUnicode(self, result, encoding):
-                return None
-
-            def transformIterable(self, result, encoding):
-                return None
-
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals(["Blah"], new_result)
+        self.assertEqual(['Blah'], new_result)
 
     def test_abort_chain(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
+        class Transform1(FauxTransformBase):
 
             def transformBytes(self, result, encoding):
-                return "One"
+                return 'One'
 
             def transformUnicode(self, result, encoding):
-                return "One"
+                return 'One'
 
             def transformIterable(self, result, encoding):
-                return "One"
-
-        class Transform2(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 1
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
+                return 'One'
 
-            def transformUnicode(self, result, encoding):
-                return None
-
-            def transformIterable(self, result, encoding):
-                return None
+        class Transform2(FauxTransformBase):
+            pass
 
-        class Transform3(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform3(FauxTransformBase):
 
             order = 2
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " three"
+                return result + ' three'
 
             def transformUnicode(self, result, encoding):
-                return result + u" three"
+                return result + u' three'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " three"
+                return ''.join(result) + ' three'
 
-        provideAdapter(Transform1, name=u"test.one")
-        provideAdapter(Transform2, name=u"test.two")
-        provideAdapter(Transform3, name=u"test.three")
+        provideAdapter(Transform1, name=u'test.one')
+        provideAdapter(Transform2, name=u'test.two')
+        provideAdapter(Transform3, name=u'test.three')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("One three", new_result)
+        self.assertEqual('One three', new_result)
 
     def test_ordering(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform1(FauxTransformBase):
 
             order = 100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " One"
+                return result + ' One'
 
             def transformUnicode(self, result, encoding):
-                return result + u" One"
+                return result + u' One'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " One"
+                return ''.join(result) + ' One'
 
-        class Transform2(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform2(FauxTransformBase):
 
             order = -100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Two"
+                return result + ' Two'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Two"
+                return result + u' Two'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Two"
+                return ''.join(result) + ' Two'
 
-        class Transform3(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform3(FauxTransformBase):
 
             order = 101
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Three"
+                return result + ' Three'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Three"
+                return result + u' Three'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Three"
+                return ''.join(result) + ' Three'
 
-        provideAdapter(Transform1, name=u"test.one")
-        provideAdapter(Transform2, name=u"test.two")
-        provideAdapter(Transform3, name=u"test.three")
+        provideAdapter(Transform1, name=u'test.one')
+        provideAdapter(Transform2, name=u'test.two')
+        provideAdapter(Transform3, name=u'test.three')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Initial"]
+        result = ['Initial']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Initial Two One Three", new_result)
+        self.assertEqual('Initial Two One Three', new_result)
 
     def test_request_marker(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform1(FauxTransformBase):
 
             order = 100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " One"
+                return result + ' One'
 
             def transformUnicode(self, result, encoding):
-                return result + u" One"
+                return result + u' One'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " One"
+                return ''.join(result) + ' One'
 
-        class Transform2(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform2(FauxTransformBase):
 
             order = -100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Two"
+                return result + ' Two'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Two"
+                return result + u' Two'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Two"
+                return ''.join(result) + ' Two'
 
-        class Transform3(object):
-            implements(ITransform)
-            adapts(Interface, IRequestMarker)
+        @implementer(ITransform)
+        @adapter(Interface, IRequestMarker)
+        class Transform3(FauxTransformBase):
 
             order = 101
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Three"
+                return result + ' Three'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Three"
+                return result + u' Three'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Three"
+                return ''.join(result) + ' Three'
 
-        provideAdapter(Transform1, name=u"test.one")
-        provideAdapter(Transform2, name=u"test.two")
-        provideAdapter(Transform3, name=u"test.three")
+        provideAdapter(Transform1, name=u'test.one')
+        provideAdapter(Transform2, name=u'test.two')
+        provideAdapter(Transform3, name=u'test.three')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Initial"]
+        result = ['Initial']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Initial Two One", new_result)
+        self.assertEqual('Initial Two One', new_result)
 
         published = FauxPublished()
         request = FauxRequest(published)
         alsoProvides(request, IRequestMarker)
-        result = ["Initial"]
+        result = ['Initial']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Initial Two One Three", new_result)
+        self.assertEqual('Initial Two One Three', new_result)
 
     def test_published_marker(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform1(FauxTransformBase):
 
             order = 100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " One"
+                return result + ' One'
 
             def transformUnicode(self, result, encoding):
-                return result + u" One"
+                return result + u' One'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " One"
+                return ''.join(result) + ' One'
 
-        class Transform2(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform2(FauxTransformBase):
 
             order = -100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Two"
+                return result + ' Two'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Two"
+                return result + u' Two'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Two"
+                return ''.join(result) + ' Two'
 
-        class Transform3(object):
-            implements(ITransform)
-            adapts(IPublishedMarker, Interface)
+        @implementer(ITransform)
+        @adapter(IPublishedMarker, Interface)
+        class Transform3(FauxTransformBase):
 
             order = 101
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Three"
+                return result + ' Three'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Three"
+                return result + u' Three'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Three"
+                return ''.join(result) + ' Three'
 
-        provideAdapter(Transform1, name=u"test.one")
-        provideAdapter(Transform2, name=u"test.two")
-        provideAdapter(Transform3, name=u"test.three")
+        provideAdapter(Transform1, name=u'test.one')
+        provideAdapter(Transform2, name=u'test.two')
+        provideAdapter(Transform3, name=u'test.three')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Initial"]
+        result = ['Initial']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Initial Two One", new_result)
+        self.assertEqual('Initial Two One', new_result)
 
         published = FauxPublished()
         alsoProvides(published, IPublishedMarker)
         request = FauxRequest(published)
-        result = ["Initial"]
+        result = ['Initial']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Initial Two One Three", new_result)
+        self.assertEqual('Initial Two One Three', new_result)
+
 
 class TestZPublisherTransforms(unittest.TestCase):
 
@@ -641,11 +478,13 @@ def setUp(self):
         self.t = Transformer()
 
     def test_applyTransform_webdav_port(self):
+
+        @implementer(ITransformer)
         class DoNotCallTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
-                raise AssertionError("Shouldn't have been called")
+                raise AssertionError('Should not have been called')
 
         transformer = DoNotCallTransformer()
         provideUtility(transformer)
@@ -656,11 +495,12 @@ def __call__(self, request, result, encoding):
         applyTransformOnSuccess(FauxPubEvent(request))
 
     def test_applyTransform_webdav_method(self):
+        @implementer(ITransformer)
         class DoNotCallTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
-                raise AssertionError("Shouldn't have been called")
+                raise AssertionError('Should not have been called')
 
         transformer = DoNotCallTransformer()
         provideUtility(transformer)
@@ -671,11 +511,13 @@ def __call__(self, request, result, encoding):
         applyTransformOnSuccess(FauxPubEvent(request))
 
     def test_applyTransform_webdav_pathinfo(self):
+
+        @implementer(ITransformer)
         class DoNotCallTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
-                raise AssertionError("Shouldn't have been called")
+                raise AssertionError('Should not have been called')
 
         transformer = DoNotCallTransformer()
         provideUtility(transformer)
@@ -691,9 +533,11 @@ def test_applyTransform_no_utility(self):
         applyTransformOnSuccess(FauxPubEvent(request))
 
     def test_applyTransform_default_encoding(self):
+
+        @implementer(ITransformer)
         class EncodingCaptureTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
                 self.encoding = encoding
 
@@ -704,12 +548,13 @@ def __call__(self, request, result, encoding):
         request = FauxRequest(published)
         applyTransformOnSuccess(FauxPubEvent(request))
 
-        self.assertEquals(default_encoding, transformer.encoding)
+        self.assertEqual(default_encoding, transformer.encoding)
 
     def test_applyTransform_other_encoding(self):
+        @implementer(ITransformer)
         class EncodingCaptureTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
                 self.encoding = encoding
 
@@ -721,12 +566,13 @@ def __call__(self, request, result, encoding):
         request.response.headers['content-type'] = 'text/html; charset=dummy'
         applyTransformOnSuccess(FauxPubEvent(request))
 
-        self.assertEquals("dummy", transformer.encoding)
+        self.assertEqual('dummy', transformer.encoding)
 
     def test_applyTransform_other_encoding_with_header_missing_space(self):
+        @implementer(ITransformer)
         class EncodingCaptureTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
                 self.encoding = encoding
 
@@ -738,11 +584,12 @@ def __call__(self, request, result, encoding):
         request.response.headers['content-type'] = 'text/html;charset=dummy'
         applyTransformOnSuccess(FauxPubEvent(request))
 
-        self.assertEquals("dummy", transformer.encoding)
+        self.assertEqual('dummy', transformer.encoding)
 
     def test_applyTransform_str(self):
+        @implementer(ITransformer)
         class FauxTransformer(object):
-            implements(ITransformer)
+
             def __call__(self, request, result, encoding):
                 return 'dummystr'
 
@@ -753,11 +600,12 @@ def __call__(self, request, result, encoding):
         request = FauxRequest(published)
         applyTransformOnSuccess(FauxPubEvent(request))
 
-        self.assertEquals('dummystr', request.response.getBody())
+        self.assertEqual('dummystr', request.response.getBody())
 
     def test_applyTransform_unicode(self):
+        @implementer(ITransformer)
         class FauxTransformer(object):
-            implements(ITransformer)
+
             def __call__(self, request, result, encoding):
                 return u'dummystr'
 
@@ -769,11 +617,12 @@ def __call__(self, request, result, encoding):
         applyTransformOnSuccess(FauxPubEvent(request))
 
         # note: the real setBody would encode here
-        self.assertEquals(u'dummystr', request.response.getBody())
+        self.assertEqual(u'dummystr', request.response.getBody())
 
     def test_applyTransform_iterable(self):
+        @implementer(ITransformer)
         class FauxTransformer(object):
-            implements(ITransformer)
+
             def __call__(self, request, result, encoding):
                 return ['iter', 'one']
 
@@ -784,18 +633,18 @@ def __call__(self, request, result, encoding):
         request = FauxRequest(published)
         applyTransformOnSuccess(FauxPubEvent(request))
 
-        self.assertEquals('iterone', request.response.getBody())
+        self.assertEqual('iterone', request.response.getBody())
 
     def test_applyTransform_streamiterator(self):
         tmp = tempfile.mkstemp()[1]
         try:
 
-            out = open(tmp, 'w')
-            print >> out, "foo"
-            out.close()
+            with open(tmp, 'w') as out:
+                out.write('foo')
 
+            @implementer(ITransformer)
             class FauxTransformer(object):
-                implements(ITransformer)
+
                 def __call__(self, request, result, encoding):
                     return filestream_iterator(tmp)
 
@@ -806,13 +655,19 @@ def __call__(self, request, result, encoding):
             request = FauxRequest(published)
             applyTransformOnSuccess(FauxPubEvent(request))
 
-            self.failUnless(isinstance(request.response.getBody(), filestream_iterator,))
+            self.assertTrue(
+                isinstance(
+                    request.response.getBody(),
+                    filestream_iterator
+                )
+            )
         finally:
             os.unlink(tmp)
 
     def test_applyTransform_str_input_body(self):
+        @implementer(ITransformer)
         class FauxTransformer(object):
-            implements(ITransformer)
+
             def __call__(self, request, result, encoding):
                 assert isinstance(result, list)
                 assert isinstance(result[0], str)
@@ -823,16 +678,17 @@ def __call__(self, request, result, encoding):
 
         published = FauxPublished()
         request = FauxRequest(published)
-        request.response.setBody("<html />")
+        request.response.setBody('<html />')
 
         applyTransformOnSuccess(FauxPubEvent(request))
 
         # note: the real setBody would encode here
-        self.assertEquals('dummystr', request.response.getBody())
+        self.assertEqual('dummystr', request.response.getBody())
 
     def test_applyTransform_unicode_input_body(self):
+        @implementer(ITransformer)
         class FauxTransformer(object):
-            implements(ITransformer)
+
             def __call__(self, request, result, encoding):
                 assert isinstance(result, list)
                 assert isinstance(result[0], str)
@@ -843,9 +699,9 @@ def __call__(self, request, result, encoding):
 
         published = FauxPublished()
         request = FauxRequest(published)
-        request.response.setBody(u"<html />")
+        request.response.setBody(u'<html />')
 
         applyTransformOnSuccess(FauxPubEvent(request))
 
         # note: the real setBody would encode here
-        self.assertEquals(u'dummystr', request.response.getBody())
+        self.assertEqual(u'dummystr', request.response.getBody())
diff --git a/plone/transformchain/transformer.py b/plone/transformchain/transformer.py
index f6f9585..9979fe8 100644
--- a/plone/transformchain/transformer.py
+++ b/plone/transformchain/transformer.py
@@ -1,29 +1,29 @@
+# -*- coding: utf-8 -*-
+from plone.transformchain.interfaces import DISABLE_TRANSFORM_REQUEST_KEY
+from plone.transformchain.interfaces import ITransform
+from plone.transformchain.interfaces import ITransformer
+from ZODB.POSException import ConflictError
+from zope.component import getAdapters
+from zope.interface import implementer
+from ZServer.FTPRequest import FTPRequest
+
 import logging
 
-from zope.interface import implements
-from zope.component import getAdapters
 
-from plone.transformchain.interfaces import ITransform, ITransformer
-from plone.transformchain.interfaces import DISABLE_TRANSFORM_REQUEST_KEY
+LOGGER = logging.getLogger('plone.transformchain')
 
-from ZODB.POSException import ConflictError
-from ZServer.FTPRequest import FTPRequest
 
 def sort_key(a, b):
     return cmp(a.order, b.order)
 
-LOGGER = logging.getLogger('plone.transformchain')
 
+@implementer(ITransformer)
 class Transformer(object):
     """Delegate the opportunity to transform the response to multiple,
     ordered adapters.
     """
 
-    implements(ITransformer)
-
     def __call__(self, request, result, encoding):
-
-
         # Don't transform FTP requests
         if isinstance(request, FTPRequest):
             return None
@@ -35,11 +35,11 @@ def __call__(self, request, result, encoding):
         try:
             published = request.get('PUBLISHED', None)
 
-            handlers = [v[1] for v in getAdapters((published, request,), ITransform)]
-            handlers.sort(sort_key)
-
-            for handler in handlers:
+            handlers = [
+                v[1] for v in getAdapters((published, request,), ITransform)
+            ]
 
+            for handler in sorted(handlers, key=sort_key):
                 if isinstance(result, unicode):
                     newResult = handler.transformUnicode(result, encoding)
                 elif isinstance(result, str):
@@ -53,5 +53,7 @@ def __call__(self, request, result, encoding):
             return result
         except ConflictError:
             raise
-        except Exception, e:
-            LOGGER.exception(u"Unexpected error whilst trying to apply transform chain")
+        except Exception:
+            LOGGER.exception(
+                u"Unexpected error whilst trying to apply transform chain"
+            )
diff --git a/plone/transformchain/zpublisher.py b/plone/transformchain/zpublisher.py
index 52bf5d7..8de080d 100644
--- a/plone/transformchain/zpublisher.py
+++ b/plone/transformchain/zpublisher.py
@@ -1,16 +1,14 @@
-import sys
-import re
-
+# -*- coding: utf-8 -*-
+from plone.transformchain.interfaces import ITransformer
+from zope.component import adapter
+from zope.component import queryUtility
 from zope.interface import Interface
-from zope.interface.interfaces import IInterface
-from zope.component import queryUtility, adapter
-
-from ZPublisher.Iterators import IStreamIterator
 from ZPublisher.HTTPResponse import default_encoding
+from ZPublisher.interfaces import IPubBeforeCommit
+from ZPublisher.Iterators import IStreamIterator
 
-from plone.transformchain.interfaces import ITransformer
+import re
 
-from ZPublisher.interfaces import IPubBeforeCommit
 
 try:
     from ZPublisher.interfaces import IPubBeforeAbort
@@ -20,7 +18,12 @@
     class IPubBeforeAbort(Interface):
         pass
 
-CHARSET_RE = re.compile(r'(?:application|text)/[-+0-9a-z]+\s*;\s?charset=([-_0-9a-z]+)(?:(?:\s*;)|\Z)', re.IGNORECASE)
+CHARSET_RE = re.compile(
+    r'(?:application|text)/[-+0-9a-z]+\s*;\s?charset=([-_0-9a-z]+)'
+    r'(?:(?:\s*;)|\Z)',
+    re.IGNORECASE
+)
+
 
 def extractEncoding(response):
     """Get the content encoding for the response body
@@ -33,6 +36,7 @@ def extractEncoding(response):
             encoding = match.group(1)
     return encoding
 
+
 def isEvilWebDAVRequest(request):
     if request.get('WEBDAV_SOURCE_PORT', None):
         return True
@@ -45,6 +49,7 @@ def isEvilWebDAVRequest(request):
 
     return False
 
+
 def applyTransform(request, body=None):
     """Apply any transforms by delegating to the ITransformer utility
     """
@@ -72,51 +77,40 @@ def applyTransform(request, body=None):
 
     return None
 
+
 @adapter(IPubBeforeCommit)
 def applyTransformOnSuccess(event):
     """Apply the transform after a successful request
     """
     transformed = applyTransform(event.request)
-    if transformed is not None:
-        response = event.request.response
-
-        # horrid check to deal with Plone 3/Zope 2.10, where this is still an old-style interface
-        if ((IInterface.providedBy(IStreamIterator)     and IStreamIterator.providedBy(transformed))
-         or (not IInterface.providedBy(IStreamIterator) and IStreamIterator.isImplementedBy(transformed))
-        ):
-            response.setBody(transformed)
-        # setBody() can deal with byte and unicode strings (and will encode as necessary)...
-        elif isinstance(transformed, basestring):
-            response.setBody(transformed)
-        # ... but not with iterables
-        else:
-            response.setBody(''.join(transformed))
+    if transformed is None:
+        return
+    response = event.request.response
+
+    if IStreamIterator.providedBy(transformed):
+        response.setBody(transformed)
+    # setBody() can deal with byte and unicode strings (and will encode as
+    # necessary)...
+    elif isinstance(transformed, basestring):
+        response.setBody(transformed)
+    # ... but not with iterables
+    else:
+        response.setBody(''.join(transformed))
+
 
 @adapter(IPubBeforeAbort)
 def applyTransformOnFailure(event):
     """Apply the transform to the error html output
     """
-    if not event.retry:
-        request = event.request
-        exc_info = sys.exc_info()
-        error = exc_info[1]
-        if isinstance(error, basestring): # Zope 2.10 - the exception is rendered (eeeeek)
-            transformed = applyTransform(request, error)
-            if transformed is not None:
-
-                if not isinstance(transformed, basestring):
-                    transformed = ''.join(transformed)
-
-                # If it's any consolation, Laurence felt quite dirty doing this...
-                raise exc_info[0], transformed, exc_info[2]
-        else: # Zope 2.12 - we are allowed to call setBody()
-            # response.status might still be 200 because
-            # IPubBeforeAbort is notified before
-            # ZPublisher.Publish.publish_module_standard
-            # calls HTTPResponse.exception()
-            # which actually updates the status
-            setErrorStatusOnResponse(event)
-            applyTransformOnSuccess(event)
+    if event.retry:
+        return
+    # response.status might still be 200 because
+    # IPubBeforeAbort is notified before
+    # ZPublisher.Publish.publish_module_standard
+    # calls HTTPResponse.exception()
+    # which actually updates the status
+    setErrorStatusOnResponse(event)
+    applyTransformOnSuccess(event)
 
 
 def setErrorStatusOnResponse(event):
diff --git a/setup.py b/setup.py
index 0eb2898..2663c73 100644
--- a/setup.py
+++ b/setup.py
@@ -1,45 +1,48 @@
-from setuptools import setup, find_packages
+from setuptools import find_packages
+from setuptools import setup
 
-version = '1.0.5.dev0'
 
-setup(name='plone.transformchain',
-      version=version,
-      description=("Hook into repoze.zope2 that allows third party packages "
-                   "to register a sequence of hooks that will be allowed to "
-                   "modify the response before it is returned to the browser"),
-      long_description=(open("README.rst").read() + "\n" +
-                        open("CHANGES.rst").read()),
-      # Get more strings from
-      # https://pypi.python.org/pypi?%3Aaction=list_classifiers
-      classifiers=[
-          "Framework :: Plone",
-          "Framework :: Plone :: 4.3",
-          "Framework :: Plone :: 5.0",
-          "Programming Language :: Python",
-          "Topic :: Software Development :: Libraries :: Python Modules",
-          "Programming Language :: Python :: 2.6",
-          "Programming Language :: Python :: 2.7",
-          ],
-      keywords='zope2 repoze transform',
-      author='Martin Aspeli',
-      author_email='optilude@gmail.com',
-      url='https://pypi.python.org/pypi/plone.transformchain',
-      license='BSD',
-      packages=find_packages(exclude=['ez_setup']),
-      namespace_packages=['plone'],
-      include_package_data=True,
-      zip_safe=False,
-      extras_require={
-          'repoze': ['repoze.zope2'],
-          'Zope2.10': ['ZPublisherEventsBackport'],
-          'test': 'plone.testing [zca]',
-      },
-      install_requires=[
-          'setuptools',
-          'zope.interface',
-          'zope.component',
-          'zope.schema',
-      ],
-      entry_points="""
-      """,
-      )
+version = '1.1.0.dev0'
+
+setup(
+    name='plone.transformchain',
+    version=version,
+    description=("Hook into repoze.zope2 that allows third party packages "
+                 "to register a sequence of hooks that will be allowed to "
+                 "modify the response before it is returned to the browser"),
+    long_description=(open("README.rst").read() + "\n" +
+                      open("CHANGES.rst").read()),
+    # Get more strings from
+    # https://pypi.python.org/pypi?%3Aaction=list_classifiers
+    classifiers=[
+        "Framework :: Plone",
+        "Framework :: Plone :: 4.3",
+        "Framework :: Plone :: 5.0",
+        "Programming Language :: Python",
+        "Topic :: Software Development :: Libraries :: Python Modules",
+        "Programming Language :: Python :: 2.6",
+        "Programming Language :: Python :: 2.7",
+    ],
+    keywords='zope2 repoze transform',
+    author='Martin Aspeli',
+    author_email='optilude@gmail.com',
+    url='https://pypi.python.org/pypi/plone.transformchain',
+    license='BSD',
+    packages=find_packages(exclude=['ez_setup']),
+    namespace_packages=['plone'],
+    include_package_data=True,
+    zip_safe=False,
+    extras_require={
+        'repoze': ['repoze.zope2'],
+        'test': 'plone.testing [zca]',
+    },
+    install_requires=[
+        'setuptools',
+        'zope.interface',
+        'zope.component',
+        'zope.schema',
+        'Zope2>=2.13.23'
+    ],
+    entry_points="""
+    """,
+)


Repository: plone.transformchain


Branch: refs/heads/master
Date: 2016-02-15T16:54:04+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.transformchain/commit/453e897bc071101924912c173ae2c7c27c43710a

code block seems to be problematic on pypi

Files changed:
M README.rst

diff --git a/README.rst b/README.rst
index 9a6f25a..1bff593 100644
--- a/README.rst
+++ b/README.rst
@@ -36,9 +36,7 @@ If a byte string or unicode string is returned by the last transform in the chai
 
 Return ``None`` to signal that the result should not be changed from the previous transform.
 
-Here is an example that uppercases everything:
-
-.. code_block:: python
+Here is an example that uppercases everything::
 
     from zope.component import adapter
     from zope.interface import implementer
@@ -64,9 +62,7 @@ Here is an example that uppercases everything:
         def transformIterable(self, result, encoding):
             return [s.upper() for s in result]
 
-You could register this in ZCML like so:
-
-.. code_block:: xml
+You could register this in ZCML like so::
 
     <adapter factory=".transforms.UpperTransform" name="example.uppertransform" />
 


Repository: plone.transformchain


Branch: refs/heads/master
Date: 2016-02-16T11:53:44+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.transformchain/commit/8decf91edc339b57c45fb9259c18b2ae2b399f5d

sorting was broken - simplified using attrgetters - also fixed tests

Files changed:
M plone/transformchain/tests.py
M plone/transformchain/transformer.py

diff --git a/plone/transformchain/tests.py b/plone/transformchain/tests.py
index cecf9ad..9572b90 100644
--- a/plone/transformchain/tests.py
+++ b/plone/transformchain/tests.py
@@ -75,14 +75,14 @@ def __init__(self, published, request):
         self.published = published
         self.request = request
 
-        def transformBytes(self, result, encoding):
-            return None
+    def transformBytes(self, result, encoding):
+        return None
 
-        def transformUnicode(self, result, encoding):
-            return None
+    def transformUnicode(self, result, encoding):
+        return None
 
-        def transformIterable(self, result, encoding):
-            return None
+    def transformIterable(self, result, encoding):
+        return None
 
 
 class TestTransformChain(unittest.TestCase):
@@ -237,15 +237,15 @@ def test_abort(self):
         class Transform1(FauxTransformBase):
             pass
 
-        provideAdapter(Transform1, name=u'test.one')
+        provideAdapter(Transform1, name=u"test.one")
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ['Blah']
+        result = ["Blah"]
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEqual(['Blah'], new_result)
+        self.assertEquals(["Blah"], new_result)
 
     def test_abort_chain(self):
 
diff --git a/plone/transformchain/transformer.py b/plone/transformchain/transformer.py
index 9979fe8..19fb069 100644
--- a/plone/transformchain/transformer.py
+++ b/plone/transformchain/transformer.py
@@ -1,4 +1,5 @@
 # -*- coding: utf-8 -*-
+from operator import attrgetter
 from plone.transformchain.interfaces import DISABLE_TRANSFORM_REQUEST_KEY
 from plone.transformchain.interfaces import ITransform
 from plone.transformchain.interfaces import ITransformer
@@ -13,10 +14,6 @@
 LOGGER = logging.getLogger('plone.transformchain')
 
 
-def sort_key(a, b):
-    return cmp(a.order, b.order)
-
-
 @implementer(ITransformer)
 class Transformer(object):
     """Delegate the opportunity to transform the response to multiple,
@@ -34,12 +31,10 @@ def __call__(self, request, result, encoding):
 
         try:
             published = request.get('PUBLISHED', None)
-
-            handlers = [
+            handlers = (
                 v[1] for v in getAdapters((published, request,), ITransform)
-            ]
-
-            for handler in sorted(handlers, key=sort_key):
+            )
+            for handler in sorted(handlers, key=attrgetter('order')):
                 if isinstance(result, unicode):
                     newResult = handler.transformUnicode(result, encoding)
                 elif isinstance(result, str):


Repository: plone.transformchain


Branch: refs/heads/master
Date: 2016-02-16T12:02:29+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.transformchain/commit/b58178afd878499e3fcdfebac4a8d77d8803091e

fix Q000 D001

Files changed:
M plone/transformchain/tests.py

diff --git a/plone/transformchain/tests.py b/plone/transformchain/tests.py
index 9572b90..9314d66 100644
--- a/plone/transformchain/tests.py
+++ b/plone/transformchain/tests.py
@@ -237,15 +237,15 @@ def test_abort(self):
         class Transform1(FauxTransformBase):
             pass
 
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals(["Blah"], new_result)
+        self.assertEqual(['Blah'], new_result)
 
     def test_abort_chain(self):
 


Repository: plone.transformchain


Branch: refs/heads/master
Date: 2016-02-16T14:19:06+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.transformchain/commit/e69c1fefe5c35a8171491dcf9ab5da236b45eddd

Merge pull request #4 from plone/cleanup

pep8, rst fixes, doc-style, removal of Zope2.10 specialities

Files changed:
A .isort.cfg
M CHANGES.rst
M README.rst
M docs/INSTALL.txt
M plone/__init__.py
M plone/transformchain/__init__.py
M plone/transformchain/configure.zcml
M plone/transformchain/interfaces.py
M plone/transformchain/tests.py
M plone/transformchain/transformer.py
M plone/transformchain/zpublisher.py
M setup.py

diff --git a/.isort.cfg b/.isort.cfg
new file mode 100644
index 0000000..fb79921
--- /dev/null
+++ b/.isort.cfg
@@ -0,0 +1,5 @@
+[settings]
+force_alphabetical_sort=True
+force_single_line=True
+lines_after_imports=2
+line_length=200
diff --git a/CHANGES.rst b/CHANGES.rst
index 616a087..0866ed5 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,16 +1,18 @@
 Changelog
 =========
 
-1.0.5 (unreleased)
+1.1.0 (unreleased)
 ------------------
 
 New:
 
-- *add item here*
+- Require Zope2 >= 2.13.23
+  [jensens]
 
 Fixes:
 
-- *add item here*
+- PEP8 et al. use zca decorators, ...
+  [jensens]
 
 
 1.0.4 (2015-05-11)
diff --git a/README.rst b/README.rst
index 788bdd3..1bff593 100644
--- a/README.rst
+++ b/README.rst
@@ -1,62 +1,51 @@
 Introduction
 ============
 
-This package provides a means of modifying the response from a page published
-with ``repoze.zope2`` or the "classic" ``ZPublisher`` before it is returned to
-the browser.
+``plone.transformchain`` provides methods to modify the response from a page published with ``repoze.zope2`` or the "classic" ``ZPublisher`` before it is returned to the browser.
 
-Register a uniquely named adapter from ``(published, request)`` providing
-the ``ITransform`` interface. ``published`` is the published object, e.g. a
-view; ``request`` is the current request.
+Register a uniquely named adapter from ``(published, request)`` providing the ``ITransform`` interface.
+``published`` is the published object, e.g. a view; ``request`` is the current request.
 
-The order of the transforms can be maintained using the ``order`` property of
-the adapter.
+The order of the transforms can be maintained using the ``order`` property of the adapter.
 
-One of three methods will be called, depending on what type of input was
-obtained from the publisher and/or the previous method.
+One of three methods will be called, depending on what type of input was obtained from the publisher and/or the previous method.
 
-  * transformBytes() is called if the input is a str (bytes) object
-  * transformUnicode() is called if the input is a unicode object
-  * transformIterable() is called if the input is another type of iterable
+  * ``transformBytes()`` is called if the input is a str (bytes) object
+  * ``transformUnicode()`` is called if the input is a unicode object
+  * ``transformIterable()`` is called if the input is another type of iterable
 
 Each stage can return a byte string, a unicode string, or an iterable.
 
-Most transformers will have a "natural" representation of the result, and will
-implement the respective method to return another value of the same
-representation, e.g. implement transformUnicode() to transform and return a
-unicode object. The other methods may then either be implemented to return
-None (do nothing) or convert the value to the appropriate type.
+Most transformers will have a "natural" representation of the result,
+and will implement the respective method to return another value of the same representation,
+e.g. implement transformUnicode() to transform and return a unicode object.
+The other methods may then either be implemented to return None (do nothing) or convert the value to the appropriate type.
 
 The first transformer in the chain is likely to get:
 
-  * A byte string if the transformer is running under the standard Zope 2
-    ZPublisher.
-  * An iterable if the transformer is running under repoze.zope2 or another
-    WSGI pipeline.
+* A byte string if the transformer is running under the standard Zope 2 ZPublisher.
+* An iterable if the transformer is running under repoze.zope2 or another WSGI pipeline.
 
-Check ``self.request.response.getHeader('content-type')`` to see the type of
-result. The iterable, when unwound, will conform to this type, e.g. for
-text/html, ``''.join(result)`` should be an HTML string.
+Check ``self.request.response.getHeader('content-type')`` to see the type of result.
+The iterable, when unwound, will conform to this type, e.g. for "text/html", ``''.join(result)`` should be an HTML string.
 
-The return value is passed to the next transform in the chain. The final
-transform should return a unicode string, an encoded string, or an iterable.
+The return value is passed to the next transform in the chain.
+The final transform should return a unicode string, an encoded string, or an iterable.
 
-If a byte string or unicode string is returned by the last transform in the
-chain, the ``Content-Length`` header will be automatically updated
+If a byte string or unicode string is returned by the last transform in the chain, the ``Content-Length`` header will be automatically updated.
 
-Return ``None`` to signal that the result should not be changed from the
-previous transform.
+Return ``None`` to signal that the result should not be changed from the previous transform.
 
 Here is an example that uppercases everything::
 
-    from zope.interface import implements, Interface
-    from zope.component import adapts
-
+    from zope.component import adapter
+    from zope.interface import implementer
+    from zope.interface import Interface
     from plone.transformchain.interfaces import ITransform
 
+    @implementer(ITransform)
+    @adapter(Interface, Interface) # any context, any request
     class UpperTransform(object):
-        implements(ITransform)
-        adapts(Interface, Interface) # any context, any request
 
         order = 1000
 
@@ -77,10 +66,9 @@ You could register this in ZCML like so::
 
     <adapter factory=".transforms.UpperTransform" name="example.uppertransform" />
 
-If you need to turn off transformations for a particular request, you can
-set a key in ``request.environ``::
+If you need to turn off transformations for a particular request,
+you can set a key in ``request.environ``::
 
     request.environ['plone.transformchain.disable'] = True
 
-This will leave the response untouched and will not invoke any
-``ITransform`` adapters at all.
+This will leave the response untouched and will not invoke any ``ITransform`` adapters at all.
diff --git a/docs/INSTALL.txt b/docs/INSTALL.txt
index ff052e8..40fc759 100644
--- a/docs/INSTALL.txt
+++ b/docs/INSTALL.txt
@@ -1,12 +1,11 @@
 plone.transformchain Installation
 ---------------------------------
 
-To install plone.transformchain into the global Python environment (or a workingenv),
+To install plone.transformchain into the global Python environment (or a virtualenv),
 using a traditional Zope 2 instance, you can do this:
 
-* When you're reading this you have probably already run
-  ``easy_install plone.transformchain``. Find out how to install setuptools
-  (and EasyInstall) here:
+* When you're reading this you have probably already run ``easy_install plone.transformchain``.
+  Find out how to install setuptools (and EasyInstall) here:
   http://peak.telecommunity.com/DevCenter/EasyInstall
 
 * Create a file called ``plone.transformchain-configure.zcml`` in the
diff --git a/plone/__init__.py b/plone/__init__.py
index f48ad10..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,6 +1,2 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/transformchain/__init__.py b/plone/transformchain/__init__.py
index e69de29..40a96af 100644
--- a/plone/transformchain/__init__.py
+++ b/plone/transformchain/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/plone/transformchain/configure.zcml b/plone/transformchain/configure.zcml
index 5d9ab7a..0d8d97b 100644
--- a/plone/transformchain/configure.zcml
+++ b/plone/transformchain/configure.zcml
@@ -1,21 +1,15 @@
 <configure
+    i18n_domain="plone.transformchain"
     xmlns="http://namespaces.zope.org/zope"
-    xmlns:zcml="http://namespaces.zope.org/zcml"
-    i18n_domain="plone.transformchain">
-
-    <!-- For Zope 2.10, we need to backport the relevant events -->
-    <include
-        zcml:condition="installed ZPublisherEventsBackport"
-        package="ZPublisherEventsBackport"
-        />
-
-    <!-- Default transformation utility which delegates to ITransform adapters -->
-    <utility
-        factory=".transformer.Transformer"
-        />
-
-    <!-- Hooks for ZPublisher -->
-    <subscriber handler=".zpublisher.applyTransformOnSuccess" />
-    <subscriber handler=".zpublisher.applyTransformOnFailure" />
-
+    xmlns:zcml="http://namespaces.zope.org/zcml">
+  <!-- For Zope 2.10, we need to backport the relevant events -->
+  <include
+      package="ZPublisherEventsBackport"
+      zcml:condition="installed ZPublisherEventsBackport"
+  />
+  <!-- Default transformation utility which delegates to ITransform adapters -->
+  <utility factory=".transformer.Transformer" />
+  <!-- Hooks for ZPublisher -->
+  <subscriber handler=".zpublisher.applyTransformOnSuccess" />
+  <subscriber handler=".zpublisher.applyTransformOnFailure" />
 </configure>
diff --git a/plone/transformchain/interfaces.py b/plone/transformchain/interfaces.py
index dfd4199..ebfad19 100644
--- a/plone/transformchain/interfaces.py
+++ b/plone/transformchain/interfaces.py
@@ -1,5 +1,7 @@
-from zope.interface import Interface
+# -*- coding: utf-8 -*-
 from zope import schema
+from zope.interface import Interface
+
 
 try:
     from repoze.zope2.interfaces import ITransformer as IBaseTransformer
@@ -8,6 +10,7 @@
 
 DISABLE_TRANSFORM_REQUEST_KEY = 'plone.transformchain.disable'
 
+
 class ITransform(Interface):
     """Register a named multi adapter from (published, request,) to
     this interface to change the response.
@@ -50,6 +53,7 @@ def transformIterable(result, encoding):
         Return None to indicate that the response should not be modified.
         """
 
+
 class ITransformer(IBaseTransformer):
     """Low-level hook. This interface is defined in repoze.zope2, but since
     this package can be used with the classic ZPublisher as well, we redefine
diff --git a/plone/transformchain/tests.py b/plone/transformchain/tests.py
index 089e349..9314d66 100644
--- a/plone/transformchain/tests.py
+++ b/plone/transformchain/tests.py
@@ -1,39 +1,38 @@
-import unittest2 as unittest
+# -*- coding: utf-8 -*-
 from plone.testing.zca import UNIT_TESTING
-
-import os
-import tempfile
-
-# Load patch for Zope 2.10
-try:
-    from ZPublisher import interfaces
-except ImportError:
-    import ZPublisherEventsBackport
-
-
-from zope.interface import Interface, implements, alsoProvides
-from zope.component import adapts, provideAdapter, provideUtility
-
-from plone.transformchain.interfaces import ITransform, ITransformer
+from plone.transformchain.interfaces import ITransform
+from plone.transformchain.interfaces import ITransformer
 from plone.transformchain.transformer import Transformer
 from plone.transformchain.zpublisher import applyTransformOnSuccess
-
+from zope.component import adapter
+from zope.component import provideAdapter
+from zope.component import provideUtility
+from zope.interface import alsoProvides
+from zope.interface import implementer
+from zope.interface import Interface
 from ZPublisher.HTTPResponse import default_encoding
 from ZPublisher.Iterators import filestream_iterator
 from ZServer.FTPRequest import FTPRequest
 
+import os
+import tempfile
+import unittest2 as unittest
+
 
 class FauxPubEvent(object):
 
     def __init__(self, request):
         self.request = request
 
+
 class IRequestMarker(Interface):
     pass
 
+
 class IPublishedMarker(Interface):
     pass
 
+
 class FauxResponse(object):
 
     def __init__(self, body=''):
@@ -42,9 +41,11 @@ def __init__(self, body=''):
 
     def getBody(self):
         return self._body
+
     def setBody(self, body):
         self._body = body
 
+
 class FauxRequest(dict):
 
     def __init__(self, published, response=None):
@@ -55,12 +56,35 @@ def __init__(self, published, response=None):
         self.response = response
         self.environ = {}
 
+
 class FauxFTPRequest(FauxRequest, FTPRequest):
     pass
 
+
 class FauxPublished(object):
     pass
 
+
+@implementer(ITransform)
+@adapter(Interface, Interface)
+class FauxTransformBase(object):
+
+    order = 0
+
+    def __init__(self, published, request):
+        self.published = published
+        self.request = request
+
+    def transformBytes(self, result, encoding):
+        return None
+
+    def transformUnicode(self, result, encoding):
+        return None
+
+    def transformIterable(self, result, encoding):
+        return None
+
+
 class TestTransformChain(unittest.TestCase):
 
     layer = UNIT_TESTING
@@ -70,568 +94,381 @@ def setUp(self):
 
     def test_simple(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
+        class Transform1(FauxTransformBase):
 
             def transformBytes(self, result, encoding):
-                return result + " transformed"
+                return result + ' transformed'
 
             def transformUnicode(self, result, encoding):
-                return result + u" transformed"
+                return result + u' transformed'
 
             def transformIterable(self, result, encoding):
                 return ''.join(result) + ' transformed'
 
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Blah transformed", new_result)
+        self.assertEqual('Blah transformed', new_result)
 
     def test_off_switch(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform1(FauxTransformBase):
 
             order = 0
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " transformed"
+                return result + ' transformed'
 
             def transformUnicode(self, result, encoding):
-                return result + u" transformed"
+                return result + u' transformed'
 
             def transformIterable(self, result, encoding):
                 return ''.join(result) + ' transformed'
 
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
         request.environ['plone.transformchain.disable'] = True
 
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals(None, new_result)
+        self.assertEqual(None, new_result)
 
     def test_ftp_request_not_transformed(self):
         request = FauxFTPRequest(FauxPublished())
-        result = ["Blah"]
+        result = ['Blah']
         new_result = self.t(request, result, 'utf8')
-        self.assertEquals(None, new_result)
+        self.assertEqual(None, new_result)
 
     def test_transform_string(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
+        class Transform1(FauxTransformBase):
 
             def transformBytes(self, result, encoding):
-                return result + " One"
+                return result + ' One'
 
-            def transformUnicode(self, result, encoding):
-                return None
-
-            def transformIterable(self, result, encoding):
-                return None
-
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = "Blah"
+        result = 'Blah'
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Blah One", new_result)
+        self.assertEqual('Blah One', new_result)
 
     def test_transform_unicode(self):
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
 
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
+        class Transform1(FauxTransformBase):
 
             def transformUnicode(self, result, encoding):
-                return result + u" One"
+                return result + u' One'
 
-            def transformIterable(self, result, encoding):
-                return None
-
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = u"Blah"
+        result = u'Blah'
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals(u"Blah One", new_result)
+        self.assertEqual(u'Blah One', new_result)
 
     def test_transform_iterable(self):
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
 
-            def transformUnicode(self, result, encoding):
-                return None
+        class Transform1(FauxTransformBase):
 
             def transformIterable(self, result, encoding):
-                return result + [" One"]
+                return result + [' One']
 
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals(["Blah", " One"], new_result)
+        self.assertEqual(['Blah', ' One'], new_result)
 
     def test_transform_mixed(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
-
-            def transformUnicode(self, result, encoding):
-                return None
+        class Transform1(FauxTransformBase):
 
             def transformIterable(self, result, encoding):
-                return u''.join(result) + u" One"
+                return u''.join(result) + u' One'
 
-        class Transform2(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform2(FauxTransformBase):
 
             order = 1
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
-
             def transformUnicode(self, result, encoding):
                 return result.encode(encoding) + ' Two'
 
-            def transformIterable(self, result, encoding):
-                return None
-
-        class Transform3(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform3(FauxTransformBase):
 
             order = 2
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result.decode(encoding) + u" Three"
+                return result.decode(encoding) + u' Three'
 
-            def transformUnicode(self, result, encoding):
-                None
-
-            def transformIterable(self, result, encoding):
-                return None
-
-        provideAdapter(Transform1, name=u"test.one")
-        provideAdapter(Transform2, name=u"test.two")
-        provideAdapter(Transform3, name=u"test.three")
+        provideAdapter(Transform1, name=u'test.one')
+        provideAdapter(Transform2, name=u'test.two')
+        provideAdapter(Transform3, name=u'test.three')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals(u"Blah One Two Three", new_result)
+        self.assertEqual(u'Blah One Two Three', new_result)
 
     def test_abort(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform1(FauxTransformBase):
+            pass
 
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
-
-            def transformUnicode(self, result, encoding):
-                return None
-
-            def transformIterable(self, result, encoding):
-                return None
-
-        provideAdapter(Transform1, name=u"test.one")
+        provideAdapter(Transform1, name=u'test.one')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals(["Blah"], new_result)
+        self.assertEqual(['Blah'], new_result)
 
     def test_abort_chain(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 0
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
+        class Transform1(FauxTransformBase):
 
             def transformBytes(self, result, encoding):
-                return "One"
+                return 'One'
 
             def transformUnicode(self, result, encoding):
-                return "One"
+                return 'One'
 
             def transformIterable(self, result, encoding):
-                return "One"
-
-        class Transform2(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
-
-            order = 1
-
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
-            def transformBytes(self, result, encoding):
-                return None
+                return 'One'
 
-            def transformUnicode(self, result, encoding):
-                return None
-
-            def transformIterable(self, result, encoding):
-                return None
+        class Transform2(FauxTransformBase):
+            pass
 
-        class Transform3(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform3(FauxTransformBase):
 
             order = 2
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " three"
+                return result + ' three'
 
             def transformUnicode(self, result, encoding):
-                return result + u" three"
+                return result + u' three'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " three"
+                return ''.join(result) + ' three'
 
-        provideAdapter(Transform1, name=u"test.one")
-        provideAdapter(Transform2, name=u"test.two")
-        provideAdapter(Transform3, name=u"test.three")
+        provideAdapter(Transform1, name=u'test.one')
+        provideAdapter(Transform2, name=u'test.two')
+        provideAdapter(Transform3, name=u'test.three')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Blah"]
+        result = ['Blah']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("One three", new_result)
+        self.assertEqual('One three', new_result)
 
     def test_ordering(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform1(FauxTransformBase):
 
             order = 100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " One"
+                return result + ' One'
 
             def transformUnicode(self, result, encoding):
-                return result + u" One"
+                return result + u' One'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " One"
+                return ''.join(result) + ' One'
 
-        class Transform2(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform2(FauxTransformBase):
 
             order = -100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Two"
+                return result + ' Two'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Two"
+                return result + u' Two'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Two"
+                return ''.join(result) + ' Two'
 
-        class Transform3(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform3(FauxTransformBase):
 
             order = 101
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Three"
+                return result + ' Three'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Three"
+                return result + u' Three'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Three"
+                return ''.join(result) + ' Three'
 
-        provideAdapter(Transform1, name=u"test.one")
-        provideAdapter(Transform2, name=u"test.two")
-        provideAdapter(Transform3, name=u"test.three")
+        provideAdapter(Transform1, name=u'test.one')
+        provideAdapter(Transform2, name=u'test.two')
+        provideAdapter(Transform3, name=u'test.three')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Initial"]
+        result = ['Initial']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Initial Two One Three", new_result)
+        self.assertEqual('Initial Two One Three', new_result)
 
     def test_request_marker(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform1(FauxTransformBase):
 
             order = 100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " One"
+                return result + ' One'
 
             def transformUnicode(self, result, encoding):
-                return result + u" One"
+                return result + u' One'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " One"
+                return ''.join(result) + ' One'
 
-        class Transform2(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform2(FauxTransformBase):
 
             order = -100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Two"
+                return result + ' Two'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Two"
+                return result + u' Two'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Two"
+                return ''.join(result) + ' Two'
 
-        class Transform3(object):
-            implements(ITransform)
-            adapts(Interface, IRequestMarker)
+        @implementer(ITransform)
+        @adapter(Interface, IRequestMarker)
+        class Transform3(FauxTransformBase):
 
             order = 101
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Three"
+                return result + ' Three'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Three"
+                return result + u' Three'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Three"
+                return ''.join(result) + ' Three'
 
-        provideAdapter(Transform1, name=u"test.one")
-        provideAdapter(Transform2, name=u"test.two")
-        provideAdapter(Transform3, name=u"test.three")
+        provideAdapter(Transform1, name=u'test.one')
+        provideAdapter(Transform2, name=u'test.two')
+        provideAdapter(Transform3, name=u'test.three')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Initial"]
+        result = ['Initial']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Initial Two One", new_result)
+        self.assertEqual('Initial Two One', new_result)
 
         published = FauxPublished()
         request = FauxRequest(published)
         alsoProvides(request, IRequestMarker)
-        result = ["Initial"]
+        result = ['Initial']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Initial Two One Three", new_result)
+        self.assertEqual('Initial Two One Three', new_result)
 
     def test_published_marker(self):
 
-        class Transform1(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform1(FauxTransformBase):
 
             order = 100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " One"
+                return result + ' One'
 
             def transformUnicode(self, result, encoding):
-                return result + u" One"
+                return result + u' One'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " One"
+                return ''.join(result) + ' One'
 
-        class Transform2(object):
-            implements(ITransform)
-            adapts(Interface, Interface)
+        class Transform2(FauxTransformBase):
 
             order = -100
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Two"
+                return result + ' Two'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Two"
+                return result + u' Two'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Two"
+                return ''.join(result) + ' Two'
 
-        class Transform3(object):
-            implements(ITransform)
-            adapts(IPublishedMarker, Interface)
+        @implementer(ITransform)
+        @adapter(IPublishedMarker, Interface)
+        class Transform3(FauxTransformBase):
 
             order = 101
 
-            def __init__(self, published, request):
-                self.published = published
-                self.request = request
-
             def transformBytes(self, result, encoding):
-                return result + " Three"
+                return result + ' Three'
 
             def transformUnicode(self, result, encoding):
-                return result + u" Three"
+                return result + u' Three'
 
             def transformIterable(self, result, encoding):
-                return ''.join(result) + " Three"
+                return ''.join(result) + ' Three'
 
-        provideAdapter(Transform1, name=u"test.one")
-        provideAdapter(Transform2, name=u"test.two")
-        provideAdapter(Transform3, name=u"test.three")
+        provideAdapter(Transform1, name=u'test.one')
+        provideAdapter(Transform2, name=u'test.two')
+        provideAdapter(Transform3, name=u'test.three')
 
         published = FauxPublished()
         request = FauxRequest(published)
-        result = ["Initial"]
+        result = ['Initial']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Initial Two One", new_result)
+        self.assertEqual('Initial Two One', new_result)
 
         published = FauxPublished()
         alsoProvides(published, IPublishedMarker)
         request = FauxRequest(published)
-        result = ["Initial"]
+        result = ['Initial']
         encoding = 'utf-8'
 
         new_result = self.t(request, result, encoding)
-        self.assertEquals("Initial Two One Three", new_result)
+        self.assertEqual('Initial Two One Three', new_result)
+
 
 class TestZPublisherTransforms(unittest.TestCase):
 
@@ -641,11 +478,13 @@ def setUp(self):
         self.t = Transformer()
 
     def test_applyTransform_webdav_port(self):
+
+        @implementer(ITransformer)
         class DoNotCallTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
-                raise AssertionError("Shouldn't have been called")
+                raise AssertionError('Should not have been called')
 
         transformer = DoNotCallTransformer()
         provideUtility(transformer)
@@ -656,11 +495,12 @@ def __call__(self, request, result, encoding):
         applyTransformOnSuccess(FauxPubEvent(request))
 
     def test_applyTransform_webdav_method(self):
+        @implementer(ITransformer)
         class DoNotCallTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
-                raise AssertionError("Shouldn't have been called")
+                raise AssertionError('Should not have been called')
 
         transformer = DoNotCallTransformer()
         provideUtility(transformer)
@@ -671,11 +511,13 @@ def __call__(self, request, result, encoding):
         applyTransformOnSuccess(FauxPubEvent(request))
 
     def test_applyTransform_webdav_pathinfo(self):
+
+        @implementer(ITransformer)
         class DoNotCallTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
-                raise AssertionError("Shouldn't have been called")
+                raise AssertionError('Should not have been called')
 
         transformer = DoNotCallTransformer()
         provideUtility(transformer)
@@ -691,9 +533,11 @@ def test_applyTransform_no_utility(self):
         applyTransformOnSuccess(FauxPubEvent(request))
 
     def test_applyTransform_default_encoding(self):
+
+        @implementer(ITransformer)
         class EncodingCaptureTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
                 self.encoding = encoding
 
@@ -704,12 +548,13 @@ def __call__(self, request, result, encoding):
         request = FauxRequest(published)
         applyTransformOnSuccess(FauxPubEvent(request))
 
-        self.assertEquals(default_encoding, transformer.encoding)
+        self.assertEqual(default_encoding, transformer.encoding)
 
     def test_applyTransform_other_encoding(self):
+        @implementer(ITransformer)
         class EncodingCaptureTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
                 self.encoding = encoding
 
@@ -721,12 +566,13 @@ def __call__(self, request, result, encoding):
         request.response.headers['content-type'] = 'text/html; charset=dummy'
         applyTransformOnSuccess(FauxPubEvent(request))
 
-        self.assertEquals("dummy", transformer.encoding)
+        self.assertEqual('dummy', transformer.encoding)
 
     def test_applyTransform_other_encoding_with_header_missing_space(self):
+        @implementer(ITransformer)
         class EncodingCaptureTransformer(object):
-            implements(ITransformer)
             encoding = None
+
             def __call__(self, request, result, encoding):
                 self.encoding = encoding
 
@@ -738,11 +584,12 @@ def __call__(self, request, result, encoding):
         request.response.headers['content-type'] = 'text/html;charset=dummy'
         applyTransformOnSuccess(FauxPubEvent(request))
 
-        self.assertEquals("dummy", transformer.encoding)
+        self.assertEqual('dummy', transformer.encoding)
 
     def test_applyTransform_str(self):
+        @implementer(ITransformer)
         class FauxTransformer(object):
-            implements(ITransformer)
+
             def __call__(self, request, result, encoding):
                 return 'dummystr'
 
@@ -753,11 +600,12 @@ def __call__(self, request, result, encoding):
         request = FauxRequest(published)
         applyTransformOnSuccess(FauxPubEvent(request))
 
-        self.assertEquals('dummystr', request.response.getBody())
+        self.assertEqual('dummystr', request.response.getBody())
 
     def test_applyTransform_unicode(self):
+        @implementer(ITransformer)
         class FauxTransformer(object):
-            implements(ITransformer)
+
             def __call__(self, request, result, encoding):
                 return u'dummystr'
 
@@ -769,11 +617,12 @@ def __call__(self, request, result, encoding):
         applyTransformOnSuccess(FauxPubEvent(request))
 
         # note: the real setBody would encode here
-        self.assertEquals(u'dummystr', request.response.getBody())
+        self.assertEqual(u'dummystr', request.response.getBody())
 
     def test_applyTransform_iterable(self):
+        @implementer(ITransformer)
         class FauxTransformer(object):
-            implements(ITransformer)
+
             def __call__(self, request, result, encoding):
                 return ['iter', 'one']
 
@@ -784,18 +633,18 @@ def __call__(self, request, result, encoding):
         request = FauxRequest(published)
         applyTransformOnSuccess(FauxPubEvent(request))
 
-        self.assertEquals('iterone', request.response.getBody())
+        self.assertEqual('iterone', request.response.getBody())
 
     def test_applyTransform_streamiterator(self):
         tmp = tempfile.mkstemp()[1]
         try:
 
-            out = open(tmp, 'w')
-            print >> out, "foo"
-            out.close()
+            with open(tmp, 'w') as out:
+                out.write('foo')
 
+            @implementer(ITransformer)
             class FauxTransformer(object):
-                implements(ITransformer)
+
                 def __call__(self, request, result, encoding):
                     return filestream_iterator(tmp)
 
@@ -806,13 +655,19 @@ def __call__(self, request, result, encoding):
             request = FauxRequest(published)
             applyTransformOnSuccess(FauxPubEvent(request))
 
-            self.failUnless(isinstance(request.response.getBody(), filestream_iterator,))
+            self.assertTrue(
+                isinstance(
+                    request.response.getBody(),
+                    filestream_iterator
+                )
+            )
         finally:
             os.unlink(tmp)
 
     def test_applyTransform_str_input_body(self):
+        @implementer(ITransformer)
         class FauxTransformer(object):
-            implements(ITransformer)
+
             def __call__(self, request, result, encoding):
                 assert isinstance(result, list)
                 assert isinstance(result[0], str)
@@ -823,16 +678,17 @@ def __call__(self, request, result, encoding):
 
         published = FauxPublished()
         request = FauxRequest(published)
-        request.response.setBody("<html />")
+        request.response.setBody('<html />')
 
         applyTransformOnSuccess(FauxPubEvent(request))
 
         # note: the real setBody would encode here
-        self.assertEquals('dummystr', request.response.getBody())
+        self.assertEqual('dummystr', request.response.getBody())
 
     def test_applyTransform_unicode_input_body(self):
+        @implementer(ITransformer)
         class FauxTransformer(object):
-            implements(ITransformer)
+
             def __call__(self, request, result, encoding):
                 assert isinstance(result, list)
                 assert isinstance(result[0], str)
@@ -843,9 +699,9 @@ def __call__(self, request, result, encoding):
 
         published = FauxPublished()
         request = FauxRequest(published)
-        request.response.setBody(u"<html />")
+        request.response.setBody(u'<html />')
 
         applyTransformOnSuccess(FauxPubEvent(request))
 
         # note: the real setBody would encode here
-        self.assertEquals(u'dummystr', request.response.getBody())
+        self.assertEqual(u'dummystr', request.response.getBody())
diff --git a/plone/transformchain/transformer.py b/plone/transformchain/transformer.py
index f6f9585..19fb069 100644
--- a/plone/transformchain/transformer.py
+++ b/plone/transformchain/transformer.py
@@ -1,29 +1,26 @@
-import logging
-
-from zope.interface import implements
-from zope.component import getAdapters
-
-from plone.transformchain.interfaces import ITransform, ITransformer
+# -*- coding: utf-8 -*-
+from operator import attrgetter
 from plone.transformchain.interfaces import DISABLE_TRANSFORM_REQUEST_KEY
-
+from plone.transformchain.interfaces import ITransform
+from plone.transformchain.interfaces import ITransformer
 from ZODB.POSException import ConflictError
+from zope.component import getAdapters
+from zope.interface import implementer
 from ZServer.FTPRequest import FTPRequest
 
-def sort_key(a, b):
-    return cmp(a.order, b.order)
+import logging
+
 
 LOGGER = logging.getLogger('plone.transformchain')
 
+
+@implementer(ITransformer)
 class Transformer(object):
     """Delegate the opportunity to transform the response to multiple,
     ordered adapters.
     """
 
-    implements(ITransformer)
-
     def __call__(self, request, result, encoding):
-
-
         # Don't transform FTP requests
         if isinstance(request, FTPRequest):
             return None
@@ -34,12 +31,10 @@ def __call__(self, request, result, encoding):
 
         try:
             published = request.get('PUBLISHED', None)
-
-            handlers = [v[1] for v in getAdapters((published, request,), ITransform)]
-            handlers.sort(sort_key)
-
-            for handler in handlers:
-
+            handlers = (
+                v[1] for v in getAdapters((published, request,), ITransform)
+            )
+            for handler in sorted(handlers, key=attrgetter('order')):
                 if isinstance(result, unicode):
                     newResult = handler.transformUnicode(result, encoding)
                 elif isinstance(result, str):
@@ -53,5 +48,7 @@ def __call__(self, request, result, encoding):
             return result
         except ConflictError:
             raise
-        except Exception, e:
-            LOGGER.exception(u"Unexpected error whilst trying to apply transform chain")
+        except Exception:
+            LOGGER.exception(
+                u"Unexpected error whilst trying to apply transform chain"
+            )
diff --git a/plone/transformchain/zpublisher.py b/plone/transformchain/zpublisher.py
index 52bf5d7..8de080d 100644
--- a/plone/transformchain/zpublisher.py
+++ b/plone/transformchain/zpublisher.py
@@ -1,16 +1,14 @@
-import sys
-import re
-
+# -*- coding: utf-8 -*-
+from plone.transformchain.interfaces import ITransformer
+from zope.component import adapter
+from zope.component import queryUtility
 from zope.interface import Interface
-from zope.interface.interfaces import IInterface
-from zope.component import queryUtility, adapter
-
-from ZPublisher.Iterators import IStreamIterator
 from ZPublisher.HTTPResponse import default_encoding
+from ZPublisher.interfaces import IPubBeforeCommit
+from ZPublisher.Iterators import IStreamIterator
 
-from plone.transformchain.interfaces import ITransformer
+import re
 
-from ZPublisher.interfaces import IPubBeforeCommit
 
 try:
     from ZPublisher.interfaces import IPubBeforeAbort
@@ -20,7 +18,12 @@
     class IPubBeforeAbort(Interface):
         pass
 
-CHARSET_RE = re.compile(r'(?:application|text)/[-+0-9a-z]+\s*;\s?charset=([-_0-9a-z]+)(?:(?:\s*;)|\Z)', re.IGNORECASE)
+CHARSET_RE = re.compile(
+    r'(?:application|text)/[-+0-9a-z]+\s*;\s?charset=([-_0-9a-z]+)'
+    r'(?:(?:\s*;)|\Z)',
+    re.IGNORECASE
+)
+
 
 def extractEncoding(response):
     """Get the content encoding for the response body
@@ -33,6 +36,7 @@ def extractEncoding(response):
             encoding = match.group(1)
     return encoding
 
+
 def isEvilWebDAVRequest(request):
     if request.get('WEBDAV_SOURCE_PORT', None):
         return True
@@ -45,6 +49,7 @@ def isEvilWebDAVRequest(request):
 
     return False
 
+
 def applyTransform(request, body=None):
     """Apply any transforms by delegating to the ITransformer utility
     """
@@ -72,51 +77,40 @@ def applyTransform(request, body=None):
 
     return None
 
+
 @adapter(IPubBeforeCommit)
 def applyTransformOnSuccess(event):
     """Apply the transform after a successful request
     """
     transformed = applyTransform(event.request)
-    if transformed is not None:
-        response = event.request.response
-
-        # horrid check to deal with Plone 3/Zope 2.10, where this is still an old-style interface
-        if ((IInterface.providedBy(IStreamIterator)     and IStreamIterator.providedBy(transformed))
-         or (not IInterface.providedBy(IStreamIterator) and IStreamIterator.isImplementedBy(transformed))
-        ):
-            response.setBody(transformed)
-        # setBody() can deal with byte and unicode strings (and will encode as necessary)...
-        elif isinstance(transformed, basestring):
-            response.setBody(transformed)
-        # ... but not with iterables
-        else:
-            response.setBody(''.join(transformed))
+    if transformed is None:
+        return
+    response = event.request.response
+
+    if IStreamIterator.providedBy(transformed):
+        response.setBody(transformed)
+    # setBody() can deal with byte and unicode strings (and will encode as
+    # necessary)...
+    elif isinstance(transformed, basestring):
+        response.setBody(transformed)
+    # ... but not with iterables
+    else:
+        response.setBody(''.join(transformed))
+
 
 @adapter(IPubBeforeAbort)
 def applyTransformOnFailure(event):
     """Apply the transform to the error html output
     """
-    if not event.retry:
-        request = event.request
-        exc_info = sys.exc_info()
-        error = exc_info[1]
-        if isinstance(error, basestring): # Zope 2.10 - the exception is rendered (eeeeek)
-            transformed = applyTransform(request, error)
-            if transformed is not None:
-
-                if not isinstance(transformed, basestring):
-                    transformed = ''.join(transformed)
-
-                # If it's any consolation, Laurence felt quite dirty doing this...
-                raise exc_info[0], transformed, exc_info[2]
-        else: # Zope 2.12 - we are allowed to call setBody()
-            # response.status might still be 200 because
-            # IPubBeforeAbort is notified before
-            # ZPublisher.Publish.publish_module_standard
-            # calls HTTPResponse.exception()
-            # which actually updates the status
-            setErrorStatusOnResponse(event)
-            applyTransformOnSuccess(event)
+    if event.retry:
+        return
+    # response.status might still be 200 because
+    # IPubBeforeAbort is notified before
+    # ZPublisher.Publish.publish_module_standard
+    # calls HTTPResponse.exception()
+    # which actually updates the status
+    setErrorStatusOnResponse(event)
+    applyTransformOnSuccess(event)
 
 
 def setErrorStatusOnResponse(event):
diff --git a/setup.py b/setup.py
index 0eb2898..2663c73 100644
--- a/setup.py
+++ b/setup.py
@@ -1,45 +1,48 @@
-from setuptools import setup, find_packages
+from setuptools import find_packages
+from setuptools import setup
 
-version = '1.0.5.dev0'
 
-setup(name='plone.transformchain',
-      version=version,
-      description=("Hook into repoze.zope2 that allows third party packages "
-                   "to register a sequence of hooks that will be allowed to "
-                   "modify the response before it is returned to the browser"),
-      long_description=(open("README.rst").read() + "\n" +
-                        open("CHANGES.rst").read()),
-      # Get more strings from
-      # https://pypi.python.org/pypi?%3Aaction=list_classifiers
-      classifiers=[
-          "Framework :: Plone",
-          "Framework :: Plone :: 4.3",
-          "Framework :: Plone :: 5.0",
-          "Programming Language :: Python",
-          "Topic :: Software Development :: Libraries :: Python Modules",
-          "Programming Language :: Python :: 2.6",
-          "Programming Language :: Python :: 2.7",
-          ],
-      keywords='zope2 repoze transform',
-      author='Martin Aspeli',
-      author_email='optilude@gmail.com',
-      url='https://pypi.python.org/pypi/plone.transformchain',
-      license='BSD',
-      packages=find_packages(exclude=['ez_setup']),
-      namespace_packages=['plone'],
-      include_package_data=True,
-      zip_safe=False,
-      extras_require={
-          'repoze': ['repoze.zope2'],
-          'Zope2.10': ['ZPublisherEventsBackport'],
-          'test': 'plone.testing [zca]',
-      },
-      install_requires=[
-          'setuptools',
-          'zope.interface',
-          'zope.component',
-          'zope.schema',
-      ],
-      entry_points="""
-      """,
-      )
+version = '1.1.0.dev0'
+
+setup(
+    name='plone.transformchain',
+    version=version,
+    description=("Hook into repoze.zope2 that allows third party packages "
+                 "to register a sequence of hooks that will be allowed to "
+                 "modify the response before it is returned to the browser"),
+    long_description=(open("README.rst").read() + "\n" +
+                      open("CHANGES.rst").read()),
+    # Get more strings from
+    # https://pypi.python.org/pypi?%3Aaction=list_classifiers
+    classifiers=[
+        "Framework :: Plone",
+        "Framework :: Plone :: 4.3",
+        "Framework :: Plone :: 5.0",
+        "Programming Language :: Python",
+        "Topic :: Software Development :: Libraries :: Python Modules",
+        "Programming Language :: Python :: 2.6",
+        "Programming Language :: Python :: 2.7",
+    ],
+    keywords='zope2 repoze transform',
+    author='Martin Aspeli',
+    author_email='optilude@gmail.com',
+    url='https://pypi.python.org/pypi/plone.transformchain',
+    license='BSD',
+    packages=find_packages(exclude=['ez_setup']),
+    namespace_packages=['plone'],
+    include_package_data=True,
+    zip_safe=False,
+    extras_require={
+        'repoze': ['repoze.zope2'],
+        'test': 'plone.testing [zca]',
+    },
+    install_requires=[
+        'setuptools',
+        'zope.interface',
+        'zope.component',
+        'zope.schema',
+        'Zope2>=2.13.23'
+    ],
+    entry_points="""
+    """,
+)


