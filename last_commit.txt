Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2016-12-20T20:39:09+01:00
Author: Gil Forcada (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/a5ad845a3f057202be87ee5e3d11e39f51672cc2

Cleanup code

Files changed:
M CHANGES.rst
M plone/app/iterate/__init__.py
M plone/app/iterate/archiver.py
M plone/app/iterate/browser/cancel.py
M plone/app/iterate/browser/checkin.py
M plone/app/iterate/browser/checkout.py
M plone/app/iterate/browser/control.py
M plone/app/iterate/browser/diff.py
M plone/app/iterate/browser/info.py
M plone/app/iterate/containers.py
M plone/app/iterate/copier.py
M plone/app/iterate/dexterity/copier.py
M plone/app/iterate/dexterity/interfaces.py
M plone/app/iterate/dexterity/policy.py
M plone/app/iterate/dexterity/relation.py
M plone/app/iterate/dexterity/utils.py
M plone/app/iterate/interfaces.py
M plone/app/iterate/permissions.py
M plone/app/iterate/policy.py
M plone/app/iterate/relation.py
M plone/app/iterate/subscribers/versioning.py
M plone/app/iterate/subscribers/workflow.py
M plone/app/iterate/testing.py
M plone/app/iterate/tests/test_doctests.py
M plone/app/iterate/tests/test_iterate.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 0e5c653..42f1217 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -17,6 +17,8 @@ Bug fixes:
 - Cleanup: isort, zca decorators, etc.
   [jensens]
 
+- Some more cleanup.
+  [gforcada]
 
 3.2.3 (2016-11-10)
 ------------------
diff --git a/plone/app/iterate/__init__.py b/plone/app/iterate/__init__.py
index 74f6375..8d1a70e 100644
--- a/plone/app/iterate/__init__.py
+++ b/plone/app/iterate/__init__.py
@@ -42,8 +42,10 @@
 
 try:
     import plone.app.stagingbehavior  # noqa
-    logger.error('plone.app.stagingbehavior should NOT be installed with this version '
-                 'of plone.app.iterate. You may experience problems running this configuration. '
-                 'plone.app.iterate now has dexterity suport built-in.')
+    logger.error(
+        'plone.app.stagingbehavior should NOT be installed with this version '
+        'of plone.app.iterate. You may experience problems running this '
+        'configuration. plone.app.iterate now has dexterity suport built-in.'
+    )
 except ImportError:
     pass
diff --git a/plone/app/iterate/archiver.py b/plone/app/iterate/archiver.py
index d008abc..b61cb68 100644
--- a/plone/app/iterate/archiver.py
+++ b/plone/app/iterate/archiver.py
@@ -20,10 +20,6 @@
 # along with CMFDeployment; if not, write to the Free Software
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ##################################################################
-"""
-$Id: archiver.py 1824 2007-02-08 17:59:41Z hazmat $
-"""
-
 from Products.CMFCore.utils import getToolByName
 from zope.component import adapter
 from zope.interface import implementer
@@ -55,5 +51,5 @@ def isVersioned(self):
     def isModified(self):
         try:
             return not self.repository.isUpToDate(self.context)
-        except:
+        except Exception:
             return False
diff --git a/plone/app/iterate/browser/cancel.py b/plone/app/iterate/browser/cancel.py
index 4d6439c..95582fe 100644
--- a/plone/app/iterate/browser/cancel.py
+++ b/plone/app/iterate/browser/cancel.py
@@ -38,24 +38,24 @@ class Cancel(BrowserView):
     def __call__(self):
         context = aq_inner(self.context)
 
-        if self.request.form.has_key('form.button.Cancel'):
+        if 'form.button.Cancel' in self.request.form:
             control = getMultiAdapter(
-                (context, self.request), name=u"iterate_control")
+                (context, self.request), name=u'iterate_control')
             if not control.cancel_allowed():
-                raise CheckoutException(u"Not a checkout")
+                raise CheckoutException(u'Not a checkout')
 
             policy = ICheckinCheckoutPolicy(context)
             baseline = policy.cancelCheckout()
             baseline.reindexObject()
 
             IStatusMessage(self.request).addStatusMessage(
-                _(u"Checkout cancelled"), type='info')
+                _(u'Checkout cancelled'), type='info')
             view_url = baseline.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
-        elif self.request.form.has_key('form.button.Keep'):
+        elif 'form.button.Keep' in self.request.form:
             view_url = context.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
diff --git a/plone/app/iterate/browser/checkin.py b/plone/app/iterate/browser/checkin.py
index 7fb1a50..28f56ea 100644
--- a/plone/app/iterate/browser/checkin.py
+++ b/plone/app/iterate/browser/checkin.py
@@ -38,25 +38,25 @@ class Checkin(BrowserView):
     def __call__(self):
         context = aq_inner(self.context)
 
-        if self.request.form.has_key('form.button.Checkin'):
+        if 'form.button.Checkin' in self.request.form:
             control = getMultiAdapter(
-                (context, self.request), name=u"iterate_control")
+                (context, self.request), name=u'iterate_control')
             if not control.checkin_allowed():
-                raise CheckinException(u"Not a checkout")
+                raise CheckinException(u'Not a checkout')
 
-            message = self.request.form.get('checkin_message', "")
+            message = self.request.form.get('checkin_message', '')
 
             policy = ICheckinCheckoutPolicy(context)
             baseline = policy.checkin(message)
 
             IStatusMessage(self.request).addStatusMessage(
-                _("Checked in"), type='info')
+                _('Checked in'), type='info')
             view_url = baseline.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
-        elif self.request.form.has_key('form.button.Cancel'):
+        elif 'form.button.Cancel'in self.request.form:
             view_url = context.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
diff --git a/plone/app/iterate/browser/checkout.py b/plone/app/iterate/browser/checkout.py
index 12185ee..4fb9577 100644
--- a/plone/app/iterate/browser/checkout.py
+++ b/plone/app/iterate/browser/checkout.py
@@ -52,20 +52,25 @@ def __call__(self):
         # end up downloading a file
         if 'form.button.Checkout' in self.request.form:
             control = getMultiAdapter(
-                (context, self.request), name=u"iterate_control")
+                (context, self.request), name=u'iterate_control')
             if not control.checkout_allowed():
-                raise CheckoutException(u"Not allowed")
+                raise CheckoutException(u'Not allowed')
 
             location = self.request.form.get('checkout_location', None)
             locator = None
             try:
-                locator = [c['locator']
-                           for c in self.containers() if c['name'] == location][0]
+                locator = [
+                    c['locator']
+                    for c in self.containers()
+                    if c['name'] == location
+                ][0]
             except IndexError:
-                IStatusMessage(self.request).addStatusMessage(_("Cannot find checkout location"),
-                                                              type='error')
+                IStatusMessage(self.request).addStatusMessage(
+                    _('Cannot find checkout location'),
+                    type='error'
+                )
                 view_url = context.restrictedTraverse(
-                    "@@plone_context_state").view_url()
+                    '@@plone_context_state').view_url()
                 self.request.response.redirect(view_url)
                 return
 
@@ -77,13 +82,13 @@ def __call__(self):
             context.reindexObject('review_state')
 
             IStatusMessage(self.request).addStatusMessage(
-                _("Check-out created"), type='info')
+                _('Check-out created'), type='info')
             view_url = wc.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
         elif 'form.button.Cancel' in self.request.form:
             view_url = context.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
diff --git a/plone/app/iterate/browser/control.py b/plone/app/iterate/browser/control.py
index 309a343..56762bb 100644
--- a/plone/app/iterate/browser/control.py
+++ b/plone/app/iterate/browser/control.py
@@ -62,7 +62,11 @@ def checkin_allowed(self):
         if original is None:
             return False
 
-        if not checkPermission(Products.CMFCore.permissions.ModifyPortalContent, original):
+        can_modify = checkPermission(
+            Products.CMFCore.permissions.ModifyPortalContent,
+            original,
+        )
+        if not can_modify:
             return False
 
         return True
diff --git a/plone/app/iterate/browser/diff.py b/plone/app/iterate/browser/diff.py
index 75835c7..f63e19e 100644
--- a/plone/app/iterate/browser/diff.py
+++ b/plone/app/iterate/browser/diff.py
@@ -21,12 +21,12 @@ def __call__(self):
             self.working_copy = self.context
             self.baseline = policy.getBaseline()
         else:
-            raise AttributeError("Invalid Context")
+            raise AttributeError('Invalid Context')
         return self.index()
 
     def diffs(self):
         diff = getToolByName(self.context, 'portal_diff')
         return diff.createChangeSet(self.baseline,
                                     self.working_copy,
-                                    id1="Baseline",
-                                    id2="Working Copy")
+                                    id1='Baseline',
+                                    id2='Working Copy')
diff --git a/plone/app/iterate/browser/info.py b/plone/app/iterate/browser/info.py
index 2fba85e..8a6316e 100644
--- a/plone/app/iterate/browser/info.py
+++ b/plone/app/iterate/browser/info.py
@@ -43,7 +43,11 @@ def policy(self):
     def created(self):
         time = self.properties.get(keys.checkout_time, DateTime())
         util = getToolByName(self.context, 'translation_service')
-        return util.ulocalized_time(time, context=self.context, domain='plonelocales')
+        return util.ulocalized_time(
+            time,
+            context=self.context,
+            domain='plonelocales',
+        )
 
     @memoize
     def creator(self):
@@ -58,7 +62,7 @@ def creator_url(self):
         creator = self.creator()
         if creator is not None:
             portal_url = getToolByName(self.context, 'portal_url')
-            return "%s/author/%s" % (portal_url(), creator.getId())
+            return '{0}/author/{1}'.format(portal_url(), creator.getId())
 
     @memoize
     def creator_name(self):
@@ -69,10 +73,12 @@ def creator_name(self):
         # the user and log this.
         name = self.properties.get(keys.checkout_user)
         if IBaseline.providedBy(self.context):
-            warning_tpl = "%s is a baseline of a plone.app.iterate checkout by an unknown user id '%s'"  # noqa
+            warning_tpl = '%s is a baseline of a plone.app.iterate checkout ' \
+                          'by an unknown user id "%s"'
         else:
             # IWorkingCopy.providedBy(self.context)
-            warning_tpl = "%s is a working copy of a plone.app.iterate checkout by an unknown user id '%s'"  # noqa
+            warning_tpl = '%s is a working copy of a plone.app.iterate ' \
+                          'checkout by an unknown user id "%s"'
         logger.warning(warning_tpl, self.context, name)
         return name
 
@@ -102,7 +108,7 @@ def render(self):
                 sm.checkPermission(ModifyPortalContent, working_copy)):
             return self.index()
         else:
-            return ""
+            return ''
 
     @memoize
     def working_copy(self):
@@ -124,7 +130,7 @@ def render(self):
                 sm.checkPermission(CheckoutPermission, baseline)):
             return self.index()
         else:
-            return ""
+            return ''
 
     @memoize
     def baseline(self):
diff --git a/plone/app/iterate/containers.py b/plone/app/iterate/containers.py
index ce52d45..063ecdb 100644
--- a/plone/app/iterate/containers.py
+++ b/plone/app/iterate/containers.py
@@ -42,7 +42,7 @@ class HomeFolderLocator(object):
     def __init__(self, context):
         self.context = context
 
-    title = _(u"Home folder")
+    title = _(u'Home folder')
 
     @property
     def available(self):
@@ -62,7 +62,7 @@ class ParentFolderLocator(object):
     def __init__(self, context):
         self.context = context
 
-    title = _(u"Parent folder")
+    title = _(u'Parent folder')
 
     @property
     def available(self):
diff --git a/plone/app/iterate/copier.py b/plone/app/iterate/copier.py
index 256cc4a..70e0fa3 100644
--- a/plone/app/iterate/copier.py
+++ b/plone/app/iterate/copier.py
@@ -57,7 +57,7 @@ def copyTo(self, container):
             self.context,
             relationship=WorkingCopyRelation.relationship,
             referenceClass=WorkingCopyRelation)
-        self._handleReferences(self.context, wc, "checkout", wc_ref)
+        self._handleReferences(self.context, wc, 'checkout', wc_ref)
         return wc, wc_ref
 
     def merge(self):
@@ -67,7 +67,7 @@ def merge(self):
         wc_ref = self._deleteWorkingCopyRelation()
 
         # reassemble references on the new baseline
-        self._handleReferences(baseline, self.context, "checkin", wc_ref)
+        self._handleReferences(baseline, self.context, 'checkin', wc_ref)
 
         # move the working copy to the baseline container, deleting
         # the baseline
@@ -84,10 +84,10 @@ def _getBaseline(self):
         refs = self.context.getRefs(WorkingCopyRelation.relationship)
 
         if not len(refs) == 1:
-            raise CheckinException("Baseline count mismatch")
+            raise CheckinException('Baseline count mismatch')
 
         if not refs or refs[0] is None:
-            raise CheckinException("Baseline has disappeared")
+            raise CheckinException('Baseline has disappeared')
 
         baseline = refs[0]
         return baseline
@@ -251,7 +251,7 @@ def _handleReferences(self, baseline, wc, mode, wc_ref):
             mode_method = getattr(adapter, mode)
             mode_method(baseline, wc, references, annotations)
 
-        mode = mode + "BackReferences"
+        mode = mode + 'BackReferences'
 
         # handle backward references
         for relationship in baseline.getBRelationships():
diff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py
index 64219d4..7e6c82b 100644
--- a/plone/app/iterate/dexterity/copier.py
+++ b/plone/app/iterate/dexterity/copier.py
@@ -21,7 +21,7 @@
 
 try:
     from zope.intid.interfaces import IIntIds
-except:
+except ImportError:
     from zope.app.intid.interfaces import IIntIds
 
 
@@ -48,7 +48,7 @@ def merge(self):
         wc_ref = self._deleteWorkingCopyRelation()
 
         # reassemble references on the new baseline
-        self._handleReferences(baseline, self.context, "checkin", wc_ref)
+        self._handleReferences(baseline, self.context, 'checkin', wc_ref)
 
         # move the working copy to the baseline container, deleting the
         # baseline
@@ -74,7 +74,7 @@ def _replaceBaseline(self, baseline):
                     continue
                 try:
                     value = field.get(schema(self.context))
-                except:
+                except Exception:
                     value = None
 
                 # TODO: We need a way to identify the DCFieldProperty
@@ -141,10 +141,10 @@ def _get_relation_to_baseline(self):
                            relations)
         # do we have a baseline in our relations?
         if relations and not len(relations) == 1:
-            raise interfaces.CheckinException("Baseline count mismatch")
+            raise interfaces.CheckinException('Baseline count mismatch')
 
         if not relations or not relations[0]:
-            raise interfaces.CheckinException("Baseline has disappeared")
+            raise interfaces.CheckinException('Baseline has disappeared')
         return relations[0]
 
     def _getBaseline(self):
@@ -154,7 +154,7 @@ def _getBaseline(self):
             baseline = intids.getObject(relation.from_id)
 
         if not baseline:
-            raise interfaces.CheckinException("Baseline has disappeared")
+            raise interfaces.CheckinException('Baseline has disappeared')
         return baseline
 
     def checkin(self, checkin_message):
diff --git a/plone/app/iterate/dexterity/interfaces.py b/plone/app/iterate/dexterity/interfaces.py
index d0674dc..53fdc57 100644
--- a/plone/app/iterate/dexterity/interfaces.py
+++ b/plone/app/iterate/dexterity/interfaces.py
@@ -1,7 +1,6 @@
 # -*- coding: utf-8 -*-
 from plone.app.iterate.interfaces import IIterateAware
 from z3c.relationfield.interfaces import IRelationValue
-from zope.interface import Attribute
 
 
 class IStagingRelationValue(IRelationValue):
diff --git a/plone/app/iterate/dexterity/policy.py b/plone/app/iterate/dexterity/policy.py
index 9ca3886..a7496fc 100644
--- a/plone/app/iterate/dexterity/policy.py
+++ b/plone/app/iterate/dexterity/policy.py
@@ -11,7 +11,9 @@
 
 
 @implementer(iterate.interfaces.ICheckinCheckoutPolicy)
-class CheckinCheckoutPolicyAdapter(iterate.policy.CheckinCheckoutPolicyAdapter):
+class CheckinCheckoutPolicyAdapter(
+    iterate.policy.CheckinCheckoutPolicyAdapter
+):
     """
     Dexterity Checkin Checkout Policy
     """
@@ -22,11 +24,11 @@ def _get_relation_to_baseline(self):
 
         if relations and not len(relations) == 1:
             raise iterate.interfaces.CheckinException(
-                "Baseline count mismatch")
+                'Baseline count mismatch')
 
         if not relations or not relations[0]:
             raise iterate.interfaces.CheckinException(
-                "Baseline has disappeared")
+                'Baseline has disappeared')
 
         return relations[0]
 
@@ -34,7 +36,7 @@ def _getBaseline(self):
         baseline = get_baseline(self.context)
         if not baseline:
             raise iterate.interfaces.CheckinException(
-                "Baseline has disappeared")
+                'Baseline has disappeared')
         return baseline
 
     def checkin(self, checkin_message):
diff --git a/plone/app/iterate/dexterity/relation.py b/plone/app/iterate/dexterity/relation.py
index 64fb3b0..fa3b054 100644
--- a/plone/app/iterate/dexterity/relation.py
+++ b/plone/app/iterate/dexterity/relation.py
@@ -26,6 +26,9 @@ def get_relations_of(cls, obj, from_attribute=None):
         items = list(catalog.findRelations({'from_id': obj_id}))
         items += list(catalog.findRelations({'to_id': obj_id}))
         if from_attribute:
-            condition = lambda r: r.from_attribute == from_attribute and not r.is_broken()
+
+            def condition(r):
+                return r.from_attribute == from_attribute and not r.is_broken()
+
             items = filter(condition, items)
         return items
diff --git a/plone/app/iterate/dexterity/utils.py b/plone/app/iterate/dexterity/utils.py
index f2a0d02..ad7bada 100644
--- a/plone/app/iterate/dexterity/utils.py
+++ b/plone/app/iterate/dexterity/utils.py
@@ -8,7 +8,7 @@
 
 try:
     from zope.intid.interfaces import IIntIds
-except:
+except ImportError:
     from zope.app.intid.interfaces import IIntIds
 
 
diff --git a/plone/app/iterate/interfaces.py b/plone/app/iterate/interfaces.py
index a5c3fc4..1656454 100644
--- a/plone/app/iterate/interfaces.py
+++ b/plone/app/iterate/interfaces.py
@@ -69,13 +69,13 @@ class ConflictError(CheckinException):
 
 #################################
 # Annotation Key
-annotation_key = "ore.iterate"
+annotation_key = 'ore.iterate'
 
 
 class keys(object):
     # various common keys
-    checkout_user = "checkout_user"
-    checkout_time = "checkout_time"
+    checkout_user = 'checkout_user'
+    checkout_time = 'checkout_time'
 
 
 #################################
@@ -86,15 +86,15 @@ class ICheckinEvent(IObjectEvent):
     message is sent before any mutation/merge has been done on the objects
     """
 
-    baseline = Attribute("The Working Copy's baseline")
-    relation = Attribute("The Working Copy Archetypes Relation Object")
-    checkin_message = Attribute("checkin message")
+    baseline = Attribute('The Working Copy\'s baseline')
+    relation = Attribute('The Working Copy Archetypes Relation Object')
+    checkin_message = Attribute('checkin message')
 
 
 class IAfterCheckinEvent(IObjectEvent):
     """ sent out after an object is checked in """
 
-    checkin_message = Attribute("checkin message")
+    checkin_message = Attribute('checkin message')
 
 
 class IBeforeCheckoutEvent(IObjectEvent):
@@ -104,25 +104,26 @@ class IBeforeCheckoutEvent(IObjectEvent):
 class ICheckoutEvent(IObjectEvent):
     """ an object is being checked out, event.object is the baseline """
 
-    working_copy = Attribute("The object's working copy")
-    relation = Attribute("The Working Copy Archetypes Relation Object")
+    working_copy = Attribute('The object\'s working copy')
+    relation = Attribute('The Working Copy Archetypes Relation Object')
 
 
 class ICancelCheckoutEvent(IObjectEvent):
     """ a working copy is being cancelled """
 
-    baseline = Attribute("The working copy's baseline")
+    baseline = Attribute('The working copy\'s baseline')
 
 
 class IWorkingCopyDeletedEvent(IObjectEvent):
-    """ a working copy is being deleted, this gets called multiple times at different
-    states. so on cancel checkout and checkin operations, its mostly designed to
+    """ a working copy is being deleted, this gets called multiple times at
+    different states.
+    So on cancel checkout and checkin operations, its mostly designed to
     broadcast an event when the user deletes a working copy using the standard
     container paradigms.
     """
 
-    baseline = Attribute("The working copy baseline")
-    relation = Attribute("The Working Copy Archetypes Relation Object")
+    baseline = Attribute('The working copy baseline')
+    relation = Attribute('The Working Copy Archetypes Relation Object')
 
 #################################
 # Content Marker Interfaces
@@ -158,10 +159,10 @@ class IWCContainerLocator(Interface):
     """
 
     available = schema.Bool(
-        title=u"Available", description=u"Whether location will be available.")
+        title=u'Available', description=u'Whether location will be available.')
 
     title = schema.TextLine(
-        title=u"Title", description=u"Title of this location")
+        title=u'Title', description=u'Title of this location')
 
     def __call__():
         """Return a container object, or None if available() is False
@@ -184,23 +185,20 @@ def allowCheckout(content):
         """
 
     def allowCancelCheckout(content):
-        """
-        denotes whether a cancel checkout operation can be performed on the content.
+        """denotes whether a cancel checkout operation can be performed on the
+        content.
         """
 
     def checkin(content, checkin_messsage):
-        """
-        check the working copy in, this will merge the working copy with the baseline
-
+        """check the working copy in, this will merge the working copy with
+        the baseline
         """
 
     def checkout(container, content):
-        """
-        """
+        pass
 
     def cancelCheckout(content):
-        """
-        """
+        pass
 
 
 class IObjectCopier(Interface):
@@ -208,8 +206,9 @@ class IObjectCopier(Interface):
     """
 
     def copyTo(container):
-        """ copy the context to the given container, must also create an AT relation
-        using the WorkingCopyRelation.relation name between the source and the copy.
+        """ copy the context to the given container, must also create an AT
+        relation using the WorkingCopyRelation.relation name between the
+        source and the copy.
         returns the copy.
         """
 
@@ -240,23 +239,21 @@ def isModified(self):
 
 
 class ICheckinCheckoutPolicy(Interface):
-    """
-    Checkin / Checkout Policy
-    """
+    """Checkin / Checkout Policy"""
 
     def checkin(checkin_message):
-        """
-        checkin the context, if the target has been deleted then raises a checkin exception.
+        """checkin the context, if the target has been deleted then raises a
+        checkin exception.
 
-#       if the object version has changed since the checkout begin (due to another checkin)
-#       raises a conflict error.
-#
+       if the object version has changed since the checkout begin (due to
+       another checkin) raises a conflict error.
         """
 
     def checkout(container):
         """
         checkout the content object into the container, iff another object with
-        the same id exists the id is amended, the working copy object is returned.
+        the same id exists the id is amended, the working copy object is
+        returned.
 
         the content object is locked during checkout.
 
@@ -264,29 +261,19 @@ def checkout(container):
         """
 
     def cancelCheckout():
-        """
-        coxtent is a checkout (working copy), this method will go ahead and delete
+        """coxtent is a checkout (working copy), this method will go ahead and
+        delete
         the working copy.
         """
 
     def getWorkingCopies():
-        """
-        """
+        pass
 
     def getBaseline():
-        """
-        """
+        pass
 
     def getWorkingCopy():
-        """
-        """
-
-#     def merge( content ):
-#         """
-#         if there are known conflicts between the checkout and the checkedin version,
-#         using the merge method signals that conflicts have been resolved in the working
-#         copy.
-#         """
+        pass
 
 
 #################################
diff --git a/plone/app/iterate/permissions.py b/plone/app/iterate/permissions.py
index a2613e5..39faf34 100644
--- a/plone/app/iterate/permissions.py
+++ b/plone/app/iterate/permissions.py
@@ -24,8 +24,8 @@
 from Products.CMFCore.permissions import setDefaultRoles
 
 
-CheckinPermission = "iterate : Check in content"
-CheckoutPermission = "iterate : Check out content"
+CheckinPermission = 'iterate : Check in content'
+CheckoutPermission = 'iterate : Check out content'
 
 DEFAULT_ROLES = ('Manager', 'Owner', 'Site Administrator', 'Editor')
 setDefaultRoles(CheckinPermission, DEFAULT_ROLES)
diff --git a/plone/app/iterate/policy.py b/plone/app/iterate/policy.py
index f916201..f7109f0 100644
--- a/plone/app/iterate/policy.py
+++ b/plone/app/iterate/policy.py
@@ -54,7 +54,7 @@ class CheckinCheckoutPolicyAdapter(object):
     """
 
     # used when creating baseline version for first time
-    default_base_message = "Created Baseline"
+    default_base_message = 'Created Baseline'
 
     def __init__(self, context):
         self.context = context
@@ -123,10 +123,10 @@ def _getBaseline(self):
         refs = self.context.getReferences(WorkingCopyRelation.relationship)
 
         if not len(refs) == 1:
-            raise interfaces.CheckinException("Baseline count mismatch")
+            raise interfaces.CheckinException('Baseline count mismatch')
 
         if not refs or refs[0] is None:
-            raise interfaces.CheckinException("Baseline has disappeared")
+            raise interfaces.CheckinException('Baseline has disappeared')
 
         baseline = refs[0]
         return baseline
diff --git a/plone/app/iterate/relation.py b/plone/app/iterate/relation.py
index 10d75f8..bc96439 100644
--- a/plone/app/iterate/relation.py
+++ b/plone/app/iterate/relation.py
@@ -47,7 +47,7 @@ class WorkingCopyRelation(Reference):
 
     Target Object is Baseline Version
     """
-    relationship = "Working Copy Relation"
+    relationship = 'Working Copy Relation'
 
 
 @implementer(ICheckinCheckoutReference)
@@ -71,7 +71,7 @@ class CheckinCheckoutReferenceAdapter(object):
 
     """
 
-    storage_key = "coci.references"
+    storage_key = 'coci.references'
 
     def __init__(self, context):
         self.context = context
diff --git a/plone/app/iterate/subscribers/versioning.py b/plone/app/iterate/subscribers/versioning.py
index 027f60e..f1daa5a 100644
--- a/plone/app/iterate/subscribers/versioning.py
+++ b/plone/app/iterate/subscribers/versioning.py
@@ -29,7 +29,7 @@
 def handleBeforeCheckout(event):
     archiver = interfaces.IObjectArchiver(event.object)
     if archiver.isModified() or not archiver.isVersioned():
-        archiver.save("Baseline created")
+        archiver.save('Baseline created')
 
 
 def handleAfterCheckin(event):
diff --git a/plone/app/iterate/subscribers/workflow.py b/plone/app/iterate/subscribers/workflow.py
index 83afb8d..e4a1dd9 100644
--- a/plone/app/iterate/subscribers/workflow.py
+++ b/plone/app/iterate/subscribers/workflow.py
@@ -36,9 +36,9 @@
 from zope.component import getUtility
 
 
-USE_WORKFLOW = "checkout_workflow_policy"
+USE_WORKFLOW = 'checkout_workflow_policy'
 
-policy_storage = "previous_wf_policy"
+policy_storage = 'previous_wf_policy'
 
 
 def handleCheckout(event):
diff --git a/plone/app/iterate/testing.py b/plone/app/iterate/testing.py
index 082ecf2..cd0484b 100644
--- a/plone/app/iterate/testing.py
+++ b/plone/app/iterate/testing.py
@@ -106,11 +106,11 @@ def setUpPloneSite(self, portal):
 
 PLONEAPPITERATE_INTEGRATION_TESTING = IntegrationTesting(
     bases=(PLONEAPPITERATE_FIXTURE,),
-    name="PloneAppIterateLayer:Integration")
+    name='PloneAppIterateLayer:Integration')
 
 PLONEAPPITERATE_FUNCTIONAL_TESTING = FunctionalTesting(
     bases=(PLONEAPPITERATE_FIXTURE,),
-    name="PloneAppIterateLayer:Functional")
+    name='PloneAppIterateLayer:Functional')
 
 
 class DexPloneAppIterateLayer(PloneAppContenttypes):
@@ -133,8 +133,8 @@ def setUpPloneSite(self, portal):
 PLONEAPPITERATEDEX_FIXTURE = DexPloneAppIterateLayer()
 PLONEAPPITERATEDEX_INTEGRATION_TESTING = IntegrationTesting(
     bases=(PLONEAPPITERATEDEX_FIXTURE,),
-    name="DexPloneAppIterateLayer:Integration")
+    name='DexPloneAppIterateLayer:Integration')
 
 PLONEAPPITERATEDEX_FUNCTIONAL_TESTING = FunctionalTesting(
     bases=(PLONEAPPITERATEDEX_FIXTURE,),
-    name="DexPloneAppIterateLayer:Functional")
+    name='DexPloneAppIterateLayer:Functional')
diff --git a/plone/app/iterate/tests/test_doctests.py b/plone/app/iterate/tests/test_doctests.py
index 579a925..6fa81e8 100644
--- a/plone/app/iterate/tests/test_doctests.py
+++ b/plone/app/iterate/tests/test_doctests.py
@@ -14,7 +14,7 @@ def test_suite():
         doctest.DocFileSuite(
             'browser.rst',
             optionflags=OPTIONFLAGS,
-            package="plone.app.iterate.tests",
+            package='plone.app.iterate.tests',
         ),
         layer=PLONEAPPITERATE_FUNCTIONAL_TESTING)
     )
@@ -22,7 +22,7 @@ def test_suite():
         doctest.DocFileSuite(
             'dexterity.rst',
             optionflags=OPTIONFLAGS,
-            package="plone.app.iterate.tests",
+            package='plone.app.iterate.tests',
         ),
         layer=PLONEAPPITERATEDEX_FUNCTIONAL_TESTING)
     )
diff --git a/plone/app/iterate/tests/test_iterate.py b/plone/app/iterate/tests/test_iterate.py
index 235928a..f31539c 100644
--- a/plone/app/iterate/tests/test_iterate.py
+++ b/plone/app/iterate/tests/test_iterate.py
@@ -63,13 +63,9 @@ def shim_test(self, test_method):
 
         try:
             test_method()
-        except:
-            import sys
-            import pdb
+        except Exception:
             import traceback
-            ec, e, tb = sys.exc_info()
             traceback.print_exc()
-            pdb.post_mortem(tb)
 
     def test_workflowState(self):
         # ensure baseline workflow state is retained on checkin, including
@@ -80,7 +76,7 @@ def test_workflowState(self):
         # sanity check that owner can edit visible docs
         setRoles(self.portal, TEST_USER_ID, ['Owner'])
         self.assertTrue(getSecurityManager().checkPermission(
-            "Modify portal content", self.portal.docs.doc1))
+            'Modify portal content', self.portal.docs.doc1))
 
         setRoles(self.portal, TEST_USER_ID, ['Manager'])
         self.wf.doActionFor(doc, 'publish')
@@ -92,7 +88,7 @@ def test_workflowState(self):
 
         self.assertNotEqual(state, wc_state)
 
-        ICheckinCheckoutPolicy(wc).checkin("modified")
+        ICheckinCheckoutPolicy(wc).checkin('modified')
         bstate = self.wf.getInfoFor(wc, 'review_state')
         self.assertEqual(state, bstate)
         setRoles(self.portal, TEST_USER_ID, ['Owner'])
@@ -124,35 +120,35 @@ def test_wcNewForwardReferencesCopied(self):
         # checkin
         doc = self.portal.docs.doc1
         doc.addReference(self.portal.docs)
-        self.assertEqual(len(doc.getReferences("zebra")), 0)
+        self.assertEqual(len(doc.getReferences('zebra')), 0)
         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)
-        wc.addReference(self.portal.docs.doc2, "zebra")
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
-        self.assertEqual(len(doc.getReferences("zebra")), 1)
+        wc.addReference(self.portal.docs.doc2, 'zebra')
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
+        self.assertEqual(len(doc.getReferences('zebra')), 1)
 
     def test_wcNewBackwardReferencesCopied(self):
         # ensure that new wc back references are copied back to the baseline on
         # checkin
 
         doc = self.portal.docs.doc1
-        self.assertEqual(len(doc.getBackReferences("zebra")), 0)
+        self.assertEqual(len(doc.getBackReferences('zebra')), 0)
         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)
-        self.portal.docs.doc2.addReference(wc, "zebra")
-        self.assertEqual(len(wc.getBackReferences("zebra")), 1)
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
-        self.assertEqual(len(doc.getBackReferences("zebra")), 1)
+        self.portal.docs.doc2.addReference(wc, 'zebra')
+        self.assertEqual(len(wc.getBackReferences('zebra')), 1)
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
+        self.assertEqual(len(doc.getBackReferences('zebra')), 1)
 
     def test_baselineReferencesMaintained(self):
         # ensure that baseline references are maintained when the object is
         # checked in copies forward, bkw are not copied, but are maintained.
 
         doc = self.portal.docs.doc1
-        doc.addReference(self.portal.docs, "elephant")
+        doc.addReference(self.portal.docs, 'elephant')
         self.portal.docs.doc2.addReference(doc)
 
         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)
 
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
 
         # TODO: This fails in Plone 4.1. The new optimized catalog lookups
         # in the reference catalog no longer filter out non-existing reference
@@ -167,7 +163,7 @@ def test_baselineBrokenReferencesRemoved(self):
         # checkout should not fail with a ReferenceException.
 
         doc = self.portal.docs.doc1
-        doc.addReference(self.portal.docs.doc2, "pony")
+        doc.addReference(self.portal.docs.doc2, 'pony')
         self.portal.docs._delOb('doc2')
         # _delOb is low level enough that the reference does not get cleaned
         # up.
@@ -178,7 +174,7 @@ def test_baselineBrokenReferencesRemoved(self):
         self.assertEqual(len(wc.getReferences()), 1)
         self.assertEqual(wc.getReferences()[0].id, 'doc1')
 
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
         # The checkin removes the broken reference.
         self.assertEqual(len(doc.getReferences()), 0)
 
@@ -195,25 +191,25 @@ def test_baselineNoCopyReferences(self):
             adapts=(IBaseObject,),
             provides=interfaces.ICheckinCheckoutReference,
             factory=relation.NoCopyReferenceAdapter,
-            name="zebra")
+            name='zebra')
 
         doc = self.portal.docs.doc1
         ref = doc.addReference(
-            self.portal.docs, "zebra", referenceClass=CustomReference)
-        ref.custom_state = "hello world"
+            self.portal.docs, 'zebra', referenceClass=CustomReference)
+        ref.custom_state = 'hello world'
 
         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)
 
-        self.assertEqual(len(wc.getReferences("zebra")), 0)
+        self.assertEqual(len(wc.getReferences('zebra')), 0)
 
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
 
-        self.assertEqual(len(doc.getReferences("zebra")), 1)
+        self.assertEqual(len(doc.getReferences('zebra')), 1)
 
-        ref = doc.getReferenceImpl("zebra")[0]
+        ref = doc.getReferenceImpl('zebra')[0]
 
-        self.assert_(hasattr(ref, "custom_state"))
-        self.assertEqual(ref.custom_state, "hello world")
+        self.assertTrue(hasattr(ref, 'custom_state'))
+        self.assertEqual(ref.custom_state, 'hello world')
 
     def test_folderOrder(self):
         """When an item is checked out and then back in, the original
@@ -235,7 +231,7 @@ def test_folderOrder(self):
         copy_position = container.getObjectPosition(wc.getId())
         self.assertTrue(copy_position > doc2_position)
 
-        new_doc = ICheckinCheckoutPolicy(wc).checkin("updated")
+        new_doc = ICheckinCheckoutPolicy(wc).checkin('updated')
         new_position = container.getObjectPosition(new_doc.getId())
         self.assertEqual(new_position, original_position)
 
@@ -257,7 +253,7 @@ def test_folderContents(self):
                                       id='new-folder-item',
                                       text='new folder item text')]
         new_doc_uid = new_doc.UID()
-        new_folder = ICheckinCheckoutPolicy(wc).checkin("updated")
+        new_folder = ICheckinCheckoutPolicy(wc).checkin('updated')
 
         catalog = getToolByName(self.portal, 'portal_catalog')
 
@@ -293,7 +289,7 @@ def test_checkinObjectLinkedInParentsRichTextField(self):
 
         # try to checkout and checkin the subobject
         wc = ICheckinCheckoutPolicy(subobject).checkout(rich_text_folder)
-        ICheckinCheckoutPolicy(wc).checkin("updated")
+        ICheckinCheckoutPolicy(wc).checkin('updated')
 
         # everything went right and the working copy is checked in
         self.assertEqual(subobject_uid, wc.UID())
@@ -312,7 +308,7 @@ def test_default_page_is_kept_in_folder(self):
         # without changes.  But the default behavior in Plone is to check a
         # document out in its original folder, so that is what we check here.
         wc = ICheckinCheckoutPolicy(doc).checkout(folder)
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
         self.assertEqual(folder.getProperty('default_page', ''), 'doc1')
         self.assertEqual(folder.getDefaultPage(), 'doc1')
 


Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2016-12-20T22:45:02+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/fe49bc33a0f0b38fe9d762c63c507f592ff85d9a

Merge pull request #37 from plone/gforcada-patch-1

Cleanup code

Files changed:
M CHANGES.rst
M plone/app/iterate/__init__.py
M plone/app/iterate/archiver.py
M plone/app/iterate/browser/cancel.py
M plone/app/iterate/browser/checkin.py
M plone/app/iterate/browser/checkout.py
M plone/app/iterate/browser/control.py
M plone/app/iterate/browser/diff.py
M plone/app/iterate/browser/info.py
M plone/app/iterate/containers.py
M plone/app/iterate/copier.py
M plone/app/iterate/dexterity/copier.py
M plone/app/iterate/dexterity/interfaces.py
M plone/app/iterate/dexterity/policy.py
M plone/app/iterate/dexterity/relation.py
M plone/app/iterate/dexterity/utils.py
M plone/app/iterate/interfaces.py
M plone/app/iterate/permissions.py
M plone/app/iterate/policy.py
M plone/app/iterate/relation.py
M plone/app/iterate/subscribers/versioning.py
M plone/app/iterate/subscribers/workflow.py
M plone/app/iterate/testing.py
M plone/app/iterate/tests/test_doctests.py
M plone/app/iterate/tests/test_iterate.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 0e5c653..42f1217 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -17,6 +17,8 @@ Bug fixes:
 - Cleanup: isort, zca decorators, etc.
   [jensens]
 
+- Some more cleanup.
+  [gforcada]
 
 3.2.3 (2016-11-10)
 ------------------
diff --git a/plone/app/iterate/__init__.py b/plone/app/iterate/__init__.py
index 74f6375..8d1a70e 100644
--- a/plone/app/iterate/__init__.py
+++ b/plone/app/iterate/__init__.py
@@ -42,8 +42,10 @@
 
 try:
     import plone.app.stagingbehavior  # noqa
-    logger.error('plone.app.stagingbehavior should NOT be installed with this version '
-                 'of plone.app.iterate. You may experience problems running this configuration. '
-                 'plone.app.iterate now has dexterity suport built-in.')
+    logger.error(
+        'plone.app.stagingbehavior should NOT be installed with this version '
+        'of plone.app.iterate. You may experience problems running this '
+        'configuration. plone.app.iterate now has dexterity suport built-in.'
+    )
 except ImportError:
     pass
diff --git a/plone/app/iterate/archiver.py b/plone/app/iterate/archiver.py
index d008abc..b61cb68 100644
--- a/plone/app/iterate/archiver.py
+++ b/plone/app/iterate/archiver.py
@@ -20,10 +20,6 @@
 # along with CMFDeployment; if not, write to the Free Software
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ##################################################################
-"""
-$Id: archiver.py 1824 2007-02-08 17:59:41Z hazmat $
-"""
-
 from Products.CMFCore.utils import getToolByName
 from zope.component import adapter
 from zope.interface import implementer
@@ -55,5 +51,5 @@ def isVersioned(self):
     def isModified(self):
         try:
             return not self.repository.isUpToDate(self.context)
-        except:
+        except Exception:
             return False
diff --git a/plone/app/iterate/browser/cancel.py b/plone/app/iterate/browser/cancel.py
index 4d6439c..95582fe 100644
--- a/plone/app/iterate/browser/cancel.py
+++ b/plone/app/iterate/browser/cancel.py
@@ -38,24 +38,24 @@ class Cancel(BrowserView):
     def __call__(self):
         context = aq_inner(self.context)
 
-        if self.request.form.has_key('form.button.Cancel'):
+        if 'form.button.Cancel' in self.request.form:
             control = getMultiAdapter(
-                (context, self.request), name=u"iterate_control")
+                (context, self.request), name=u'iterate_control')
             if not control.cancel_allowed():
-                raise CheckoutException(u"Not a checkout")
+                raise CheckoutException(u'Not a checkout')
 
             policy = ICheckinCheckoutPolicy(context)
             baseline = policy.cancelCheckout()
             baseline.reindexObject()
 
             IStatusMessage(self.request).addStatusMessage(
-                _(u"Checkout cancelled"), type='info')
+                _(u'Checkout cancelled'), type='info')
             view_url = baseline.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
-        elif self.request.form.has_key('form.button.Keep'):
+        elif 'form.button.Keep' in self.request.form:
             view_url = context.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
diff --git a/plone/app/iterate/browser/checkin.py b/plone/app/iterate/browser/checkin.py
index 7fb1a50..28f56ea 100644
--- a/plone/app/iterate/browser/checkin.py
+++ b/plone/app/iterate/browser/checkin.py
@@ -38,25 +38,25 @@ class Checkin(BrowserView):
     def __call__(self):
         context = aq_inner(self.context)
 
-        if self.request.form.has_key('form.button.Checkin'):
+        if 'form.button.Checkin' in self.request.form:
             control = getMultiAdapter(
-                (context, self.request), name=u"iterate_control")
+                (context, self.request), name=u'iterate_control')
             if not control.checkin_allowed():
-                raise CheckinException(u"Not a checkout")
+                raise CheckinException(u'Not a checkout')
 
-            message = self.request.form.get('checkin_message', "")
+            message = self.request.form.get('checkin_message', '')
 
             policy = ICheckinCheckoutPolicy(context)
             baseline = policy.checkin(message)
 
             IStatusMessage(self.request).addStatusMessage(
-                _("Checked in"), type='info')
+                _('Checked in'), type='info')
             view_url = baseline.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
-        elif self.request.form.has_key('form.button.Cancel'):
+        elif 'form.button.Cancel'in self.request.form:
             view_url = context.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
diff --git a/plone/app/iterate/browser/checkout.py b/plone/app/iterate/browser/checkout.py
index 12185ee..4fb9577 100644
--- a/plone/app/iterate/browser/checkout.py
+++ b/plone/app/iterate/browser/checkout.py
@@ -52,20 +52,25 @@ def __call__(self):
         # end up downloading a file
         if 'form.button.Checkout' in self.request.form:
             control = getMultiAdapter(
-                (context, self.request), name=u"iterate_control")
+                (context, self.request), name=u'iterate_control')
             if not control.checkout_allowed():
-                raise CheckoutException(u"Not allowed")
+                raise CheckoutException(u'Not allowed')
 
             location = self.request.form.get('checkout_location', None)
             locator = None
             try:
-                locator = [c['locator']
-                           for c in self.containers() if c['name'] == location][0]
+                locator = [
+                    c['locator']
+                    for c in self.containers()
+                    if c['name'] == location
+                ][0]
             except IndexError:
-                IStatusMessage(self.request).addStatusMessage(_("Cannot find checkout location"),
-                                                              type='error')
+                IStatusMessage(self.request).addStatusMessage(
+                    _('Cannot find checkout location'),
+                    type='error'
+                )
                 view_url = context.restrictedTraverse(
-                    "@@plone_context_state").view_url()
+                    '@@plone_context_state').view_url()
                 self.request.response.redirect(view_url)
                 return
 
@@ -77,13 +82,13 @@ def __call__(self):
             context.reindexObject('review_state')
 
             IStatusMessage(self.request).addStatusMessage(
-                _("Check-out created"), type='info')
+                _('Check-out created'), type='info')
             view_url = wc.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
         elif 'form.button.Cancel' in self.request.form:
             view_url = context.restrictedTraverse(
-                "@@plone_context_state").view_url()
+                '@@plone_context_state').view_url()
             self.request.response.redirect(view_url)
         else:
             return self.index()
diff --git a/plone/app/iterate/browser/control.py b/plone/app/iterate/browser/control.py
index 309a343..56762bb 100644
--- a/plone/app/iterate/browser/control.py
+++ b/plone/app/iterate/browser/control.py
@@ -62,7 +62,11 @@ def checkin_allowed(self):
         if original is None:
             return False
 
-        if not checkPermission(Products.CMFCore.permissions.ModifyPortalContent, original):
+        can_modify = checkPermission(
+            Products.CMFCore.permissions.ModifyPortalContent,
+            original,
+        )
+        if not can_modify:
             return False
 
         return True
diff --git a/plone/app/iterate/browser/diff.py b/plone/app/iterate/browser/diff.py
index 75835c7..f63e19e 100644
--- a/plone/app/iterate/browser/diff.py
+++ b/plone/app/iterate/browser/diff.py
@@ -21,12 +21,12 @@ def __call__(self):
             self.working_copy = self.context
             self.baseline = policy.getBaseline()
         else:
-            raise AttributeError("Invalid Context")
+            raise AttributeError('Invalid Context')
         return self.index()
 
     def diffs(self):
         diff = getToolByName(self.context, 'portal_diff')
         return diff.createChangeSet(self.baseline,
                                     self.working_copy,
-                                    id1="Baseline",
-                                    id2="Working Copy")
+                                    id1='Baseline',
+                                    id2='Working Copy')
diff --git a/plone/app/iterate/browser/info.py b/plone/app/iterate/browser/info.py
index 2fba85e..8a6316e 100644
--- a/plone/app/iterate/browser/info.py
+++ b/plone/app/iterate/browser/info.py
@@ -43,7 +43,11 @@ def policy(self):
     def created(self):
         time = self.properties.get(keys.checkout_time, DateTime())
         util = getToolByName(self.context, 'translation_service')
-        return util.ulocalized_time(time, context=self.context, domain='plonelocales')
+        return util.ulocalized_time(
+            time,
+            context=self.context,
+            domain='plonelocales',
+        )
 
     @memoize
     def creator(self):
@@ -58,7 +62,7 @@ def creator_url(self):
         creator = self.creator()
         if creator is not None:
             portal_url = getToolByName(self.context, 'portal_url')
-            return "%s/author/%s" % (portal_url(), creator.getId())
+            return '{0}/author/{1}'.format(portal_url(), creator.getId())
 
     @memoize
     def creator_name(self):
@@ -69,10 +73,12 @@ def creator_name(self):
         # the user and log this.
         name = self.properties.get(keys.checkout_user)
         if IBaseline.providedBy(self.context):
-            warning_tpl = "%s is a baseline of a plone.app.iterate checkout by an unknown user id '%s'"  # noqa
+            warning_tpl = '%s is a baseline of a plone.app.iterate checkout ' \
+                          'by an unknown user id "%s"'
         else:
             # IWorkingCopy.providedBy(self.context)
-            warning_tpl = "%s is a working copy of a plone.app.iterate checkout by an unknown user id '%s'"  # noqa
+            warning_tpl = '%s is a working copy of a plone.app.iterate ' \
+                          'checkout by an unknown user id "%s"'
         logger.warning(warning_tpl, self.context, name)
         return name
 
@@ -102,7 +108,7 @@ def render(self):
                 sm.checkPermission(ModifyPortalContent, working_copy)):
             return self.index()
         else:
-            return ""
+            return ''
 
     @memoize
     def working_copy(self):
@@ -124,7 +130,7 @@ def render(self):
                 sm.checkPermission(CheckoutPermission, baseline)):
             return self.index()
         else:
-            return ""
+            return ''
 
     @memoize
     def baseline(self):
diff --git a/plone/app/iterate/containers.py b/plone/app/iterate/containers.py
index ce52d45..063ecdb 100644
--- a/plone/app/iterate/containers.py
+++ b/plone/app/iterate/containers.py
@@ -42,7 +42,7 @@ class HomeFolderLocator(object):
     def __init__(self, context):
         self.context = context
 
-    title = _(u"Home folder")
+    title = _(u'Home folder')
 
     @property
     def available(self):
@@ -62,7 +62,7 @@ class ParentFolderLocator(object):
     def __init__(self, context):
         self.context = context
 
-    title = _(u"Parent folder")
+    title = _(u'Parent folder')
 
     @property
     def available(self):
diff --git a/plone/app/iterate/copier.py b/plone/app/iterate/copier.py
index 256cc4a..70e0fa3 100644
--- a/plone/app/iterate/copier.py
+++ b/plone/app/iterate/copier.py
@@ -57,7 +57,7 @@ def copyTo(self, container):
             self.context,
             relationship=WorkingCopyRelation.relationship,
             referenceClass=WorkingCopyRelation)
-        self._handleReferences(self.context, wc, "checkout", wc_ref)
+        self._handleReferences(self.context, wc, 'checkout', wc_ref)
         return wc, wc_ref
 
     def merge(self):
@@ -67,7 +67,7 @@ def merge(self):
         wc_ref = self._deleteWorkingCopyRelation()
 
         # reassemble references on the new baseline
-        self._handleReferences(baseline, self.context, "checkin", wc_ref)
+        self._handleReferences(baseline, self.context, 'checkin', wc_ref)
 
         # move the working copy to the baseline container, deleting
         # the baseline
@@ -84,10 +84,10 @@ def _getBaseline(self):
         refs = self.context.getRefs(WorkingCopyRelation.relationship)
 
         if not len(refs) == 1:
-            raise CheckinException("Baseline count mismatch")
+            raise CheckinException('Baseline count mismatch')
 
         if not refs or refs[0] is None:
-            raise CheckinException("Baseline has disappeared")
+            raise CheckinException('Baseline has disappeared')
 
         baseline = refs[0]
         return baseline
@@ -251,7 +251,7 @@ def _handleReferences(self, baseline, wc, mode, wc_ref):
             mode_method = getattr(adapter, mode)
             mode_method(baseline, wc, references, annotations)
 
-        mode = mode + "BackReferences"
+        mode = mode + 'BackReferences'
 
         # handle backward references
         for relationship in baseline.getBRelationships():
diff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py
index 64219d4..7e6c82b 100644
--- a/plone/app/iterate/dexterity/copier.py
+++ b/plone/app/iterate/dexterity/copier.py
@@ -21,7 +21,7 @@
 
 try:
     from zope.intid.interfaces import IIntIds
-except:
+except ImportError:
     from zope.app.intid.interfaces import IIntIds
 
 
@@ -48,7 +48,7 @@ def merge(self):
         wc_ref = self._deleteWorkingCopyRelation()
 
         # reassemble references on the new baseline
-        self._handleReferences(baseline, self.context, "checkin", wc_ref)
+        self._handleReferences(baseline, self.context, 'checkin', wc_ref)
 
         # move the working copy to the baseline container, deleting the
         # baseline
@@ -74,7 +74,7 @@ def _replaceBaseline(self, baseline):
                     continue
                 try:
                     value = field.get(schema(self.context))
-                except:
+                except Exception:
                     value = None
 
                 # TODO: We need a way to identify the DCFieldProperty
@@ -141,10 +141,10 @@ def _get_relation_to_baseline(self):
                            relations)
         # do we have a baseline in our relations?
         if relations and not len(relations) == 1:
-            raise interfaces.CheckinException("Baseline count mismatch")
+            raise interfaces.CheckinException('Baseline count mismatch')
 
         if not relations or not relations[0]:
-            raise interfaces.CheckinException("Baseline has disappeared")
+            raise interfaces.CheckinException('Baseline has disappeared')
         return relations[0]
 
     def _getBaseline(self):
@@ -154,7 +154,7 @@ def _getBaseline(self):
             baseline = intids.getObject(relation.from_id)
 
         if not baseline:
-            raise interfaces.CheckinException("Baseline has disappeared")
+            raise interfaces.CheckinException('Baseline has disappeared')
         return baseline
 
     def checkin(self, checkin_message):
diff --git a/plone/app/iterate/dexterity/interfaces.py b/plone/app/iterate/dexterity/interfaces.py
index d0674dc..53fdc57 100644
--- a/plone/app/iterate/dexterity/interfaces.py
+++ b/plone/app/iterate/dexterity/interfaces.py
@@ -1,7 +1,6 @@
 # -*- coding: utf-8 -*-
 from plone.app.iterate.interfaces import IIterateAware
 from z3c.relationfield.interfaces import IRelationValue
-from zope.interface import Attribute
 
 
 class IStagingRelationValue(IRelationValue):
diff --git a/plone/app/iterate/dexterity/policy.py b/plone/app/iterate/dexterity/policy.py
index 9ca3886..a7496fc 100644
--- a/plone/app/iterate/dexterity/policy.py
+++ b/plone/app/iterate/dexterity/policy.py
@@ -11,7 +11,9 @@
 
 
 @implementer(iterate.interfaces.ICheckinCheckoutPolicy)
-class CheckinCheckoutPolicyAdapter(iterate.policy.CheckinCheckoutPolicyAdapter):
+class CheckinCheckoutPolicyAdapter(
+    iterate.policy.CheckinCheckoutPolicyAdapter
+):
     """
     Dexterity Checkin Checkout Policy
     """
@@ -22,11 +24,11 @@ def _get_relation_to_baseline(self):
 
         if relations and not len(relations) == 1:
             raise iterate.interfaces.CheckinException(
-                "Baseline count mismatch")
+                'Baseline count mismatch')
 
         if not relations or not relations[0]:
             raise iterate.interfaces.CheckinException(
-                "Baseline has disappeared")
+                'Baseline has disappeared')
 
         return relations[0]
 
@@ -34,7 +36,7 @@ def _getBaseline(self):
         baseline = get_baseline(self.context)
         if not baseline:
             raise iterate.interfaces.CheckinException(
-                "Baseline has disappeared")
+                'Baseline has disappeared')
         return baseline
 
     def checkin(self, checkin_message):
diff --git a/plone/app/iterate/dexterity/relation.py b/plone/app/iterate/dexterity/relation.py
index 64fb3b0..fa3b054 100644
--- a/plone/app/iterate/dexterity/relation.py
+++ b/plone/app/iterate/dexterity/relation.py
@@ -26,6 +26,9 @@ def get_relations_of(cls, obj, from_attribute=None):
         items = list(catalog.findRelations({'from_id': obj_id}))
         items += list(catalog.findRelations({'to_id': obj_id}))
         if from_attribute:
-            condition = lambda r: r.from_attribute == from_attribute and not r.is_broken()
+
+            def condition(r):
+                return r.from_attribute == from_attribute and not r.is_broken()
+
             items = filter(condition, items)
         return items
diff --git a/plone/app/iterate/dexterity/utils.py b/plone/app/iterate/dexterity/utils.py
index f2a0d02..ad7bada 100644
--- a/plone/app/iterate/dexterity/utils.py
+++ b/plone/app/iterate/dexterity/utils.py
@@ -8,7 +8,7 @@
 
 try:
     from zope.intid.interfaces import IIntIds
-except:
+except ImportError:
     from zope.app.intid.interfaces import IIntIds
 
 
diff --git a/plone/app/iterate/interfaces.py b/plone/app/iterate/interfaces.py
index a5c3fc4..1656454 100644
--- a/plone/app/iterate/interfaces.py
+++ b/plone/app/iterate/interfaces.py
@@ -69,13 +69,13 @@ class ConflictError(CheckinException):
 
 #################################
 # Annotation Key
-annotation_key = "ore.iterate"
+annotation_key = 'ore.iterate'
 
 
 class keys(object):
     # various common keys
-    checkout_user = "checkout_user"
-    checkout_time = "checkout_time"
+    checkout_user = 'checkout_user'
+    checkout_time = 'checkout_time'
 
 
 #################################
@@ -86,15 +86,15 @@ class ICheckinEvent(IObjectEvent):
     message is sent before any mutation/merge has been done on the objects
     """
 
-    baseline = Attribute("The Working Copy's baseline")
-    relation = Attribute("The Working Copy Archetypes Relation Object")
-    checkin_message = Attribute("checkin message")
+    baseline = Attribute('The Working Copy\'s baseline')
+    relation = Attribute('The Working Copy Archetypes Relation Object')
+    checkin_message = Attribute('checkin message')
 
 
 class IAfterCheckinEvent(IObjectEvent):
     """ sent out after an object is checked in """
 
-    checkin_message = Attribute("checkin message")
+    checkin_message = Attribute('checkin message')
 
 
 class IBeforeCheckoutEvent(IObjectEvent):
@@ -104,25 +104,26 @@ class IBeforeCheckoutEvent(IObjectEvent):
 class ICheckoutEvent(IObjectEvent):
     """ an object is being checked out, event.object is the baseline """
 
-    working_copy = Attribute("The object's working copy")
-    relation = Attribute("The Working Copy Archetypes Relation Object")
+    working_copy = Attribute('The object\'s working copy')
+    relation = Attribute('The Working Copy Archetypes Relation Object')
 
 
 class ICancelCheckoutEvent(IObjectEvent):
     """ a working copy is being cancelled """
 
-    baseline = Attribute("The working copy's baseline")
+    baseline = Attribute('The working copy\'s baseline')
 
 
 class IWorkingCopyDeletedEvent(IObjectEvent):
-    """ a working copy is being deleted, this gets called multiple times at different
-    states. so on cancel checkout and checkin operations, its mostly designed to
+    """ a working copy is being deleted, this gets called multiple times at
+    different states.
+    So on cancel checkout and checkin operations, its mostly designed to
     broadcast an event when the user deletes a working copy using the standard
     container paradigms.
     """
 
-    baseline = Attribute("The working copy baseline")
-    relation = Attribute("The Working Copy Archetypes Relation Object")
+    baseline = Attribute('The working copy baseline')
+    relation = Attribute('The Working Copy Archetypes Relation Object')
 
 #################################
 # Content Marker Interfaces
@@ -158,10 +159,10 @@ class IWCContainerLocator(Interface):
     """
 
     available = schema.Bool(
-        title=u"Available", description=u"Whether location will be available.")
+        title=u'Available', description=u'Whether location will be available.')
 
     title = schema.TextLine(
-        title=u"Title", description=u"Title of this location")
+        title=u'Title', description=u'Title of this location')
 
     def __call__():
         """Return a container object, or None if available() is False
@@ -184,23 +185,20 @@ def allowCheckout(content):
         """
 
     def allowCancelCheckout(content):
-        """
-        denotes whether a cancel checkout operation can be performed on the content.
+        """denotes whether a cancel checkout operation can be performed on the
+        content.
         """
 
     def checkin(content, checkin_messsage):
-        """
-        check the working copy in, this will merge the working copy with the baseline
-
+        """check the working copy in, this will merge the working copy with
+        the baseline
         """
 
     def checkout(container, content):
-        """
-        """
+        pass
 
     def cancelCheckout(content):
-        """
-        """
+        pass
 
 
 class IObjectCopier(Interface):
@@ -208,8 +206,9 @@ class IObjectCopier(Interface):
     """
 
     def copyTo(container):
-        """ copy the context to the given container, must also create an AT relation
-        using the WorkingCopyRelation.relation name between the source and the copy.
+        """ copy the context to the given container, must also create an AT
+        relation using the WorkingCopyRelation.relation name between the
+        source and the copy.
         returns the copy.
         """
 
@@ -240,23 +239,21 @@ def isModified(self):
 
 
 class ICheckinCheckoutPolicy(Interface):
-    """
-    Checkin / Checkout Policy
-    """
+    """Checkin / Checkout Policy"""
 
     def checkin(checkin_message):
-        """
-        checkin the context, if the target has been deleted then raises a checkin exception.
+        """checkin the context, if the target has been deleted then raises a
+        checkin exception.
 
-#       if the object version has changed since the checkout begin (due to another checkin)
-#       raises a conflict error.
-#
+       if the object version has changed since the checkout begin (due to
+       another checkin) raises a conflict error.
         """
 
     def checkout(container):
         """
         checkout the content object into the container, iff another object with
-        the same id exists the id is amended, the working copy object is returned.
+        the same id exists the id is amended, the working copy object is
+        returned.
 
         the content object is locked during checkout.
 
@@ -264,29 +261,19 @@ def checkout(container):
         """
 
     def cancelCheckout():
-        """
-        coxtent is a checkout (working copy), this method will go ahead and delete
+        """coxtent is a checkout (working copy), this method will go ahead and
+        delete
         the working copy.
         """
 
     def getWorkingCopies():
-        """
-        """
+        pass
 
     def getBaseline():
-        """
-        """
+        pass
 
     def getWorkingCopy():
-        """
-        """
-
-#     def merge( content ):
-#         """
-#         if there are known conflicts between the checkout and the checkedin version,
-#         using the merge method signals that conflicts have been resolved in the working
-#         copy.
-#         """
+        pass
 
 
 #################################
diff --git a/plone/app/iterate/permissions.py b/plone/app/iterate/permissions.py
index a2613e5..39faf34 100644
--- a/plone/app/iterate/permissions.py
+++ b/plone/app/iterate/permissions.py
@@ -24,8 +24,8 @@
 from Products.CMFCore.permissions import setDefaultRoles
 
 
-CheckinPermission = "iterate : Check in content"
-CheckoutPermission = "iterate : Check out content"
+CheckinPermission = 'iterate : Check in content'
+CheckoutPermission = 'iterate : Check out content'
 
 DEFAULT_ROLES = ('Manager', 'Owner', 'Site Administrator', 'Editor')
 setDefaultRoles(CheckinPermission, DEFAULT_ROLES)
diff --git a/plone/app/iterate/policy.py b/plone/app/iterate/policy.py
index f916201..f7109f0 100644
--- a/plone/app/iterate/policy.py
+++ b/plone/app/iterate/policy.py
@@ -54,7 +54,7 @@ class CheckinCheckoutPolicyAdapter(object):
     """
 
     # used when creating baseline version for first time
-    default_base_message = "Created Baseline"
+    default_base_message = 'Created Baseline'
 
     def __init__(self, context):
         self.context = context
@@ -123,10 +123,10 @@ def _getBaseline(self):
         refs = self.context.getReferences(WorkingCopyRelation.relationship)
 
         if not len(refs) == 1:
-            raise interfaces.CheckinException("Baseline count mismatch")
+            raise interfaces.CheckinException('Baseline count mismatch')
 
         if not refs or refs[0] is None:
-            raise interfaces.CheckinException("Baseline has disappeared")
+            raise interfaces.CheckinException('Baseline has disappeared')
 
         baseline = refs[0]
         return baseline
diff --git a/plone/app/iterate/relation.py b/plone/app/iterate/relation.py
index 10d75f8..bc96439 100644
--- a/plone/app/iterate/relation.py
+++ b/plone/app/iterate/relation.py
@@ -47,7 +47,7 @@ class WorkingCopyRelation(Reference):
 
     Target Object is Baseline Version
     """
-    relationship = "Working Copy Relation"
+    relationship = 'Working Copy Relation'
 
 
 @implementer(ICheckinCheckoutReference)
@@ -71,7 +71,7 @@ class CheckinCheckoutReferenceAdapter(object):
 
     """
 
-    storage_key = "coci.references"
+    storage_key = 'coci.references'
 
     def __init__(self, context):
         self.context = context
diff --git a/plone/app/iterate/subscribers/versioning.py b/plone/app/iterate/subscribers/versioning.py
index 027f60e..f1daa5a 100644
--- a/plone/app/iterate/subscribers/versioning.py
+++ b/plone/app/iterate/subscribers/versioning.py
@@ -29,7 +29,7 @@
 def handleBeforeCheckout(event):
     archiver = interfaces.IObjectArchiver(event.object)
     if archiver.isModified() or not archiver.isVersioned():
-        archiver.save("Baseline created")
+        archiver.save('Baseline created')
 
 
 def handleAfterCheckin(event):
diff --git a/plone/app/iterate/subscribers/workflow.py b/plone/app/iterate/subscribers/workflow.py
index 83afb8d..e4a1dd9 100644
--- a/plone/app/iterate/subscribers/workflow.py
+++ b/plone/app/iterate/subscribers/workflow.py
@@ -36,9 +36,9 @@
 from zope.component import getUtility
 
 
-USE_WORKFLOW = "checkout_workflow_policy"
+USE_WORKFLOW = 'checkout_workflow_policy'
 
-policy_storage = "previous_wf_policy"
+policy_storage = 'previous_wf_policy'
 
 
 def handleCheckout(event):
diff --git a/plone/app/iterate/testing.py b/plone/app/iterate/testing.py
index 082ecf2..cd0484b 100644
--- a/plone/app/iterate/testing.py
+++ b/plone/app/iterate/testing.py
@@ -106,11 +106,11 @@ def setUpPloneSite(self, portal):
 
 PLONEAPPITERATE_INTEGRATION_TESTING = IntegrationTesting(
     bases=(PLONEAPPITERATE_FIXTURE,),
-    name="PloneAppIterateLayer:Integration")
+    name='PloneAppIterateLayer:Integration')
 
 PLONEAPPITERATE_FUNCTIONAL_TESTING = FunctionalTesting(
     bases=(PLONEAPPITERATE_FIXTURE,),
-    name="PloneAppIterateLayer:Functional")
+    name='PloneAppIterateLayer:Functional')
 
 
 class DexPloneAppIterateLayer(PloneAppContenttypes):
@@ -133,8 +133,8 @@ def setUpPloneSite(self, portal):
 PLONEAPPITERATEDEX_FIXTURE = DexPloneAppIterateLayer()
 PLONEAPPITERATEDEX_INTEGRATION_TESTING = IntegrationTesting(
     bases=(PLONEAPPITERATEDEX_FIXTURE,),
-    name="DexPloneAppIterateLayer:Integration")
+    name='DexPloneAppIterateLayer:Integration')
 
 PLONEAPPITERATEDEX_FUNCTIONAL_TESTING = FunctionalTesting(
     bases=(PLONEAPPITERATEDEX_FIXTURE,),
-    name="DexPloneAppIterateLayer:Functional")
+    name='DexPloneAppIterateLayer:Functional')
diff --git a/plone/app/iterate/tests/test_doctests.py b/plone/app/iterate/tests/test_doctests.py
index 579a925..6fa81e8 100644
--- a/plone/app/iterate/tests/test_doctests.py
+++ b/plone/app/iterate/tests/test_doctests.py
@@ -14,7 +14,7 @@ def test_suite():
         doctest.DocFileSuite(
             'browser.rst',
             optionflags=OPTIONFLAGS,
-            package="plone.app.iterate.tests",
+            package='plone.app.iterate.tests',
         ),
         layer=PLONEAPPITERATE_FUNCTIONAL_TESTING)
     )
@@ -22,7 +22,7 @@ def test_suite():
         doctest.DocFileSuite(
             'dexterity.rst',
             optionflags=OPTIONFLAGS,
-            package="plone.app.iterate.tests",
+            package='plone.app.iterate.tests',
         ),
         layer=PLONEAPPITERATEDEX_FUNCTIONAL_TESTING)
     )
diff --git a/plone/app/iterate/tests/test_iterate.py b/plone/app/iterate/tests/test_iterate.py
index 235928a..f31539c 100644
--- a/plone/app/iterate/tests/test_iterate.py
+++ b/plone/app/iterate/tests/test_iterate.py
@@ -63,13 +63,9 @@ def shim_test(self, test_method):
 
         try:
             test_method()
-        except:
-            import sys
-            import pdb
+        except Exception:
             import traceback
-            ec, e, tb = sys.exc_info()
             traceback.print_exc()
-            pdb.post_mortem(tb)
 
     def test_workflowState(self):
         # ensure baseline workflow state is retained on checkin, including
@@ -80,7 +76,7 @@ def test_workflowState(self):
         # sanity check that owner can edit visible docs
         setRoles(self.portal, TEST_USER_ID, ['Owner'])
         self.assertTrue(getSecurityManager().checkPermission(
-            "Modify portal content", self.portal.docs.doc1))
+            'Modify portal content', self.portal.docs.doc1))
 
         setRoles(self.portal, TEST_USER_ID, ['Manager'])
         self.wf.doActionFor(doc, 'publish')
@@ -92,7 +88,7 @@ def test_workflowState(self):
 
         self.assertNotEqual(state, wc_state)
 
-        ICheckinCheckoutPolicy(wc).checkin("modified")
+        ICheckinCheckoutPolicy(wc).checkin('modified')
         bstate = self.wf.getInfoFor(wc, 'review_state')
         self.assertEqual(state, bstate)
         setRoles(self.portal, TEST_USER_ID, ['Owner'])
@@ -124,35 +120,35 @@ def test_wcNewForwardReferencesCopied(self):
         # checkin
         doc = self.portal.docs.doc1
         doc.addReference(self.portal.docs)
-        self.assertEqual(len(doc.getReferences("zebra")), 0)
+        self.assertEqual(len(doc.getReferences('zebra')), 0)
         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)
-        wc.addReference(self.portal.docs.doc2, "zebra")
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
-        self.assertEqual(len(doc.getReferences("zebra")), 1)
+        wc.addReference(self.portal.docs.doc2, 'zebra')
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
+        self.assertEqual(len(doc.getReferences('zebra')), 1)
 
     def test_wcNewBackwardReferencesCopied(self):
         # ensure that new wc back references are copied back to the baseline on
         # checkin
 
         doc = self.portal.docs.doc1
-        self.assertEqual(len(doc.getBackReferences("zebra")), 0)
+        self.assertEqual(len(doc.getBackReferences('zebra')), 0)
         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)
-        self.portal.docs.doc2.addReference(wc, "zebra")
-        self.assertEqual(len(wc.getBackReferences("zebra")), 1)
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
-        self.assertEqual(len(doc.getBackReferences("zebra")), 1)
+        self.portal.docs.doc2.addReference(wc, 'zebra')
+        self.assertEqual(len(wc.getBackReferences('zebra')), 1)
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
+        self.assertEqual(len(doc.getBackReferences('zebra')), 1)
 
     def test_baselineReferencesMaintained(self):
         # ensure that baseline references are maintained when the object is
         # checked in copies forward, bkw are not copied, but are maintained.
 
         doc = self.portal.docs.doc1
-        doc.addReference(self.portal.docs, "elephant")
+        doc.addReference(self.portal.docs, 'elephant')
         self.portal.docs.doc2.addReference(doc)
 
         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)
 
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
 
         # TODO: This fails in Plone 4.1. The new optimized catalog lookups
         # in the reference catalog no longer filter out non-existing reference
@@ -167,7 +163,7 @@ def test_baselineBrokenReferencesRemoved(self):
         # checkout should not fail with a ReferenceException.
 
         doc = self.portal.docs.doc1
-        doc.addReference(self.portal.docs.doc2, "pony")
+        doc.addReference(self.portal.docs.doc2, 'pony')
         self.portal.docs._delOb('doc2')
         # _delOb is low level enough that the reference does not get cleaned
         # up.
@@ -178,7 +174,7 @@ def test_baselineBrokenReferencesRemoved(self):
         self.assertEqual(len(wc.getReferences()), 1)
         self.assertEqual(wc.getReferences()[0].id, 'doc1')
 
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
         # The checkin removes the broken reference.
         self.assertEqual(len(doc.getReferences()), 0)
 
@@ -195,25 +191,25 @@ def test_baselineNoCopyReferences(self):
             adapts=(IBaseObject,),
             provides=interfaces.ICheckinCheckoutReference,
             factory=relation.NoCopyReferenceAdapter,
-            name="zebra")
+            name='zebra')
 
         doc = self.portal.docs.doc1
         ref = doc.addReference(
-            self.portal.docs, "zebra", referenceClass=CustomReference)
-        ref.custom_state = "hello world"
+            self.portal.docs, 'zebra', referenceClass=CustomReference)
+        ref.custom_state = 'hello world'
 
         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)
 
-        self.assertEqual(len(wc.getReferences("zebra")), 0)
+        self.assertEqual(len(wc.getReferences('zebra')), 0)
 
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
 
-        self.assertEqual(len(doc.getReferences("zebra")), 1)
+        self.assertEqual(len(doc.getReferences('zebra')), 1)
 
-        ref = doc.getReferenceImpl("zebra")[0]
+        ref = doc.getReferenceImpl('zebra')[0]
 
-        self.assert_(hasattr(ref, "custom_state"))
-        self.assertEqual(ref.custom_state, "hello world")
+        self.assertTrue(hasattr(ref, 'custom_state'))
+        self.assertEqual(ref.custom_state, 'hello world')
 
     def test_folderOrder(self):
         """When an item is checked out and then back in, the original
@@ -235,7 +231,7 @@ def test_folderOrder(self):
         copy_position = container.getObjectPosition(wc.getId())
         self.assertTrue(copy_position > doc2_position)
 
-        new_doc = ICheckinCheckoutPolicy(wc).checkin("updated")
+        new_doc = ICheckinCheckoutPolicy(wc).checkin('updated')
         new_position = container.getObjectPosition(new_doc.getId())
         self.assertEqual(new_position, original_position)
 
@@ -257,7 +253,7 @@ def test_folderContents(self):
                                       id='new-folder-item',
                                       text='new folder item text')]
         new_doc_uid = new_doc.UID()
-        new_folder = ICheckinCheckoutPolicy(wc).checkin("updated")
+        new_folder = ICheckinCheckoutPolicy(wc).checkin('updated')
 
         catalog = getToolByName(self.portal, 'portal_catalog')
 
@@ -293,7 +289,7 @@ def test_checkinObjectLinkedInParentsRichTextField(self):
 
         # try to checkout and checkin the subobject
         wc = ICheckinCheckoutPolicy(subobject).checkout(rich_text_folder)
-        ICheckinCheckoutPolicy(wc).checkin("updated")
+        ICheckinCheckoutPolicy(wc).checkin('updated')
 
         # everything went right and the working copy is checked in
         self.assertEqual(subobject_uid, wc.UID())
@@ -312,7 +308,7 @@ def test_default_page_is_kept_in_folder(self):
         # without changes.  But the default behavior in Plone is to check a
         # document out in its original folder, so that is what we check here.
         wc = ICheckinCheckoutPolicy(doc).checkout(folder)
-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")
+        doc = ICheckinCheckoutPolicy(wc).checkin('updated')
         self.assertEqual(folder.getProperty('default_page', ''), 'doc1')
         self.assertEqual(folder.getDefaultPage(), 'doc1')
 


