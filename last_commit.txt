Repository: plone.supermodel


Branch: refs/heads/master
Date: 2016-05-06T19:00:30+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.supermodel/commit/ded88c2f04077d4665e9822671fa1cc453f7f57e

enable orderable fieldsets

Files changed:
A plone/supermodel/directives.rst
A plone/supermodel/fields.rst
A plone/supermodel/schema.rst
A plone/supermodel/schemaclass.rst
M CHANGES.rst
M plone/supermodel/directives.py
M plone/supermodel/exportimport.py
M plone/supermodel/interfaces.py
M plone/supermodel/model.py
M plone/supermodel/parser.py
M plone/supermodel/tests.py
D plone/supermodel/directives.txt
D plone/supermodel/fields.txt
D plone/supermodel/schema.txt
D plone/supermodel/schemaclass.txt

diff --git a/CHANGES.rst b/CHANGES.rst
index 393362a..c3901b1 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,12 +1,13 @@
 Changelog
 =========
 
-1.2.8 (unreleased)
+1.3.0 (unreleased)
 ------------------
 
 New:
 
-- *add item here*
+- Support to define the order of fieldsets.
+  [jensens]
 
 Fixes:
 
diff --git a/plone/supermodel/directives.py b/plone/supermodel/directives.py
index 5d5e607..3591b46 100644
--- a/plone/supermodel/directives.py
+++ b/plone/supermodel/directives.py
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
 from plone.supermodel import loadFile
+from plone.supermodel.interfaces import DEFAULT_ORDER
 from plone.supermodel.interfaces import FIELDSETS_KEY
 from plone.supermodel.interfaces import FILENAME_KEY
 from plone.supermodel.interfaces import ISchema
@@ -12,11 +13,12 @@
 from zope.interface import alsoProvides
 from zope.interface import implementer
 from zope.interface.interface import TAGGED_DATA
+
 import os.path
 import sys
 
-# Directive
 
+# Directive
 
 class DirectiveClass(type):
     """A Directive is used to apply tagged values to a Schema
@@ -34,7 +36,11 @@ def __call__(self, *args, **kw):
         value = instance.factory(*args, **kw)
         instance.store(tags, value)
 
-Directive = DirectiveClass('Directive', (), dict(__module__='plone.supermodel.directives',),)
+Directive = DirectiveClass(
+    'Directive',
+    (),
+    dict(__module__='plone.supermodel.directives',),
+)
 
 
 class MetadataListDirective(Directive):
@@ -75,9 +81,13 @@ def check(self):
         for fieldName in self.fieldNames():
             if fieldName not in schema:
                 raise ValueError(
-                    u"The directive %s applied to interface %s "
-                    u"refers to unknown field name %s" % (self.key, schema.__identifier__, fieldName)
+                    u"The directive {0} applied to interface {1} "
+                    u"refers to unknown field name {2}".format(
+                        self.key,
+                        schema.__identifier__,
+                        fieldName
                     )
+                )
             yield fieldName
 
     def __call__(self):
@@ -166,8 +176,13 @@ def __call__(self):
         model = loadFile(filename)
         if schema not in model.schemata:
             raise ValueError(
-                    u"Schema '%s' specified for interface %s does not exist in %s." %
-                        (schema, interface.__identifier__, filename,))
+                u"Schema '{0}' specified for interface {1} does not exist "
+                "in {2}.".format(
+                    schema,
+                    interface.__identifier__,
+                    filename,
+                )
+            )
 
         syncSchema(model.schemata[schema], interface, overwrite=False)
 
@@ -177,8 +192,22 @@ class fieldset(MetadataListDirective):
     """
     key = FIELDSETS_KEY
 
-    def factory(self, name, label=None, description=None, fields=None, **kw):
-        fieldset = Fieldset(name, label=label, description=description, fields=fields)
+    def factory(
+        self,
+        name,
+        label=None,
+        description=None,
+        fields=None,
+        order=DEFAULT_ORDER,
+        **kw
+    ):
+        fieldset = Fieldset(
+            name,
+            label=label,
+            description=description,
+            fields=fields,
+            order=order,
+        )
         for (key, value) in kw.items():
             setattr(fieldset, key, value)
         return [fieldset]
@@ -208,7 +237,9 @@ class primary(MetadataListDirective):
 
         def factory(self, *args):
             if not args:
-                raise TypeError('The primary directive expects at least one argument.')
+                raise TypeError(
+                    'The primary directive expects at least one argument.'
+                )
             return args
 
     class PrimaryFieldsPlugin(ListCheckerPlugin):
diff --git a/plone/supermodel/directives.rst b/plone/supermodel/directives.rst
new file mode 100644
index 0000000..dc967a7
--- /dev/null
+++ b/plone/supermodel/directives.rst
@@ -0,0 +1,192 @@
+================================================
+Loading plone.supermodel schemata from XML files
+================================================
+
+plone.supermodel contains tools for reading and writing zope.schema-based
+interface definitions from/to XML.
+
+This package provides convenience base classes and directives for
+creating interfaces.
+
+Setup
+-----
+
+First, load this package's configuration:
+
+    >>> configuration = """\
+    ... <configure
+    ...      xmlns="http://namespaces.zope.org/zope"
+    ...      i18n_domain="plone.supermodel.tests">
+    ...
+    ...     <include package="zope.component" file="meta.zcml" />
+    ...
+    ...     <include package="plone.supermodel" />
+    ...
+    ... </configure>
+    ... """
+
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+We will also need a temporary directory for storing test schema files.
+
+    >>> import tempfile, os.path, shutil
+    >>> tmpdir = tempfile.mkdtemp()
+
+Building interfaces from schema files
+--------------------------------------
+
+Let us begin by writing a schema file. See plone.supermodel for more details
+on how this is structured.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title>Title</title>
+    ...             <required>True</required>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="body">
+    ...             <title>Body text</title>
+    ...             <required>True</required>
+    ...             <max_length>10000</max_length>
+    ...         </field>
+    ...     </schema>
+    ...
+    ...     <schema name="metadata">
+    ...         <field type="zope.schema.Datetime" name="created">
+    ...             <title>Created date</title>
+    ...             <required>False</required>
+    ...         </field>
+    ...         <field type="zope.schema.TextLine" name="creator">
+    ...             <title>Creator</title>
+    ...             <description>Name of the creator</description>
+    ...             <required>True</required>
+    ...         </field>
+    ...     </schema>
+    ...
+    ... </model>
+    ... """
+
+Ordinarily, this would be in a file in the same directory as the module
+containing the interface being defined. Here, we need to place it in the
+temporary directory created above.
+
+    >>> schema_filename = os.path.join(tmpdir, "schema.xml")
+    >>> schema_file = open(schema_filename, "w")
+    >>> schema_file.write(schema)
+    >>> schema_file.close()
+
+We can now define a schema, using the directives defined in this package:
+
+    >>> from plone.supermodel import model
+    >>> class ITestContent(model.Schema):
+    ...     model.load(schema_filename)
+
+Note: If the schema filename is not an absolute path, it will be found
+relative to the module where the interface is defined.
+
+The interface should have the fields of the default (unnamed) schema:
+
+    >>> from zope.schema import getFieldNamesInOrder
+    >>> getFieldNamesInOrder(ITestContent)
+    ['title', 'body']
+
+It also contains the filename that the schema was loaded from and the schema
+name as a tagged values in the base interface.
+
+    >>> from plone.supermodel.interfaces import FILENAME_KEY, SCHEMA_NAME_KEY
+    >>> ITestContent.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
+    '.../schema.xml'
+    >>> ITestContent.getTaggedValue(SCHEMA_NAME_KEY)
+    u''
+
+We can also use a different, named schema:
+
+    >>> class ITestMetadata(model.Schema):
+    ...     """Test metadata schema, built from XML
+    ...     """
+    ...     model.load(schema_filename, schema=u"metadata")
+
+    >>> getFieldNamesInOrder(ITestMetadata)
+    ['created', 'creator']
+
+Again, the interface has tagged values for the filename and schema name.
+
+    >>> ITestMetadata.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
+    '.../schema.xml'
+    >>> ITestMetadata.getTaggedValue(SCHEMA_NAME_KEY)
+    u'metadata'
+
+Adding and overriding fields
+----------------------------
+
+When loading a schema from XML, fields can still be added in code. If a
+field defined in code has the same name as one loaded from the file, the
+former will override the latter.
+
+    >>> import zope.schema
+    >>> class ITestContentWithNewFields(model.Schema):
+    ...     model.load(schema_filename)
+    ...
+    ...     title = zope.schema.TextLine(title=u"Title", default=u"Default title")
+    ...     postscript = zope.schema.Text(title=u"Postscript")
+
+    >>> getFieldNamesInOrder(ITestContentWithNewFields)
+    ['body', 'title', 'postscript']
+
+    >>> ITestContentWithNewFields[u'title'].default
+    u'Default title'
+
+Fieldset support
+----------------
+
+plone.supermodel can use a tagged value to store groupings of fields into
+fieldsets. The same tagged value can be populated using a directive:
+
+    >>> class IGrouped(model.Schema):
+    ...
+    ...     model.fieldset(u"default", label="Default", fields=['title', 'description'])
+    ...     model.fieldset(u"metadata", label="Metadata", fields=['publication_date'], layout='concise')
+    ...
+    ...     title = zope.schema.TextLine(title=u"Title")
+    ...     description = zope.schema.TextLine(title=u"Description")
+    ...
+    ...     publication_date = zope.schema.Date(title=u"Publication date")
+
+    >>> from plone.supermodel.interfaces import FIELDSETS_KEY
+    >>> IGrouped.getTaggedValue(FIELDSETS_KEY)
+    [<Fieldset 'default' order 9999 of title, description>, <Fieldset 'metadata' order 9999 of publication_date>]
+
+Extra parameters, such as the layout parameter for the metadata fieldset, are
+accessible as attributes on the fieldset:
+
+    >>> metadata = IGrouped.getTaggedValue(FIELDSETS_KEY)[1]
+    >>> metadata.layout
+    'concise'
+
+
+Primary field support
+---------------------
+
+In combination with plone.rfc822, primary fields may be marked:
+
+    >>> class IFields(model.Schema):
+    ...     title = zope.schema.TextLine(title=u"Title")
+    ...     description = zope.schema.TextLine(title=u"Description")
+    ...
+    ...     model.primary('body')
+    ...     body = zope.schema.Text(title=u"Body")
+
+    >>> from plone.rfc822.interfaces import IPrimaryField
+    >>> IPrimaryField.providedBy(IFields['body'])
+    True
+
+Cleanup
+-------
+
+Finally, let's clean up the temporary directory.
+
+    >>> shutil.rmtree(tmpdir)
diff --git a/plone/supermodel/directives.txt b/plone/supermodel/directives.txt
deleted file mode 100644
index babfc81..0000000
--- a/plone/supermodel/directives.txt
+++ /dev/null
@@ -1,192 +0,0 @@
-================================================
-Loading plone.supermodel schemata from XML files
-================================================
-
-plone.supermodel contains tools for reading and writing zope.schema-based
-interface definitions from/to XML.
-
-This package provides convenience base classes and directives for
-creating interfaces.
-
-Setup
------
-
-First, load this package's configuration:
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.supermodel.tests">
-    ...
-    ...     <include package="zope.component" file="meta.zcml" />
-    ...
-    ...     <include package="plone.supermodel" />
-    ...
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-We will also need a temporary directory for storing test schema files.
-
-    >>> import tempfile, os.path, shutil
-    >>> tmpdir = tempfile.mkdtemp()
-
-Building interfaces from schema files
---------------------------------------
-
-Let us begin by writing a schema file. See plone.supermodel for more details
-on how this is structured.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title>Title</title>
-    ...             <required>True</required>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="body">
-    ...             <title>Body text</title>
-    ...             <required>True</required>
-    ...             <max_length>10000</max_length>
-    ...         </field>
-    ...     </schema>
-    ...
-    ...     <schema name="metadata">
-    ...         <field type="zope.schema.Datetime" name="created">
-    ...             <title>Created date</title>
-    ...             <required>False</required>
-    ...         </field>
-    ...         <field type="zope.schema.TextLine" name="creator">
-    ...             <title>Creator</title>
-    ...             <description>Name of the creator</description>
-    ...             <required>True</required>
-    ...         </field>
-    ...     </schema>
-    ...
-    ... </model>
-    ... """
-
-Ordinarily, this would be in a file in the same directory as the module
-containing the interface being defined. Here, we need to place it in the
-temporary directory created above.
-
-    >>> schema_filename = os.path.join(tmpdir, "schema.xml")
-    >>> schema_file = open(schema_filename, "w")
-    >>> schema_file.write(schema)
-    >>> schema_file.close()
-
-We can now define a schema, using the directives defined in this package:
-
-    >>> from plone.supermodel import model
-    >>> class ITestContent(model.Schema):
-    ...     model.load(schema_filename)
-
-Note: If the schema filename is not an absolute path, it will be found
-relative to the module where the interface is defined.
-
-The interface should have the fields of the default (unnamed) schema:
-
-    >>> from zope.schema import getFieldNamesInOrder
-    >>> getFieldNamesInOrder(ITestContent)
-    ['title', 'body']
-
-It also contains the filename that the schema was loaded from and the schema
-name as a tagged values in the base interface.
-
-    >>> from plone.supermodel.interfaces import FILENAME_KEY, SCHEMA_NAME_KEY
-    >>> ITestContent.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
-    '.../schema.xml'
-    >>> ITestContent.getTaggedValue(SCHEMA_NAME_KEY)
-    u''
-
-We can also use a different, named schema:
-
-    >>> class ITestMetadata(model.Schema):
-    ...     """Test metadata schema, built from XML
-    ...     """
-    ...     model.load(schema_filename, schema=u"metadata")
-
-    >>> getFieldNamesInOrder(ITestMetadata)
-    ['created', 'creator']
-
-Again, the interface has tagged values for the filename and schema name.
-
-    >>> ITestMetadata.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
-    '.../schema.xml'
-    >>> ITestMetadata.getTaggedValue(SCHEMA_NAME_KEY)
-    u'metadata'
-
-Adding and overriding fields
-----------------------------
-
-When loading a schema from XML, fields can still be added in code. If a
-field defined in code has the same name as one loaded from the file, the
-former will override the latter.
-
-    >>> import zope.schema
-    >>> class ITestContentWithNewFields(model.Schema):
-    ...     model.load(schema_filename)
-    ...
-    ...     title = zope.schema.TextLine(title=u"Title", default=u"Default title")
-    ...     postscript = zope.schema.Text(title=u"Postscript")
-
-    >>> getFieldNamesInOrder(ITestContentWithNewFields)
-    ['body', 'title', 'postscript']
-
-    >>> ITestContentWithNewFields[u'title'].default
-    u'Default title'
-
-Fieldset support
-----------------
-
-plone.supermodel can use a tagged value to store groupings of fields into
-fieldsets. The same tagged value can be populated using a directive:
-
-    >>> class IGrouped(model.Schema):
-    ...
-    ...     model.fieldset(u"default", label="Default", fields=['title', 'description'])
-    ...     model.fieldset(u"metadata", label="Metadata", fields=['publication_date'], layout='concise')
-    ...
-    ...     title = zope.schema.TextLine(title=u"Title")
-    ...     description = zope.schema.TextLine(title=u"Description")
-    ...
-    ...     publication_date = zope.schema.Date(title=u"Publication date")
-
-    >>> from plone.supermodel.interfaces import FIELDSETS_KEY
-    >>> IGrouped.getTaggedValue(FIELDSETS_KEY)
-    [<Fieldset 'default' of title, description>, <Fieldset 'metadata' of publication_date>]
-
-Extra parameters, such as the layout parameter for the metadata fieldset, are
-accessible as attributes on the fieldset:
-
-    >>> metadata = IGrouped.getTaggedValue(FIELDSETS_KEY)[1]
-    >>> metadata.layout
-    'concise'
-
-
-Primary field support
----------------------
-
-In combination with plone.rfc822, primary fields may be marked:
-
-    >>> class IFields(model.Schema):
-    ...     title = zope.schema.TextLine(title=u"Title")
-    ...     description = zope.schema.TextLine(title=u"Description")
-    ...
-    ...     model.primary('body')
-    ...     body = zope.schema.Text(title=u"Body")
-
-    >>> from plone.rfc822.interfaces import IPrimaryField
-    >>> IPrimaryField.providedBy(IFields['body'])
-    True
-
-Cleanup
--------
-
-Finally, let's clean up the temporary directory.
-
-    >>> shutil.rmtree(tmpdir)
diff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py
index b7fcb43..2a13bb3 100644
--- a/plone/supermodel/exportimport.py
+++ b/plone/supermodel/exportimport.py
@@ -35,7 +35,8 @@ class BaseHandler(object):
     The read_field method is called to read one field of the known subtype
     from an XML element.
 
-    The write_field method is called to write one field to a particular element.
+    The write_field method is called to write one field to a particular
+    element.
     """
 
     # Elements that we will not read/write. 'r' means skip when reading;
@@ -306,38 +307,38 @@ class ChoiceHandler(BaseHandler):
     def __init__(self, klass):
         super(ChoiceHandler, self).__init__(klass)
 
-        # Special options for the constructor. These are not automatically written.
+        # Special options for the constructor. These are not automatically
+        # written.
 
-        self.fieldAttributes['vocabulary'] = \
-            zope.schema.TextLine(
-                __name__='vocabulary',
-                title=u"Named vocabulary"
-            )
+        self.fieldAttributes['vocabulary'] = zope.schema.TextLine(
+            __name__='vocabulary',
+            title=u"Named vocabulary"
+        )
 
-        self.fieldAttributes['values'] = \
-            zope.schema.List(
-                __name__='values',
-                title=u"Values",
-                value_type=zope.schema.Text(title=u"Value")
-            )
+        self.fieldAttributes['values'] = zope.schema.List(
+            __name__='values',
+            title=u"Values",
+            value_type=zope.schema.Text(title=u"Value")
+        )
 
         # XXX: We can't be more specific about the schema, since the field
         # supports both ISource and IContextSourceBinder. However, the
         # initialiser will validate.
-        self.fieldAttributes['source'] = \
-            zope.schema.Object(
-                __name__='source',
-                title=u"Source",
-                schema=Interface
-            )
+        self.fieldAttributes['source'] = zope.schema.Object(
+            __name__='source',
+            title=u"Source",
+            schema=Interface
+        )
 
     def readAttribute(self, element, attributeField):
-        if element.tag == 'values':
-            if any([child.get('key') for child in element]):
-                attributeField = OrderedDictField(
-                    key_type=zope.schema.TextLine(),
-                    value_type=zope.schema.TextLine(),
-                    )
+        if (
+            element.tag == 'values' and
+            any([child.get('key') for child in element])
+        ):
+            attributeField = OrderedDictField(
+                key_type=zope.schema.TextLine(),
+                value_type=zope.schema.TextLine(),
+            )
         return elementToValue(attributeField, element)
 
     def _constructField(self, attributes):
@@ -366,7 +367,12 @@ def _constructField(self, attributes):
 
     def write(self, field, name, type, elementName='field'):
 
-        element = super(ChoiceHandler, self).write(field, name, type, elementName)
+        element = super(ChoiceHandler, self).write(
+            field,
+            name,
+            type,
+            elementName
+        )
 
         # write vocabulary or values list
 
@@ -382,12 +388,16 @@ def write(self, field, name, type, elementName='field'):
             element.append(child)
 
         # Listed vocabulary - attempt to convert to a simple list of values
-        elif field.vocabularyName is None \
-             and IVocabularyTokenized.providedBy(field.vocabulary):
+        elif (
+            field.vocabularyName is None and
+            IVocabularyTokenized.providedBy(field.vocabulary)
+        ):
             value = []
             for term in field.vocabulary:
-                if (not isinstance(term.value, (str, unicode), )
-                    or term.token != term.value.encode('unicode_escape')):
+                if (
+                    not isinstance(term.value, (str, unicode), ) or
+                    term.token != term.value.encode('unicode_escape')
+                ):
                     raise NotImplementedError(
                         u"Cannot export a vocabulary that is not "
                         u"based on a simple list of values"
@@ -399,12 +409,13 @@ def write(self, field, name, type, elementName='field'):
 
             attributeField = self.fieldAttributes['values']
             if any(map(lambda v: isinstance(v, tuple), value)):
-                _pair = lambda v: v if len(v) == 2 else (v[0],) * 2
+                def _pair(v):
+                    return v if len(v) == 2 else (v[0],) * 2
                 value = OrderedDict(map(_pair, value))
                 attributeField = OrderedDictField(
                     key_type=zope.schema.TextLine(),
                     value_type=zope.schema.TextLine(),
-                    )
+                )
             child = valueToElement(
                 attributeField,
                 value,
diff --git a/plone/supermodel/fields.rst b/plone/supermodel/fields.rst
new file mode 100644
index 0000000..c4ba642
--- /dev/null
+++ b/plone/supermodel/fields.rst
@@ -0,0 +1,1551 @@
+================================
+plone.supermodel: field handlers
+================================
+
+This file tests the various field handlers. Please note the following known
+limitations:
+
+  * `Timedelta` fields are not supported.
+  * When an `Object` field is serialised, the `default` and `missing_value`
+    attributes are ignored.
+  * `Choice` fields can only be serialised if were created from a simple list
+    of values (the `values` constructor parameter) or use a named vocabulary.
+    It is possible to import a Choice field with a source that is either an
+    `ISource` or an `IContextSourceBinder`, but only if such instances can be
+    imported from a given dotted name. Finally, `Choice` fields imported with
+    a `values` list as a vocabulary or with the `default` or `missing_value`
+    set, are assumed store a unicode string.
+
+First, let's wire up the package.
+
+    >>> configuration = """\
+    ... <configure
+    ...      xmlns="http://namespaces.zope.org/zope"
+    ...      i18n_domain="plone.behavior.tests">
+    ...
+    ...     <include package="zope.component" file="meta.zcml" />
+    ...
+    ...     <include package="plone.supermodel" />
+    ...
+    ... </configure>
+    ... """
+
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+Then, let's test each field in turn.
+
+    >>> from zope.component import getUtility
+    >>> from zope import schema
+
+    >>> from plone.supermodel.interfaces import IFieldExportImportHandler
+    >>> from plone.supermodel.interfaces import IFieldNameExtractor
+    >>> from plone.supermodel.utils import prettyXML
+
+    >>> import datetime
+    >>> import plone.supermodel.tests
+
+    >>> from lxml import etree
+
+Bytes
+-----
+
+    >>> field = schema.Bytes(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='abc', missing_value='m',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Bytes">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Bytes'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'abc'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+BytesLine
+---------
+
+    >>> field = schema.BytesLine(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='abc', missing_value='m',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.BytesLine">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.BytesLine'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'abc'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+ASCII
+-----
+
+    >>> field = schema.ASCII(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='abc', missing_value='m',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.ASCII">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.ASCII'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'abc'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+ASCIILine
+---------
+
+    >>> field = schema.ASCIILine(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='abc', missing_value='m',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.ASCIILine">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.ASCIILine'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'abc'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+Text
+----
+
+    >>> field = schema.Text(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=u'abc', missing_value=u'm',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Text">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.Text'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'abc'
+    >>> reciprocal.missing_value
+    u'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+TextLine
+--------
+
+    >>> field = schema.TextLine(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=u'abc', missing_value=u'm',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.TextLine">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.TextLine'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'abc'
+    >>> reciprocal.missing_value
+    u'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+SourceText
+----------
+
+    >>> field = schema.SourceText(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=u'abc', missing_value=u'm',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.SourceText">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.SourceText'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'abc'
+    >>> reciprocal.missing_value
+    u'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+URI
+---
+
+    >>> field = schema.URI(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='http://plone.org', missing_value='m',
+    ...     min_length=2, max_length=100)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.URI">
+      <default>http://plone.org</default>
+      <description>Test desc</description>
+      <max_length>100</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.URI'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'http://plone.org'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    100
+
+Id
+--
+
+    >>> field = schema.Id(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='a.b.c', missing_value='m',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Id">
+      <default>a.b.c</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Id'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'a.b.c'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+DottedName
+-----------
+
+    >>> field = schema.DottedName(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='a.b.c', missing_value='m',
+    ...     min_length=2, max_length=10, min_dots=2, max_dots=4)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.DottedName">
+      <default>a.b.c</default>
+      <description>Test desc</description>
+      <max_dots>4</max_dots>
+      <max_length>10</max_length>
+      <min_dots>2</min_dots>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.DottedName'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'a.b.c'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.min_dots
+    2
+    >>> reciprocal.max_dots
+    4
+
+Password
+--------
+
+    >>> field = schema.Password(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=u'abc', missing_value=u'm',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Password">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.Password'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'abc'
+    >>> reciprocal.missing_value
+    u'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+Bool
+----
+
+    >>> field = schema.Bool(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=False, missing_value=True)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Bool">
+      <default>False</default>
+      <description>Test desc</description>
+      <missing_value>True</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.Bool'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    False
+    >>> reciprocal.missing_value
+    True
+
+Int
+---
+
+    >>> field = schema.Int(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=12, missing_value=-1,
+    ...     min=1, max=99)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Int">
+      <default>12</default>
+      <description>Test desc</description>
+      <max>99</max>
+      <min>1</min>
+      <missing_value>-1</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    12
+    >>> reciprocal.missing_value
+    -1
+    >>> reciprocal.min
+    1
+    >>> reciprocal.max
+    99
+
+Float
+-----
+
+    >>> field = schema.Float(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=12.1, missing_value=-1.0,
+    ...     min=1.123, max=99.5)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Float">
+      <default>12.1</default>
+      <description>Test desc</description>
+      <max>99.5</max>
+      <min>1.123</min>
+      <missing_value>-1.0</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Float'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    12.1
+    >>> reciprocal.missing_value
+    -1.0
+    >>> reciprocal.min
+    1.123
+    >>> reciprocal.max
+    99.5
+
+Decimal
+-------
+
+    >>> import decimal
+    >>> field = schema.Decimal(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=decimal.Decimal("12.1"), missing_value=decimal.Decimal("-1.0"),
+    ...     min=decimal.Decimal("1.123"), max=decimal.Decimal("99.5"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Decimal">
+      <default>12.1</default>
+      <description>Test desc</description>
+      <max>99.5</max>
+      <min>1.123</min>
+      <missing_value>-1.0</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Decimal'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default == decimal.Decimal('12.1')
+    True
+    >>> reciprocal.missing_value == decimal.Decimal('-1.0')
+    True
+    >>> reciprocal.min == decimal.Decimal('1.123')
+    True
+    >>> reciprocal.max == decimal.Decimal('99.5')
+    True
+
+Date
+----
+
+    >>> field = schema.Date(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=datetime.date(2001,1,2), missing_value=datetime.date(2000,1,1),
+    ...     min=datetime.date(2000,10,12), max=datetime.date(2099,12,31))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Date">
+      <default>2001-01-02</default>
+      <description>Test desc</description>
+      <max>2099-12-31</max>
+      <min>2000-10-12</min>
+      <missing_value>2000-01-01</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Date'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    datetime.date(2001, 1, 2)
+    >>> reciprocal.missing_value
+    datetime.date(2000, 1, 1)
+    >>> reciprocal.min
+    datetime.date(2000, 10, 12)
+    >>> reciprocal.max
+    datetime.date(2099, 12, 31)
+
+Datetime
+---------
+
+    >>> field = schema.Datetime(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=datetime.datetime(2001,1,2,1,2,3), missing_value=datetime.datetime(2000,1,1,2,3,4),
+    ...     min=datetime.datetime(2000,10,12,0,0,2), max=datetime.datetime(2099,12,31,1,2,2))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Datetime">
+      <default>2001-01-02 01:02:03</default>
+      <description>Test desc</description>
+      <max>2099-12-31 01:02:02</max>
+      <min>2000-10-12 00:00:02</min>
+      <missing_value>2000-01-01 02:03:04</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Datetime'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    datetime.datetime(2001, 1, 2, 1, 2, 3, 1)
+    >>> reciprocal.missing_value
+    datetime.datetime(2000, 1, 1, 2, 3, 4, 5)
+    >>> reciprocal.min
+    datetime.datetime(2000, 10, 12, 0, 0, 2, 3)
+    >>> reciprocal.max
+    datetime.datetime(2099, 12, 31, 1, 2, 2, 3)
+
+InterfaceField
+---------------
+
+    >>> field = schema.InterfaceField(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=plone.supermodel.tests.IDummy,
+    ...     missing_value=plone.supermodel.tests.IDummy)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.InterfaceField">
+      <default>plone.supermodel.tests.IDummy</default>
+      <description>Test desc</description>
+      <missing_value>plone.supermodel.tests.IDummy</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.InterfaceField'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    <InterfaceClass plone.supermodel.tests.IDummy>
+    >>> reciprocal.missing_value
+    <InterfaceClass plone.supermodel.tests.IDummy>
+
+Tuple
+-----
+
+    >>> field = schema.Tuple(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=(1,2), missing_value=(),
+    ...     min_length=2, max_length=10,
+    ...     value_type=schema.Int(title=u"Val"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Tuple">
+      <default>
+        <element>1</element>
+        <element>2</element>
+      </default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value/>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <value_type type="zope.schema.Int">
+        <title>Val</title>
+      </value_type>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Tuple'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    (1, 2)
+    >>> reciprocal.missing_value
+    ()
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.value_type.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.value_type.title
+    u'Val'
+
+List
+----
+
+    >>> field = schema.List(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=[1,2], missing_value=[],
+    ...     min_length=2, max_length=10,
+    ...     value_type=schema.Int(title=u"Val"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.List">
+      <default>
+        <element>1</element>
+        <element>2</element>
+      </default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value/>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <value_type type="zope.schema.Int">
+        <title>Val</title>
+      </value_type>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.List'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    [1, 2]
+    >>> reciprocal.missing_value
+    []
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.value_type.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.value_type.title
+    u'Val'
+
+Set
+---
+
+    >>> field = schema.Set(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=set((1,2)), missing_value=set(),
+    ...     min_length=2, max_length=10,
+    ...     value_type=schema.Int(title=u"Val"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Set">
+      <default>
+        <element>1</element>
+        <element>2</element>
+      </default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value/>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <value_type type="zope.schema.Int">
+        <title>Val</title>
+      </value_type>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Set'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    set([1, 2])
+    >>> reciprocal.missing_value
+    set([])
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.value_type.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.value_type.title
+    u'Val'
+
+FrozenSet
+---------
+
+    >>> field = schema.FrozenSet(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=frozenset((1,2)), missing_value=frozenset(),
+    ...     min_length=2, max_length=10,
+    ...     value_type=schema.Int(title=u"Val"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.FrozenSet">
+      <default>
+        <element>1</element>
+        <element>2</element>
+      </default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value/>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <value_type type="zope.schema.Int">
+        <title>Val</title>
+      </value_type>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.FrozenSet'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    frozenset([1, 2])
+    >>> reciprocal.missing_value
+    frozenset([])
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.value_type.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.value_type.title
+    u'Val'
+
+Dict
+----
+
+    >>> field = schema.Dict(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default={'a':1, 'b':2}, missing_value={},
+    ...     min_length=2, max_length=10,
+    ...     key_type=schema.ASCIILine(title=u"Key"),
+    ...     value_type=schema.Int(title=u"Val"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Dict">
+      <default>
+        <element key="a">1</element>
+        <element key="b">2</element>
+      </default>
+      <description>Test desc</description>
+      <key_type type="zope.schema.ASCIILine">
+        <title>Key</title>
+      </key_type>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value/>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <value_type type="zope.schema.Int">
+        <title>Val</title>
+      </value_type>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Dict'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    {'a': 1, 'b': 2}
+    >>> reciprocal.missing_value
+    {}
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.key_type.__class__
+    <class 'zope.schema._field.ASCIILine'>
+    >>> reciprocal.key_type.title
+    u'Key'
+    >>> reciprocal.value_type.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.value_type.title
+    u'Val'
+
+Object
+------
+
+Note: when an object field is written, the 'default' and 'missing_value'
+fields will be omitted, as there is no way to write these reliably.
+
+    >>> dummy1 = plone.supermodel.tests.Dummy()
+    >>> dummy2 = plone.supermodel.tests.Dummy()
+
+    >>> field = schema.Object(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=dummy1, missing_value=dummy2,
+    ...     schema=plone.supermodel.tests.IDummy)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType) #doctest: +ELLIPSIS
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Object">
+      <description>Test desc</description>
+      <readonly>True</readonly>
+      <required>False</required>
+      <schema>plone.supermodel.tests.IDummy</schema>
+      <title>Test</title>
+    </field>
+
+However, we support reading an object dotted name for an
+object field that references a particular dotted name.
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.Object">
+    ...   <default>plone.supermodel.tests.dummy1</default>
+    ...   <description>Test desc</description>
+    ...   <missing_value/>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <schema>plone.supermodel.tests.IDummy</schema>
+    ...   <title>Test</title>
+    ... </field>
+    ... """)
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Object'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default is plone.supermodel.tests.dummy1
+    True
+    >>> reciprocal.missing_value is None
+    True
+
+Choice
+------
+
+The choice field supports several different modes: a named vocabulary, a list
+of values, a source object, or a source context binder object. However,
+plone.supermodel only supports exporting named vocabularies or lists of
+unicode string values. In addition, it is possible to import (but not export)
+a source or context source binder, provided it can be imported from a
+dotted name.
+
+1. Named vocabularies
+
+These can be both exported and imported.
+
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='a', missing_value='', vocabulary=u'dummy.vocab')
+
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Choice">
+      <default>a</default>
+      <description>Test desc</description>
+      <missing_value></missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <vocabulary>dummy.vocab</vocabulary>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Choice'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default # note - value is always unicode
+    u'a'
+    >>> reciprocal.missing_value # note - value is always unicode
+    u''
+    >>> reciprocal.vocabulary is None
+    True
+    >>> reciprocal.vocabularyName
+    u'dummy.vocab'
+
+2. Values vocabularies
+
+These can be both imported and exported, but note that the value is always
+a unicode string when importing.
+
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='a', missing_value='', values=['a', 'b', 'c'])
+
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Choice">
+      <default>a</default>
+      <description>Test desc</description>
+      <missing_value></missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <values>
+        <element>a</element>
+        <element>b</element>
+        <element>c</element>
+      </values>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Choice'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'a'
+    >>> reciprocal.missing_value
+    u''
+    >>> [t.value for t in reciprocal.vocabulary]
+    [u'a', u'b', u'c']
+    >>> reciprocal.vocabularyName is None
+    True
+
+There was a bug when the XML namespace was specified explicitly; let's make
+sure it hasn't regressed.
+
+    >>> from plone.supermodel.interfaces import XML_NAMESPACE
+    >>> element.set('xmlns', XML_NAMESPACE)
+    >>> element = etree.parse(StringIO(prettyXML(element))).getroot()
+    >>> reciprocal = handler.read(element)
+    >>> [t.value for t in reciprocal.vocabulary]
+    [u'a', u'b', u'c']
+
+Also, make sure we can handle terms with unicode values (as long as their
+tokens are the utf8-encoded values).
+
+    >>> from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm
+    >>> vocab = SimpleVocabulary([
+    ...     SimpleTerm(token='a', value=u'a', title=u'a'),
+    ...     SimpleTerm(token=r'\xe7', value=u'\xe7', title=u'\xe7'), # c with cedilla
+    ...     ])
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='a', missing_value='', vocabulary=vocab)
+
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Choice">
+      <default>a</default>
+      <description>Test desc</description>
+      <missing_value></missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <values>
+        <element>a</element>
+        <element>&#231;</element>
+      </values>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> [t.value for t in reciprocal.vocabulary]
+    [u'a', u'\xe7']
+
+
+Additionally, it is possible for Choice fields with a values vocabulary
+whose terms contain values distinct from term titles for each
+respective term.  This is accomplished by using the 'key' attribute
+of each contained 'element' of the values element (this is consistent
+with how Dict fields are output, only for Choices, order is guaranteed).
+
+    >>> from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm
+    >>> vocab = SimpleVocabulary([
+    ...     SimpleTerm(value=u'a', title=u'A'),
+    ...     SimpleTerm(value=u'b', title=u'B'),
+    ...     ])
+    >>> field = schema.Choice(
+    ...     __name__="dummy",
+    ...     title=u"Test",
+    ...     vocabulary=vocab,
+    ...     )
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Choice">
+      <title>Test</title>
+      <values>
+        <element key="a">A</element>
+        <element key="b">B</element>
+      </values>
+    </field>
+
+3. Sources and source binders
+
+We cannot export choice fields with a source or context source binder:
+
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     vocabulary=plone.supermodel.tests.dummy_vocabulary_instance)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
+    Traceback (most recent call last):
+    ...
+    NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values
+
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     source=plone.supermodel.tests.dummy_vocabulary_instance)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
+    Traceback (most recent call last):
+    ...
+    NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values
+
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     source=plone.supermodel.tests.dummy_binder)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
+    Traceback (most recent call last):
+    ...
+    NotImplementedError: Choice fields with vocabularies not based on a simple list of values or a named vocabulary cannot be exported
+
+However, we can import a choice field with a source, provided that source can
+be specified via an importable dotted name.
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.Choice">
+    ...   <default>a</default>
+    ...   <description>Test desc</description>
+    ...   <missing_value/>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ...   <source>plone.supermodel.tests.dummy_binder</source>
+    ... </field>
+    ... """)
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Choice'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'a'
+    >>> reciprocal.vocabulary is plone.supermodel.tests.dummy_binder
+    True
+    >>> reciprocal.vocabularyName is None
+    True
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.Choice">
+    ...   <default>a</default>
+    ...   <description>Test desc</description>
+    ...   <missing_value/>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ...   <source>plone.supermodel.tests.dummy_vocabulary_instance</source>
+    ... </field>
+    ... """)
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Choice'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'a'
+    >>> reciprocal.vocabulary is plone.supermodel.tests.dummy_vocabulary_instance
+    True
+    >>> reciprocal.vocabularyName is None
+    True
+
+defaultFactory usage
+--------------------
+
+Fields may specify defaultFactory attributes as dotted interfaces.
+defaultFactory callables should provide either
+zope.schema.interfaces.IContextAwareDefaultFactory or
+plone.supermodel.interfaces.IDefaultFactory.
+
+Note that zope.schema allows callables without any marker
+interface. Our requirements are an extra validation measure.
+
+Try specifying a defaultFactory attribute::
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.TextLine">
+    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultFactory</defaultFactory>
+    ...   <description>Test desc</description>
+    ...   <max_length>10</max_length>
+    ...   <min_length>2</min_length>
+    ...   <missing_value>m</missing_value>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ... </field>
+    ... """)
+
+Import it::
+    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
+
+Sanity checks::
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.TextLine'>
+
+And, look for the specified defaultFactory::
+    >>> reciprocal.defaultFactory == plone.supermodel.tests.dummy_defaultFactory
+    True
+
+Let's try it with a callable that provides IContextAwareDefaultFactory::
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.TextLine">
+    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultCAFactory</defaultFactory>
+    ...   <description>Test desc</description>
+    ...   <max_length>10</max_length>
+    ...   <min_length>2</min_length>
+    ...   <missing_value>m</missing_value>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ... </field>
+    ... """)
+
+    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.defaultFactory == plone.supermodel.tests.dummy_defaultCAFactory
+    True
+
+And, check to make sure that we can't use a callable that doesn't have one
+of our marker interfaces::
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.TextLine">
+    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultBadFactory</defaultFactory>
+    ...   <description>Test desc</description>
+    ...   <max_length>10</max_length>
+    ...   <min_length>2</min_length>
+    ...   <missing_value>m</missing_value>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ... </field>
+    ... """)
+
+    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
+    >>> reciprocal = handler.read(element)
+    Traceback (most recent call last):
+    ...
+    ImportError: defaultFactory must provide zope.schema.interfaces.IContextAwareDefaultFactory or plone.supermodel.IDefaultFactory
+
+A non-existent callable should also raise an error::
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.TextLine">
+    ...   <defaultFactory>plone.supermodel.tests.nonExistentFactory</defaultFactory>
+    ...   <description>Test desc</description>
+    ...   <max_length>10</max_length>
+    ...   <min_length>2</min_length>
+    ...   <missing_value>m</missing_value>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ... </field>
+    ... """)
+
+    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
+    >>> reciprocal = handler.read(element)
+    Traceback (most recent call last):
+    ...
+    ImportError: No module named nonExistentFactory
diff --git a/plone/supermodel/fields.txt b/plone/supermodel/fields.txt
deleted file mode 100644
index c4ba642..0000000
--- a/plone/supermodel/fields.txt
+++ /dev/null
@@ -1,1551 +0,0 @@
-================================
-plone.supermodel: field handlers
-================================
-
-This file tests the various field handlers. Please note the following known
-limitations:
-
-  * `Timedelta` fields are not supported.
-  * When an `Object` field is serialised, the `default` and `missing_value`
-    attributes are ignored.
-  * `Choice` fields can only be serialised if were created from a simple list
-    of values (the `values` constructor parameter) or use a named vocabulary.
-    It is possible to import a Choice field with a source that is either an
-    `ISource` or an `IContextSourceBinder`, but only if such instances can be
-    imported from a given dotted name. Finally, `Choice` fields imported with
-    a `values` list as a vocabulary or with the `default` or `missing_value`
-    set, are assumed store a unicode string.
-
-First, let's wire up the package.
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.behavior.tests">
-    ...
-    ...     <include package="zope.component" file="meta.zcml" />
-    ...
-    ...     <include package="plone.supermodel" />
-    ...
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-Then, let's test each field in turn.
-
-    >>> from zope.component import getUtility
-    >>> from zope import schema
-
-    >>> from plone.supermodel.interfaces import IFieldExportImportHandler
-    >>> from plone.supermodel.interfaces import IFieldNameExtractor
-    >>> from plone.supermodel.utils import prettyXML
-
-    >>> import datetime
-    >>> import plone.supermodel.tests
-
-    >>> from lxml import etree
-
-Bytes
------
-
-    >>> field = schema.Bytes(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='abc', missing_value='m',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Bytes">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Bytes'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'abc'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-BytesLine
----------
-
-    >>> field = schema.BytesLine(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='abc', missing_value='m',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.BytesLine">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.BytesLine'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'abc'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-ASCII
------
-
-    >>> field = schema.ASCII(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='abc', missing_value='m',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.ASCII">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.ASCII'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'abc'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-ASCIILine
----------
-
-    >>> field = schema.ASCIILine(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='abc', missing_value='m',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.ASCIILine">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.ASCIILine'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'abc'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-Text
-----
-
-    >>> field = schema.Text(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=u'abc', missing_value=u'm',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Text">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.Text'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'abc'
-    >>> reciprocal.missing_value
-    u'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-TextLine
---------
-
-    >>> field = schema.TextLine(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=u'abc', missing_value=u'm',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.TextLine">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.TextLine'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'abc'
-    >>> reciprocal.missing_value
-    u'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-SourceText
-----------
-
-    >>> field = schema.SourceText(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=u'abc', missing_value=u'm',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.SourceText">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.SourceText'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'abc'
-    >>> reciprocal.missing_value
-    u'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-URI
----
-
-    >>> field = schema.URI(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='http://plone.org', missing_value='m',
-    ...     min_length=2, max_length=100)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.URI">
-      <default>http://plone.org</default>
-      <description>Test desc</description>
-      <max_length>100</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.URI'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'http://plone.org'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    100
-
-Id
---
-
-    >>> field = schema.Id(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='a.b.c', missing_value='m',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Id">
-      <default>a.b.c</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Id'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'a.b.c'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-DottedName
------------
-
-    >>> field = schema.DottedName(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='a.b.c', missing_value='m',
-    ...     min_length=2, max_length=10, min_dots=2, max_dots=4)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.DottedName">
-      <default>a.b.c</default>
-      <description>Test desc</description>
-      <max_dots>4</max_dots>
-      <max_length>10</max_length>
-      <min_dots>2</min_dots>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.DottedName'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'a.b.c'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.min_dots
-    2
-    >>> reciprocal.max_dots
-    4
-
-Password
---------
-
-    >>> field = schema.Password(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=u'abc', missing_value=u'm',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Password">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.Password'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'abc'
-    >>> reciprocal.missing_value
-    u'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-Bool
-----
-
-    >>> field = schema.Bool(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=False, missing_value=True)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Bool">
-      <default>False</default>
-      <description>Test desc</description>
-      <missing_value>True</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.Bool'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    False
-    >>> reciprocal.missing_value
-    True
-
-Int
----
-
-    >>> field = schema.Int(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=12, missing_value=-1,
-    ...     min=1, max=99)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Int">
-      <default>12</default>
-      <description>Test desc</description>
-      <max>99</max>
-      <min>1</min>
-      <missing_value>-1</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    12
-    >>> reciprocal.missing_value
-    -1
-    >>> reciprocal.min
-    1
-    >>> reciprocal.max
-    99
-
-Float
------
-
-    >>> field = schema.Float(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=12.1, missing_value=-1.0,
-    ...     min=1.123, max=99.5)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Float">
-      <default>12.1</default>
-      <description>Test desc</description>
-      <max>99.5</max>
-      <min>1.123</min>
-      <missing_value>-1.0</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Float'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    12.1
-    >>> reciprocal.missing_value
-    -1.0
-    >>> reciprocal.min
-    1.123
-    >>> reciprocal.max
-    99.5
-
-Decimal
--------
-
-    >>> import decimal
-    >>> field = schema.Decimal(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=decimal.Decimal("12.1"), missing_value=decimal.Decimal("-1.0"),
-    ...     min=decimal.Decimal("1.123"), max=decimal.Decimal("99.5"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Decimal">
-      <default>12.1</default>
-      <description>Test desc</description>
-      <max>99.5</max>
-      <min>1.123</min>
-      <missing_value>-1.0</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Decimal'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default == decimal.Decimal('12.1')
-    True
-    >>> reciprocal.missing_value == decimal.Decimal('-1.0')
-    True
-    >>> reciprocal.min == decimal.Decimal('1.123')
-    True
-    >>> reciprocal.max == decimal.Decimal('99.5')
-    True
-
-Date
-----
-
-    >>> field = schema.Date(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=datetime.date(2001,1,2), missing_value=datetime.date(2000,1,1),
-    ...     min=datetime.date(2000,10,12), max=datetime.date(2099,12,31))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Date">
-      <default>2001-01-02</default>
-      <description>Test desc</description>
-      <max>2099-12-31</max>
-      <min>2000-10-12</min>
-      <missing_value>2000-01-01</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Date'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    datetime.date(2001, 1, 2)
-    >>> reciprocal.missing_value
-    datetime.date(2000, 1, 1)
-    >>> reciprocal.min
-    datetime.date(2000, 10, 12)
-    >>> reciprocal.max
-    datetime.date(2099, 12, 31)
-
-Datetime
----------
-
-    >>> field = schema.Datetime(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=datetime.datetime(2001,1,2,1,2,3), missing_value=datetime.datetime(2000,1,1,2,3,4),
-    ...     min=datetime.datetime(2000,10,12,0,0,2), max=datetime.datetime(2099,12,31,1,2,2))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Datetime">
-      <default>2001-01-02 01:02:03</default>
-      <description>Test desc</description>
-      <max>2099-12-31 01:02:02</max>
-      <min>2000-10-12 00:00:02</min>
-      <missing_value>2000-01-01 02:03:04</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Datetime'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    datetime.datetime(2001, 1, 2, 1, 2, 3, 1)
-    >>> reciprocal.missing_value
-    datetime.datetime(2000, 1, 1, 2, 3, 4, 5)
-    >>> reciprocal.min
-    datetime.datetime(2000, 10, 12, 0, 0, 2, 3)
-    >>> reciprocal.max
-    datetime.datetime(2099, 12, 31, 1, 2, 2, 3)
-
-InterfaceField
----------------
-
-    >>> field = schema.InterfaceField(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=plone.supermodel.tests.IDummy,
-    ...     missing_value=plone.supermodel.tests.IDummy)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.InterfaceField">
-      <default>plone.supermodel.tests.IDummy</default>
-      <description>Test desc</description>
-      <missing_value>plone.supermodel.tests.IDummy</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.InterfaceField'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    <InterfaceClass plone.supermodel.tests.IDummy>
-    >>> reciprocal.missing_value
-    <InterfaceClass plone.supermodel.tests.IDummy>
-
-Tuple
------
-
-    >>> field = schema.Tuple(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=(1,2), missing_value=(),
-    ...     min_length=2, max_length=10,
-    ...     value_type=schema.Int(title=u"Val"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Tuple">
-      <default>
-        <element>1</element>
-        <element>2</element>
-      </default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value/>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <value_type type="zope.schema.Int">
-        <title>Val</title>
-      </value_type>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Tuple'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    (1, 2)
-    >>> reciprocal.missing_value
-    ()
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.value_type.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.value_type.title
-    u'Val'
-
-List
-----
-
-    >>> field = schema.List(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=[1,2], missing_value=[],
-    ...     min_length=2, max_length=10,
-    ...     value_type=schema.Int(title=u"Val"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.List">
-      <default>
-        <element>1</element>
-        <element>2</element>
-      </default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value/>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <value_type type="zope.schema.Int">
-        <title>Val</title>
-      </value_type>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.List'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    [1, 2]
-    >>> reciprocal.missing_value
-    []
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.value_type.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.value_type.title
-    u'Val'
-
-Set
----
-
-    >>> field = schema.Set(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=set((1,2)), missing_value=set(),
-    ...     min_length=2, max_length=10,
-    ...     value_type=schema.Int(title=u"Val"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Set">
-      <default>
-        <element>1</element>
-        <element>2</element>
-      </default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value/>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <value_type type="zope.schema.Int">
-        <title>Val</title>
-      </value_type>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Set'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    set([1, 2])
-    >>> reciprocal.missing_value
-    set([])
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.value_type.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.value_type.title
-    u'Val'
-
-FrozenSet
----------
-
-    >>> field = schema.FrozenSet(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=frozenset((1,2)), missing_value=frozenset(),
-    ...     min_length=2, max_length=10,
-    ...     value_type=schema.Int(title=u"Val"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.FrozenSet">
-      <default>
-        <element>1</element>
-        <element>2</element>
-      </default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value/>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <value_type type="zope.schema.Int">
-        <title>Val</title>
-      </value_type>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.FrozenSet'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    frozenset([1, 2])
-    >>> reciprocal.missing_value
-    frozenset([])
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.value_type.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.value_type.title
-    u'Val'
-
-Dict
-----
-
-    >>> field = schema.Dict(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default={'a':1, 'b':2}, missing_value={},
-    ...     min_length=2, max_length=10,
-    ...     key_type=schema.ASCIILine(title=u"Key"),
-    ...     value_type=schema.Int(title=u"Val"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Dict">
-      <default>
-        <element key="a">1</element>
-        <element key="b">2</element>
-      </default>
-      <description>Test desc</description>
-      <key_type type="zope.schema.ASCIILine">
-        <title>Key</title>
-      </key_type>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value/>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <value_type type="zope.schema.Int">
-        <title>Val</title>
-      </value_type>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Dict'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    {'a': 1, 'b': 2}
-    >>> reciprocal.missing_value
-    {}
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.key_type.__class__
-    <class 'zope.schema._field.ASCIILine'>
-    >>> reciprocal.key_type.title
-    u'Key'
-    >>> reciprocal.value_type.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.value_type.title
-    u'Val'
-
-Object
-------
-
-Note: when an object field is written, the 'default' and 'missing_value'
-fields will be omitted, as there is no way to write these reliably.
-
-    >>> dummy1 = plone.supermodel.tests.Dummy()
-    >>> dummy2 = plone.supermodel.tests.Dummy()
-
-    >>> field = schema.Object(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=dummy1, missing_value=dummy2,
-    ...     schema=plone.supermodel.tests.IDummy)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType) #doctest: +ELLIPSIS
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Object">
-      <description>Test desc</description>
-      <readonly>True</readonly>
-      <required>False</required>
-      <schema>plone.supermodel.tests.IDummy</schema>
-      <title>Test</title>
-    </field>
-
-However, we support reading an object dotted name for an
-object field that references a particular dotted name.
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.Object">
-    ...   <default>plone.supermodel.tests.dummy1</default>
-    ...   <description>Test desc</description>
-    ...   <missing_value/>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <schema>plone.supermodel.tests.IDummy</schema>
-    ...   <title>Test</title>
-    ... </field>
-    ... """)
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Object'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default is plone.supermodel.tests.dummy1
-    True
-    >>> reciprocal.missing_value is None
-    True
-
-Choice
-------
-
-The choice field supports several different modes: a named vocabulary, a list
-of values, a source object, or a source context binder object. However,
-plone.supermodel only supports exporting named vocabularies or lists of
-unicode string values. In addition, it is possible to import (but not export)
-a source or context source binder, provided it can be imported from a
-dotted name.
-
-1. Named vocabularies
-
-These can be both exported and imported.
-
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='a', missing_value='', vocabulary=u'dummy.vocab')
-
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Choice">
-      <default>a</default>
-      <description>Test desc</description>
-      <missing_value></missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <vocabulary>dummy.vocab</vocabulary>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Choice'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default # note - value is always unicode
-    u'a'
-    >>> reciprocal.missing_value # note - value is always unicode
-    u''
-    >>> reciprocal.vocabulary is None
-    True
-    >>> reciprocal.vocabularyName
-    u'dummy.vocab'
-
-2. Values vocabularies
-
-These can be both imported and exported, but note that the value is always
-a unicode string when importing.
-
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='a', missing_value='', values=['a', 'b', 'c'])
-
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Choice">
-      <default>a</default>
-      <description>Test desc</description>
-      <missing_value></missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <values>
-        <element>a</element>
-        <element>b</element>
-        <element>c</element>
-      </values>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Choice'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'a'
-    >>> reciprocal.missing_value
-    u''
-    >>> [t.value for t in reciprocal.vocabulary]
-    [u'a', u'b', u'c']
-    >>> reciprocal.vocabularyName is None
-    True
-
-There was a bug when the XML namespace was specified explicitly; let's make
-sure it hasn't regressed.
-
-    >>> from plone.supermodel.interfaces import XML_NAMESPACE
-    >>> element.set('xmlns', XML_NAMESPACE)
-    >>> element = etree.parse(StringIO(prettyXML(element))).getroot()
-    >>> reciprocal = handler.read(element)
-    >>> [t.value for t in reciprocal.vocabulary]
-    [u'a', u'b', u'c']
-
-Also, make sure we can handle terms with unicode values (as long as their
-tokens are the utf8-encoded values).
-
-    >>> from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm
-    >>> vocab = SimpleVocabulary([
-    ...     SimpleTerm(token='a', value=u'a', title=u'a'),
-    ...     SimpleTerm(token=r'\xe7', value=u'\xe7', title=u'\xe7'), # c with cedilla
-    ...     ])
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='a', missing_value='', vocabulary=vocab)
-
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Choice">
-      <default>a</default>
-      <description>Test desc</description>
-      <missing_value></missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <values>
-        <element>a</element>
-        <element>&#231;</element>
-      </values>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> [t.value for t in reciprocal.vocabulary]
-    [u'a', u'\xe7']
-
-
-Additionally, it is possible for Choice fields with a values vocabulary
-whose terms contain values distinct from term titles for each
-respective term.  This is accomplished by using the 'key' attribute
-of each contained 'element' of the values element (this is consistent
-with how Dict fields are output, only for Choices, order is guaranteed).
-
-    >>> from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm
-    >>> vocab = SimpleVocabulary([
-    ...     SimpleTerm(value=u'a', title=u'A'),
-    ...     SimpleTerm(value=u'b', title=u'B'),
-    ...     ])
-    >>> field = schema.Choice(
-    ...     __name__="dummy",
-    ...     title=u"Test",
-    ...     vocabulary=vocab,
-    ...     )
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Choice">
-      <title>Test</title>
-      <values>
-        <element key="a">A</element>
-        <element key="b">B</element>
-      </values>
-    </field>
-
-3. Sources and source binders
-
-We cannot export choice fields with a source or context source binder:
-
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     vocabulary=plone.supermodel.tests.dummy_vocabulary_instance)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
-    Traceback (most recent call last):
-    ...
-    NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values
-
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     source=plone.supermodel.tests.dummy_vocabulary_instance)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
-    Traceback (most recent call last):
-    ...
-    NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values
-
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     source=plone.supermodel.tests.dummy_binder)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
-    Traceback (most recent call last):
-    ...
-    NotImplementedError: Choice fields with vocabularies not based on a simple list of values or a named vocabulary cannot be exported
-
-However, we can import a choice field with a source, provided that source can
-be specified via an importable dotted name.
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.Choice">
-    ...   <default>a</default>
-    ...   <description>Test desc</description>
-    ...   <missing_value/>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ...   <source>plone.supermodel.tests.dummy_binder</source>
-    ... </field>
-    ... """)
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Choice'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'a'
-    >>> reciprocal.vocabulary is plone.supermodel.tests.dummy_binder
-    True
-    >>> reciprocal.vocabularyName is None
-    True
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.Choice">
-    ...   <default>a</default>
-    ...   <description>Test desc</description>
-    ...   <missing_value/>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ...   <source>plone.supermodel.tests.dummy_vocabulary_instance</source>
-    ... </field>
-    ... """)
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Choice'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'a'
-    >>> reciprocal.vocabulary is plone.supermodel.tests.dummy_vocabulary_instance
-    True
-    >>> reciprocal.vocabularyName is None
-    True
-
-defaultFactory usage
---------------------
-
-Fields may specify defaultFactory attributes as dotted interfaces.
-defaultFactory callables should provide either
-zope.schema.interfaces.IContextAwareDefaultFactory or
-plone.supermodel.interfaces.IDefaultFactory.
-
-Note that zope.schema allows callables without any marker
-interface. Our requirements are an extra validation measure.
-
-Try specifying a defaultFactory attribute::
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.TextLine">
-    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultFactory</defaultFactory>
-    ...   <description>Test desc</description>
-    ...   <max_length>10</max_length>
-    ...   <min_length>2</min_length>
-    ...   <missing_value>m</missing_value>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ... </field>
-    ... """)
-
-Import it::
-    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
-
-Sanity checks::
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.TextLine'>
-
-And, look for the specified defaultFactory::
-    >>> reciprocal.defaultFactory == plone.supermodel.tests.dummy_defaultFactory
-    True
-
-Let's try it with a callable that provides IContextAwareDefaultFactory::
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.TextLine">
-    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultCAFactory</defaultFactory>
-    ...   <description>Test desc</description>
-    ...   <max_length>10</max_length>
-    ...   <min_length>2</min_length>
-    ...   <missing_value>m</missing_value>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ... </field>
-    ... """)
-
-    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.defaultFactory == plone.supermodel.tests.dummy_defaultCAFactory
-    True
-
-And, check to make sure that we can't use a callable that doesn't have one
-of our marker interfaces::
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.TextLine">
-    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultBadFactory</defaultFactory>
-    ...   <description>Test desc</description>
-    ...   <max_length>10</max_length>
-    ...   <min_length>2</min_length>
-    ...   <missing_value>m</missing_value>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ... </field>
-    ... """)
-
-    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
-    >>> reciprocal = handler.read(element)
-    Traceback (most recent call last):
-    ...
-    ImportError: defaultFactory must provide zope.schema.interfaces.IContextAwareDefaultFactory or plone.supermodel.IDefaultFactory
-
-A non-existent callable should also raise an error::
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.TextLine">
-    ...   <defaultFactory>plone.supermodel.tests.nonExistentFactory</defaultFactory>
-    ...   <description>Test desc</description>
-    ...   <max_length>10</max_length>
-    ...   <min_length>2</min_length>
-    ...   <missing_value>m</missing_value>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ... </field>
-    ... """)
-
-    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
-    >>> reciprocal = handler.read(element)
-    Traceback (most recent call last):
-    ...
-    ImportError: No module named nonExistentFactory
diff --git a/plone/supermodel/interfaces.py b/plone/supermodel/interfaces.py
index 74fa109..115f330 100644
--- a/plone/supermodel/interfaces.py
+++ b/plone/supermodel/interfaces.py
@@ -1,8 +1,10 @@
 # -*- coding: utf-8 -*-
 from zope.interface import Interface
 from zope.interface.interfaces import IInterface
+
 import zope.schema
 
+
 # Keys for tagged values on interfaces
 
 # absolute file name of model file
@@ -22,6 +24,8 @@
 XML_NAMESPACE = u"http://namespaces.plone.org/supermodel/schema"
 I18N_NAMESPACE = u'http://xml.zope.org/namespaces/i18n'
 
+DEFAULT_ORDER = 9999
+
 
 class ISchema(IInterface):
     """Describes a schema as generated by this library
@@ -39,10 +43,14 @@ class IModel(Interface):
 
     schemata = zope.schema.Dict(
         title=u"Schemata",
-        key_type=zope.schema.TextLine(title=u"Schema name",
-        description=u"Default schema is under the key u''."),
-        value_type=zope.schema.Object(title=u"Schema interface",
-        schema=ISchema)
+        key_type=zope.schema.TextLine(
+            title=u"Schema name",
+            description=u"Default schema is under the key u''."
+        ),
+        value_type=zope.schema.Object(
+            title=u"Schema interface",
+            schema=ISchema
+        )
     )
 
 
@@ -59,6 +67,12 @@ class IFieldset(Interface):
         required=False
     )
 
+    order = zope.schema.Int(
+        title=u"Order",
+        required=False,
+        default=DEFAULT_ORDER,
+    )
+
     fields = zope.schema.List(
         title=u"Field names",
         value_type=zope.schema.TextLine(title=u"Field name")
diff --git a/plone/supermodel/model.py b/plone/supermodel/model.py
index fc838a3..05c24bf 100644
--- a/plone/supermodel/model.py
+++ b/plone/supermodel/model.py
@@ -1,16 +1,20 @@
 # -*- coding: utf-8 -*-
+from plone.supermodel.interfaces import DEFAULT_ORDER
 from plone.supermodel.interfaces import IFieldset
 from plone.supermodel.interfaces import IModel
 from plone.supermodel.interfaces import ISchema
 from plone.supermodel.interfaces import ISchemaPlugin
 from zope.component import getAdapters
-from zope.interface import Interface
 from zope.interface import implementer
+from zope.interface import Interface
 from zope.interface.interface import InterfaceClass
+
 import logging
 import zope.deferredimport
 
-zope.deferredimport.defineFrom('plone.supermodel.directives',
+
+zope.deferredimport.defineFrom(
+    'plone.supermodel.directives',
     'load',
     'fieldset',
 )
@@ -29,10 +33,18 @@
 @implementer(IFieldset)
 class Fieldset(object):
 
-    def __init__(self, __name__, label=None, description=None, fields=None):
+    def __init__(
+        self,
+        __name__,
+        label=None,
+        description=None,
+        fields=None,
+        order=DEFAULT_ORDER
+    ):
         self.__name__ = __name__
         self.label = label or __name__
         self.description = description
+        self.order = order
 
         if fields:
             self.fields = fields
@@ -40,7 +52,11 @@ def __init__(self, __name__, label=None, description=None, fields=None):
             self.fields = []
 
     def __repr__(self):
-        return "<Fieldset '%s' of %s>" % (self.__name__, ', '.join(self.fields))
+        return "<Fieldset '{0}' order {1:d} of {2}>".format(
+            self.__name__,
+            self.order,
+            ', '.join(self.fields)
+        )
 
 
 @implementer(IModel)
@@ -73,14 +89,21 @@ def _SchemaClass_finalize(self):
         for order, name, adapter in adapters:
             adapter()
 
-Schema = SchemaClass("Schema", (Interface,), __module__='plone.supermodel.model')
+Schema = SchemaClass(
+    'Schema',
+    (Interface,),
+    __module__='plone.supermodel.model'
+)
 
 
 def finalizeSchemas(parent=Schema):
     """Configuration action called after plone.supermodel is configured.
     """
     if not isinstance(parent, SchemaClass):
-        raise TypeError('Only instances of plone.supermodel.model.SchemaClass can be finalized.')
+        raise TypeError(
+            'Only instances of plone.supermodel.model.SchemaClass can be '
+            'finalized.'
+        )
 
     def walk(schema):
         yield schema
@@ -106,7 +129,12 @@ def walk(schema):
         if hasattr(schema, '_SchemaClass_finalize'):
             schema._SchemaClass_finalize()
         elif isinstance(schema, InterfaceClass):
-            logger.warn('%s is not an instance of SchemaClass. '
+            logger.warn(
+                '{0}.{1} is not an instance of SchemaClass. '
                 'This can happen if the first base class of a schema is not a '
-                'SchemaClass. See https://bugs.launchpad.net/zope.interface/+bug/791218'
-                % ('%s.%s' % (schema.__module__, schema.__name__)))
+                'SchemaClass. See '
+                'https://bugs.launchpad.net/zope.interface/+bug/791218'.format(
+                    schema.__module__,
+                    schema.__name__
+                )
+            )
diff --git a/plone/supermodel/parser.py b/plone/supermodel/parser.py
index 233d956..0c712a2 100644
--- a/plone/supermodel/parser.py
+++ b/plone/supermodel/parser.py
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 from lxml import etree
 from plone.supermodel.debug import parseinfo
+from plone.supermodel.interfaces import DEFAULT_ORDER
 from plone.supermodel.interfaces import FIELDSETS_KEY
 from plone.supermodel.interfaces import I18N_NAMESPACE
 from plone.supermodel.interfaces import IFieldExportImportHandler
@@ -19,11 +20,13 @@
 from zope.dottedname.resolve import resolve
 from zope.interface import implementer
 from zope.schema import getFields
+
 import linecache
 import sys
 
 # Exception
 
+
 class SupermodelParseError(Exception):
 
     def __init__(self, orig_exc, fname, element):
@@ -42,8 +45,8 @@ def __init__(self, orig_exc, fname, element):
             msg += '\n    %s' % line
         self.args = [msg]
 
-# Helper adapters
 
+# Helper adapters
 @implementer(ISchemaPolicy)
 class DefaultSchemaPolicy(object):
 
@@ -58,7 +61,6 @@ def name(self, schemaName, tree):
 
 
 # Algorithm
-
 def parse(source, policy=u""):
     fname = None
     if isinstance(source, basestring):
@@ -69,16 +71,22 @@ def parse(source, policy=u""):
     except Exception, e:
         # Re-package the exception as a parse error that will get rendered with
         # the filename and line number of the element that caused the problem.
-        # Keep the original traceback so the developer can debug where the problem
-        # happened.
-        raise SupermodelParseError(e, fname, parseinfo.stack[-1]), None, sys.exc_info()[2]
+        # Keep the original traceback so the developer can debug where the
+        # problem happened.
+        raise SupermodelParseError(
+            e,
+            fname,
+            parseinfo.stack[-1]
+        ), None, sys.exc_info()[2]
 
 
 def _parse(source, policy):
     tree = etree.parse(source)
     root = tree.getroot()
 
-    parseinfo.i18n_domain = root.attrib.get(ns('domain', prefix=I18N_NAMESPACE))
+    parseinfo.i18n_domain = root.attrib.get(
+        ns('domain', prefix=I18N_NAMESPACE)
+    )
 
     model = Model()
 
@@ -95,13 +103,22 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):
         fieldType = fieldElement.get('type')
 
         if fieldName is None or fieldType is None:
-            raise ValueError("The attributes 'name' and 'type' are required for each <field /> element")
+            raise ValueError(
+                'The attributes \'name\' and \'type\' are required for each '
+                '<field /> element'
+            )
 
         handler = handlers.get(fieldType, None)
         if handler is None:
-            handler = handlers[fieldType] = queryUtility(IFieldExportImportHandler, name=fieldType)
+            handler = handlers[fieldType] = queryUtility(
+                IFieldExportImportHandler,
+                name=fieldType
+            )
             if handler is None:
-                raise ValueError("Field type %s specified for field %s is not supported" % (fieldType, fieldName, ))
+                raise ValueError(
+                    'Field type {0} specified for field {1} is not '
+                    'supported'.format(fieldType, fieldName)
+                )
 
         field = handler.read(fieldElement)
 
@@ -138,7 +155,12 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):
         # Read global fields
         for fieldElement in schema_element.findall(ns('field')):
             parseinfo.stack.append(fieldElement)
-            readField(fieldElement, schemaAttributes, fieldElements, baseFields)
+            readField(
+                fieldElement,
+                schemaAttributes,
+                fieldElements,
+                baseFields
+            )
             parseinfo.stack.pop()
 
         # Read invariants, fieldsets and their fields
@@ -150,26 +172,48 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):
             parseinfo.stack.append(subelement)
 
             if subelement.tag == ns('field'):
-                readField(subelement, schemaAttributes, fieldElements, baseFields)
+                readField(
+                    subelement,
+                    schemaAttributes,
+                    fieldElements,
+                    baseFields
+                )
             elif subelement.tag == ns('fieldset'):
 
                 fieldset_name = subelement.get('name')
                 if fieldset_name is None:
-                    raise ValueError(u"Fieldset in schema %s has no name" % (schemaName))
+                    raise ValueError(
+                        u'Fieldset in schema {0} has no name'.format(
+                            schemaName
+                        )
+                    )
 
                 fieldset = fieldsets_by_name.get(fieldset_name, None)
                 if fieldset is None:
                     fieldset_label = subelement.get('label')
                     fieldset_description = subelement.get('description')
-
-                    fieldset = fieldsets_by_name[fieldset_name] = Fieldset(fieldset_name,
-                                    label=fieldset_label, description=fieldset_description)
+                    fieldset_order = subelement.get('order')
+                    if fieldset_order is None:
+                        fieldset_order = DEFAULT_ORDER
+                    elif isinstance(fieldset_order, basestring):
+                        fieldset_order = int(fieldset_order)
+                    fieldset = fieldsets_by_name[fieldset_name] = Fieldset(
+                        fieldset_name,
+                        label=fieldset_label,
+                        description=fieldset_description,
+                        order=fieldset_order,
+                    )
                     fieldsets_by_name[fieldset_name] = fieldset
                     fieldsets.append(fieldset)
 
                 for fieldElement in subelement.findall(ns('field')):
                     parseinfo.stack.append(fieldElement)
-                    parsed_fieldName = readField(fieldElement, schemaAttributes, fieldElements, baseFields)
+                    parsed_fieldName = readField(
+                        fieldElement,
+                        schemaAttributes,
+                        fieldElements,
+                        baseFields
+                    )
                     if parsed_fieldName:
                         fieldset.fields.append(parsed_fieldName)
                     parseinfo.stack.pop()
@@ -178,15 +222,18 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):
                 invariant = resolve(dotted)
                 if not IInvariant.providedBy(invariant):
                     raise ImportError(
-                        u"Invariant functions must provide plone.supermodel.interfaces.IInvariant"
+                        u'Invariant functions must provide '
+                        u'plone.supermodel.interfaces.IInvariant'
                     )
                 invariants.append(invariant)
             parseinfo.stack.pop()
 
-        schema = SchemaClass(name=policy_util.name(schemaName, tree),
-                                bases=bases + policy_util.bases(schemaName, tree) + (Schema,),
-                                __module__=policy_util.module(schemaName, tree),
-                                attrs=schemaAttributes)
+        schema = SchemaClass(
+            name=policy_util.name(schemaName, tree),
+            bases=bases + policy_util.bases(schemaName, tree) + (Schema,),
+            __module__=policy_util.module(schemaName, tree),
+            attrs=schemaAttributes
+        )
 
         # add invariants to schema as tagged values
         if invariants:
@@ -200,7 +247,11 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):
         for handler_name, metadata_handler in field_metadata_handlers:
             for fieldName in schema:
                 if fieldName in fieldElements:
-                    metadata_handler.read(fieldElements[fieldName], schema, schema[fieldName])
+                    metadata_handler.read(
+                        fieldElements[fieldName],
+                        schema,
+                        schema[fieldName]
+                    )
 
         for handler_name, metadata_handler in schema_metadata_handlers:
             metadata_handler.read(schema_element, schema)
diff --git a/plone/supermodel/schema.rst b/plone/supermodel/schema.rst
new file mode 100644
index 0000000..177922d
--- /dev/null
+++ b/plone/supermodel/schema.rst
@@ -0,0 +1,687 @@
+==================================================
+plone.supermodel: content schemata loaded from XML
+==================================================
+
+This package allows content schemata to be read and written as XML. It has a
+standard importer and serialiser for interfaces that contain zope.schema
+fields. The format is general enough to be able to handle future fields
+easily, so long as they are properly specified through interfaces.
+
+Parsing and serializing simple schemata
+---------------------------------------
+
+Before we can begin, we must register the field handlers that know how to
+import and export fields from/to XML. These are registered as named utilities,
+and can be loaded from the configure.zcml file of plone.supermodel.
+
+    >>> configuration = """\
+    ... <configure
+    ...      xmlns="http://namespaces.zope.org/zope"
+    ...      i18n_domain="plone.supermodel.tests">
+    ...
+    ...     <include package="zope.component" file="meta.zcml" />
+    ...
+    ...     <include package="plone.supermodel" />
+    ...
+    ... </configure>
+    ... """
+
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+Next, let's define a sample model with a single, unnamed schema.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title>Title</title>
+    ...             <required>True</required>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="description">
+    ...             <!-- we can also put comments in here -->
+    ...             <title>Description</title>
+    ...             <description>A short summary</description>
+    ...             <required>False</required>
+    ...             <min_length>10</min_length>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+We can parse this model using the loadString() function:
+
+    >>> from plone.supermodel import loadString
+    >>> model = loadString(schema)
+
+This will load one schema, with the default name u"":
+
+    >>> model.schemata.keys()
+    [u'']
+
+We can inspect this schema and see that it contains zope.schema fields with
+attributes corresponding to the values set in XML.
+
+    >>> schema = model.schema # shortcut to model.schemata[u""]
+
+    >>> from zope.schema import getFieldNamesInOrder
+    >>> getFieldNamesInOrder(schema)
+    ['title', 'description']
+
+    >>> schema['title'].title
+    u'Title'
+    >>> schema['title'].required
+    True
+
+    >>> schema['description'].title
+    u'Description'
+    >>> schema['description'].description
+    u'A short summary'
+    >>> schema['description'].required
+    False
+    >>> schema['description'].min_length
+    10
+
+If we try to parse a schema that has errors, we'll get a useful
+SupermodelParseError that includes contextual information. (This requires
+lxml.)
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <field type="aint_gonna_exist" name="title">
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+    >>> loadString(schema)
+    Traceback (most recent call last):
+    ...
+    SupermodelParseError: Field type aint_gonna_exist specified for field title is not supported
+      File "<unknown>", line ...
+
+In addition to parsing, we can serialize a model to an XML representation:
+
+    >>> from plone.supermodel import serializeModel
+    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema>
+        <field name="title" type="zope.schema.TextLine">
+          <title>Title</title>
+        </field>
+        <field name="description" type="zope.schema.Text">
+          <description>A short summary</description>
+          <min_length>10</min_length>
+          <required>False</required>
+          <title>Description</title>
+        </field>
+      </schema>
+    </model>
+
+Building interfaces from schemata
+---------------------------------
+
+Above, we saw how to parse a schema from a file directly. Next, let's see how
+this can be used more practically to define a custom interface. Here, we will
+use two schemata in one file.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title>Title</title>
+    ...             <required>True</required>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="body">
+    ...             <title>Body text</title>
+    ...             <required>True</required>
+    ...             <max_length>10000</max_length>
+    ...         </field>
+    ...     </schema>
+    ...
+    ...     <schema name="metadata">
+    ...         <field type="zope.schema.Datetime" name="created">
+    ...             <title>Created date</title>
+    ...             <required>False</required>
+    ...         </field>
+    ...         <field type="zope.schema.TextLine" name="creator">
+    ...             <title>Creator</title>
+    ...             <description>Name of the creator</description>
+    ...             <required>True</required>
+    ...         </field>
+    ...     </schema>
+    ...
+    ... </model>
+    ... """
+
+Ordinarily, this would be in a file in the same directory as the module
+containing the interface being defined. Here, we need to create a temporary
+directory.
+
+    >>> import tempfile, os.path, shutil
+    >>> tmpdir = tempfile.mkdtemp()
+    >>> schema_filename = os.path.join(tmpdir, "schema.xml")
+    >>> schema_file = open(schema_filename, "w")
+    >>> schema_file.write(schema)
+    >>> schema_file.close()
+
+We can define interfaces from this using a helper function:
+
+    >>> from plone.supermodel import xmlSchema
+    >>> ITestContent = xmlSchema(schema_filename)
+
+Note: If the schema filename is not an absolute path, it will be found
+relative to the module where the interface is defined.
+
+After being loaded, the interface should have the fields of the default
+(unnamed) schema:
+
+    >>> getFieldNamesInOrder(ITestContent)
+    ['title', 'body']
+
+We can also use a different, named schema:
+
+    >>> ITestMetadata = xmlSchema(schema_filename, schema=u"metadata")
+    >>> getFieldNamesInOrder(ITestMetadata)
+    ['created', 'creator']
+
+Of course, a schema can also be written to XML. Either, you can build a model
+dict as per the serializeModel() method seen above, or you can write a model
+of just a single schema using serializeSchema():
+
+    >>> from plone.supermodel import serializeSchema
+    >>> print serializeSchema(ITestContent) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema>
+        <field name="title" type="zope.schema.TextLine">
+          <title>Title</title>
+        </field>
+        <field name="body" type="zope.schema.Text">
+          <max_length>10000</max_length>
+          <title>Body text</title>
+        </field>
+      </schema>
+    </model>
+
+    >>> print serializeSchema(ITestMetadata, name=u"metadata") # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema name="metadata">
+        <field name="created" type="zope.schema.Datetime">
+          <required>False</required>
+          <title>Created date</title>
+        </field>
+        <field name="creator" type="zope.schema.TextLine">
+          <description>Name of the creator</description>
+          <title>Creator</title>
+        </field>
+      </schema>
+    </model>
+
+Finally, let's clean up the temporary directory.
+
+    >>> shutil.rmtree(tmpdir)
+
+Base interface support
+----------------------
+
+When building a schema interface from XML, it is possible to specify a base
+interface. This is analogous to "subclassing" an existing interface. The XML
+schema representation can override and/or extend fields from the base.
+
+For the purposes of this test, we have defined a dummy interface in
+plone.supermodel.tests. We can't define it in the doctest, because the import
+resolver needs to have a proper module path. The interface looks like this
+though:
+
+    class IBase(Interface):
+        title = zope.schema.TextLine(title=u"Title")
+        description = zope.schema.TextLine(title=u"Description")
+        name = zope.schema.TextLine(title=u"Name")
+
+In real life, you'd more likely have a dotted name like
+my.package.interfaces.IBase, of course.
+
+Then, let's define a schema that is based on this interface.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema based-on="plone.supermodel.tests.IBase">
+    ...         <field type="zope.schema.Text" name="description">
+    ...             <title>Description</title>
+    ...             <description>A short summary</description>
+    ...         </field>
+    ...         <field type="zope.schema.Int" name="age">
+    ...             <title>Age</title>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+Here, notice the use of the 'based-on' attribute, which specifies a dotted
+name to the base interface. It is possible to specify multiple interfaces
+as a space-separated list. However, if you find that you need this, you
+may want to ask yourself why. :) Inside the schema proper, we override the
+'description' field and add a new field, 'age'.
+
+When we load this model, we should find that the __bases__ list of the
+generated interface contains the base schema.
+
+    >>> model = loadString(schema)
+    >>> model.schema.__bases__
+    (<InterfaceClass plone.supermodel.tests.IBase>, <SchemaClass plone.supermodel.model.Schema>)
+
+The fields of the base interface will also be replicated in the new schema.
+
+    >>> getFieldNamesInOrder(model.schema)
+    ['title', 'description', 'name', 'age']
+
+Notice how the order of the 'description' field is dictated by where it
+appeared in the base interface, not where it appears in the XML schema.
+
+We should also verify that the description field was indeed overridden:
+
+    >>> model.schema['description'] # doctest: +ELLIPSIS
+    <zope.schema._bootstrapfields.Text object at ...>
+
+Finally, let's verify that bases are preserved upon serialisation:
+
+    >>> print serializeSchema(model.schema) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema based-on="plone.supermodel.tests.IBase">
+        <field name="description" type="zope.schema.Text">
+          <description>A short summary</description>
+          <title>Description</title>
+        </field>
+        <field name="age" type="zope.schema.Int">
+          <title>Age</title>
+        </field>
+      </schema>
+    </model>
+
+Fieldset support
+----------------
+
+It is often useful to be able to group form fields in the same schema into
+fieldsets, for example for form rendering. While plone.supermodel doesn't have
+anything to do with such rendering, it does support some markup to make it
+possible to define fieldsets. These are stored in a tagged value on the
+generated interface, which can then be used by other code.
+
+Fieldsets can be defined from and serialised to XML, using the <fieldset />
+tag to wrap a sequence of fields.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title>Title</title>
+    ...             <required>True</required>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="body">
+    ...             <title>Body text</title>
+    ...             <required>True</required>
+    ...             <max_length>10000</max_length>
+    ...         </field>
+    ...
+    ...         <fieldset name="dates" label="Dates" description="Standard dates" order="1">
+    ...             <field type="zope.schema.Date" name="publication_date">
+    ...                 <title>Publication date</title>
+    ...             </field>
+    ...         </fieldset>
+    ...
+    ...         <field type="zope.schema.TextLine" name="author">
+    ...             <title>Author</title>
+    ...         </field>
+    ...
+    ...         <fieldset name="dates" label="Ignored" description="Ignored">
+    ...             <field type="zope.schema.Date" name="expiry_date">
+    ...                 <title>Expiry date</title>
+    ...             </field>
+    ...             <field type="zope.schema.Date" name="notification_date">
+    ...                 <title>Notification date</title>
+    ...             </field>
+    ...         </fieldset>
+    ...     </schema>
+    ...
+    ...     <schema name="metadata">
+    ...
+    ...         <fieldset name="standard" label="Standard" />
+    ...         <fieldset name="dates" label="Metadata dates" />
+    ...         <fieldset name="author" label="Author info" />
+    ...
+    ...         <fieldset name="dates">
+    ...             <field type="zope.schema.Datetime" name="created">
+    ...                 <title>Created date</title>
+    ...                 <required>False</required>
+    ...             </field>
+    ...         </fieldset>
+    ...
+    ...         <fieldset name="standard">
+    ...             <field type="zope.schema.TextLine" name="creator">
+    ...                 <title>Creator</title>
+    ...                 <description>Name of the creator</description>
+    ...                 <required>True</required>
+    ...             </field>
+    ...         </fieldset>
+    ...     </schema>
+    ...
+    ... </model>
+    ... """
+
+Fields outside any <fieldset /> tag are not placed in any fieldset. An
+empty <fieldset /> will be recorded as one having no fields. This is sometimes
+useful to control the order of fieldsets, if those are to be filled later.
+
+If there are two <fieldset /> blocks with the same name, fields from the second
+will be appended to the first, and the label and description will be kept
+from the first one, as appropriate.
+
+Note that fieldsets are specific to each schema, i.e. the fieldset in the
+default schema above is unrelated to the one in the metadata schema.
+
+    >>> model = loadString(schema)
+    >>> getFieldNamesInOrder(model.schema)
+    ['title', 'body', 'publication_date', 'author', 'expiry_date', 'notification_date']
+
+    >>> getFieldNamesInOrder(model.schemata['metadata'])
+    ['created', 'creator']
+
+    >>> from plone.supermodel.interfaces import FIELDSETS_KEY
+    >>> model.schema.getTaggedValue(FIELDSETS_KEY)
+    [<Fieldset 'dates' order 1 of publication_date, expiry_date, notification_date>]
+
+    >>> model.schemata[u"metadata"].getTaggedValue(FIELDSETS_KEY)
+    [<Fieldset 'standard' order 9999 of creator>, <Fieldset 'dates' order 9999 of created>, <Fieldset 'author' order 9999 of >]
+
+When we serialise a schema with fieldsets, fields will be grouped by
+fieldset.
+
+    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema>
+        <field name="title" type="zope.schema.TextLine">
+          <title>Title</title>
+        </field>
+        <field name="body" type="zope.schema.Text">
+          <max_length>10000</max_length>
+          <title>Body text</title>
+        </field>
+        <field name="author" type="zope.schema.TextLine">
+          <title>Author</title>
+        </field>
+        <fieldset name="dates" label="Dates" description="Standard dates">
+          <field name="publication_date" type="zope.schema.Date">
+            <title>Publication date</title>
+          </field>
+          <field name="expiry_date" type="zope.schema.Date">
+            <title>Expiry date</title>
+          </field>
+          <field name="notification_date" type="zope.schema.Date">
+            <title>Notification date</title>
+          </field>
+        </fieldset>
+      </schema>
+      <schema name="metadata">
+        <fieldset name="standard" label="Standard">
+          <field name="creator" type="zope.schema.TextLine">
+            <description>Name of the creator</description>
+            <title>Creator</title>
+          </field>
+        </fieldset>
+        <fieldset name="dates" label="Metadata dates">
+          <field name="created" type="zope.schema.Datetime">
+            <required>False</required>
+            <title>Created date</title>
+          </field>
+        </fieldset>
+        <fieldset name="author" label="Author info"/>
+      </schema>
+    </model>
+
+Invariant Support
+-----------------
+
+We may specify one or more invariants for the form via the "invariant" tag with
+a dotted name for the invariant function.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <invariant>plone.supermodel.tests.dummy_invariant</invariant>
+    ...         <invariant>plone.supermodel.tests.dummy_invariant_prime</invariant>
+    ...         <field type="zope.schema.Text" name="description">
+    ...             <title>Description</title>
+    ...             <description>A short summary</description>
+    ...         </field>
+    ...         <field type="zope.schema.Int" name="age">
+    ...             <title>Age</title>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+    >>> model = loadString(schema)
+    >>> model.schema.getTaggedValue('invariants')
+    [<function dummy_invariant at ...>, <function dummy_invariant_prime at ...>]
+
+When invariants are checked for our model.schema, we'll see our invariant
+in action.
+
+    >>> model.schema.validateInvariants(object())
+    Traceback (most recent call last):
+    ...
+    Invalid: Yikes! Invalid
+
+The model's serialization should include the invariant.
+
+    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema>
+        <invariant>plone.supermodel.tests.dummy_invariant</invariant>
+        <invariant>plone.supermodel.tests.dummy_invariant_prime</invariant>
+        <field name="description" type="zope.schema.Text">
+          <description>A short summary</description>
+          <title>Description</title>
+        </field>
+        <field name="age" type="zope.schema.Int">
+          <title>Age</title>
+        </field>
+      </schema>
+    </model>
+
+Invariant functions must provide plone.supermodel.interfaces.IInvariant
+or we won't accept them.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <invariant>plone.supermodel.tests.dummy_unmarkedInvariant</invariant>
+    ...         <field type="zope.schema.Text" name="description">
+    ...             <title>Description</title>
+    ...             <description>A short summary</description>
+    ...         </field>
+    ...         <field type="zope.schema.Int" name="age">
+    ...             <title>Age</title>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+    >>> model = loadString(schema)
+    Traceback (most recent call last):
+    ...
+    SupermodelParseError: Invariant functions must provide plone.supermodel.interfaces.IInvariant
+      File "<unknown>", line ...
+
+
+Internationalization
+--------------------
+
+Translation domains and message ids can be specified for text
+that is interpreted as unicode. This will result in deserialization
+as a zope.i18nmessageid message id rather than a basic Unicode string::
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
+    ...        xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    ...        i18n:domain="plone.supermodel">
+    ...     <schema>
+    ...
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title i18n:translate="supermodel_test_title">Title</title>
+    ...         </field>
+    ...
+    ...         <field type="zope.schema.TextLine" name="description">
+    ...             <title i18n:translate="">description</title>
+    ...         </field>
+    ...
+    ...         <field type="zope.schema.TextLine" name="feature">
+    ...             <title i18n:translate="domain_test"
+    ...                    i18n:domain="other">feature</title>
+    ...         </field>
+    ...
+    ...     </schema>
+    ... </model>
+    ... """
+    >>> model = loadString(schema)
+    >>> msgid = model.schema['title'].title
+    >>> msgid
+    u'supermodel_test_title'
+    >>> type(msgid)
+    <type 'zope.i18nmessageid.message.Message'>
+    >>> msgid.default
+    u'Title'
+    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema" i18n:domain="plone.supermodel">
+      <schema>
+        <field name="title" type="zope.schema.TextLine">
+          <title i18n:translate="supermodel_test_title">Title</title>
+        </field>
+        <field name="description" type="zope.schema.TextLine">
+          <title i18n:translate="">description</title>
+        </field>
+        <field name="feature" type="zope.schema.TextLine">
+          <title i18n:domain="other" i18n:translate="domain_test">feature</title>
+        </field>
+      </schema>
+    </model>
+
+Creating custom metadata handlers
+---------------------------------
+
+The plone.supermodel format is extensible with custom utilities that can
+write to a "metadata" dictionary. Such utilities may for example read
+information captured in attributes in particular namespaces.
+
+Let's imagine we wanted to make it possible to override form layout on a
+per-schema level, and override widgets on a per-field level. For this, we
+may expect to be able to parse a format like this:
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
+    ...        xmlns:ui="http://namespaces.acme.com/ui">
+    ...     <schema ui:layout="horizontal">
+    ...         <field type="zope.schema.TextLine" name="title"
+    ...             ui:widget="largetype">
+    ...             <title>Title</title>
+    ...             <required>True</required>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="description">
+    ...             <title>Description</title>
+    ...             <description>A short summary</description>
+    ...             <required>False</required>
+    ...             <min_length>10</min_length>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+We can register schema and field metadata handlers as named utilities.
+Metadata handlers should be able to reciprocally read and write metadata.
+
+    >>> from zope.interface import implements
+    >>> from zope.component import provideUtility
+
+    >>> from plone.supermodel.interfaces import ISchemaMetadataHandler
+    >>> from plone.supermodel.utils import ns
+
+    >>> class FormLayoutMetadata(object):
+    ...     implements(ISchemaMetadataHandler)
+    ...
+    ...     namespace = "http://namespaces.acme.com/ui"
+    ...     prefix = "ui"
+    ...
+    ...     def read(self, schemaNode, schema):
+    ...         layout = schemaNode.get(ns('layout', self.namespace))
+    ...         if layout:
+    ...             schema.setTaggedValue(u'acme.layout', layout)
+    ...
+    ...     def write(self, schemaNode, schema):
+    ...         layout = schema.queryTaggedValue(u'acme.layout', None)
+    ...         if layout:
+    ...             schemaNode.set(ns('layout', self.namespace), layout)
+
+    >>> provideUtility(component=FormLayoutMetadata(), name='acme.ui.schema')
+
+    >>> from plone.supermodel.interfaces import IFieldMetadataHandler
+    >>> class FieldWidgetMetadata(object):
+    ...     implements(IFieldMetadataHandler)
+    ...
+    ...     namespace = "http://namespaces.acme.com/ui"
+    ...     prefix = "ui"
+    ...
+    ...     def read(self, fieldNode, schema, field):
+    ...         name = field.__name__
+    ...         widget = fieldNode.get(ns('widget', self.namespace))
+    ...         if widget:
+    ...             widgets = schema.queryTaggedValue(u'acme.widgets', {})
+    ...             widgets[name] = widget
+    ...             schema.setTaggedValue(u'acme.widgets', widgets)
+    ...
+    ...     def write(self, fieldNode, schema, field):
+    ...         name = field.__name__
+    ...         widget = schema.queryTaggedValue(u'acme.widgets', {}).get(name, {})
+    ...         if widget:
+    ...             fieldNode.set(ns('widget', self.namespace), widget)
+
+    >>> provideUtility(component=FieldWidgetMetadata(), name='acme.ui.fields')
+
+When this model is loaded, utilities above will be invoked for each schema
+and each field, respectively.
+
+    >>> model = loadString(schema)
+
+    >>> model.schema.getTaggedValue('acme.layout')
+    'horizontal'
+
+    >>> model.schema.getTaggedValue('acme.widgets')
+    {'title': 'largetype'}
+
+Of course, we can also serialize the schema back to XML. Here, the 'prefix'
+set in the utility (if any) will be used by default.
+
+    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:ui="http://namespaces.acme.com/ui" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema ui:layout="horizontal">
+        <field name="title" type="zope.schema.TextLine" ui:widget="largetype">
+          <title>Title</title>
+        </field>
+        <field name="description" type="zope.schema.Text">
+          <description>A short summary</description>
+          <min_length>10</min_length>
+          <required>False</required>
+          <title>Description</title>
+        </field>
+      </schema>
+    </model>
diff --git a/plone/supermodel/schema.txt b/plone/supermodel/schema.txt
deleted file mode 100644
index 4bcbc0f..0000000
--- a/plone/supermodel/schema.txt
+++ /dev/null
@@ -1,687 +0,0 @@
-==================================================
-plone.supermodel: content schemata loaded from XML
-==================================================
-
-This package allows content schemata to be read and written as XML. It has a
-standard importer and serialiser for interfaces that contain zope.schema
-fields. The format is general enough to be able to handle future fields
-easily, so long as they are properly specified through interfaces.
-
-Parsing and serializing simple schemata
----------------------------------------
-
-Before we can begin, we must register the field handlers that know how to
-import and export fields from/to XML. These are registered as named utilities,
-and can be loaded from the configure.zcml file of plone.supermodel.
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.supermodel.tests">
-    ...
-    ...     <include package="zope.component" file="meta.zcml" />
-    ...
-    ...     <include package="plone.supermodel" />
-    ...
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-Next, let's define a sample model with a single, unnamed schema.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title>Title</title>
-    ...             <required>True</required>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="description">
-    ...             <!-- we can also put comments in here -->
-    ...             <title>Description</title>
-    ...             <description>A short summary</description>
-    ...             <required>False</required>
-    ...             <min_length>10</min_length>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-We can parse this model using the loadString() function:
-
-    >>> from plone.supermodel import loadString
-    >>> model = loadString(schema)
-
-This will load one schema, with the default name u"":
-
-    >>> model.schemata.keys()
-    [u'']
-
-We can inspect this schema and see that it contains zope.schema fields with
-attributes corresponding to the values set in XML.
-
-    >>> schema = model.schema # shortcut to model.schemata[u""]
-
-    >>> from zope.schema import getFieldNamesInOrder
-    >>> getFieldNamesInOrder(schema)
-    ['title', 'description']
-
-    >>> schema['title'].title
-    u'Title'
-    >>> schema['title'].required
-    True
-
-    >>> schema['description'].title
-    u'Description'
-    >>> schema['description'].description
-    u'A short summary'
-    >>> schema['description'].required
-    False
-    >>> schema['description'].min_length
-    10
-
-If we try to parse a schema that has errors, we'll get a useful
-SupermodelParseError that includes contextual information. (This requires
-lxml.)
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <field type="aint_gonna_exist" name="title">
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-    >>> loadString(schema)
-    Traceback (most recent call last):
-    ...
-    SupermodelParseError: Field type aint_gonna_exist specified for field title is not supported
-      File "<unknown>", line ...
-
-In addition to parsing, we can serialize a model to an XML representation:
-
-    >>> from plone.supermodel import serializeModel
-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema>
-        <field name="title" type="zope.schema.TextLine">
-          <title>Title</title>
-        </field>
-        <field name="description" type="zope.schema.Text">
-          <description>A short summary</description>
-          <min_length>10</min_length>
-          <required>False</required>
-          <title>Description</title>
-        </field>
-      </schema>
-    </model>
-
-Building interfaces from schemata
----------------------------------
-
-Above, we saw how to parse a schema from a file directly. Next, let's see how
-this can be used more practically to define a custom interface. Here, we will
-use two schemata in one file.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title>Title</title>
-    ...             <required>True</required>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="body">
-    ...             <title>Body text</title>
-    ...             <required>True</required>
-    ...             <max_length>10000</max_length>
-    ...         </field>
-    ...     </schema>
-    ...
-    ...     <schema name="metadata">
-    ...         <field type="zope.schema.Datetime" name="created">
-    ...             <title>Created date</title>
-    ...             <required>False</required>
-    ...         </field>
-    ...         <field type="zope.schema.TextLine" name="creator">
-    ...             <title>Creator</title>
-    ...             <description>Name of the creator</description>
-    ...             <required>True</required>
-    ...         </field>
-    ...     </schema>
-    ...
-    ... </model>
-    ... """
-
-Ordinarily, this would be in a file in the same directory as the module
-containing the interface being defined. Here, we need to create a temporary
-directory.
-
-    >>> import tempfile, os.path, shutil
-    >>> tmpdir = tempfile.mkdtemp()
-    >>> schema_filename = os.path.join(tmpdir, "schema.xml")
-    >>> schema_file = open(schema_filename, "w")
-    >>> schema_file.write(schema)
-    >>> schema_file.close()
-
-We can define interfaces from this using a helper function:
-
-    >>> from plone.supermodel import xmlSchema
-    >>> ITestContent = xmlSchema(schema_filename)
-
-Note: If the schema filename is not an absolute path, it will be found
-relative to the module where the interface is defined.
-
-After being loaded, the interface should have the fields of the default
-(unnamed) schema:
-
-    >>> getFieldNamesInOrder(ITestContent)
-    ['title', 'body']
-
-We can also use a different, named schema:
-
-    >>> ITestMetadata = xmlSchema(schema_filename, schema=u"metadata")
-    >>> getFieldNamesInOrder(ITestMetadata)
-    ['created', 'creator']
-
-Of course, a schema can also be written to XML. Either, you can build a model
-dict as per the serializeModel() method seen above, or you can write a model
-of just a single schema using serializeSchema():
-
-    >>> from plone.supermodel import serializeSchema
-    >>> print serializeSchema(ITestContent) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema>
-        <field name="title" type="zope.schema.TextLine">
-          <title>Title</title>
-        </field>
-        <field name="body" type="zope.schema.Text">
-          <max_length>10000</max_length>
-          <title>Body text</title>
-        </field>
-      </schema>
-    </model>
-
-    >>> print serializeSchema(ITestMetadata, name=u"metadata") # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema name="metadata">
-        <field name="created" type="zope.schema.Datetime">
-          <required>False</required>
-          <title>Created date</title>
-        </field>
-        <field name="creator" type="zope.schema.TextLine">
-          <description>Name of the creator</description>
-          <title>Creator</title>
-        </field>
-      </schema>
-    </model>
-
-Finally, let's clean up the temporary directory.
-
-    >>> shutil.rmtree(tmpdir)
-
-Base interface support
-----------------------
-
-When building a schema interface from XML, it is possible to specify a base
-interface. This is analogous to "subclassing" an existing interface. The XML
-schema representation can override and/or extend fields from the base.
-
-For the purposes of this test, we have defined a dummy interface in
-plone.supermodel.tests. We can't define it in the doctest, because the import
-resolver needs to have a proper module path. The interface looks like this
-though:
-
-    class IBase(Interface):
-        title = zope.schema.TextLine(title=u"Title")
-        description = zope.schema.TextLine(title=u"Description")
-        name = zope.schema.TextLine(title=u"Name")
-
-In real life, you'd more likely have a dotted name like
-my.package.interfaces.IBase, of course.
-
-Then, let's define a schema that is based on this interface.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema based-on="plone.supermodel.tests.IBase">
-    ...         <field type="zope.schema.Text" name="description">
-    ...             <title>Description</title>
-    ...             <description>A short summary</description>
-    ...         </field>
-    ...         <field type="zope.schema.Int" name="age">
-    ...             <title>Age</title>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-Here, notice the use of the 'based-on' attribute, which specifies a dotted
-name to the base interface. It is possible to specify multiple interfaces
-as a space-separated list. However, if you find that you need this, you
-may want to ask yourself why. :) Inside the schema proper, we override the
-'description' field and add a new field, 'age'.
-
-When we load this model, we should find that the __bases__ list of the
-generated interface contains the base schema.
-
-    >>> model = loadString(schema)
-    >>> model.schema.__bases__
-    (<InterfaceClass plone.supermodel.tests.IBase>, <SchemaClass plone.supermodel.model.Schema>)
-
-The fields of the base interface will also be replicated in the new schema.
-
-    >>> getFieldNamesInOrder(model.schema)
-    ['title', 'description', 'name', 'age']
-
-Notice how the order of the 'description' field is dictated by where it
-appeared in the base interface, not where it appears in the XML schema.
-
-We should also verify that the description field was indeed overridden:
-
-    >>> model.schema['description'] # doctest: +ELLIPSIS
-    <zope.schema._bootstrapfields.Text object at ...>
-
-Finally, let's verify that bases are preserved upon serialisation:
-
-    >>> print serializeSchema(model.schema) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema based-on="plone.supermodel.tests.IBase">
-        <field name="description" type="zope.schema.Text">
-          <description>A short summary</description>
-          <title>Description</title>
-        </field>
-        <field name="age" type="zope.schema.Int">
-          <title>Age</title>
-        </field>
-      </schema>
-    </model>
-
-Fieldset support
-----------------
-
-It is often useful to be able to group form fields in the same schema into
-fieldsets, for example for form rendering. While plone.supermodel doesn't have
-anything to do with such rendering, it does support some markup to make it
-possible to define fieldsets. These are stored in a tagged value on the
-generated interface, which can then be used by other code.
-
-Fieldsets can be defined from and serialised to XML, using the <fieldset />
-tag to wrap a sequence of fields.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title>Title</title>
-    ...             <required>True</required>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="body">
-    ...             <title>Body text</title>
-    ...             <required>True</required>
-    ...             <max_length>10000</max_length>
-    ...         </field>
-    ...
-    ...         <fieldset name="dates" label="Dates" description="Standard dates">
-    ...             <field type="zope.schema.Date" name="publication_date">
-    ...                 <title>Publication date</title>
-    ...             </field>
-    ...         </fieldset>
-    ...
-    ...         <field type="zope.schema.TextLine" name="author">
-    ...             <title>Author</title>
-    ...         </field>
-    ...
-    ...         <fieldset name="dates" label="Ignored" description="Ignored">
-    ...             <field type="zope.schema.Date" name="expiry_date">
-    ...                 <title>Expiry date</title>
-    ...             </field>
-    ...             <field type="zope.schema.Date" name="notification_date">
-    ...                 <title>Notification date</title>
-    ...             </field>
-    ...         </fieldset>
-    ...     </schema>
-    ...
-    ...     <schema name="metadata">
-    ...
-    ...         <fieldset name="standard" label="Standard" />
-    ...         <fieldset name="dates" label="Metadata dates" />
-    ...         <fieldset name="author" label="Author info" />
-    ...
-    ...         <fieldset name="dates">
-    ...             <field type="zope.schema.Datetime" name="created">
-    ...                 <title>Created date</title>
-    ...                 <required>False</required>
-    ...             </field>
-    ...         </fieldset>
-    ...
-    ...         <fieldset name="standard">
-    ...             <field type="zope.schema.TextLine" name="creator">
-    ...                 <title>Creator</title>
-    ...                 <description>Name of the creator</description>
-    ...                 <required>True</required>
-    ...             </field>
-    ...         </fieldset>
-    ...     </schema>
-    ...
-    ... </model>
-    ... """
-
-Fields outside any <fieldset /> tag are not placed in any fieldset. An
-empty <fieldset /> will be recorded as one having no fields. This is sometimes
-useful to control the order of fieldsets, if those are to be filled later.
-
-If there are two <fieldset /> blocks with the same name, fields from the second
-will be appended to the first, and the label and description will be kept
-from the first one, as appropriate.
-
-Note that fieldsets are specific to each schema, i.e. the fieldset in the
-default schema above is unrelated to the one in the metadata schema.
-
-    >>> model = loadString(schema)
-    >>> getFieldNamesInOrder(model.schema)
-    ['title', 'body', 'publication_date', 'author', 'expiry_date', 'notification_date']
-
-    >>> getFieldNamesInOrder(model.schemata['metadata'])
-    ['created', 'creator']
-
-    >>> from plone.supermodel.interfaces import FIELDSETS_KEY
-    >>> model.schema.getTaggedValue(FIELDSETS_KEY)
-    [<Fieldset 'dates' of publication_date, expiry_date, notification_date>]
-
-    >>> model.schemata[u"metadata"].getTaggedValue(FIELDSETS_KEY)
-    [<Fieldset 'standard' of creator>, <Fieldset 'dates' of created>, <Fieldset 'author' of >]
-
-When we serialise a schema with fieldsets, fields will be grouped by
-fieldset.
-
-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema>
-        <field name="title" type="zope.schema.TextLine">
-          <title>Title</title>
-        </field>
-        <field name="body" type="zope.schema.Text">
-          <max_length>10000</max_length>
-          <title>Body text</title>
-        </field>
-        <field name="author" type="zope.schema.TextLine">
-          <title>Author</title>
-        </field>
-        <fieldset name="dates" label="Dates" description="Standard dates">
-          <field name="publication_date" type="zope.schema.Date">
-            <title>Publication date</title>
-          </field>
-          <field name="expiry_date" type="zope.schema.Date">
-            <title>Expiry date</title>
-          </field>
-          <field name="notification_date" type="zope.schema.Date">
-            <title>Notification date</title>
-          </field>
-        </fieldset>
-      </schema>
-      <schema name="metadata">
-        <fieldset name="standard" label="Standard">
-          <field name="creator" type="zope.schema.TextLine">
-            <description>Name of the creator</description>
-            <title>Creator</title>
-          </field>
-        </fieldset>
-        <fieldset name="dates" label="Metadata dates">
-          <field name="created" type="zope.schema.Datetime">
-            <required>False</required>
-            <title>Created date</title>
-          </field>
-        </fieldset>
-        <fieldset name="author" label="Author info"/>
-      </schema>
-    </model>
-
-Invariant Support
------------------
-
-We may specify one or more invariants for the form via the "invariant" tag with
-a dotted name for the invariant function.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <invariant>plone.supermodel.tests.dummy_invariant</invariant>
-    ...         <invariant>plone.supermodel.tests.dummy_invariant_prime</invariant>
-    ...         <field type="zope.schema.Text" name="description">
-    ...             <title>Description</title>
-    ...             <description>A short summary</description>
-    ...         </field>
-    ...         <field type="zope.schema.Int" name="age">
-    ...             <title>Age</title>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-    >>> model = loadString(schema)
-    >>> model.schema.getTaggedValue('invariants')
-    [<function dummy_invariant at ...>, <function dummy_invariant_prime at ...>]
-
-When invariants are checked for our model.schema, we'll see our invariant
-in action.
-
-    >>> model.schema.validateInvariants(object())
-    Traceback (most recent call last):
-    ...
-    Invalid: Yikes! Invalid
-
-The model's serialization should include the invariant.
-
-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema>
-        <invariant>plone.supermodel.tests.dummy_invariant</invariant>
-        <invariant>plone.supermodel.tests.dummy_invariant_prime</invariant>
-        <field name="description" type="zope.schema.Text">
-          <description>A short summary</description>
-          <title>Description</title>
-        </field>
-        <field name="age" type="zope.schema.Int">
-          <title>Age</title>
-        </field>
-      </schema>
-    </model>
-
-Invariant functions must provide plone.supermodel.interfaces.IInvariant
-or we won't accept them.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <invariant>plone.supermodel.tests.dummy_unmarkedInvariant</invariant>
-    ...         <field type="zope.schema.Text" name="description">
-    ...             <title>Description</title>
-    ...             <description>A short summary</description>
-    ...         </field>
-    ...         <field type="zope.schema.Int" name="age">
-    ...             <title>Age</title>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-    >>> model = loadString(schema)
-    Traceback (most recent call last):
-    ...
-    SupermodelParseError: Invariant functions must provide plone.supermodel.interfaces.IInvariant
-      File "<unknown>", line ...
-
-
-Internationalization
---------------------
-
-Translation domains and message ids can be specified for text
-that is interpreted as unicode. This will result in deserialization
-as a zope.i18nmessageid message id rather than a basic Unicode string::
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
-    ...        xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-    ...        i18n:domain="plone.supermodel">
-    ...     <schema>
-    ...
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title i18n:translate="supermodel_test_title">Title</title>
-    ...         </field>
-    ...
-    ...         <field type="zope.schema.TextLine" name="description">
-    ...             <title i18n:translate="">description</title>
-    ...         </field>
-    ...
-    ...         <field type="zope.schema.TextLine" name="feature">
-    ...             <title i18n:translate="domain_test"
-    ...                    i18n:domain="other">feature</title>
-    ...         </field>
-    ...
-    ...     </schema>
-    ... </model>
-    ... """
-    >>> model = loadString(schema)
-    >>> msgid = model.schema['title'].title
-    >>> msgid
-    u'supermodel_test_title'
-    >>> type(msgid)
-    <type 'zope.i18nmessageid.message.Message'>
-    >>> msgid.default
-    u'Title'
-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema" i18n:domain="plone.supermodel">
-      <schema>
-        <field name="title" type="zope.schema.TextLine">
-          <title i18n:translate="supermodel_test_title">Title</title>
-        </field>
-        <field name="description" type="zope.schema.TextLine">
-          <title i18n:translate="">description</title>
-        </field>
-        <field name="feature" type="zope.schema.TextLine">
-          <title i18n:domain="other" i18n:translate="domain_test">feature</title>
-        </field>
-      </schema>
-    </model>
-
-Creating custom metadata handlers
----------------------------------
-
-The plone.supermodel format is extensible with custom utilities that can
-write to a "metadata" dictionary. Such utilities may for example read
-information captured in attributes in particular namespaces.
-
-Let's imagine we wanted to make it possible to override form layout on a
-per-schema level, and override widgets on a per-field level. For this, we
-may expect to be able to parse a format like this:
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
-    ...        xmlns:ui="http://namespaces.acme.com/ui">
-    ...     <schema ui:layout="horizontal">
-    ...         <field type="zope.schema.TextLine" name="title"
-    ...             ui:widget="largetype">
-    ...             <title>Title</title>
-    ...             <required>True</required>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="description">
-    ...             <title>Description</title>
-    ...             <description>A short summary</description>
-    ...             <required>False</required>
-    ...             <min_length>10</min_length>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-We can register schema and field metadata handlers as named utilities.
-Metadata handlers should be able to reciprocally read and write metadata.
-
-    >>> from zope.interface import implements
-    >>> from zope.component import provideUtility
-
-    >>> from plone.supermodel.interfaces import ISchemaMetadataHandler
-    >>> from plone.supermodel.utils import ns
-
-    >>> class FormLayoutMetadata(object):
-    ...     implements(ISchemaMetadataHandler)
-    ...
-    ...     namespace = "http://namespaces.acme.com/ui"
-    ...     prefix = "ui"
-    ...
-    ...     def read(self, schemaNode, schema):
-    ...         layout = schemaNode.get(ns('layout', self.namespace))
-    ...         if layout:
-    ...             schema.setTaggedValue(u'acme.layout', layout)
-    ...
-    ...     def write(self, schemaNode, schema):
-    ...         layout = schema.queryTaggedValue(u'acme.layout', None)
-    ...         if layout:
-    ...             schemaNode.set(ns('layout', self.namespace), layout)
-
-    >>> provideUtility(component=FormLayoutMetadata(), name='acme.ui.schema')
-
-    >>> from plone.supermodel.interfaces import IFieldMetadataHandler
-    >>> class FieldWidgetMetadata(object):
-    ...     implements(IFieldMetadataHandler)
-    ...
-    ...     namespace = "http://namespaces.acme.com/ui"
-    ...     prefix = "ui"
-    ...
-    ...     def read(self, fieldNode, schema, field):
-    ...         name = field.__name__
-    ...         widget = fieldNode.get(ns('widget', self.namespace))
-    ...         if widget:
-    ...             widgets = schema.queryTaggedValue(u'acme.widgets', {})
-    ...             widgets[name] = widget
-    ...             schema.setTaggedValue(u'acme.widgets', widgets)
-    ...
-    ...     def write(self, fieldNode, schema, field):
-    ...         name = field.__name__
-    ...         widget = schema.queryTaggedValue(u'acme.widgets', {}).get(name, {})
-    ...         if widget:
-    ...             fieldNode.set(ns('widget', self.namespace), widget)
-
-    >>> provideUtility(component=FieldWidgetMetadata(), name='acme.ui.fields')
-
-When this model is loaded, utilities above will be invoked for each schema
-and each field, respectively.
-
-    >>> model = loadString(schema)
-
-    >>> model.schema.getTaggedValue('acme.layout')
-    'horizontal'
-
-    >>> model.schema.getTaggedValue('acme.widgets')
-    {'title': 'largetype'}
-
-Of course, we can also serialize the schema back to XML. Here, the 'prefix'
-set in the utility (if any) will be used by default.
-
-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:ui="http://namespaces.acme.com/ui" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema ui:layout="horizontal">
-        <field name="title" type="zope.schema.TextLine" ui:widget="largetype">
-          <title>Title</title>
-        </field>
-        <field name="description" type="zope.schema.Text">
-          <description>A short summary</description>
-          <min_length>10</min_length>
-          <required>False</required>
-          <title>Description</title>
-        </field>
-      </schema>
-    </model>
diff --git a/plone/supermodel/schemaclass.rst b/plone/supermodel/schemaclass.rst
new file mode 100644
index 0000000..a909c7e
--- /dev/null
+++ b/plone/supermodel/schemaclass.rst
@@ -0,0 +1,69 @@
+=============================
+plone.supermodel: SchemaClass
+=============================
+
+    >>> from plone.supermodel.model import Schema, SchemaClass
+    >>> from plone.supermodel import interfaces
+    >>> from zope.interface import Interface, implements
+    >>> from zope.component import adapts, provideAdapter
+
+Schema plugins are registered as named adapters. They may optionally contain
+an order attribute, which defaults to 0.
+
+    >>> class TestPlugin(object):
+    ...     adapts(interfaces.ISchema)
+    ...     implements(interfaces.ISchemaPlugin)
+    ...     order = 1
+    ...     def __init__(self, schema):
+    ...         self.schema = schema
+    ...     def __call__(self):
+    ...         print("%s: %r" % (self.__class__.__name__, self.schema))
+    ...
+    >>> provideAdapter(TestPlugin, name=u"plone.supermodel.tests.TestPlugin")
+
+Schema plugins are executed at schema declaration.
+
+    >>> class IA(Schema):
+    ...     pass
+    TestPlugin: <SchemaClass __builtin__.IA>
+
+Any class descending from Schema becomes an instance of SchemaClass and has any
+schema plugins called.
+
+Except, there is a known issue. Until
+https://bugs.launchpad.net/zope.interface/+bug/791218 is resolved, this
+inheritance only works if the *first* base class is an instance of SchemaClass.
+So below I've commented out the output that we hope for once that issue is
+resolved.
+
+    >>> class ISomeInterface(Interface):
+    ...     pass
+
+    >>> class IB(ISomeInterface, IA):
+    ...     pass
+
+#    TestPlugin: <SchemaClass __builtin__.IB>
+
+    >>> class IC(IB):
+    ...     pass
+
+#    TestPlugin: <SchemaClass __builtin__.IC>
+
+To support the registration of schema plugins in ZCML, plugins are
+additionally executed at zope.configuration time with a ZCML order of 1000. To
+simulate this we will define another adapter and call the configuration action
+directly.
+
+    >>> class TestPlugin2(TestPlugin):
+    ...     order = 0
+
+    >>> provideAdapter(TestPlugin2, name=u"plone.supermodel.tests.TestPlugin2")
+    >>> from plone.supermodel.model import finalizeSchemas
+    >>> finalizeSchemas(IA)
+    TestPlugin2: <SchemaClass __builtin__.IA>
+    TestPlugin: <SchemaClass __builtin__.IA>
+
+#    TestPlugin2: <SchemaClass __builtin__.IB>
+#    TestPlugin: <SchemaClass __builtin__.IB>
+#    TestPlugin2: <SchemaClass __builtin__.IC>
+#    TestPlugin: <SchemaClass __builtin__.IC>
diff --git a/plone/supermodel/schemaclass.txt b/plone/supermodel/schemaclass.txt
deleted file mode 100644
index a909c7e..0000000
--- a/plone/supermodel/schemaclass.txt
+++ /dev/null
@@ -1,69 +0,0 @@
-=============================
-plone.supermodel: SchemaClass
-=============================
-
-    >>> from plone.supermodel.model import Schema, SchemaClass
-    >>> from plone.supermodel import interfaces
-    >>> from zope.interface import Interface, implements
-    >>> from zope.component import adapts, provideAdapter
-
-Schema plugins are registered as named adapters. They may optionally contain
-an order attribute, which defaults to 0.
-
-    >>> class TestPlugin(object):
-    ...     adapts(interfaces.ISchema)
-    ...     implements(interfaces.ISchemaPlugin)
-    ...     order = 1
-    ...     def __init__(self, schema):
-    ...         self.schema = schema
-    ...     def __call__(self):
-    ...         print("%s: %r" % (self.__class__.__name__, self.schema))
-    ...
-    >>> provideAdapter(TestPlugin, name=u"plone.supermodel.tests.TestPlugin")
-
-Schema plugins are executed at schema declaration.
-
-    >>> class IA(Schema):
-    ...     pass
-    TestPlugin: <SchemaClass __builtin__.IA>
-
-Any class descending from Schema becomes an instance of SchemaClass and has any
-schema plugins called.
-
-Except, there is a known issue. Until
-https://bugs.launchpad.net/zope.interface/+bug/791218 is resolved, this
-inheritance only works if the *first* base class is an instance of SchemaClass.
-So below I've commented out the output that we hope for once that issue is
-resolved.
-
-    >>> class ISomeInterface(Interface):
-    ...     pass
-
-    >>> class IB(ISomeInterface, IA):
-    ...     pass
-
-#    TestPlugin: <SchemaClass __builtin__.IB>
-
-    >>> class IC(IB):
-    ...     pass
-
-#    TestPlugin: <SchemaClass __builtin__.IC>
-
-To support the registration of schema plugins in ZCML, plugins are
-additionally executed at zope.configuration time with a ZCML order of 1000. To
-simulate this we will define another adapter and call the configuration action
-directly.
-
-    >>> class TestPlugin2(TestPlugin):
-    ...     order = 0
-
-    >>> provideAdapter(TestPlugin2, name=u"plone.supermodel.tests.TestPlugin2")
-    >>> from plone.supermodel.model import finalizeSchemas
-    >>> finalizeSchemas(IA)
-    TestPlugin2: <SchemaClass __builtin__.IA>
-    TestPlugin: <SchemaClass __builtin__.IA>
-
-#    TestPlugin2: <SchemaClass __builtin__.IB>
-#    TestPlugin: <SchemaClass __builtin__.IB>
-#    TestPlugin2: <SchemaClass __builtin__.IC>
-#    TestPlugin: <SchemaClass __builtin__.IC>
diff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py
index e47c864..46c6a36 100644
--- a/plone/supermodel/tests.py
+++ b/plone/supermodel/tests.py
@@ -108,12 +108,12 @@ class TestUtils(unittest.TestCase):
     def test_syncSchema(self):
 
         class ISource(Interface):
-            one = schema.TextLine(title=u"A") # order: 0
-            two = schema.Int(title=u"B")      # order: 1
+            one = schema.TextLine(title=u"A")  # order: 0
+            two = schema.Int(title=u"B")       # order: 1
 
         class IDest(Interface):
-            one = schema.TextLine(title=u"C") # order: 0
-            three = schema.Int(title=u"D")    # order: 1
+            one = schema.TextLine(title=u"C")  # order: 0
+            three = schema.Int(title=u"D")     # order: 1
 
         ISource.setTaggedValue("tag1", "tag one")
         ISource.setTaggedValue("tag2", "tag two")
@@ -465,19 +465,20 @@ def test_choice_serialized(self):
         self.assertEquals(etree.tostring(el), expected)
 
     def test_choice_parsing(self):
-        _termvalues = lambda vocab: tuple((t.value, t.title) for t in vocab)
+        def _termvalues(vocab):
+            return tuple((t.value, t.title) for t in vocab)
         cases = (
             self._choice(),
             self._choice_with_empty(),
             self._choice_with_term_titles(),
-            )
+        )
         for field, expected in cases:
             el = etree.fromstring(expected)
             imported_field = self.handler.read(el)
             self.assertEquals(
                 _termvalues(imported_field.vocabulary),
                 _termvalues(field.vocabulary),
-                )
+            )
 
 
 def test_suite():
@@ -485,21 +486,25 @@ def test_suite():
         unittest.makeSuite(TestUtils),
         unittest.makeSuite(TestValueToElement),
         unittest.makeSuite(TestChoiceHandling),
-        doctest.DocFileSuite('schema.txt',
+        doctest.DocFileSuite(
+            'schema.rst',
             setUp=zope.component.testing.setUp,
             tearDown=zope.component.testing.tearDown,
             optionflags=doctest.ELLIPSIS),
-        doctest.DocFileSuite('fields.txt',
+        doctest.DocFileSuite(
+            'fields.rst',
             setUp=zope.component.testing.setUp,
             tearDown=zope.component.testing.tearDown,
             optionflags=doctest.ELLIPSIS),
-        doctest.DocFileSuite('schemaclass.txt',
+        doctest.DocFileSuite(
+            'schemaclass.rst',
             setUp=zope.component.testing.setUp,
             tearDown=zope.component.testing.tearDown),
-        doctest.DocFileSuite('directives.txt',
+        doctest.DocFileSuite(
+            'directives.rst',
             setUp=zope.component.testing.setUp,
             tearDown=zope.component.testing.tearDown),
-        ))
+    ))
 
 
 if __name__ == '__main__':


Repository: plone.supermodel


Branch: refs/heads/master
Date: 2016-05-07T10:43:18+02:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/14791cea207b4de5b6a1651080d86685ef689055

Merge pull request #15 from plone/jensens-orderable-fieldsets

enable orderable fieldsets

Files changed:
A plone/supermodel/directives.rst
A plone/supermodel/fields.rst
A plone/supermodel/schema.rst
A plone/supermodel/schemaclass.rst
M CHANGES.rst
M plone/supermodel/directives.py
M plone/supermodel/exportimport.py
M plone/supermodel/interfaces.py
M plone/supermodel/model.py
M plone/supermodel/parser.py
M plone/supermodel/tests.py
D plone/supermodel/directives.txt
D plone/supermodel/fields.txt
D plone/supermodel/schema.txt
D plone/supermodel/schemaclass.txt

diff --git a/CHANGES.rst b/CHANGES.rst
index 393362a..c3901b1 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,12 +1,13 @@
 Changelog
 =========
 
-1.2.8 (unreleased)
+1.3.0 (unreleased)
 ------------------
 
 New:
 
-- *add item here*
+- Support to define the order of fieldsets.
+  [jensens]
 
 Fixes:
 
diff --git a/plone/supermodel/directives.py b/plone/supermodel/directives.py
index 5d5e607..3591b46 100644
--- a/plone/supermodel/directives.py
+++ b/plone/supermodel/directives.py
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
 from plone.supermodel import loadFile
+from plone.supermodel.interfaces import DEFAULT_ORDER
 from plone.supermodel.interfaces import FIELDSETS_KEY
 from plone.supermodel.interfaces import FILENAME_KEY
 from plone.supermodel.interfaces import ISchema
@@ -12,11 +13,12 @@
 from zope.interface import alsoProvides
 from zope.interface import implementer
 from zope.interface.interface import TAGGED_DATA
+
 import os.path
 import sys
 
-# Directive
 
+# Directive
 
 class DirectiveClass(type):
     """A Directive is used to apply tagged values to a Schema
@@ -34,7 +36,11 @@ def __call__(self, *args, **kw):
         value = instance.factory(*args, **kw)
         instance.store(tags, value)
 
-Directive = DirectiveClass('Directive', (), dict(__module__='plone.supermodel.directives',),)
+Directive = DirectiveClass(
+    'Directive',
+    (),
+    dict(__module__='plone.supermodel.directives',),
+)
 
 
 class MetadataListDirective(Directive):
@@ -75,9 +81,13 @@ def check(self):
         for fieldName in self.fieldNames():
             if fieldName not in schema:
                 raise ValueError(
-                    u"The directive %s applied to interface %s "
-                    u"refers to unknown field name %s" % (self.key, schema.__identifier__, fieldName)
+                    u"The directive {0} applied to interface {1} "
+                    u"refers to unknown field name {2}".format(
+                        self.key,
+                        schema.__identifier__,
+                        fieldName
                     )
+                )
             yield fieldName
 
     def __call__(self):
@@ -166,8 +176,13 @@ def __call__(self):
         model = loadFile(filename)
         if schema not in model.schemata:
             raise ValueError(
-                    u"Schema '%s' specified for interface %s does not exist in %s." %
-                        (schema, interface.__identifier__, filename,))
+                u"Schema '{0}' specified for interface {1} does not exist "
+                "in {2}.".format(
+                    schema,
+                    interface.__identifier__,
+                    filename,
+                )
+            )
 
         syncSchema(model.schemata[schema], interface, overwrite=False)
 
@@ -177,8 +192,22 @@ class fieldset(MetadataListDirective):
     """
     key = FIELDSETS_KEY
 
-    def factory(self, name, label=None, description=None, fields=None, **kw):
-        fieldset = Fieldset(name, label=label, description=description, fields=fields)
+    def factory(
+        self,
+        name,
+        label=None,
+        description=None,
+        fields=None,
+        order=DEFAULT_ORDER,
+        **kw
+    ):
+        fieldset = Fieldset(
+            name,
+            label=label,
+            description=description,
+            fields=fields,
+            order=order,
+        )
         for (key, value) in kw.items():
             setattr(fieldset, key, value)
         return [fieldset]
@@ -208,7 +237,9 @@ class primary(MetadataListDirective):
 
         def factory(self, *args):
             if not args:
-                raise TypeError('The primary directive expects at least one argument.')
+                raise TypeError(
+                    'The primary directive expects at least one argument.'
+                )
             return args
 
     class PrimaryFieldsPlugin(ListCheckerPlugin):
diff --git a/plone/supermodel/directives.rst b/plone/supermodel/directives.rst
new file mode 100644
index 0000000..dc967a7
--- /dev/null
+++ b/plone/supermodel/directives.rst
@@ -0,0 +1,192 @@
+================================================
+Loading plone.supermodel schemata from XML files
+================================================
+
+plone.supermodel contains tools for reading and writing zope.schema-based
+interface definitions from/to XML.
+
+This package provides convenience base classes and directives for
+creating interfaces.
+
+Setup
+-----
+
+First, load this package's configuration:
+
+    >>> configuration = """\
+    ... <configure
+    ...      xmlns="http://namespaces.zope.org/zope"
+    ...      i18n_domain="plone.supermodel.tests">
+    ...
+    ...     <include package="zope.component" file="meta.zcml" />
+    ...
+    ...     <include package="plone.supermodel" />
+    ...
+    ... </configure>
+    ... """
+
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+We will also need a temporary directory for storing test schema files.
+
+    >>> import tempfile, os.path, shutil
+    >>> tmpdir = tempfile.mkdtemp()
+
+Building interfaces from schema files
+--------------------------------------
+
+Let us begin by writing a schema file. See plone.supermodel for more details
+on how this is structured.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title>Title</title>
+    ...             <required>True</required>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="body">
+    ...             <title>Body text</title>
+    ...             <required>True</required>
+    ...             <max_length>10000</max_length>
+    ...         </field>
+    ...     </schema>
+    ...
+    ...     <schema name="metadata">
+    ...         <field type="zope.schema.Datetime" name="created">
+    ...             <title>Created date</title>
+    ...             <required>False</required>
+    ...         </field>
+    ...         <field type="zope.schema.TextLine" name="creator">
+    ...             <title>Creator</title>
+    ...             <description>Name of the creator</description>
+    ...             <required>True</required>
+    ...         </field>
+    ...     </schema>
+    ...
+    ... </model>
+    ... """
+
+Ordinarily, this would be in a file in the same directory as the module
+containing the interface being defined. Here, we need to place it in the
+temporary directory created above.
+
+    >>> schema_filename = os.path.join(tmpdir, "schema.xml")
+    >>> schema_file = open(schema_filename, "w")
+    >>> schema_file.write(schema)
+    >>> schema_file.close()
+
+We can now define a schema, using the directives defined in this package:
+
+    >>> from plone.supermodel import model
+    >>> class ITestContent(model.Schema):
+    ...     model.load(schema_filename)
+
+Note: If the schema filename is not an absolute path, it will be found
+relative to the module where the interface is defined.
+
+The interface should have the fields of the default (unnamed) schema:
+
+    >>> from zope.schema import getFieldNamesInOrder
+    >>> getFieldNamesInOrder(ITestContent)
+    ['title', 'body']
+
+It also contains the filename that the schema was loaded from and the schema
+name as a tagged values in the base interface.
+
+    >>> from plone.supermodel.interfaces import FILENAME_KEY, SCHEMA_NAME_KEY
+    >>> ITestContent.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
+    '.../schema.xml'
+    >>> ITestContent.getTaggedValue(SCHEMA_NAME_KEY)
+    u''
+
+We can also use a different, named schema:
+
+    >>> class ITestMetadata(model.Schema):
+    ...     """Test metadata schema, built from XML
+    ...     """
+    ...     model.load(schema_filename, schema=u"metadata")
+
+    >>> getFieldNamesInOrder(ITestMetadata)
+    ['created', 'creator']
+
+Again, the interface has tagged values for the filename and schema name.
+
+    >>> ITestMetadata.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
+    '.../schema.xml'
+    >>> ITestMetadata.getTaggedValue(SCHEMA_NAME_KEY)
+    u'metadata'
+
+Adding and overriding fields
+----------------------------
+
+When loading a schema from XML, fields can still be added in code. If a
+field defined in code has the same name as one loaded from the file, the
+former will override the latter.
+
+    >>> import zope.schema
+    >>> class ITestContentWithNewFields(model.Schema):
+    ...     model.load(schema_filename)
+    ...
+    ...     title = zope.schema.TextLine(title=u"Title", default=u"Default title")
+    ...     postscript = zope.schema.Text(title=u"Postscript")
+
+    >>> getFieldNamesInOrder(ITestContentWithNewFields)
+    ['body', 'title', 'postscript']
+
+    >>> ITestContentWithNewFields[u'title'].default
+    u'Default title'
+
+Fieldset support
+----------------
+
+plone.supermodel can use a tagged value to store groupings of fields into
+fieldsets. The same tagged value can be populated using a directive:
+
+    >>> class IGrouped(model.Schema):
+    ...
+    ...     model.fieldset(u"default", label="Default", fields=['title', 'description'])
+    ...     model.fieldset(u"metadata", label="Metadata", fields=['publication_date'], layout='concise')
+    ...
+    ...     title = zope.schema.TextLine(title=u"Title")
+    ...     description = zope.schema.TextLine(title=u"Description")
+    ...
+    ...     publication_date = zope.schema.Date(title=u"Publication date")
+
+    >>> from plone.supermodel.interfaces import FIELDSETS_KEY
+    >>> IGrouped.getTaggedValue(FIELDSETS_KEY)
+    [<Fieldset 'default' order 9999 of title, description>, <Fieldset 'metadata' order 9999 of publication_date>]
+
+Extra parameters, such as the layout parameter for the metadata fieldset, are
+accessible as attributes on the fieldset:
+
+    >>> metadata = IGrouped.getTaggedValue(FIELDSETS_KEY)[1]
+    >>> metadata.layout
+    'concise'
+
+
+Primary field support
+---------------------
+
+In combination with plone.rfc822, primary fields may be marked:
+
+    >>> class IFields(model.Schema):
+    ...     title = zope.schema.TextLine(title=u"Title")
+    ...     description = zope.schema.TextLine(title=u"Description")
+    ...
+    ...     model.primary('body')
+    ...     body = zope.schema.Text(title=u"Body")
+
+    >>> from plone.rfc822.interfaces import IPrimaryField
+    >>> IPrimaryField.providedBy(IFields['body'])
+    True
+
+Cleanup
+-------
+
+Finally, let's clean up the temporary directory.
+
+    >>> shutil.rmtree(tmpdir)
diff --git a/plone/supermodel/directives.txt b/plone/supermodel/directives.txt
deleted file mode 100644
index babfc81..0000000
--- a/plone/supermodel/directives.txt
+++ /dev/null
@@ -1,192 +0,0 @@
-================================================
-Loading plone.supermodel schemata from XML files
-================================================
-
-plone.supermodel contains tools for reading and writing zope.schema-based
-interface definitions from/to XML.
-
-This package provides convenience base classes and directives for
-creating interfaces.
-
-Setup
------
-
-First, load this package's configuration:
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.supermodel.tests">
-    ...
-    ...     <include package="zope.component" file="meta.zcml" />
-    ...
-    ...     <include package="plone.supermodel" />
-    ...
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-We will also need a temporary directory for storing test schema files.
-
-    >>> import tempfile, os.path, shutil
-    >>> tmpdir = tempfile.mkdtemp()
-
-Building interfaces from schema files
---------------------------------------
-
-Let us begin by writing a schema file. See plone.supermodel for more details
-on how this is structured.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title>Title</title>
-    ...             <required>True</required>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="body">
-    ...             <title>Body text</title>
-    ...             <required>True</required>
-    ...             <max_length>10000</max_length>
-    ...         </field>
-    ...     </schema>
-    ...
-    ...     <schema name="metadata">
-    ...         <field type="zope.schema.Datetime" name="created">
-    ...             <title>Created date</title>
-    ...             <required>False</required>
-    ...         </field>
-    ...         <field type="zope.schema.TextLine" name="creator">
-    ...             <title>Creator</title>
-    ...             <description>Name of the creator</description>
-    ...             <required>True</required>
-    ...         </field>
-    ...     </schema>
-    ...
-    ... </model>
-    ... """
-
-Ordinarily, this would be in a file in the same directory as the module
-containing the interface being defined. Here, we need to place it in the
-temporary directory created above.
-
-    >>> schema_filename = os.path.join(tmpdir, "schema.xml")
-    >>> schema_file = open(schema_filename, "w")
-    >>> schema_file.write(schema)
-    >>> schema_file.close()
-
-We can now define a schema, using the directives defined in this package:
-
-    >>> from plone.supermodel import model
-    >>> class ITestContent(model.Schema):
-    ...     model.load(schema_filename)
-
-Note: If the schema filename is not an absolute path, it will be found
-relative to the module where the interface is defined.
-
-The interface should have the fields of the default (unnamed) schema:
-
-    >>> from zope.schema import getFieldNamesInOrder
-    >>> getFieldNamesInOrder(ITestContent)
-    ['title', 'body']
-
-It also contains the filename that the schema was loaded from and the schema
-name as a tagged values in the base interface.
-
-    >>> from plone.supermodel.interfaces import FILENAME_KEY, SCHEMA_NAME_KEY
-    >>> ITestContent.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
-    '.../schema.xml'
-    >>> ITestContent.getTaggedValue(SCHEMA_NAME_KEY)
-    u''
-
-We can also use a different, named schema:
-
-    >>> class ITestMetadata(model.Schema):
-    ...     """Test metadata schema, built from XML
-    ...     """
-    ...     model.load(schema_filename, schema=u"metadata")
-
-    >>> getFieldNamesInOrder(ITestMetadata)
-    ['created', 'creator']
-
-Again, the interface has tagged values for the filename and schema name.
-
-    >>> ITestMetadata.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
-    '.../schema.xml'
-    >>> ITestMetadata.getTaggedValue(SCHEMA_NAME_KEY)
-    u'metadata'
-
-Adding and overriding fields
-----------------------------
-
-When loading a schema from XML, fields can still be added in code. If a
-field defined in code has the same name as one loaded from the file, the
-former will override the latter.
-
-    >>> import zope.schema
-    >>> class ITestContentWithNewFields(model.Schema):
-    ...     model.load(schema_filename)
-    ...
-    ...     title = zope.schema.TextLine(title=u"Title", default=u"Default title")
-    ...     postscript = zope.schema.Text(title=u"Postscript")
-
-    >>> getFieldNamesInOrder(ITestContentWithNewFields)
-    ['body', 'title', 'postscript']
-
-    >>> ITestContentWithNewFields[u'title'].default
-    u'Default title'
-
-Fieldset support
-----------------
-
-plone.supermodel can use a tagged value to store groupings of fields into
-fieldsets. The same tagged value can be populated using a directive:
-
-    >>> class IGrouped(model.Schema):
-    ...
-    ...     model.fieldset(u"default", label="Default", fields=['title', 'description'])
-    ...     model.fieldset(u"metadata", label="Metadata", fields=['publication_date'], layout='concise')
-    ...
-    ...     title = zope.schema.TextLine(title=u"Title")
-    ...     description = zope.schema.TextLine(title=u"Description")
-    ...
-    ...     publication_date = zope.schema.Date(title=u"Publication date")
-
-    >>> from plone.supermodel.interfaces import FIELDSETS_KEY
-    >>> IGrouped.getTaggedValue(FIELDSETS_KEY)
-    [<Fieldset 'default' of title, description>, <Fieldset 'metadata' of publication_date>]
-
-Extra parameters, such as the layout parameter for the metadata fieldset, are
-accessible as attributes on the fieldset:
-
-    >>> metadata = IGrouped.getTaggedValue(FIELDSETS_KEY)[1]
-    >>> metadata.layout
-    'concise'
-
-
-Primary field support
----------------------
-
-In combination with plone.rfc822, primary fields may be marked:
-
-    >>> class IFields(model.Schema):
-    ...     title = zope.schema.TextLine(title=u"Title")
-    ...     description = zope.schema.TextLine(title=u"Description")
-    ...
-    ...     model.primary('body')
-    ...     body = zope.schema.Text(title=u"Body")
-
-    >>> from plone.rfc822.interfaces import IPrimaryField
-    >>> IPrimaryField.providedBy(IFields['body'])
-    True
-
-Cleanup
--------
-
-Finally, let's clean up the temporary directory.
-
-    >>> shutil.rmtree(tmpdir)
diff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py
index b7fcb43..2a13bb3 100644
--- a/plone/supermodel/exportimport.py
+++ b/plone/supermodel/exportimport.py
@@ -35,7 +35,8 @@ class BaseHandler(object):
     The read_field method is called to read one field of the known subtype
     from an XML element.
 
-    The write_field method is called to write one field to a particular element.
+    The write_field method is called to write one field to a particular
+    element.
     """
 
     # Elements that we will not read/write. 'r' means skip when reading;
@@ -306,38 +307,38 @@ class ChoiceHandler(BaseHandler):
     def __init__(self, klass):
         super(ChoiceHandler, self).__init__(klass)
 
-        # Special options for the constructor. These are not automatically written.
+        # Special options for the constructor. These are not automatically
+        # written.
 
-        self.fieldAttributes['vocabulary'] = \
-            zope.schema.TextLine(
-                __name__='vocabulary',
-                title=u"Named vocabulary"
-            )
+        self.fieldAttributes['vocabulary'] = zope.schema.TextLine(
+            __name__='vocabulary',
+            title=u"Named vocabulary"
+        )
 
-        self.fieldAttributes['values'] = \
-            zope.schema.List(
-                __name__='values',
-                title=u"Values",
-                value_type=zope.schema.Text(title=u"Value")
-            )
+        self.fieldAttributes['values'] = zope.schema.List(
+            __name__='values',
+            title=u"Values",
+            value_type=zope.schema.Text(title=u"Value")
+        )
 
         # XXX: We can't be more specific about the schema, since the field
         # supports both ISource and IContextSourceBinder. However, the
         # initialiser will validate.
-        self.fieldAttributes['source'] = \
-            zope.schema.Object(
-                __name__='source',
-                title=u"Source",
-                schema=Interface
-            )
+        self.fieldAttributes['source'] = zope.schema.Object(
+            __name__='source',
+            title=u"Source",
+            schema=Interface
+        )
 
     def readAttribute(self, element, attributeField):
-        if element.tag == 'values':
-            if any([child.get('key') for child in element]):
-                attributeField = OrderedDictField(
-                    key_type=zope.schema.TextLine(),
-                    value_type=zope.schema.TextLine(),
-                    )
+        if (
+            element.tag == 'values' and
+            any([child.get('key') for child in element])
+        ):
+            attributeField = OrderedDictField(
+                key_type=zope.schema.TextLine(),
+                value_type=zope.schema.TextLine(),
+            )
         return elementToValue(attributeField, element)
 
     def _constructField(self, attributes):
@@ -366,7 +367,12 @@ def _constructField(self, attributes):
 
     def write(self, field, name, type, elementName='field'):
 
-        element = super(ChoiceHandler, self).write(field, name, type, elementName)
+        element = super(ChoiceHandler, self).write(
+            field,
+            name,
+            type,
+            elementName
+        )
 
         # write vocabulary or values list
 
@@ -382,12 +388,16 @@ def write(self, field, name, type, elementName='field'):
             element.append(child)
 
         # Listed vocabulary - attempt to convert to a simple list of values
-        elif field.vocabularyName is None \
-             and IVocabularyTokenized.providedBy(field.vocabulary):
+        elif (
+            field.vocabularyName is None and
+            IVocabularyTokenized.providedBy(field.vocabulary)
+        ):
             value = []
             for term in field.vocabulary:
-                if (not isinstance(term.value, (str, unicode), )
-                    or term.token != term.value.encode('unicode_escape')):
+                if (
+                    not isinstance(term.value, (str, unicode), ) or
+                    term.token != term.value.encode('unicode_escape')
+                ):
                     raise NotImplementedError(
                         u"Cannot export a vocabulary that is not "
                         u"based on a simple list of values"
@@ -399,12 +409,13 @@ def write(self, field, name, type, elementName='field'):
 
             attributeField = self.fieldAttributes['values']
             if any(map(lambda v: isinstance(v, tuple), value)):
-                _pair = lambda v: v if len(v) == 2 else (v[0],) * 2
+                def _pair(v):
+                    return v if len(v) == 2 else (v[0],) * 2
                 value = OrderedDict(map(_pair, value))
                 attributeField = OrderedDictField(
                     key_type=zope.schema.TextLine(),
                     value_type=zope.schema.TextLine(),
-                    )
+                )
             child = valueToElement(
                 attributeField,
                 value,
diff --git a/plone/supermodel/fields.rst b/plone/supermodel/fields.rst
new file mode 100644
index 0000000..c4ba642
--- /dev/null
+++ b/plone/supermodel/fields.rst
@@ -0,0 +1,1551 @@
+================================
+plone.supermodel: field handlers
+================================
+
+This file tests the various field handlers. Please note the following known
+limitations:
+
+  * `Timedelta` fields are not supported.
+  * When an `Object` field is serialised, the `default` and `missing_value`
+    attributes are ignored.
+  * `Choice` fields can only be serialised if were created from a simple list
+    of values (the `values` constructor parameter) or use a named vocabulary.
+    It is possible to import a Choice field with a source that is either an
+    `ISource` or an `IContextSourceBinder`, but only if such instances can be
+    imported from a given dotted name. Finally, `Choice` fields imported with
+    a `values` list as a vocabulary or with the `default` or `missing_value`
+    set, are assumed store a unicode string.
+
+First, let's wire up the package.
+
+    >>> configuration = """\
+    ... <configure
+    ...      xmlns="http://namespaces.zope.org/zope"
+    ...      i18n_domain="plone.behavior.tests">
+    ...
+    ...     <include package="zope.component" file="meta.zcml" />
+    ...
+    ...     <include package="plone.supermodel" />
+    ...
+    ... </configure>
+    ... """
+
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+Then, let's test each field in turn.
+
+    >>> from zope.component import getUtility
+    >>> from zope import schema
+
+    >>> from plone.supermodel.interfaces import IFieldExportImportHandler
+    >>> from plone.supermodel.interfaces import IFieldNameExtractor
+    >>> from plone.supermodel.utils import prettyXML
+
+    >>> import datetime
+    >>> import plone.supermodel.tests
+
+    >>> from lxml import etree
+
+Bytes
+-----
+
+    >>> field = schema.Bytes(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='abc', missing_value='m',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Bytes">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Bytes'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'abc'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+BytesLine
+---------
+
+    >>> field = schema.BytesLine(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='abc', missing_value='m',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.BytesLine">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.BytesLine'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'abc'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+ASCII
+-----
+
+    >>> field = schema.ASCII(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='abc', missing_value='m',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.ASCII">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.ASCII'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'abc'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+ASCIILine
+---------
+
+    >>> field = schema.ASCIILine(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='abc', missing_value='m',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.ASCIILine">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.ASCIILine'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'abc'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+Text
+----
+
+    >>> field = schema.Text(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=u'abc', missing_value=u'm',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Text">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.Text'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'abc'
+    >>> reciprocal.missing_value
+    u'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+TextLine
+--------
+
+    >>> field = schema.TextLine(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=u'abc', missing_value=u'm',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.TextLine">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.TextLine'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'abc'
+    >>> reciprocal.missing_value
+    u'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+SourceText
+----------
+
+    >>> field = schema.SourceText(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=u'abc', missing_value=u'm',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.SourceText">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.SourceText'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'abc'
+    >>> reciprocal.missing_value
+    u'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+URI
+---
+
+    >>> field = schema.URI(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='http://plone.org', missing_value='m',
+    ...     min_length=2, max_length=100)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.URI">
+      <default>http://plone.org</default>
+      <description>Test desc</description>
+      <max_length>100</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.URI'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'http://plone.org'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    100
+
+Id
+--
+
+    >>> field = schema.Id(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='a.b.c', missing_value='m',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Id">
+      <default>a.b.c</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Id'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'a.b.c'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+DottedName
+-----------
+
+    >>> field = schema.DottedName(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='a.b.c', missing_value='m',
+    ...     min_length=2, max_length=10, min_dots=2, max_dots=4)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.DottedName">
+      <default>a.b.c</default>
+      <description>Test desc</description>
+      <max_dots>4</max_dots>
+      <max_length>10</max_length>
+      <min_dots>2</min_dots>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.DottedName'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    'a.b.c'
+    >>> reciprocal.missing_value
+    'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.min_dots
+    2
+    >>> reciprocal.max_dots
+    4
+
+Password
+--------
+
+    >>> field = schema.Password(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=u'abc', missing_value=u'm',
+    ...     min_length=2, max_length=10)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Password">
+      <default>abc</default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value>m</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.Password'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'abc'
+    >>> reciprocal.missing_value
+    u'm'
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+
+Bool
+----
+
+    >>> field = schema.Bool(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=False, missing_value=True)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Bool">
+      <default>False</default>
+      <description>Test desc</description>
+      <missing_value>True</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.Bool'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    False
+    >>> reciprocal.missing_value
+    True
+
+Int
+---
+
+    >>> field = schema.Int(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=12, missing_value=-1,
+    ...     min=1, max=99)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Int">
+      <default>12</default>
+      <description>Test desc</description>
+      <max>99</max>
+      <min>1</min>
+      <missing_value>-1</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    12
+    >>> reciprocal.missing_value
+    -1
+    >>> reciprocal.min
+    1
+    >>> reciprocal.max
+    99
+
+Float
+-----
+
+    >>> field = schema.Float(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=12.1, missing_value=-1.0,
+    ...     min=1.123, max=99.5)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Float">
+      <default>12.1</default>
+      <description>Test desc</description>
+      <max>99.5</max>
+      <min>1.123</min>
+      <missing_value>-1.0</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Float'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    12.1
+    >>> reciprocal.missing_value
+    -1.0
+    >>> reciprocal.min
+    1.123
+    >>> reciprocal.max
+    99.5
+
+Decimal
+-------
+
+    >>> import decimal
+    >>> field = schema.Decimal(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=decimal.Decimal("12.1"), missing_value=decimal.Decimal("-1.0"),
+    ...     min=decimal.Decimal("1.123"), max=decimal.Decimal("99.5"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Decimal">
+      <default>12.1</default>
+      <description>Test desc</description>
+      <max>99.5</max>
+      <min>1.123</min>
+      <missing_value>-1.0</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Decimal'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default == decimal.Decimal('12.1')
+    True
+    >>> reciprocal.missing_value == decimal.Decimal('-1.0')
+    True
+    >>> reciprocal.min == decimal.Decimal('1.123')
+    True
+    >>> reciprocal.max == decimal.Decimal('99.5')
+    True
+
+Date
+----
+
+    >>> field = schema.Date(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=datetime.date(2001,1,2), missing_value=datetime.date(2000,1,1),
+    ...     min=datetime.date(2000,10,12), max=datetime.date(2099,12,31))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Date">
+      <default>2001-01-02</default>
+      <description>Test desc</description>
+      <max>2099-12-31</max>
+      <min>2000-10-12</min>
+      <missing_value>2000-01-01</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Date'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    datetime.date(2001, 1, 2)
+    >>> reciprocal.missing_value
+    datetime.date(2000, 1, 1)
+    >>> reciprocal.min
+    datetime.date(2000, 10, 12)
+    >>> reciprocal.max
+    datetime.date(2099, 12, 31)
+
+Datetime
+---------
+
+    >>> field = schema.Datetime(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=datetime.datetime(2001,1,2,1,2,3), missing_value=datetime.datetime(2000,1,1,2,3,4),
+    ...     min=datetime.datetime(2000,10,12,0,0,2), max=datetime.datetime(2099,12,31,1,2,2))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Datetime">
+      <default>2001-01-02 01:02:03</default>
+      <description>Test desc</description>
+      <max>2099-12-31 01:02:02</max>
+      <min>2000-10-12 00:00:02</min>
+      <missing_value>2000-01-01 02:03:04</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Datetime'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    datetime.datetime(2001, 1, 2, 1, 2, 3, 1)
+    >>> reciprocal.missing_value
+    datetime.datetime(2000, 1, 1, 2, 3, 4, 5)
+    >>> reciprocal.min
+    datetime.datetime(2000, 10, 12, 0, 0, 2, 3)
+    >>> reciprocal.max
+    datetime.datetime(2099, 12, 31, 1, 2, 2, 3)
+
+InterfaceField
+---------------
+
+    >>> field = schema.InterfaceField(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=plone.supermodel.tests.IDummy,
+    ...     missing_value=plone.supermodel.tests.IDummy)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.InterfaceField">
+      <default>plone.supermodel.tests.IDummy</default>
+      <description>Test desc</description>
+      <missing_value>plone.supermodel.tests.IDummy</missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.InterfaceField'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    <InterfaceClass plone.supermodel.tests.IDummy>
+    >>> reciprocal.missing_value
+    <InterfaceClass plone.supermodel.tests.IDummy>
+
+Tuple
+-----
+
+    >>> field = schema.Tuple(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=(1,2), missing_value=(),
+    ...     min_length=2, max_length=10,
+    ...     value_type=schema.Int(title=u"Val"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Tuple">
+      <default>
+        <element>1</element>
+        <element>2</element>
+      </default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value/>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <value_type type="zope.schema.Int">
+        <title>Val</title>
+      </value_type>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Tuple'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    (1, 2)
+    >>> reciprocal.missing_value
+    ()
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.value_type.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.value_type.title
+    u'Val'
+
+List
+----
+
+    >>> field = schema.List(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=[1,2], missing_value=[],
+    ...     min_length=2, max_length=10,
+    ...     value_type=schema.Int(title=u"Val"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.List">
+      <default>
+        <element>1</element>
+        <element>2</element>
+      </default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value/>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <value_type type="zope.schema.Int">
+        <title>Val</title>
+      </value_type>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.List'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    [1, 2]
+    >>> reciprocal.missing_value
+    []
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.value_type.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.value_type.title
+    u'Val'
+
+Set
+---
+
+    >>> field = schema.Set(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=set((1,2)), missing_value=set(),
+    ...     min_length=2, max_length=10,
+    ...     value_type=schema.Int(title=u"Val"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Set">
+      <default>
+        <element>1</element>
+        <element>2</element>
+      </default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value/>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <value_type type="zope.schema.Int">
+        <title>Val</title>
+      </value_type>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Set'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    set([1, 2])
+    >>> reciprocal.missing_value
+    set([])
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.value_type.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.value_type.title
+    u'Val'
+
+FrozenSet
+---------
+
+    >>> field = schema.FrozenSet(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=frozenset((1,2)), missing_value=frozenset(),
+    ...     min_length=2, max_length=10,
+    ...     value_type=schema.Int(title=u"Val"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.FrozenSet">
+      <default>
+        <element>1</element>
+        <element>2</element>
+      </default>
+      <description>Test desc</description>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value/>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <value_type type="zope.schema.Int">
+        <title>Val</title>
+      </value_type>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.FrozenSet'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    frozenset([1, 2])
+    >>> reciprocal.missing_value
+    frozenset([])
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.value_type.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.value_type.title
+    u'Val'
+
+Dict
+----
+
+    >>> field = schema.Dict(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default={'a':1, 'b':2}, missing_value={},
+    ...     min_length=2, max_length=10,
+    ...     key_type=schema.ASCIILine(title=u"Key"),
+    ...     value_type=schema.Int(title=u"Val"))
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Dict">
+      <default>
+        <element key="a">1</element>
+        <element key="b">2</element>
+      </default>
+      <description>Test desc</description>
+      <key_type type="zope.schema.ASCIILine">
+        <title>Key</title>
+      </key_type>
+      <max_length>10</max_length>
+      <min_length>2</min_length>
+      <missing_value/>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <value_type type="zope.schema.Int">
+        <title>Val</title>
+      </value_type>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Dict'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    {'a': 1, 'b': 2}
+    >>> reciprocal.missing_value
+    {}
+    >>> reciprocal.min_length
+    2
+    >>> reciprocal.max_length
+    10
+    >>> reciprocal.key_type.__class__
+    <class 'zope.schema._field.ASCIILine'>
+    >>> reciprocal.key_type.title
+    u'Key'
+    >>> reciprocal.value_type.__class__
+    <class 'zope.schema._bootstrapfields.Int'>
+    >>> reciprocal.value_type.title
+    u'Val'
+
+Object
+------
+
+Note: when an object field is written, the 'default' and 'missing_value'
+fields will be omitted, as there is no way to write these reliably.
+
+    >>> dummy1 = plone.supermodel.tests.Dummy()
+    >>> dummy2 = plone.supermodel.tests.Dummy()
+
+    >>> field = schema.Object(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default=dummy1, missing_value=dummy2,
+    ...     schema=plone.supermodel.tests.IDummy)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType) #doctest: +ELLIPSIS
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Object">
+      <description>Test desc</description>
+      <readonly>True</readonly>
+      <required>False</required>
+      <schema>plone.supermodel.tests.IDummy</schema>
+      <title>Test</title>
+    </field>
+
+However, we support reading an object dotted name for an
+object field that references a particular dotted name.
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.Object">
+    ...   <default>plone.supermodel.tests.dummy1</default>
+    ...   <description>Test desc</description>
+    ...   <missing_value/>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <schema>plone.supermodel.tests.IDummy</schema>
+    ...   <title>Test</title>
+    ... </field>
+    ... """)
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Object'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default is plone.supermodel.tests.dummy1
+    True
+    >>> reciprocal.missing_value is None
+    True
+
+Choice
+------
+
+The choice field supports several different modes: a named vocabulary, a list
+of values, a source object, or a source context binder object. However,
+plone.supermodel only supports exporting named vocabularies or lists of
+unicode string values. In addition, it is possible to import (but not export)
+a source or context source binder, provided it can be imported from a
+dotted name.
+
+1. Named vocabularies
+
+These can be both exported and imported.
+
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='a', missing_value='', vocabulary=u'dummy.vocab')
+
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Choice">
+      <default>a</default>
+      <description>Test desc</description>
+      <missing_value></missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <vocabulary>dummy.vocab</vocabulary>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Choice'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default # note - value is always unicode
+    u'a'
+    >>> reciprocal.missing_value # note - value is always unicode
+    u''
+    >>> reciprocal.vocabulary is None
+    True
+    >>> reciprocal.vocabularyName
+    u'dummy.vocab'
+
+2. Values vocabularies
+
+These can be both imported and exported, but note that the value is always
+a unicode string when importing.
+
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='a', missing_value='', values=['a', 'b', 'c'])
+
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Choice">
+      <default>a</default>
+      <description>Test desc</description>
+      <missing_value></missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <values>
+        <element>a</element>
+        <element>b</element>
+        <element>c</element>
+      </values>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Choice'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'a'
+    >>> reciprocal.missing_value
+    u''
+    >>> [t.value for t in reciprocal.vocabulary]
+    [u'a', u'b', u'c']
+    >>> reciprocal.vocabularyName is None
+    True
+
+There was a bug when the XML namespace was specified explicitly; let's make
+sure it hasn't regressed.
+
+    >>> from plone.supermodel.interfaces import XML_NAMESPACE
+    >>> element.set('xmlns', XML_NAMESPACE)
+    >>> element = etree.parse(StringIO(prettyXML(element))).getroot()
+    >>> reciprocal = handler.read(element)
+    >>> [t.value for t in reciprocal.vocabulary]
+    [u'a', u'b', u'c']
+
+Also, make sure we can handle terms with unicode values (as long as their
+tokens are the utf8-encoded values).
+
+    >>> from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm
+    >>> vocab = SimpleVocabulary([
+    ...     SimpleTerm(token='a', value=u'a', title=u'a'),
+    ...     SimpleTerm(token=r'\xe7', value=u'\xe7', title=u'\xe7'), # c with cedilla
+    ...     ])
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     default='a', missing_value='', vocabulary=vocab)
+
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Choice">
+      <default>a</default>
+      <description>Test desc</description>
+      <missing_value></missing_value>
+      <readonly>True</readonly>
+      <required>False</required>
+      <title>Test</title>
+      <values>
+        <element>a</element>
+        <element>&#231;</element>
+      </values>
+    </field>
+
+    >>> reciprocal = handler.read(element)
+    >>> [t.value for t in reciprocal.vocabulary]
+    [u'a', u'\xe7']
+
+
+Additionally, it is possible for Choice fields with a values vocabulary
+whose terms contain values distinct from term titles for each
+respective term.  This is accomplished by using the 'key' attribute
+of each contained 'element' of the values element (this is consistent
+with how Dict fields are output, only for Choices, order is guaranteed).
+
+    >>> from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm
+    >>> vocab = SimpleVocabulary([
+    ...     SimpleTerm(value=u'a', title=u'A'),
+    ...     SimpleTerm(value=u'b', title=u'B'),
+    ...     ])
+    >>> field = schema.Choice(
+    ...     __name__="dummy",
+    ...     title=u"Test",
+    ...     vocabulary=vocab,
+    ...     )
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType)
+    >>> print prettyXML(element)
+    <field name="dummy" type="zope.schema.Choice">
+      <title>Test</title>
+      <values>
+        <element key="a">A</element>
+        <element key="b">B</element>
+      </values>
+    </field>
+
+3. Sources and source binders
+
+We cannot export choice fields with a source or context source binder:
+
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     vocabulary=plone.supermodel.tests.dummy_vocabulary_instance)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
+    Traceback (most recent call last):
+    ...
+    NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values
+
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     source=plone.supermodel.tests.dummy_vocabulary_instance)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
+    Traceback (most recent call last):
+    ...
+    NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values
+
+    >>> field = schema.Choice(__name__="dummy", title=u"Test",
+    ...     description=u"Test desc", required=False, readonly=True,
+    ...     source=plone.supermodel.tests.dummy_binder)
+    >>> fieldType = IFieldNameExtractor(field)()
+    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
+    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
+    Traceback (most recent call last):
+    ...
+    NotImplementedError: Choice fields with vocabularies not based on a simple list of values or a named vocabulary cannot be exported
+
+However, we can import a choice field with a source, provided that source can
+be specified via an importable dotted name.
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.Choice">
+    ...   <default>a</default>
+    ...   <description>Test desc</description>
+    ...   <missing_value/>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ...   <source>plone.supermodel.tests.dummy_binder</source>
+    ... </field>
+    ... """)
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Choice'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'a'
+    >>> reciprocal.vocabulary is plone.supermodel.tests.dummy_binder
+    True
+    >>> reciprocal.vocabularyName is None
+    True
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.Choice">
+    ...   <default>a</default>
+    ...   <description>Test desc</description>
+    ...   <missing_value/>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ...   <source>plone.supermodel.tests.dummy_vocabulary_instance</source>
+    ... </field>
+    ... """)
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._field.Choice'>
+    >>> reciprocal.__name__
+    'dummy'
+    >>> reciprocal.title
+    u'Test'
+    >>> reciprocal.description
+    u'Test desc'
+    >>> reciprocal.required
+    False
+    >>> reciprocal.readonly
+    True
+    >>> reciprocal.default
+    u'a'
+    >>> reciprocal.vocabulary is plone.supermodel.tests.dummy_vocabulary_instance
+    True
+    >>> reciprocal.vocabularyName is None
+    True
+
+defaultFactory usage
+--------------------
+
+Fields may specify defaultFactory attributes as dotted interfaces.
+defaultFactory callables should provide either
+zope.schema.interfaces.IContextAwareDefaultFactory or
+plone.supermodel.interfaces.IDefaultFactory.
+
+Note that zope.schema allows callables without any marker
+interface. Our requirements are an extra validation measure.
+
+Try specifying a defaultFactory attribute::
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.TextLine">
+    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultFactory</defaultFactory>
+    ...   <description>Test desc</description>
+    ...   <max_length>10</max_length>
+    ...   <min_length>2</min_length>
+    ...   <missing_value>m</missing_value>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ... </field>
+    ... """)
+
+Import it::
+    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
+
+Sanity checks::
+
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.__class__
+    <class 'zope.schema._bootstrapfields.TextLine'>
+
+And, look for the specified defaultFactory::
+    >>> reciprocal.defaultFactory == plone.supermodel.tests.dummy_defaultFactory
+    True
+
+Let's try it with a callable that provides IContextAwareDefaultFactory::
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.TextLine">
+    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultCAFactory</defaultFactory>
+    ...   <description>Test desc</description>
+    ...   <max_length>10</max_length>
+    ...   <min_length>2</min_length>
+    ...   <missing_value>m</missing_value>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ... </field>
+    ... """)
+
+    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
+    >>> reciprocal = handler.read(element)
+    >>> reciprocal.defaultFactory == plone.supermodel.tests.dummy_defaultCAFactory
+    True
+
+And, check to make sure that we can't use a callable that doesn't have one
+of our marker interfaces::
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.TextLine">
+    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultBadFactory</defaultFactory>
+    ...   <description>Test desc</description>
+    ...   <max_length>10</max_length>
+    ...   <min_length>2</min_length>
+    ...   <missing_value>m</missing_value>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ... </field>
+    ... """)
+
+    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
+    >>> reciprocal = handler.read(element)
+    Traceback (most recent call last):
+    ...
+    ImportError: defaultFactory must provide zope.schema.interfaces.IContextAwareDefaultFactory or plone.supermodel.IDefaultFactory
+
+A non-existent callable should also raise an error::
+
+    >>> element = etree.XML("""\
+    ... <field name="dummy" type="zope.schema.TextLine">
+    ...   <defaultFactory>plone.supermodel.tests.nonExistentFactory</defaultFactory>
+    ...   <description>Test desc</description>
+    ...   <max_length>10</max_length>
+    ...   <min_length>2</min_length>
+    ...   <missing_value>m</missing_value>
+    ...   <readonly>True</readonly>
+    ...   <required>False</required>
+    ...   <title>Test</title>
+    ... </field>
+    ... """)
+
+    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
+    >>> reciprocal = handler.read(element)
+    Traceback (most recent call last):
+    ...
+    ImportError: No module named nonExistentFactory
diff --git a/plone/supermodel/fields.txt b/plone/supermodel/fields.txt
deleted file mode 100644
index c4ba642..0000000
--- a/plone/supermodel/fields.txt
+++ /dev/null
@@ -1,1551 +0,0 @@
-================================
-plone.supermodel: field handlers
-================================
-
-This file tests the various field handlers. Please note the following known
-limitations:
-
-  * `Timedelta` fields are not supported.
-  * When an `Object` field is serialised, the `default` and `missing_value`
-    attributes are ignored.
-  * `Choice` fields can only be serialised if were created from a simple list
-    of values (the `values` constructor parameter) or use a named vocabulary.
-    It is possible to import a Choice field with a source that is either an
-    `ISource` or an `IContextSourceBinder`, but only if such instances can be
-    imported from a given dotted name. Finally, `Choice` fields imported with
-    a `values` list as a vocabulary or with the `default` or `missing_value`
-    set, are assumed store a unicode string.
-
-First, let's wire up the package.
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.behavior.tests">
-    ...
-    ...     <include package="zope.component" file="meta.zcml" />
-    ...
-    ...     <include package="plone.supermodel" />
-    ...
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-Then, let's test each field in turn.
-
-    >>> from zope.component import getUtility
-    >>> from zope import schema
-
-    >>> from plone.supermodel.interfaces import IFieldExportImportHandler
-    >>> from plone.supermodel.interfaces import IFieldNameExtractor
-    >>> from plone.supermodel.utils import prettyXML
-
-    >>> import datetime
-    >>> import plone.supermodel.tests
-
-    >>> from lxml import etree
-
-Bytes
------
-
-    >>> field = schema.Bytes(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='abc', missing_value='m',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Bytes">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Bytes'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'abc'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-BytesLine
----------
-
-    >>> field = schema.BytesLine(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='abc', missing_value='m',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.BytesLine">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.BytesLine'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'abc'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-ASCII
------
-
-    >>> field = schema.ASCII(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='abc', missing_value='m',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.ASCII">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.ASCII'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'abc'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-ASCIILine
----------
-
-    >>> field = schema.ASCIILine(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='abc', missing_value='m',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.ASCIILine">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.ASCIILine'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'abc'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-Text
-----
-
-    >>> field = schema.Text(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=u'abc', missing_value=u'm',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Text">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.Text'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'abc'
-    >>> reciprocal.missing_value
-    u'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-TextLine
---------
-
-    >>> field = schema.TextLine(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=u'abc', missing_value=u'm',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.TextLine">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.TextLine'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'abc'
-    >>> reciprocal.missing_value
-    u'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-SourceText
-----------
-
-    >>> field = schema.SourceText(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=u'abc', missing_value=u'm',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.SourceText">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.SourceText'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'abc'
-    >>> reciprocal.missing_value
-    u'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-URI
----
-
-    >>> field = schema.URI(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='http://plone.org', missing_value='m',
-    ...     min_length=2, max_length=100)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.URI">
-      <default>http://plone.org</default>
-      <description>Test desc</description>
-      <max_length>100</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.URI'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'http://plone.org'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    100
-
-Id
---
-
-    >>> field = schema.Id(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='a.b.c', missing_value='m',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Id">
-      <default>a.b.c</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Id'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'a.b.c'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-DottedName
------------
-
-    >>> field = schema.DottedName(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='a.b.c', missing_value='m',
-    ...     min_length=2, max_length=10, min_dots=2, max_dots=4)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.DottedName">
-      <default>a.b.c</default>
-      <description>Test desc</description>
-      <max_dots>4</max_dots>
-      <max_length>10</max_length>
-      <min_dots>2</min_dots>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.DottedName'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    'a.b.c'
-    >>> reciprocal.missing_value
-    'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.min_dots
-    2
-    >>> reciprocal.max_dots
-    4
-
-Password
---------
-
-    >>> field = schema.Password(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=u'abc', missing_value=u'm',
-    ...     min_length=2, max_length=10)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Password">
-      <default>abc</default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value>m</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.Password'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'abc'
-    >>> reciprocal.missing_value
-    u'm'
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-
-Bool
-----
-
-    >>> field = schema.Bool(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=False, missing_value=True)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Bool">
-      <default>False</default>
-      <description>Test desc</description>
-      <missing_value>True</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.Bool'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    False
-    >>> reciprocal.missing_value
-    True
-
-Int
----
-
-    >>> field = schema.Int(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=12, missing_value=-1,
-    ...     min=1, max=99)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Int">
-      <default>12</default>
-      <description>Test desc</description>
-      <max>99</max>
-      <min>1</min>
-      <missing_value>-1</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    12
-    >>> reciprocal.missing_value
-    -1
-    >>> reciprocal.min
-    1
-    >>> reciprocal.max
-    99
-
-Float
------
-
-    >>> field = schema.Float(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=12.1, missing_value=-1.0,
-    ...     min=1.123, max=99.5)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Float">
-      <default>12.1</default>
-      <description>Test desc</description>
-      <max>99.5</max>
-      <min>1.123</min>
-      <missing_value>-1.0</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Float'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    12.1
-    >>> reciprocal.missing_value
-    -1.0
-    >>> reciprocal.min
-    1.123
-    >>> reciprocal.max
-    99.5
-
-Decimal
--------
-
-    >>> import decimal
-    >>> field = schema.Decimal(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=decimal.Decimal("12.1"), missing_value=decimal.Decimal("-1.0"),
-    ...     min=decimal.Decimal("1.123"), max=decimal.Decimal("99.5"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Decimal">
-      <default>12.1</default>
-      <description>Test desc</description>
-      <max>99.5</max>
-      <min>1.123</min>
-      <missing_value>-1.0</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Decimal'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default == decimal.Decimal('12.1')
-    True
-    >>> reciprocal.missing_value == decimal.Decimal('-1.0')
-    True
-    >>> reciprocal.min == decimal.Decimal('1.123')
-    True
-    >>> reciprocal.max == decimal.Decimal('99.5')
-    True
-
-Date
-----
-
-    >>> field = schema.Date(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=datetime.date(2001,1,2), missing_value=datetime.date(2000,1,1),
-    ...     min=datetime.date(2000,10,12), max=datetime.date(2099,12,31))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Date">
-      <default>2001-01-02</default>
-      <description>Test desc</description>
-      <max>2099-12-31</max>
-      <min>2000-10-12</min>
-      <missing_value>2000-01-01</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Date'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    datetime.date(2001, 1, 2)
-    >>> reciprocal.missing_value
-    datetime.date(2000, 1, 1)
-    >>> reciprocal.min
-    datetime.date(2000, 10, 12)
-    >>> reciprocal.max
-    datetime.date(2099, 12, 31)
-
-Datetime
----------
-
-    >>> field = schema.Datetime(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=datetime.datetime(2001,1,2,1,2,3), missing_value=datetime.datetime(2000,1,1,2,3,4),
-    ...     min=datetime.datetime(2000,10,12,0,0,2), max=datetime.datetime(2099,12,31,1,2,2))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Datetime">
-      <default>2001-01-02 01:02:03</default>
-      <description>Test desc</description>
-      <max>2099-12-31 01:02:02</max>
-      <min>2000-10-12 00:00:02</min>
-      <missing_value>2000-01-01 02:03:04</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Datetime'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    datetime.datetime(2001, 1, 2, 1, 2, 3, 1)
-    >>> reciprocal.missing_value
-    datetime.datetime(2000, 1, 1, 2, 3, 4, 5)
-    >>> reciprocal.min
-    datetime.datetime(2000, 10, 12, 0, 0, 2, 3)
-    >>> reciprocal.max
-    datetime.datetime(2099, 12, 31, 1, 2, 2, 3)
-
-InterfaceField
----------------
-
-    >>> field = schema.InterfaceField(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=plone.supermodel.tests.IDummy,
-    ...     missing_value=plone.supermodel.tests.IDummy)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.InterfaceField">
-      <default>plone.supermodel.tests.IDummy</default>
-      <description>Test desc</description>
-      <missing_value>plone.supermodel.tests.IDummy</missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.InterfaceField'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    <InterfaceClass plone.supermodel.tests.IDummy>
-    >>> reciprocal.missing_value
-    <InterfaceClass plone.supermodel.tests.IDummy>
-
-Tuple
------
-
-    >>> field = schema.Tuple(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=(1,2), missing_value=(),
-    ...     min_length=2, max_length=10,
-    ...     value_type=schema.Int(title=u"Val"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Tuple">
-      <default>
-        <element>1</element>
-        <element>2</element>
-      </default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value/>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <value_type type="zope.schema.Int">
-        <title>Val</title>
-      </value_type>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Tuple'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    (1, 2)
-    >>> reciprocal.missing_value
-    ()
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.value_type.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.value_type.title
-    u'Val'
-
-List
-----
-
-    >>> field = schema.List(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=[1,2], missing_value=[],
-    ...     min_length=2, max_length=10,
-    ...     value_type=schema.Int(title=u"Val"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.List">
-      <default>
-        <element>1</element>
-        <element>2</element>
-      </default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value/>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <value_type type="zope.schema.Int">
-        <title>Val</title>
-      </value_type>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.List'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    [1, 2]
-    >>> reciprocal.missing_value
-    []
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.value_type.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.value_type.title
-    u'Val'
-
-Set
----
-
-    >>> field = schema.Set(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=set((1,2)), missing_value=set(),
-    ...     min_length=2, max_length=10,
-    ...     value_type=schema.Int(title=u"Val"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Set">
-      <default>
-        <element>1</element>
-        <element>2</element>
-      </default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value/>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <value_type type="zope.schema.Int">
-        <title>Val</title>
-      </value_type>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Set'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    set([1, 2])
-    >>> reciprocal.missing_value
-    set([])
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.value_type.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.value_type.title
-    u'Val'
-
-FrozenSet
----------
-
-    >>> field = schema.FrozenSet(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=frozenset((1,2)), missing_value=frozenset(),
-    ...     min_length=2, max_length=10,
-    ...     value_type=schema.Int(title=u"Val"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.FrozenSet">
-      <default>
-        <element>1</element>
-        <element>2</element>
-      </default>
-      <description>Test desc</description>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value/>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <value_type type="zope.schema.Int">
-        <title>Val</title>
-      </value_type>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.FrozenSet'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    frozenset([1, 2])
-    >>> reciprocal.missing_value
-    frozenset([])
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.value_type.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.value_type.title
-    u'Val'
-
-Dict
-----
-
-    >>> field = schema.Dict(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default={'a':1, 'b':2}, missing_value={},
-    ...     min_length=2, max_length=10,
-    ...     key_type=schema.ASCIILine(title=u"Key"),
-    ...     value_type=schema.Int(title=u"Val"))
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Dict">
-      <default>
-        <element key="a">1</element>
-        <element key="b">2</element>
-      </default>
-      <description>Test desc</description>
-      <key_type type="zope.schema.ASCIILine">
-        <title>Key</title>
-      </key_type>
-      <max_length>10</max_length>
-      <min_length>2</min_length>
-      <missing_value/>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <value_type type="zope.schema.Int">
-        <title>Val</title>
-      </value_type>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Dict'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    {'a': 1, 'b': 2}
-    >>> reciprocal.missing_value
-    {}
-    >>> reciprocal.min_length
-    2
-    >>> reciprocal.max_length
-    10
-    >>> reciprocal.key_type.__class__
-    <class 'zope.schema._field.ASCIILine'>
-    >>> reciprocal.key_type.title
-    u'Key'
-    >>> reciprocal.value_type.__class__
-    <class 'zope.schema._bootstrapfields.Int'>
-    >>> reciprocal.value_type.title
-    u'Val'
-
-Object
-------
-
-Note: when an object field is written, the 'default' and 'missing_value'
-fields will be omitted, as there is no way to write these reliably.
-
-    >>> dummy1 = plone.supermodel.tests.Dummy()
-    >>> dummy2 = plone.supermodel.tests.Dummy()
-
-    >>> field = schema.Object(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default=dummy1, missing_value=dummy2,
-    ...     schema=plone.supermodel.tests.IDummy)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType) #doctest: +ELLIPSIS
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Object">
-      <description>Test desc</description>
-      <readonly>True</readonly>
-      <required>False</required>
-      <schema>plone.supermodel.tests.IDummy</schema>
-      <title>Test</title>
-    </field>
-
-However, we support reading an object dotted name for an
-object field that references a particular dotted name.
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.Object">
-    ...   <default>plone.supermodel.tests.dummy1</default>
-    ...   <description>Test desc</description>
-    ...   <missing_value/>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <schema>plone.supermodel.tests.IDummy</schema>
-    ...   <title>Test</title>
-    ... </field>
-    ... """)
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Object'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default is plone.supermodel.tests.dummy1
-    True
-    >>> reciprocal.missing_value is None
-    True
-
-Choice
-------
-
-The choice field supports several different modes: a named vocabulary, a list
-of values, a source object, or a source context binder object. However,
-plone.supermodel only supports exporting named vocabularies or lists of
-unicode string values. In addition, it is possible to import (but not export)
-a source or context source binder, provided it can be imported from a
-dotted name.
-
-1. Named vocabularies
-
-These can be both exported and imported.
-
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='a', missing_value='', vocabulary=u'dummy.vocab')
-
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Choice">
-      <default>a</default>
-      <description>Test desc</description>
-      <missing_value></missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <vocabulary>dummy.vocab</vocabulary>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Choice'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default # note - value is always unicode
-    u'a'
-    >>> reciprocal.missing_value # note - value is always unicode
-    u''
-    >>> reciprocal.vocabulary is None
-    True
-    >>> reciprocal.vocabularyName
-    u'dummy.vocab'
-
-2. Values vocabularies
-
-These can be both imported and exported, but note that the value is always
-a unicode string when importing.
-
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='a', missing_value='', values=['a', 'b', 'c'])
-
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Choice">
-      <default>a</default>
-      <description>Test desc</description>
-      <missing_value></missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <values>
-        <element>a</element>
-        <element>b</element>
-        <element>c</element>
-      </values>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Choice'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'a'
-    >>> reciprocal.missing_value
-    u''
-    >>> [t.value for t in reciprocal.vocabulary]
-    [u'a', u'b', u'c']
-    >>> reciprocal.vocabularyName is None
-    True
-
-There was a bug when the XML namespace was specified explicitly; let's make
-sure it hasn't regressed.
-
-    >>> from plone.supermodel.interfaces import XML_NAMESPACE
-    >>> element.set('xmlns', XML_NAMESPACE)
-    >>> element = etree.parse(StringIO(prettyXML(element))).getroot()
-    >>> reciprocal = handler.read(element)
-    >>> [t.value for t in reciprocal.vocabulary]
-    [u'a', u'b', u'c']
-
-Also, make sure we can handle terms with unicode values (as long as their
-tokens are the utf8-encoded values).
-
-    >>> from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm
-    >>> vocab = SimpleVocabulary([
-    ...     SimpleTerm(token='a', value=u'a', title=u'a'),
-    ...     SimpleTerm(token=r'\xe7', value=u'\xe7', title=u'\xe7'), # c with cedilla
-    ...     ])
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     default='a', missing_value='', vocabulary=vocab)
-
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Choice">
-      <default>a</default>
-      <description>Test desc</description>
-      <missing_value></missing_value>
-      <readonly>True</readonly>
-      <required>False</required>
-      <title>Test</title>
-      <values>
-        <element>a</element>
-        <element>&#231;</element>
-      </values>
-    </field>
-
-    >>> reciprocal = handler.read(element)
-    >>> [t.value for t in reciprocal.vocabulary]
-    [u'a', u'\xe7']
-
-
-Additionally, it is possible for Choice fields with a values vocabulary
-whose terms contain values distinct from term titles for each
-respective term.  This is accomplished by using the 'key' attribute
-of each contained 'element' of the values element (this is consistent
-with how Dict fields are output, only for Choices, order is guaranteed).
-
-    >>> from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm
-    >>> vocab = SimpleVocabulary([
-    ...     SimpleTerm(value=u'a', title=u'A'),
-    ...     SimpleTerm(value=u'b', title=u'B'),
-    ...     ])
-    >>> field = schema.Choice(
-    ...     __name__="dummy",
-    ...     title=u"Test",
-    ...     vocabulary=vocab,
-    ...     )
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType)
-    >>> print prettyXML(element)
-    <field name="dummy" type="zope.schema.Choice">
-      <title>Test</title>
-      <values>
-        <element key="a">A</element>
-        <element key="b">B</element>
-      </values>
-    </field>
-
-3. Sources and source binders
-
-We cannot export choice fields with a source or context source binder:
-
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     vocabulary=plone.supermodel.tests.dummy_vocabulary_instance)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
-    Traceback (most recent call last):
-    ...
-    NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values
-
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     source=plone.supermodel.tests.dummy_vocabulary_instance)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
-    Traceback (most recent call last):
-    ...
-    NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values
-
-    >>> field = schema.Choice(__name__="dummy", title=u"Test",
-    ...     description=u"Test desc", required=False, readonly=True,
-    ...     source=plone.supermodel.tests.dummy_binder)
-    >>> fieldType = IFieldNameExtractor(field)()
-    >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)
-    >>> element = handler.write(field, 'dummy', fieldType) # doctest: +ELLIPSIS
-    Traceback (most recent call last):
-    ...
-    NotImplementedError: Choice fields with vocabularies not based on a simple list of values or a named vocabulary cannot be exported
-
-However, we can import a choice field with a source, provided that source can
-be specified via an importable dotted name.
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.Choice">
-    ...   <default>a</default>
-    ...   <description>Test desc</description>
-    ...   <missing_value/>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ...   <source>plone.supermodel.tests.dummy_binder</source>
-    ... </field>
-    ... """)
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Choice'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'a'
-    >>> reciprocal.vocabulary is plone.supermodel.tests.dummy_binder
-    True
-    >>> reciprocal.vocabularyName is None
-    True
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.Choice">
-    ...   <default>a</default>
-    ...   <description>Test desc</description>
-    ...   <missing_value/>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ...   <source>plone.supermodel.tests.dummy_vocabulary_instance</source>
-    ... </field>
-    ... """)
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._field.Choice'>
-    >>> reciprocal.__name__
-    'dummy'
-    >>> reciprocal.title
-    u'Test'
-    >>> reciprocal.description
-    u'Test desc'
-    >>> reciprocal.required
-    False
-    >>> reciprocal.readonly
-    True
-    >>> reciprocal.default
-    u'a'
-    >>> reciprocal.vocabulary is plone.supermodel.tests.dummy_vocabulary_instance
-    True
-    >>> reciprocal.vocabularyName is None
-    True
-
-defaultFactory usage
---------------------
-
-Fields may specify defaultFactory attributes as dotted interfaces.
-defaultFactory callables should provide either
-zope.schema.interfaces.IContextAwareDefaultFactory or
-plone.supermodel.interfaces.IDefaultFactory.
-
-Note that zope.schema allows callables without any marker
-interface. Our requirements are an extra validation measure.
-
-Try specifying a defaultFactory attribute::
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.TextLine">
-    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultFactory</defaultFactory>
-    ...   <description>Test desc</description>
-    ...   <max_length>10</max_length>
-    ...   <min_length>2</min_length>
-    ...   <missing_value>m</missing_value>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ... </field>
-    ... """)
-
-Import it::
-    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
-
-Sanity checks::
-
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.__class__
-    <class 'zope.schema._bootstrapfields.TextLine'>
-
-And, look for the specified defaultFactory::
-    >>> reciprocal.defaultFactory == plone.supermodel.tests.dummy_defaultFactory
-    True
-
-Let's try it with a callable that provides IContextAwareDefaultFactory::
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.TextLine">
-    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultCAFactory</defaultFactory>
-    ...   <description>Test desc</description>
-    ...   <max_length>10</max_length>
-    ...   <min_length>2</min_length>
-    ...   <missing_value>m</missing_value>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ... </field>
-    ... """)
-
-    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
-    >>> reciprocal = handler.read(element)
-    >>> reciprocal.defaultFactory == plone.supermodel.tests.dummy_defaultCAFactory
-    True
-
-And, check to make sure that we can't use a callable that doesn't have one
-of our marker interfaces::
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.TextLine">
-    ...   <defaultFactory>plone.supermodel.tests.dummy_defaultBadFactory</defaultFactory>
-    ...   <description>Test desc</description>
-    ...   <max_length>10</max_length>
-    ...   <min_length>2</min_length>
-    ...   <missing_value>m</missing_value>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ... </field>
-    ... """)
-
-    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
-    >>> reciprocal = handler.read(element)
-    Traceback (most recent call last):
-    ...
-    ImportError: defaultFactory must provide zope.schema.interfaces.IContextAwareDefaultFactory or plone.supermodel.IDefaultFactory
-
-A non-existent callable should also raise an error::
-
-    >>> element = etree.XML("""\
-    ... <field name="dummy" type="zope.schema.TextLine">
-    ...   <defaultFactory>plone.supermodel.tests.nonExistentFactory</defaultFactory>
-    ...   <description>Test desc</description>
-    ...   <max_length>10</max_length>
-    ...   <min_length>2</min_length>
-    ...   <missing_value>m</missing_value>
-    ...   <readonly>True</readonly>
-    ...   <required>False</required>
-    ...   <title>Test</title>
-    ... </field>
-    ... """)
-
-    >>> handler = getUtility(IFieldExportImportHandler, name='zope.schema.TextLine')
-    >>> reciprocal = handler.read(element)
-    Traceback (most recent call last):
-    ...
-    ImportError: No module named nonExistentFactory
diff --git a/plone/supermodel/interfaces.py b/plone/supermodel/interfaces.py
index 74fa109..115f330 100644
--- a/plone/supermodel/interfaces.py
+++ b/plone/supermodel/interfaces.py
@@ -1,8 +1,10 @@
 # -*- coding: utf-8 -*-
 from zope.interface import Interface
 from zope.interface.interfaces import IInterface
+
 import zope.schema
 
+
 # Keys for tagged values on interfaces
 
 # absolute file name of model file
@@ -22,6 +24,8 @@
 XML_NAMESPACE = u"http://namespaces.plone.org/supermodel/schema"
 I18N_NAMESPACE = u'http://xml.zope.org/namespaces/i18n'
 
+DEFAULT_ORDER = 9999
+
 
 class ISchema(IInterface):
     """Describes a schema as generated by this library
@@ -39,10 +43,14 @@ class IModel(Interface):
 
     schemata = zope.schema.Dict(
         title=u"Schemata",
-        key_type=zope.schema.TextLine(title=u"Schema name",
-        description=u"Default schema is under the key u''."),
-        value_type=zope.schema.Object(title=u"Schema interface",
-        schema=ISchema)
+        key_type=zope.schema.TextLine(
+            title=u"Schema name",
+            description=u"Default schema is under the key u''."
+        ),
+        value_type=zope.schema.Object(
+            title=u"Schema interface",
+            schema=ISchema
+        )
     )
 
 
@@ -59,6 +67,12 @@ class IFieldset(Interface):
         required=False
     )
 
+    order = zope.schema.Int(
+        title=u"Order",
+        required=False,
+        default=DEFAULT_ORDER,
+    )
+
     fields = zope.schema.List(
         title=u"Field names",
         value_type=zope.schema.TextLine(title=u"Field name")
diff --git a/plone/supermodel/model.py b/plone/supermodel/model.py
index fc838a3..05c24bf 100644
--- a/plone/supermodel/model.py
+++ b/plone/supermodel/model.py
@@ -1,16 +1,20 @@
 # -*- coding: utf-8 -*-
+from plone.supermodel.interfaces import DEFAULT_ORDER
 from plone.supermodel.interfaces import IFieldset
 from plone.supermodel.interfaces import IModel
 from plone.supermodel.interfaces import ISchema
 from plone.supermodel.interfaces import ISchemaPlugin
 from zope.component import getAdapters
-from zope.interface import Interface
 from zope.interface import implementer
+from zope.interface import Interface
 from zope.interface.interface import InterfaceClass
+
 import logging
 import zope.deferredimport
 
-zope.deferredimport.defineFrom('plone.supermodel.directives',
+
+zope.deferredimport.defineFrom(
+    'plone.supermodel.directives',
     'load',
     'fieldset',
 )
@@ -29,10 +33,18 @@
 @implementer(IFieldset)
 class Fieldset(object):
 
-    def __init__(self, __name__, label=None, description=None, fields=None):
+    def __init__(
+        self,
+        __name__,
+        label=None,
+        description=None,
+        fields=None,
+        order=DEFAULT_ORDER
+    ):
         self.__name__ = __name__
         self.label = label or __name__
         self.description = description
+        self.order = order
 
         if fields:
             self.fields = fields
@@ -40,7 +52,11 @@ def __init__(self, __name__, label=None, description=None, fields=None):
             self.fields = []
 
     def __repr__(self):
-        return "<Fieldset '%s' of %s>" % (self.__name__, ', '.join(self.fields))
+        return "<Fieldset '{0}' order {1:d} of {2}>".format(
+            self.__name__,
+            self.order,
+            ', '.join(self.fields)
+        )
 
 
 @implementer(IModel)
@@ -73,14 +89,21 @@ def _SchemaClass_finalize(self):
         for order, name, adapter in adapters:
             adapter()
 
-Schema = SchemaClass("Schema", (Interface,), __module__='plone.supermodel.model')
+Schema = SchemaClass(
+    'Schema',
+    (Interface,),
+    __module__='plone.supermodel.model'
+)
 
 
 def finalizeSchemas(parent=Schema):
     """Configuration action called after plone.supermodel is configured.
     """
     if not isinstance(parent, SchemaClass):
-        raise TypeError('Only instances of plone.supermodel.model.SchemaClass can be finalized.')
+        raise TypeError(
+            'Only instances of plone.supermodel.model.SchemaClass can be '
+            'finalized.'
+        )
 
     def walk(schema):
         yield schema
@@ -106,7 +129,12 @@ def walk(schema):
         if hasattr(schema, '_SchemaClass_finalize'):
             schema._SchemaClass_finalize()
         elif isinstance(schema, InterfaceClass):
-            logger.warn('%s is not an instance of SchemaClass. '
+            logger.warn(
+                '{0}.{1} is not an instance of SchemaClass. '
                 'This can happen if the first base class of a schema is not a '
-                'SchemaClass. See https://bugs.launchpad.net/zope.interface/+bug/791218'
-                % ('%s.%s' % (schema.__module__, schema.__name__)))
+                'SchemaClass. See '
+                'https://bugs.launchpad.net/zope.interface/+bug/791218'.format(
+                    schema.__module__,
+                    schema.__name__
+                )
+            )
diff --git a/plone/supermodel/parser.py b/plone/supermodel/parser.py
index 233d956..0c712a2 100644
--- a/plone/supermodel/parser.py
+++ b/plone/supermodel/parser.py
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 from lxml import etree
 from plone.supermodel.debug import parseinfo
+from plone.supermodel.interfaces import DEFAULT_ORDER
 from plone.supermodel.interfaces import FIELDSETS_KEY
 from plone.supermodel.interfaces import I18N_NAMESPACE
 from plone.supermodel.interfaces import IFieldExportImportHandler
@@ -19,11 +20,13 @@
 from zope.dottedname.resolve import resolve
 from zope.interface import implementer
 from zope.schema import getFields
+
 import linecache
 import sys
 
 # Exception
 
+
 class SupermodelParseError(Exception):
 
     def __init__(self, orig_exc, fname, element):
@@ -42,8 +45,8 @@ def __init__(self, orig_exc, fname, element):
             msg += '\n    %s' % line
         self.args = [msg]
 
-# Helper adapters
 
+# Helper adapters
 @implementer(ISchemaPolicy)
 class DefaultSchemaPolicy(object):
 
@@ -58,7 +61,6 @@ def name(self, schemaName, tree):
 
 
 # Algorithm
-
 def parse(source, policy=u""):
     fname = None
     if isinstance(source, basestring):
@@ -69,16 +71,22 @@ def parse(source, policy=u""):
     except Exception, e:
         # Re-package the exception as a parse error that will get rendered with
         # the filename and line number of the element that caused the problem.
-        # Keep the original traceback so the developer can debug where the problem
-        # happened.
-        raise SupermodelParseError(e, fname, parseinfo.stack[-1]), None, sys.exc_info()[2]
+        # Keep the original traceback so the developer can debug where the
+        # problem happened.
+        raise SupermodelParseError(
+            e,
+            fname,
+            parseinfo.stack[-1]
+        ), None, sys.exc_info()[2]
 
 
 def _parse(source, policy):
     tree = etree.parse(source)
     root = tree.getroot()
 
-    parseinfo.i18n_domain = root.attrib.get(ns('domain', prefix=I18N_NAMESPACE))
+    parseinfo.i18n_domain = root.attrib.get(
+        ns('domain', prefix=I18N_NAMESPACE)
+    )
 
     model = Model()
 
@@ -95,13 +103,22 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):
         fieldType = fieldElement.get('type')
 
         if fieldName is None or fieldType is None:
-            raise ValueError("The attributes 'name' and 'type' are required for each <field /> element")
+            raise ValueError(
+                'The attributes \'name\' and \'type\' are required for each '
+                '<field /> element'
+            )
 
         handler = handlers.get(fieldType, None)
         if handler is None:
-            handler = handlers[fieldType] = queryUtility(IFieldExportImportHandler, name=fieldType)
+            handler = handlers[fieldType] = queryUtility(
+                IFieldExportImportHandler,
+                name=fieldType
+            )
             if handler is None:
-                raise ValueError("Field type %s specified for field %s is not supported" % (fieldType, fieldName, ))
+                raise ValueError(
+                    'Field type {0} specified for field {1} is not '
+                    'supported'.format(fieldType, fieldName)
+                )
 
         field = handler.read(fieldElement)
 
@@ -138,7 +155,12 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):
         # Read global fields
         for fieldElement in schema_element.findall(ns('field')):
             parseinfo.stack.append(fieldElement)
-            readField(fieldElement, schemaAttributes, fieldElements, baseFields)
+            readField(
+                fieldElement,
+                schemaAttributes,
+                fieldElements,
+                baseFields
+            )
             parseinfo.stack.pop()
 
         # Read invariants, fieldsets and their fields
@@ -150,26 +172,48 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):
             parseinfo.stack.append(subelement)
 
             if subelement.tag == ns('field'):
-                readField(subelement, schemaAttributes, fieldElements, baseFields)
+                readField(
+                    subelement,
+                    schemaAttributes,
+                    fieldElements,
+                    baseFields
+                )
             elif subelement.tag == ns('fieldset'):
 
                 fieldset_name = subelement.get('name')
                 if fieldset_name is None:
-                    raise ValueError(u"Fieldset in schema %s has no name" % (schemaName))
+                    raise ValueError(
+                        u'Fieldset in schema {0} has no name'.format(
+                            schemaName
+                        )
+                    )
 
                 fieldset = fieldsets_by_name.get(fieldset_name, None)
                 if fieldset is None:
                     fieldset_label = subelement.get('label')
                     fieldset_description = subelement.get('description')
-
-                    fieldset = fieldsets_by_name[fieldset_name] = Fieldset(fieldset_name,
-                                    label=fieldset_label, description=fieldset_description)
+                    fieldset_order = subelement.get('order')
+                    if fieldset_order is None:
+                        fieldset_order = DEFAULT_ORDER
+                    elif isinstance(fieldset_order, basestring):
+                        fieldset_order = int(fieldset_order)
+                    fieldset = fieldsets_by_name[fieldset_name] = Fieldset(
+                        fieldset_name,
+                        label=fieldset_label,
+                        description=fieldset_description,
+                        order=fieldset_order,
+                    )
                     fieldsets_by_name[fieldset_name] = fieldset
                     fieldsets.append(fieldset)
 
                 for fieldElement in subelement.findall(ns('field')):
                     parseinfo.stack.append(fieldElement)
-                    parsed_fieldName = readField(fieldElement, schemaAttributes, fieldElements, baseFields)
+                    parsed_fieldName = readField(
+                        fieldElement,
+                        schemaAttributes,
+                        fieldElements,
+                        baseFields
+                    )
                     if parsed_fieldName:
                         fieldset.fields.append(parsed_fieldName)
                     parseinfo.stack.pop()
@@ -178,15 +222,18 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):
                 invariant = resolve(dotted)
                 if not IInvariant.providedBy(invariant):
                     raise ImportError(
-                        u"Invariant functions must provide plone.supermodel.interfaces.IInvariant"
+                        u'Invariant functions must provide '
+                        u'plone.supermodel.interfaces.IInvariant'
                     )
                 invariants.append(invariant)
             parseinfo.stack.pop()
 
-        schema = SchemaClass(name=policy_util.name(schemaName, tree),
-                                bases=bases + policy_util.bases(schemaName, tree) + (Schema,),
-                                __module__=policy_util.module(schemaName, tree),
-                                attrs=schemaAttributes)
+        schema = SchemaClass(
+            name=policy_util.name(schemaName, tree),
+            bases=bases + policy_util.bases(schemaName, tree) + (Schema,),
+            __module__=policy_util.module(schemaName, tree),
+            attrs=schemaAttributes
+        )
 
         # add invariants to schema as tagged values
         if invariants:
@@ -200,7 +247,11 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):
         for handler_name, metadata_handler in field_metadata_handlers:
             for fieldName in schema:
                 if fieldName in fieldElements:
-                    metadata_handler.read(fieldElements[fieldName], schema, schema[fieldName])
+                    metadata_handler.read(
+                        fieldElements[fieldName],
+                        schema,
+                        schema[fieldName]
+                    )
 
         for handler_name, metadata_handler in schema_metadata_handlers:
             metadata_handler.read(schema_element, schema)
diff --git a/plone/supermodel/schema.rst b/plone/supermodel/schema.rst
new file mode 100644
index 0000000..177922d
--- /dev/null
+++ b/plone/supermodel/schema.rst
@@ -0,0 +1,687 @@
+==================================================
+plone.supermodel: content schemata loaded from XML
+==================================================
+
+This package allows content schemata to be read and written as XML. It has a
+standard importer and serialiser for interfaces that contain zope.schema
+fields. The format is general enough to be able to handle future fields
+easily, so long as they are properly specified through interfaces.
+
+Parsing and serializing simple schemata
+---------------------------------------
+
+Before we can begin, we must register the field handlers that know how to
+import and export fields from/to XML. These are registered as named utilities,
+and can be loaded from the configure.zcml file of plone.supermodel.
+
+    >>> configuration = """\
+    ... <configure
+    ...      xmlns="http://namespaces.zope.org/zope"
+    ...      i18n_domain="plone.supermodel.tests">
+    ...
+    ...     <include package="zope.component" file="meta.zcml" />
+    ...
+    ...     <include package="plone.supermodel" />
+    ...
+    ... </configure>
+    ... """
+
+    >>> from StringIO import StringIO
+    >>> from zope.configuration import xmlconfig
+    >>> xmlconfig.xmlconfig(StringIO(configuration))
+
+Next, let's define a sample model with a single, unnamed schema.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title>Title</title>
+    ...             <required>True</required>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="description">
+    ...             <!-- we can also put comments in here -->
+    ...             <title>Description</title>
+    ...             <description>A short summary</description>
+    ...             <required>False</required>
+    ...             <min_length>10</min_length>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+We can parse this model using the loadString() function:
+
+    >>> from plone.supermodel import loadString
+    >>> model = loadString(schema)
+
+This will load one schema, with the default name u"":
+
+    >>> model.schemata.keys()
+    [u'']
+
+We can inspect this schema and see that it contains zope.schema fields with
+attributes corresponding to the values set in XML.
+
+    >>> schema = model.schema # shortcut to model.schemata[u""]
+
+    >>> from zope.schema import getFieldNamesInOrder
+    >>> getFieldNamesInOrder(schema)
+    ['title', 'description']
+
+    >>> schema['title'].title
+    u'Title'
+    >>> schema['title'].required
+    True
+
+    >>> schema['description'].title
+    u'Description'
+    >>> schema['description'].description
+    u'A short summary'
+    >>> schema['description'].required
+    False
+    >>> schema['description'].min_length
+    10
+
+If we try to parse a schema that has errors, we'll get a useful
+SupermodelParseError that includes contextual information. (This requires
+lxml.)
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <field type="aint_gonna_exist" name="title">
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+    >>> loadString(schema)
+    Traceback (most recent call last):
+    ...
+    SupermodelParseError: Field type aint_gonna_exist specified for field title is not supported
+      File "<unknown>", line ...
+
+In addition to parsing, we can serialize a model to an XML representation:
+
+    >>> from plone.supermodel import serializeModel
+    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema>
+        <field name="title" type="zope.schema.TextLine">
+          <title>Title</title>
+        </field>
+        <field name="description" type="zope.schema.Text">
+          <description>A short summary</description>
+          <min_length>10</min_length>
+          <required>False</required>
+          <title>Description</title>
+        </field>
+      </schema>
+    </model>
+
+Building interfaces from schemata
+---------------------------------
+
+Above, we saw how to parse a schema from a file directly. Next, let's see how
+this can be used more practically to define a custom interface. Here, we will
+use two schemata in one file.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title>Title</title>
+    ...             <required>True</required>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="body">
+    ...             <title>Body text</title>
+    ...             <required>True</required>
+    ...             <max_length>10000</max_length>
+    ...         </field>
+    ...     </schema>
+    ...
+    ...     <schema name="metadata">
+    ...         <field type="zope.schema.Datetime" name="created">
+    ...             <title>Created date</title>
+    ...             <required>False</required>
+    ...         </field>
+    ...         <field type="zope.schema.TextLine" name="creator">
+    ...             <title>Creator</title>
+    ...             <description>Name of the creator</description>
+    ...             <required>True</required>
+    ...         </field>
+    ...     </schema>
+    ...
+    ... </model>
+    ... """
+
+Ordinarily, this would be in a file in the same directory as the module
+containing the interface being defined. Here, we need to create a temporary
+directory.
+
+    >>> import tempfile, os.path, shutil
+    >>> tmpdir = tempfile.mkdtemp()
+    >>> schema_filename = os.path.join(tmpdir, "schema.xml")
+    >>> schema_file = open(schema_filename, "w")
+    >>> schema_file.write(schema)
+    >>> schema_file.close()
+
+We can define interfaces from this using a helper function:
+
+    >>> from plone.supermodel import xmlSchema
+    >>> ITestContent = xmlSchema(schema_filename)
+
+Note: If the schema filename is not an absolute path, it will be found
+relative to the module where the interface is defined.
+
+After being loaded, the interface should have the fields of the default
+(unnamed) schema:
+
+    >>> getFieldNamesInOrder(ITestContent)
+    ['title', 'body']
+
+We can also use a different, named schema:
+
+    >>> ITestMetadata = xmlSchema(schema_filename, schema=u"metadata")
+    >>> getFieldNamesInOrder(ITestMetadata)
+    ['created', 'creator']
+
+Of course, a schema can also be written to XML. Either, you can build a model
+dict as per the serializeModel() method seen above, or you can write a model
+of just a single schema using serializeSchema():
+
+    >>> from plone.supermodel import serializeSchema
+    >>> print serializeSchema(ITestContent) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema>
+        <field name="title" type="zope.schema.TextLine">
+          <title>Title</title>
+        </field>
+        <field name="body" type="zope.schema.Text">
+          <max_length>10000</max_length>
+          <title>Body text</title>
+        </field>
+      </schema>
+    </model>
+
+    >>> print serializeSchema(ITestMetadata, name=u"metadata") # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema name="metadata">
+        <field name="created" type="zope.schema.Datetime">
+          <required>False</required>
+          <title>Created date</title>
+        </field>
+        <field name="creator" type="zope.schema.TextLine">
+          <description>Name of the creator</description>
+          <title>Creator</title>
+        </field>
+      </schema>
+    </model>
+
+Finally, let's clean up the temporary directory.
+
+    >>> shutil.rmtree(tmpdir)
+
+Base interface support
+----------------------
+
+When building a schema interface from XML, it is possible to specify a base
+interface. This is analogous to "subclassing" an existing interface. The XML
+schema representation can override and/or extend fields from the base.
+
+For the purposes of this test, we have defined a dummy interface in
+plone.supermodel.tests. We can't define it in the doctest, because the import
+resolver needs to have a proper module path. The interface looks like this
+though:
+
+    class IBase(Interface):
+        title = zope.schema.TextLine(title=u"Title")
+        description = zope.schema.TextLine(title=u"Description")
+        name = zope.schema.TextLine(title=u"Name")
+
+In real life, you'd more likely have a dotted name like
+my.package.interfaces.IBase, of course.
+
+Then, let's define a schema that is based on this interface.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema based-on="plone.supermodel.tests.IBase">
+    ...         <field type="zope.schema.Text" name="description">
+    ...             <title>Description</title>
+    ...             <description>A short summary</description>
+    ...         </field>
+    ...         <field type="zope.schema.Int" name="age">
+    ...             <title>Age</title>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+Here, notice the use of the 'based-on' attribute, which specifies a dotted
+name to the base interface. It is possible to specify multiple interfaces
+as a space-separated list. However, if you find that you need this, you
+may want to ask yourself why. :) Inside the schema proper, we override the
+'description' field and add a new field, 'age'.
+
+When we load this model, we should find that the __bases__ list of the
+generated interface contains the base schema.
+
+    >>> model = loadString(schema)
+    >>> model.schema.__bases__
+    (<InterfaceClass plone.supermodel.tests.IBase>, <SchemaClass plone.supermodel.model.Schema>)
+
+The fields of the base interface will also be replicated in the new schema.
+
+    >>> getFieldNamesInOrder(model.schema)
+    ['title', 'description', 'name', 'age']
+
+Notice how the order of the 'description' field is dictated by where it
+appeared in the base interface, not where it appears in the XML schema.
+
+We should also verify that the description field was indeed overridden:
+
+    >>> model.schema['description'] # doctest: +ELLIPSIS
+    <zope.schema._bootstrapfields.Text object at ...>
+
+Finally, let's verify that bases are preserved upon serialisation:
+
+    >>> print serializeSchema(model.schema) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema based-on="plone.supermodel.tests.IBase">
+        <field name="description" type="zope.schema.Text">
+          <description>A short summary</description>
+          <title>Description</title>
+        </field>
+        <field name="age" type="zope.schema.Int">
+          <title>Age</title>
+        </field>
+      </schema>
+    </model>
+
+Fieldset support
+----------------
+
+It is often useful to be able to group form fields in the same schema into
+fieldsets, for example for form rendering. While plone.supermodel doesn't have
+anything to do with such rendering, it does support some markup to make it
+possible to define fieldsets. These are stored in a tagged value on the
+generated interface, which can then be used by other code.
+
+Fieldsets can be defined from and serialised to XML, using the <fieldset />
+tag to wrap a sequence of fields.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title>Title</title>
+    ...             <required>True</required>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="body">
+    ...             <title>Body text</title>
+    ...             <required>True</required>
+    ...             <max_length>10000</max_length>
+    ...         </field>
+    ...
+    ...         <fieldset name="dates" label="Dates" description="Standard dates" order="1">
+    ...             <field type="zope.schema.Date" name="publication_date">
+    ...                 <title>Publication date</title>
+    ...             </field>
+    ...         </fieldset>
+    ...
+    ...         <field type="zope.schema.TextLine" name="author">
+    ...             <title>Author</title>
+    ...         </field>
+    ...
+    ...         <fieldset name="dates" label="Ignored" description="Ignored">
+    ...             <field type="zope.schema.Date" name="expiry_date">
+    ...                 <title>Expiry date</title>
+    ...             </field>
+    ...             <field type="zope.schema.Date" name="notification_date">
+    ...                 <title>Notification date</title>
+    ...             </field>
+    ...         </fieldset>
+    ...     </schema>
+    ...
+    ...     <schema name="metadata">
+    ...
+    ...         <fieldset name="standard" label="Standard" />
+    ...         <fieldset name="dates" label="Metadata dates" />
+    ...         <fieldset name="author" label="Author info" />
+    ...
+    ...         <fieldset name="dates">
+    ...             <field type="zope.schema.Datetime" name="created">
+    ...                 <title>Created date</title>
+    ...                 <required>False</required>
+    ...             </field>
+    ...         </fieldset>
+    ...
+    ...         <fieldset name="standard">
+    ...             <field type="zope.schema.TextLine" name="creator">
+    ...                 <title>Creator</title>
+    ...                 <description>Name of the creator</description>
+    ...                 <required>True</required>
+    ...             </field>
+    ...         </fieldset>
+    ...     </schema>
+    ...
+    ... </model>
+    ... """
+
+Fields outside any <fieldset /> tag are not placed in any fieldset. An
+empty <fieldset /> will be recorded as one having no fields. This is sometimes
+useful to control the order of fieldsets, if those are to be filled later.
+
+If there are two <fieldset /> blocks with the same name, fields from the second
+will be appended to the first, and the label and description will be kept
+from the first one, as appropriate.
+
+Note that fieldsets are specific to each schema, i.e. the fieldset in the
+default schema above is unrelated to the one in the metadata schema.
+
+    >>> model = loadString(schema)
+    >>> getFieldNamesInOrder(model.schema)
+    ['title', 'body', 'publication_date', 'author', 'expiry_date', 'notification_date']
+
+    >>> getFieldNamesInOrder(model.schemata['metadata'])
+    ['created', 'creator']
+
+    >>> from plone.supermodel.interfaces import FIELDSETS_KEY
+    >>> model.schema.getTaggedValue(FIELDSETS_KEY)
+    [<Fieldset 'dates' order 1 of publication_date, expiry_date, notification_date>]
+
+    >>> model.schemata[u"metadata"].getTaggedValue(FIELDSETS_KEY)
+    [<Fieldset 'standard' order 9999 of creator>, <Fieldset 'dates' order 9999 of created>, <Fieldset 'author' order 9999 of >]
+
+When we serialise a schema with fieldsets, fields will be grouped by
+fieldset.
+
+    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema>
+        <field name="title" type="zope.schema.TextLine">
+          <title>Title</title>
+        </field>
+        <field name="body" type="zope.schema.Text">
+          <max_length>10000</max_length>
+          <title>Body text</title>
+        </field>
+        <field name="author" type="zope.schema.TextLine">
+          <title>Author</title>
+        </field>
+        <fieldset name="dates" label="Dates" description="Standard dates">
+          <field name="publication_date" type="zope.schema.Date">
+            <title>Publication date</title>
+          </field>
+          <field name="expiry_date" type="zope.schema.Date">
+            <title>Expiry date</title>
+          </field>
+          <field name="notification_date" type="zope.schema.Date">
+            <title>Notification date</title>
+          </field>
+        </fieldset>
+      </schema>
+      <schema name="metadata">
+        <fieldset name="standard" label="Standard">
+          <field name="creator" type="zope.schema.TextLine">
+            <description>Name of the creator</description>
+            <title>Creator</title>
+          </field>
+        </fieldset>
+        <fieldset name="dates" label="Metadata dates">
+          <field name="created" type="zope.schema.Datetime">
+            <required>False</required>
+            <title>Created date</title>
+          </field>
+        </fieldset>
+        <fieldset name="author" label="Author info"/>
+      </schema>
+    </model>
+
+Invariant Support
+-----------------
+
+We may specify one or more invariants for the form via the "invariant" tag with
+a dotted name for the invariant function.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <invariant>plone.supermodel.tests.dummy_invariant</invariant>
+    ...         <invariant>plone.supermodel.tests.dummy_invariant_prime</invariant>
+    ...         <field type="zope.schema.Text" name="description">
+    ...             <title>Description</title>
+    ...             <description>A short summary</description>
+    ...         </field>
+    ...         <field type="zope.schema.Int" name="age">
+    ...             <title>Age</title>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+    >>> model = loadString(schema)
+    >>> model.schema.getTaggedValue('invariants')
+    [<function dummy_invariant at ...>, <function dummy_invariant_prime at ...>]
+
+When invariants are checked for our model.schema, we'll see our invariant
+in action.
+
+    >>> model.schema.validateInvariants(object())
+    Traceback (most recent call last):
+    ...
+    Invalid: Yikes! Invalid
+
+The model's serialization should include the invariant.
+
+    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema>
+        <invariant>plone.supermodel.tests.dummy_invariant</invariant>
+        <invariant>plone.supermodel.tests.dummy_invariant_prime</invariant>
+        <field name="description" type="zope.schema.Text">
+          <description>A short summary</description>
+          <title>Description</title>
+        </field>
+        <field name="age" type="zope.schema.Int">
+          <title>Age</title>
+        </field>
+      </schema>
+    </model>
+
+Invariant functions must provide plone.supermodel.interfaces.IInvariant
+or we won't accept them.
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
+    ...     <schema>
+    ...         <invariant>plone.supermodel.tests.dummy_unmarkedInvariant</invariant>
+    ...         <field type="zope.schema.Text" name="description">
+    ...             <title>Description</title>
+    ...             <description>A short summary</description>
+    ...         </field>
+    ...         <field type="zope.schema.Int" name="age">
+    ...             <title>Age</title>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+    >>> model = loadString(schema)
+    Traceback (most recent call last):
+    ...
+    SupermodelParseError: Invariant functions must provide plone.supermodel.interfaces.IInvariant
+      File "<unknown>", line ...
+
+
+Internationalization
+--------------------
+
+Translation domains and message ids can be specified for text
+that is interpreted as unicode. This will result in deserialization
+as a zope.i18nmessageid message id rather than a basic Unicode string::
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
+    ...        xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    ...        i18n:domain="plone.supermodel">
+    ...     <schema>
+    ...
+    ...         <field type="zope.schema.TextLine" name="title">
+    ...             <title i18n:translate="supermodel_test_title">Title</title>
+    ...         </field>
+    ...
+    ...         <field type="zope.schema.TextLine" name="description">
+    ...             <title i18n:translate="">description</title>
+    ...         </field>
+    ...
+    ...         <field type="zope.schema.TextLine" name="feature">
+    ...             <title i18n:translate="domain_test"
+    ...                    i18n:domain="other">feature</title>
+    ...         </field>
+    ...
+    ...     </schema>
+    ... </model>
+    ... """
+    >>> model = loadString(schema)
+    >>> msgid = model.schema['title'].title
+    >>> msgid
+    u'supermodel_test_title'
+    >>> type(msgid)
+    <type 'zope.i18nmessageid.message.Message'>
+    >>> msgid.default
+    u'Title'
+    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema" i18n:domain="plone.supermodel">
+      <schema>
+        <field name="title" type="zope.schema.TextLine">
+          <title i18n:translate="supermodel_test_title">Title</title>
+        </field>
+        <field name="description" type="zope.schema.TextLine">
+          <title i18n:translate="">description</title>
+        </field>
+        <field name="feature" type="zope.schema.TextLine">
+          <title i18n:domain="other" i18n:translate="domain_test">feature</title>
+        </field>
+      </schema>
+    </model>
+
+Creating custom metadata handlers
+---------------------------------
+
+The plone.supermodel format is extensible with custom utilities that can
+write to a "metadata" dictionary. Such utilities may for example read
+information captured in attributes in particular namespaces.
+
+Let's imagine we wanted to make it possible to override form layout on a
+per-schema level, and override widgets on a per-field level. For this, we
+may expect to be able to parse a format like this:
+
+    >>> schema = """\
+    ... <?xml version="1.0" encoding="UTF-8"?>
+    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
+    ...        xmlns:ui="http://namespaces.acme.com/ui">
+    ...     <schema ui:layout="horizontal">
+    ...         <field type="zope.schema.TextLine" name="title"
+    ...             ui:widget="largetype">
+    ...             <title>Title</title>
+    ...             <required>True</required>
+    ...         </field>
+    ...         <field type="zope.schema.Text" name="description">
+    ...             <title>Description</title>
+    ...             <description>A short summary</description>
+    ...             <required>False</required>
+    ...             <min_length>10</min_length>
+    ...         </field>
+    ...     </schema>
+    ... </model>
+    ... """
+
+We can register schema and field metadata handlers as named utilities.
+Metadata handlers should be able to reciprocally read and write metadata.
+
+    >>> from zope.interface import implements
+    >>> from zope.component import provideUtility
+
+    >>> from plone.supermodel.interfaces import ISchemaMetadataHandler
+    >>> from plone.supermodel.utils import ns
+
+    >>> class FormLayoutMetadata(object):
+    ...     implements(ISchemaMetadataHandler)
+    ...
+    ...     namespace = "http://namespaces.acme.com/ui"
+    ...     prefix = "ui"
+    ...
+    ...     def read(self, schemaNode, schema):
+    ...         layout = schemaNode.get(ns('layout', self.namespace))
+    ...         if layout:
+    ...             schema.setTaggedValue(u'acme.layout', layout)
+    ...
+    ...     def write(self, schemaNode, schema):
+    ...         layout = schema.queryTaggedValue(u'acme.layout', None)
+    ...         if layout:
+    ...             schemaNode.set(ns('layout', self.namespace), layout)
+
+    >>> provideUtility(component=FormLayoutMetadata(), name='acme.ui.schema')
+
+    >>> from plone.supermodel.interfaces import IFieldMetadataHandler
+    >>> class FieldWidgetMetadata(object):
+    ...     implements(IFieldMetadataHandler)
+    ...
+    ...     namespace = "http://namespaces.acme.com/ui"
+    ...     prefix = "ui"
+    ...
+    ...     def read(self, fieldNode, schema, field):
+    ...         name = field.__name__
+    ...         widget = fieldNode.get(ns('widget', self.namespace))
+    ...         if widget:
+    ...             widgets = schema.queryTaggedValue(u'acme.widgets', {})
+    ...             widgets[name] = widget
+    ...             schema.setTaggedValue(u'acme.widgets', widgets)
+    ...
+    ...     def write(self, fieldNode, schema, field):
+    ...         name = field.__name__
+    ...         widget = schema.queryTaggedValue(u'acme.widgets', {}).get(name, {})
+    ...         if widget:
+    ...             fieldNode.set(ns('widget', self.namespace), widget)
+
+    >>> provideUtility(component=FieldWidgetMetadata(), name='acme.ui.fields')
+
+When this model is loaded, utilities above will be invoked for each schema
+and each field, respectively.
+
+    >>> model = loadString(schema)
+
+    >>> model.schema.getTaggedValue('acme.layout')
+    'horizontal'
+
+    >>> model.schema.getTaggedValue('acme.widgets')
+    {'title': 'largetype'}
+
+Of course, we can also serialize the schema back to XML. Here, the 'prefix'
+set in the utility (if any) will be used by default.
+
+    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
+    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:ui="http://namespaces.acme.com/ui" xmlns="http://namespaces.plone.org/supermodel/schema">
+      <schema ui:layout="horizontal">
+        <field name="title" type="zope.schema.TextLine" ui:widget="largetype">
+          <title>Title</title>
+        </field>
+        <field name="description" type="zope.schema.Text">
+          <description>A short summary</description>
+          <min_length>10</min_length>
+          <required>False</required>
+          <title>Description</title>
+        </field>
+      </schema>
+    </model>
diff --git a/plone/supermodel/schema.txt b/plone/supermodel/schema.txt
deleted file mode 100644
index 4bcbc0f..0000000
--- a/plone/supermodel/schema.txt
+++ /dev/null
@@ -1,687 +0,0 @@
-==================================================
-plone.supermodel: content schemata loaded from XML
-==================================================
-
-This package allows content schemata to be read and written as XML. It has a
-standard importer and serialiser for interfaces that contain zope.schema
-fields. The format is general enough to be able to handle future fields
-easily, so long as they are properly specified through interfaces.
-
-Parsing and serializing simple schemata
----------------------------------------
-
-Before we can begin, we must register the field handlers that know how to
-import and export fields from/to XML. These are registered as named utilities,
-and can be loaded from the configure.zcml file of plone.supermodel.
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.supermodel.tests">
-    ...
-    ...     <include package="zope.component" file="meta.zcml" />
-    ...
-    ...     <include package="plone.supermodel" />
-    ...
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-Next, let's define a sample model with a single, unnamed schema.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title>Title</title>
-    ...             <required>True</required>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="description">
-    ...             <!-- we can also put comments in here -->
-    ...             <title>Description</title>
-    ...             <description>A short summary</description>
-    ...             <required>False</required>
-    ...             <min_length>10</min_length>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-We can parse this model using the loadString() function:
-
-    >>> from plone.supermodel import loadString
-    >>> model = loadString(schema)
-
-This will load one schema, with the default name u"":
-
-    >>> model.schemata.keys()
-    [u'']
-
-We can inspect this schema and see that it contains zope.schema fields with
-attributes corresponding to the values set in XML.
-
-    >>> schema = model.schema # shortcut to model.schemata[u""]
-
-    >>> from zope.schema import getFieldNamesInOrder
-    >>> getFieldNamesInOrder(schema)
-    ['title', 'description']
-
-    >>> schema['title'].title
-    u'Title'
-    >>> schema['title'].required
-    True
-
-    >>> schema['description'].title
-    u'Description'
-    >>> schema['description'].description
-    u'A short summary'
-    >>> schema['description'].required
-    False
-    >>> schema['description'].min_length
-    10
-
-If we try to parse a schema that has errors, we'll get a useful
-SupermodelParseError that includes contextual information. (This requires
-lxml.)
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <field type="aint_gonna_exist" name="title">
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-    >>> loadString(schema)
-    Traceback (most recent call last):
-    ...
-    SupermodelParseError: Field type aint_gonna_exist specified for field title is not supported
-      File "<unknown>", line ...
-
-In addition to parsing, we can serialize a model to an XML representation:
-
-    >>> from plone.supermodel import serializeModel
-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema>
-        <field name="title" type="zope.schema.TextLine">
-          <title>Title</title>
-        </field>
-        <field name="description" type="zope.schema.Text">
-          <description>A short summary</description>
-          <min_length>10</min_length>
-          <required>False</required>
-          <title>Description</title>
-        </field>
-      </schema>
-    </model>
-
-Building interfaces from schemata
----------------------------------
-
-Above, we saw how to parse a schema from a file directly. Next, let's see how
-this can be used more practically to define a custom interface. Here, we will
-use two schemata in one file.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title>Title</title>
-    ...             <required>True</required>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="body">
-    ...             <title>Body text</title>
-    ...             <required>True</required>
-    ...             <max_length>10000</max_length>
-    ...         </field>
-    ...     </schema>
-    ...
-    ...     <schema name="metadata">
-    ...         <field type="zope.schema.Datetime" name="created">
-    ...             <title>Created date</title>
-    ...             <required>False</required>
-    ...         </field>
-    ...         <field type="zope.schema.TextLine" name="creator">
-    ...             <title>Creator</title>
-    ...             <description>Name of the creator</description>
-    ...             <required>True</required>
-    ...         </field>
-    ...     </schema>
-    ...
-    ... </model>
-    ... """
-
-Ordinarily, this would be in a file in the same directory as the module
-containing the interface being defined. Here, we need to create a temporary
-directory.
-
-    >>> import tempfile, os.path, shutil
-    >>> tmpdir = tempfile.mkdtemp()
-    >>> schema_filename = os.path.join(tmpdir, "schema.xml")
-    >>> schema_file = open(schema_filename, "w")
-    >>> schema_file.write(schema)
-    >>> schema_file.close()
-
-We can define interfaces from this using a helper function:
-
-    >>> from plone.supermodel import xmlSchema
-    >>> ITestContent = xmlSchema(schema_filename)
-
-Note: If the schema filename is not an absolute path, it will be found
-relative to the module where the interface is defined.
-
-After being loaded, the interface should have the fields of the default
-(unnamed) schema:
-
-    >>> getFieldNamesInOrder(ITestContent)
-    ['title', 'body']
-
-We can also use a different, named schema:
-
-    >>> ITestMetadata = xmlSchema(schema_filename, schema=u"metadata")
-    >>> getFieldNamesInOrder(ITestMetadata)
-    ['created', 'creator']
-
-Of course, a schema can also be written to XML. Either, you can build a model
-dict as per the serializeModel() method seen above, or you can write a model
-of just a single schema using serializeSchema():
-
-    >>> from plone.supermodel import serializeSchema
-    >>> print serializeSchema(ITestContent) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema>
-        <field name="title" type="zope.schema.TextLine">
-          <title>Title</title>
-        </field>
-        <field name="body" type="zope.schema.Text">
-          <max_length>10000</max_length>
-          <title>Body text</title>
-        </field>
-      </schema>
-    </model>
-
-    >>> print serializeSchema(ITestMetadata, name=u"metadata") # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema name="metadata">
-        <field name="created" type="zope.schema.Datetime">
-          <required>False</required>
-          <title>Created date</title>
-        </field>
-        <field name="creator" type="zope.schema.TextLine">
-          <description>Name of the creator</description>
-          <title>Creator</title>
-        </field>
-      </schema>
-    </model>
-
-Finally, let's clean up the temporary directory.
-
-    >>> shutil.rmtree(tmpdir)
-
-Base interface support
-----------------------
-
-When building a schema interface from XML, it is possible to specify a base
-interface. This is analogous to "subclassing" an existing interface. The XML
-schema representation can override and/or extend fields from the base.
-
-For the purposes of this test, we have defined a dummy interface in
-plone.supermodel.tests. We can't define it in the doctest, because the import
-resolver needs to have a proper module path. The interface looks like this
-though:
-
-    class IBase(Interface):
-        title = zope.schema.TextLine(title=u"Title")
-        description = zope.schema.TextLine(title=u"Description")
-        name = zope.schema.TextLine(title=u"Name")
-
-In real life, you'd more likely have a dotted name like
-my.package.interfaces.IBase, of course.
-
-Then, let's define a schema that is based on this interface.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema based-on="plone.supermodel.tests.IBase">
-    ...         <field type="zope.schema.Text" name="description">
-    ...             <title>Description</title>
-    ...             <description>A short summary</description>
-    ...         </field>
-    ...         <field type="zope.schema.Int" name="age">
-    ...             <title>Age</title>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-Here, notice the use of the 'based-on' attribute, which specifies a dotted
-name to the base interface. It is possible to specify multiple interfaces
-as a space-separated list. However, if you find that you need this, you
-may want to ask yourself why. :) Inside the schema proper, we override the
-'description' field and add a new field, 'age'.
-
-When we load this model, we should find that the __bases__ list of the
-generated interface contains the base schema.
-
-    >>> model = loadString(schema)
-    >>> model.schema.__bases__
-    (<InterfaceClass plone.supermodel.tests.IBase>, <SchemaClass plone.supermodel.model.Schema>)
-
-The fields of the base interface will also be replicated in the new schema.
-
-    >>> getFieldNamesInOrder(model.schema)
-    ['title', 'description', 'name', 'age']
-
-Notice how the order of the 'description' field is dictated by where it
-appeared in the base interface, not where it appears in the XML schema.
-
-We should also verify that the description field was indeed overridden:
-
-    >>> model.schema['description'] # doctest: +ELLIPSIS
-    <zope.schema._bootstrapfields.Text object at ...>
-
-Finally, let's verify that bases are preserved upon serialisation:
-
-    >>> print serializeSchema(model.schema) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema based-on="plone.supermodel.tests.IBase">
-        <field name="description" type="zope.schema.Text">
-          <description>A short summary</description>
-          <title>Description</title>
-        </field>
-        <field name="age" type="zope.schema.Int">
-          <title>Age</title>
-        </field>
-      </schema>
-    </model>
-
-Fieldset support
-----------------
-
-It is often useful to be able to group form fields in the same schema into
-fieldsets, for example for form rendering. While plone.supermodel doesn't have
-anything to do with such rendering, it does support some markup to make it
-possible to define fieldsets. These are stored in a tagged value on the
-generated interface, which can then be used by other code.
-
-Fieldsets can be defined from and serialised to XML, using the <fieldset />
-tag to wrap a sequence of fields.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title>Title</title>
-    ...             <required>True</required>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="body">
-    ...             <title>Body text</title>
-    ...             <required>True</required>
-    ...             <max_length>10000</max_length>
-    ...         </field>
-    ...
-    ...         <fieldset name="dates" label="Dates" description="Standard dates">
-    ...             <field type="zope.schema.Date" name="publication_date">
-    ...                 <title>Publication date</title>
-    ...             </field>
-    ...         </fieldset>
-    ...
-    ...         <field type="zope.schema.TextLine" name="author">
-    ...             <title>Author</title>
-    ...         </field>
-    ...
-    ...         <fieldset name="dates" label="Ignored" description="Ignored">
-    ...             <field type="zope.schema.Date" name="expiry_date">
-    ...                 <title>Expiry date</title>
-    ...             </field>
-    ...             <field type="zope.schema.Date" name="notification_date">
-    ...                 <title>Notification date</title>
-    ...             </field>
-    ...         </fieldset>
-    ...     </schema>
-    ...
-    ...     <schema name="metadata">
-    ...
-    ...         <fieldset name="standard" label="Standard" />
-    ...         <fieldset name="dates" label="Metadata dates" />
-    ...         <fieldset name="author" label="Author info" />
-    ...
-    ...         <fieldset name="dates">
-    ...             <field type="zope.schema.Datetime" name="created">
-    ...                 <title>Created date</title>
-    ...                 <required>False</required>
-    ...             </field>
-    ...         </fieldset>
-    ...
-    ...         <fieldset name="standard">
-    ...             <field type="zope.schema.TextLine" name="creator">
-    ...                 <title>Creator</title>
-    ...                 <description>Name of the creator</description>
-    ...                 <required>True</required>
-    ...             </field>
-    ...         </fieldset>
-    ...     </schema>
-    ...
-    ... </model>
-    ... """
-
-Fields outside any <fieldset /> tag are not placed in any fieldset. An
-empty <fieldset /> will be recorded as one having no fields. This is sometimes
-useful to control the order of fieldsets, if those are to be filled later.
-
-If there are two <fieldset /> blocks with the same name, fields from the second
-will be appended to the first, and the label and description will be kept
-from the first one, as appropriate.
-
-Note that fieldsets are specific to each schema, i.e. the fieldset in the
-default schema above is unrelated to the one in the metadata schema.
-
-    >>> model = loadString(schema)
-    >>> getFieldNamesInOrder(model.schema)
-    ['title', 'body', 'publication_date', 'author', 'expiry_date', 'notification_date']
-
-    >>> getFieldNamesInOrder(model.schemata['metadata'])
-    ['created', 'creator']
-
-    >>> from plone.supermodel.interfaces import FIELDSETS_KEY
-    >>> model.schema.getTaggedValue(FIELDSETS_KEY)
-    [<Fieldset 'dates' of publication_date, expiry_date, notification_date>]
-
-    >>> model.schemata[u"metadata"].getTaggedValue(FIELDSETS_KEY)
-    [<Fieldset 'standard' of creator>, <Fieldset 'dates' of created>, <Fieldset 'author' of >]
-
-When we serialise a schema with fieldsets, fields will be grouped by
-fieldset.
-
-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema>
-        <field name="title" type="zope.schema.TextLine">
-          <title>Title</title>
-        </field>
-        <field name="body" type="zope.schema.Text">
-          <max_length>10000</max_length>
-          <title>Body text</title>
-        </field>
-        <field name="author" type="zope.schema.TextLine">
-          <title>Author</title>
-        </field>
-        <fieldset name="dates" label="Dates" description="Standard dates">
-          <field name="publication_date" type="zope.schema.Date">
-            <title>Publication date</title>
-          </field>
-          <field name="expiry_date" type="zope.schema.Date">
-            <title>Expiry date</title>
-          </field>
-          <field name="notification_date" type="zope.schema.Date">
-            <title>Notification date</title>
-          </field>
-        </fieldset>
-      </schema>
-      <schema name="metadata">
-        <fieldset name="standard" label="Standard">
-          <field name="creator" type="zope.schema.TextLine">
-            <description>Name of the creator</description>
-            <title>Creator</title>
-          </field>
-        </fieldset>
-        <fieldset name="dates" label="Metadata dates">
-          <field name="created" type="zope.schema.Datetime">
-            <required>False</required>
-            <title>Created date</title>
-          </field>
-        </fieldset>
-        <fieldset name="author" label="Author info"/>
-      </schema>
-    </model>
-
-Invariant Support
------------------
-
-We may specify one or more invariants for the form via the "invariant" tag with
-a dotted name for the invariant function.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <invariant>plone.supermodel.tests.dummy_invariant</invariant>
-    ...         <invariant>plone.supermodel.tests.dummy_invariant_prime</invariant>
-    ...         <field type="zope.schema.Text" name="description">
-    ...             <title>Description</title>
-    ...             <description>A short summary</description>
-    ...         </field>
-    ...         <field type="zope.schema.Int" name="age">
-    ...             <title>Age</title>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-    >>> model = loadString(schema)
-    >>> model.schema.getTaggedValue('invariants')
-    [<function dummy_invariant at ...>, <function dummy_invariant_prime at ...>]
-
-When invariants are checked for our model.schema, we'll see our invariant
-in action.
-
-    >>> model.schema.validateInvariants(object())
-    Traceback (most recent call last):
-    ...
-    Invalid: Yikes! Invalid
-
-The model's serialization should include the invariant.
-
-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema>
-        <invariant>plone.supermodel.tests.dummy_invariant</invariant>
-        <invariant>plone.supermodel.tests.dummy_invariant_prime</invariant>
-        <field name="description" type="zope.schema.Text">
-          <description>A short summary</description>
-          <title>Description</title>
-        </field>
-        <field name="age" type="zope.schema.Int">
-          <title>Age</title>
-        </field>
-      </schema>
-    </model>
-
-Invariant functions must provide plone.supermodel.interfaces.IInvariant
-or we won't accept them.
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
-    ...     <schema>
-    ...         <invariant>plone.supermodel.tests.dummy_unmarkedInvariant</invariant>
-    ...         <field type="zope.schema.Text" name="description">
-    ...             <title>Description</title>
-    ...             <description>A short summary</description>
-    ...         </field>
-    ...         <field type="zope.schema.Int" name="age">
-    ...             <title>Age</title>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-    >>> model = loadString(schema)
-    Traceback (most recent call last):
-    ...
-    SupermodelParseError: Invariant functions must provide plone.supermodel.interfaces.IInvariant
-      File "<unknown>", line ...
-
-
-Internationalization
---------------------
-
-Translation domains and message ids can be specified for text
-that is interpreted as unicode. This will result in deserialization
-as a zope.i18nmessageid message id rather than a basic Unicode string::
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
-    ...        xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-    ...        i18n:domain="plone.supermodel">
-    ...     <schema>
-    ...
-    ...         <field type="zope.schema.TextLine" name="title">
-    ...             <title i18n:translate="supermodel_test_title">Title</title>
-    ...         </field>
-    ...
-    ...         <field type="zope.schema.TextLine" name="description">
-    ...             <title i18n:translate="">description</title>
-    ...         </field>
-    ...
-    ...         <field type="zope.schema.TextLine" name="feature">
-    ...             <title i18n:translate="domain_test"
-    ...                    i18n:domain="other">feature</title>
-    ...         </field>
-    ...
-    ...     </schema>
-    ... </model>
-    ... """
-    >>> model = loadString(schema)
-    >>> msgid = model.schema['title'].title
-    >>> msgid
-    u'supermodel_test_title'
-    >>> type(msgid)
-    <type 'zope.i18nmessageid.message.Message'>
-    >>> msgid.default
-    u'Title'
-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema" i18n:domain="plone.supermodel">
-      <schema>
-        <field name="title" type="zope.schema.TextLine">
-          <title i18n:translate="supermodel_test_title">Title</title>
-        </field>
-        <field name="description" type="zope.schema.TextLine">
-          <title i18n:translate="">description</title>
-        </field>
-        <field name="feature" type="zope.schema.TextLine">
-          <title i18n:domain="other" i18n:translate="domain_test">feature</title>
-        </field>
-      </schema>
-    </model>
-
-Creating custom metadata handlers
----------------------------------
-
-The plone.supermodel format is extensible with custom utilities that can
-write to a "metadata" dictionary. Such utilities may for example read
-information captured in attributes in particular namespaces.
-
-Let's imagine we wanted to make it possible to override form layout on a
-per-schema level, and override widgets on a per-field level. For this, we
-may expect to be able to parse a format like this:
-
-    >>> schema = """\
-    ... <?xml version="1.0" encoding="UTF-8"?>
-    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
-    ...        xmlns:ui="http://namespaces.acme.com/ui">
-    ...     <schema ui:layout="horizontal">
-    ...         <field type="zope.schema.TextLine" name="title"
-    ...             ui:widget="largetype">
-    ...             <title>Title</title>
-    ...             <required>True</required>
-    ...         </field>
-    ...         <field type="zope.schema.Text" name="description">
-    ...             <title>Description</title>
-    ...             <description>A short summary</description>
-    ...             <required>False</required>
-    ...             <min_length>10</min_length>
-    ...         </field>
-    ...     </schema>
-    ... </model>
-    ... """
-
-We can register schema and field metadata handlers as named utilities.
-Metadata handlers should be able to reciprocally read and write metadata.
-
-    >>> from zope.interface import implements
-    >>> from zope.component import provideUtility
-
-    >>> from plone.supermodel.interfaces import ISchemaMetadataHandler
-    >>> from plone.supermodel.utils import ns
-
-    >>> class FormLayoutMetadata(object):
-    ...     implements(ISchemaMetadataHandler)
-    ...
-    ...     namespace = "http://namespaces.acme.com/ui"
-    ...     prefix = "ui"
-    ...
-    ...     def read(self, schemaNode, schema):
-    ...         layout = schemaNode.get(ns('layout', self.namespace))
-    ...         if layout:
-    ...             schema.setTaggedValue(u'acme.layout', layout)
-    ...
-    ...     def write(self, schemaNode, schema):
-    ...         layout = schema.queryTaggedValue(u'acme.layout', None)
-    ...         if layout:
-    ...             schemaNode.set(ns('layout', self.namespace), layout)
-
-    >>> provideUtility(component=FormLayoutMetadata(), name='acme.ui.schema')
-
-    >>> from plone.supermodel.interfaces import IFieldMetadataHandler
-    >>> class FieldWidgetMetadata(object):
-    ...     implements(IFieldMetadataHandler)
-    ...
-    ...     namespace = "http://namespaces.acme.com/ui"
-    ...     prefix = "ui"
-    ...
-    ...     def read(self, fieldNode, schema, field):
-    ...         name = field.__name__
-    ...         widget = fieldNode.get(ns('widget', self.namespace))
-    ...         if widget:
-    ...             widgets = schema.queryTaggedValue(u'acme.widgets', {})
-    ...             widgets[name] = widget
-    ...             schema.setTaggedValue(u'acme.widgets', widgets)
-    ...
-    ...     def write(self, fieldNode, schema, field):
-    ...         name = field.__name__
-    ...         widget = schema.queryTaggedValue(u'acme.widgets', {}).get(name, {})
-    ...         if widget:
-    ...             fieldNode.set(ns('widget', self.namespace), widget)
-
-    >>> provideUtility(component=FieldWidgetMetadata(), name='acme.ui.fields')
-
-When this model is loaded, utilities above will be invoked for each schema
-and each field, respectively.
-
-    >>> model = loadString(schema)
-
-    >>> model.schema.getTaggedValue('acme.layout')
-    'horizontal'
-
-    >>> model.schema.getTaggedValue('acme.widgets')
-    {'title': 'largetype'}
-
-Of course, we can also serialize the schema back to XML. Here, the 'prefix'
-set in the utility (if any) will be used by default.
-
-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE
-    <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:ui="http://namespaces.acme.com/ui" xmlns="http://namespaces.plone.org/supermodel/schema">
-      <schema ui:layout="horizontal">
-        <field name="title" type="zope.schema.TextLine" ui:widget="largetype">
-          <title>Title</title>
-        </field>
-        <field name="description" type="zope.schema.Text">
-          <description>A short summary</description>
-          <min_length>10</min_length>
-          <required>False</required>
-          <title>Description</title>
-        </field>
-      </schema>
-    </model>
diff --git a/plone/supermodel/schemaclass.rst b/plone/supermodel/schemaclass.rst
new file mode 100644
index 0000000..a909c7e
--- /dev/null
+++ b/plone/supermodel/schemaclass.rst
@@ -0,0 +1,69 @@
+=============================
+plone.supermodel: SchemaClass
+=============================
+
+    >>> from plone.supermodel.model import Schema, SchemaClass
+    >>> from plone.supermodel import interfaces
+    >>> from zope.interface import Interface, implements
+    >>> from zope.component import adapts, provideAdapter
+
+Schema plugins are registered as named adapters. They may optionally contain
+an order attribute, which defaults to 0.
+
+    >>> class TestPlugin(object):
+    ...     adapts(interfaces.ISchema)
+    ...     implements(interfaces.ISchemaPlugin)
+    ...     order = 1
+    ...     def __init__(self, schema):
+    ...         self.schema = schema
+    ...     def __call__(self):
+    ...         print("%s: %r" % (self.__class__.__name__, self.schema))
+    ...
+    >>> provideAdapter(TestPlugin, name=u"plone.supermodel.tests.TestPlugin")
+
+Schema plugins are executed at schema declaration.
+
+    >>> class IA(Schema):
+    ...     pass
+    TestPlugin: <SchemaClass __builtin__.IA>
+
+Any class descending from Schema becomes an instance of SchemaClass and has any
+schema plugins called.
+
+Except, there is a known issue. Until
+https://bugs.launchpad.net/zope.interface/+bug/791218 is resolved, this
+inheritance only works if the *first* base class is an instance of SchemaClass.
+So below I've commented out the output that we hope for once that issue is
+resolved.
+
+    >>> class ISomeInterface(Interface):
+    ...     pass
+
+    >>> class IB(ISomeInterface, IA):
+    ...     pass
+
+#    TestPlugin: <SchemaClass __builtin__.IB>
+
+    >>> class IC(IB):
+    ...     pass
+
+#    TestPlugin: <SchemaClass __builtin__.IC>
+
+To support the registration of schema plugins in ZCML, plugins are
+additionally executed at zope.configuration time with a ZCML order of 1000. To
+simulate this we will define another adapter and call the configuration action
+directly.
+
+    >>> class TestPlugin2(TestPlugin):
+    ...     order = 0
+
+    >>> provideAdapter(TestPlugin2, name=u"plone.supermodel.tests.TestPlugin2")
+    >>> from plone.supermodel.model import finalizeSchemas
+    >>> finalizeSchemas(IA)
+    TestPlugin2: <SchemaClass __builtin__.IA>
+    TestPlugin: <SchemaClass __builtin__.IA>
+
+#    TestPlugin2: <SchemaClass __builtin__.IB>
+#    TestPlugin: <SchemaClass __builtin__.IB>
+#    TestPlugin2: <SchemaClass __builtin__.IC>
+#    TestPlugin: <SchemaClass __builtin__.IC>
diff --git a/plone/supermodel/schemaclass.txt b/plone/supermodel/schemaclass.txt
deleted file mode 100644
index a909c7e..0000000
--- a/plone/supermodel/schemaclass.txt
+++ /dev/null
@@ -1,69 +0,0 @@
-=============================
-plone.supermodel: SchemaClass
-=============================
-
-    >>> from plone.supermodel.model import Schema, SchemaClass
-    >>> from plone.supermodel import interfaces
-    >>> from zope.interface import Interface, implements
-    >>> from zope.component import adapts, provideAdapter
-
-Schema plugins are registered as named adapters. They may optionally contain
-an order attribute, which defaults to 0.
-
-    >>> class TestPlugin(object):
-    ...     adapts(interfaces.ISchema)
-    ...     implements(interfaces.ISchemaPlugin)
-    ...     order = 1
-    ...     def __init__(self, schema):
-    ...         self.schema = schema
-    ...     def __call__(self):
-    ...         print("%s: %r" % (self.__class__.__name__, self.schema))
-    ...
-    >>> provideAdapter(TestPlugin, name=u"plone.supermodel.tests.TestPlugin")
-
-Schema plugins are executed at schema declaration.
-
-    >>> class IA(Schema):
-    ...     pass
-    TestPlugin: <SchemaClass __builtin__.IA>
-
-Any class descending from Schema becomes an instance of SchemaClass and has any
-schema plugins called.
-
-Except, there is a known issue. Until
-https://bugs.launchpad.net/zope.interface/+bug/791218 is resolved, this
-inheritance only works if the *first* base class is an instance of SchemaClass.
-So below I've commented out the output that we hope for once that issue is
-resolved.
-
-    >>> class ISomeInterface(Interface):
-    ...     pass
-
-    >>> class IB(ISomeInterface, IA):
-    ...     pass
-
-#    TestPlugin: <SchemaClass __builtin__.IB>
-
-    >>> class IC(IB):
-    ...     pass
-
-#    TestPlugin: <SchemaClass __builtin__.IC>
-
-To support the registration of schema plugins in ZCML, plugins are
-additionally executed at zope.configuration time with a ZCML order of 1000. To
-simulate this we will define another adapter and call the configuration action
-directly.
-
-    >>> class TestPlugin2(TestPlugin):
-    ...     order = 0
-
-    >>> provideAdapter(TestPlugin2, name=u"plone.supermodel.tests.TestPlugin2")
-    >>> from plone.supermodel.model import finalizeSchemas
-    >>> finalizeSchemas(IA)
-    TestPlugin2: <SchemaClass __builtin__.IA>
-    TestPlugin: <SchemaClass __builtin__.IA>
-
-#    TestPlugin2: <SchemaClass __builtin__.IB>
-#    TestPlugin: <SchemaClass __builtin__.IB>
-#    TestPlugin2: <SchemaClass __builtin__.IC>
-#    TestPlugin: <SchemaClass __builtin__.IC>
diff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py
index e47c864..46c6a36 100644
--- a/plone/supermodel/tests.py
+++ b/plone/supermodel/tests.py
@@ -108,12 +108,12 @@ class TestUtils(unittest.TestCase):
     def test_syncSchema(self):
 
         class ISource(Interface):
-            one = schema.TextLine(title=u"A") # order: 0
-            two = schema.Int(title=u"B")      # order: 1
+            one = schema.TextLine(title=u"A")  # order: 0
+            two = schema.Int(title=u"B")       # order: 1
 
         class IDest(Interface):
-            one = schema.TextLine(title=u"C") # order: 0
-            three = schema.Int(title=u"D")    # order: 1
+            one = schema.TextLine(title=u"C")  # order: 0
+            three = schema.Int(title=u"D")     # order: 1
 
         ISource.setTaggedValue("tag1", "tag one")
         ISource.setTaggedValue("tag2", "tag two")
@@ -465,19 +465,20 @@ def test_choice_serialized(self):
         self.assertEquals(etree.tostring(el), expected)
 
     def test_choice_parsing(self):
-        _termvalues = lambda vocab: tuple((t.value, t.title) for t in vocab)
+        def _termvalues(vocab):
+            return tuple((t.value, t.title) for t in vocab)
         cases = (
             self._choice(),
             self._choice_with_empty(),
             self._choice_with_term_titles(),
-            )
+        )
         for field, expected in cases:
             el = etree.fromstring(expected)
             imported_field = self.handler.read(el)
             self.assertEquals(
                 _termvalues(imported_field.vocabulary),
                 _termvalues(field.vocabulary),
-                )
+            )
 
 
 def test_suite():
@@ -485,21 +486,25 @@ def test_suite():
         unittest.makeSuite(TestUtils),
         unittest.makeSuite(TestValueToElement),
         unittest.makeSuite(TestChoiceHandling),
-        doctest.DocFileSuite('schema.txt',
+        doctest.DocFileSuite(
+            'schema.rst',
             setUp=zope.component.testing.setUp,
             tearDown=zope.component.testing.tearDown,
             optionflags=doctest.ELLIPSIS),
-        doctest.DocFileSuite('fields.txt',
+        doctest.DocFileSuite(
+            'fields.rst',
             setUp=zope.component.testing.setUp,
             tearDown=zope.component.testing.tearDown,
             optionflags=doctest.ELLIPSIS),
-        doctest.DocFileSuite('schemaclass.txt',
+        doctest.DocFileSuite(
+            'schemaclass.rst',
             setUp=zope.component.testing.setUp,
             tearDown=zope.component.testing.tearDown),
-        doctest.DocFileSuite('directives.txt',
+        doctest.DocFileSuite(
+            'directives.rst',
             setUp=zope.component.testing.setUp,
             tearDown=zope.component.testing.tearDown),
-        ))
+    ))
 
 
 if __name__ == '__main__':


